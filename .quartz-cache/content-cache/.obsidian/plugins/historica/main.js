/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/toml/lib/parser.js
var require_parser = __commonJS({
  "node_modules/toml/lib/parser.js"(exports, module2) {
    module2.exports = function() {
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function SyntaxError2(message, expected, found, offset2, line, column) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.offset = offset2;
        this.line = line;
        this.column = column;
        this.name = "SyntaxError";
      }
      peg$subclass(SyntaxError2, Error);
      function parse18(input) {
        var options2 = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
          return nodes;
        }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
          addNode(node2("ObjectPath", name, line, column));
        }, peg$c12 = function(name) {
          addNode(node2("ArrayPath", name, line, column));
        }, peg$c13 = function(parts, name) {
          return parts.concat(name);
        }, peg$c14 = function(name) {
          return [name];
        }, peg$c15 = function(name) {
          return name;
        }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
          addNode(node2("Assign", value, line, column, key));
        }, peg$c21 = function(chars) {
          return chars.join("");
        }, peg$c22 = function(node3) {
          return node3.value;
        }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
          return node2("String", chars.join(""), line, column);
        }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
          return char;
        }, peg$c34 = function(char) {
          return char;
        }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
          return "";
        }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
          return node2("Float", parseFloat(left + "e" + right), line, column);
        }, peg$c43 = function(text2) {
          return node2("Float", parseFloat(text2), line, column);
        }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
          return digits.join("");
        }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
          return "-" + digits.join("");
        }, peg$c50 = function(text2) {
          return node2("Integer", parseInt(text2, 10), line, column);
        }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
          return node2("Boolean", true, line, column);
        }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
          return node2("Boolean", false, line, column);
        }, peg$c57 = function() {
          return node2("Array", [], line, column);
        }, peg$c58 = function(value) {
          return node2("Array", value ? [value] : [], line, column);
        }, peg$c59 = function(values) {
          return node2("Array", values, line, column);
        }, peg$c60 = function(values, value) {
          return node2("Array", values.concat(value), line, column);
        }, peg$c61 = function(value) {
          return value;
        }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
          return node2("InlineTable", values, line, column);
        }, peg$c69 = function(key, value) {
          return node2("InlineTableValue", value, line, column, key);
        }, peg$c70 = function(digits) {
          return "." + digits;
        }, peg$c71 = function(date) {
          return date.join("");
        }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
          return time.join("");
        }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date, time) {
          return node2("Date", new Date(date + "T" + time + "Z"), line, column);
        }, peg$c80 = function(date, time) {
          return node2("Date", new Date(date + "T" + time), line, column);
        }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
          return "";
        }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d3) {
          return d3.join("");
        }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
          return '"';
        }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
          return "\\";
        }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
          return "\b";
        }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
          return "	";
        }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
          return "\n";
        }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
          return "\f";
        }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
          return "\r";
        }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
          return convertCodePoint(digits.join(""));
        }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
        if ("startRule" in options2) {
          if (!(options2.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options2.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options2.startRule];
        }
        function text() {
          return input.substring(peg$reportedPos, peg$currPos);
        }
        function offset2() {
          return peg$reportedPos;
        }
        function line() {
          return peg$computePosDetails(peg$reportedPos).line;
        }
        function column() {
          return peg$computePosDetails(peg$reportedPos).column;
        }
        function expected(description) {
          throw peg$buildException(
            null,
            [{ type: "other", description }],
            peg$reportedPos
          );
        }
        function error(message) {
          throw peg$buildException(message, null, peg$reportedPos);
        }
        function peg$computePosDetails(pos) {
          function advance(details, startPos, endPos) {
            var p7, ch;
            for (p7 = startPos; p7 < endPos; p7++) {
              ch = input.charAt(p7);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
            }
          }
          if (peg$cachedPos !== pos) {
            if (peg$cachedPos > pos) {
              peg$cachedPos = 0;
              peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advance(peg$cachedPosDetails, peg$cachedPos, pos);
            peg$cachedPos = pos;
          }
          return peg$cachedPosDetails;
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, pos) {
          function cleanupExpected(expected3) {
            var i5 = 1;
            expected3.sort(function(a4, b2) {
              if (a4.description < b2.description) {
                return -1;
              } else if (a4.description > b2.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i5 < expected3.length) {
              if (expected3[i5 - 1] === expected3[i5]) {
                expected3.splice(i5, 1);
              } else {
                i5++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s5) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i5;
            for (i5 = 0; i5 < expected3.length; i5++) {
              expectedDescs[i5] = expected3[i5].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new SyntaxError2(
            message !== null ? message : buildMessage(expected2, found),
            expected2,
            found,
            pos,
            posDetails.line,
            posDetails.column
          );
        }
        function peg$parsestart() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 0, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseline();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseline();
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c1();
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseline() {
          var s0, s1, s22, s32, s42, s5, s6;
          var key = peg$currPos * 49 + 1, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseexpression();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parsecomment();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parsecomment();
                }
                if (s42 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseNL();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseNL();
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseEOF();
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = [s1, s22, s32, s42, s5];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            if (s22 !== peg$FAILED) {
              while (s22 !== peg$FAILED) {
                s1.push(s22);
                s22 = peg$parseS();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseNL();
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$parseNL();
                }
              } else {
                s22 = peg$c2;
              }
              if (s22 === peg$FAILED) {
                s22 = peg$parseEOF();
              }
              if (s22 !== peg$FAILED) {
                s1 = [s1, s22];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseexpression() {
          var s0;
          var key = peg$currPos * 49 + 2, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsecomment();
          if (s0 === peg$FAILED) {
            s0 = peg$parsepath();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetablearray();
              if (s0 === peg$FAILED) {
                s0 = peg$parseassignment();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsecomment() {
          var s0, s1, s22, s32, s42, s5;
          var key = peg$currPos * 49 + 3, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c3;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c4);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$currPos;
            s42 = peg$currPos;
            peg$silentFails++;
            s5 = peg$parseNL();
            if (s5 === peg$FAILED) {
              s5 = peg$parseEOF();
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s42 = peg$c5;
            } else {
              peg$currPos = s42;
              s42 = peg$c2;
            }
            if (s42 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s5 !== peg$FAILED) {
                s42 = [s42, s5];
                s32 = s42;
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
            } else {
              peg$currPos = s32;
              s32 = peg$c2;
            }
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$currPos;
              s42 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s42 = peg$c5;
              } else {
                peg$currPos = s42;
                s42 = peg$c2;
              }
              if (s42 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s42 = [s42, s5];
                  s32 = s42;
                } else {
                  peg$currPos = s32;
                  s32 = peg$c2;
                }
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
            }
            if (s22 !== peg$FAILED) {
              s1 = [s1, s22];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsepath() {
          var s0, s1, s22, s32, s42, s5;
          var key = peg$currPos * 49 + 4, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parsetable_key();
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c9;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c11(s32);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetablearray() {
          var s0, s1, s22, s32, s42, s5, s6, s7;
          var key = peg$currPos * 49 + 5, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s22 = peg$c7;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                s42 = peg$parsetable_key();
                if (s42 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s6 = peg$c9;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s7 = peg$c9;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c12(s42);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 6, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsedot_ended_table_key_part();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parsedot_ended_table_key_part();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsetable_key_part();
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c13(s1, s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetable_key_part();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c14(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetable_key_part() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 7, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsequoted_key();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedot_ended_table_key_part() {
          var s0, s1, s22, s32, s42, s5, s6;
          var key = peg$currPos * 49 + 8, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsequoted_key();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s42 = peg$c16;
                    peg$currPos++;
                  } else {
                    s42 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s22);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseassignment() {
          var s0, s1, s22, s32, s42, s5;
          var key = peg$currPos * 49 + 9, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsekey();
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s32 = peg$c18;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c19);
                }
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parsevalue();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c20(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsequoted_key();
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseS();
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parseS();
              }
              if (s22 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s32 = peg$c18;
                  peg$currPos++;
                } else {
                  s32 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s32 !== peg$FAILED) {
                  s42 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s42.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsekey() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 10, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseASCII_BASIC();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseASCII_BASIC();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsequoted_key() {
          var s0, s1;
          var key = peg$currPos * 49 + 11, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedouble_quoted_single_line_string();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c22(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsesingle_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsevalue() {
          var s0;
          var key = peg$currPos * 49 + 12, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsestring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedatetime();
            if (s0 === peg$FAILED) {
              s0 = peg$parsefloat();
              if (s0 === peg$FAILED) {
                s0 = peg$parseinteger();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseboolean();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsearray();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseinline_table();
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring() {
          var s0;
          var key = peg$currPos * 49 + 13, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parsedouble_quoted_multiline_string();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedouble_quoted_single_line_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesingle_quoted_multiline_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_single_line_string();
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_multiline_string() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 14, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 === peg$FAILED) {
              s22 = peg$c25;
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsemultiline_string_char();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsemultiline_string_char();
              }
              if (s32 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s42 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedouble_quoted_single_line_string() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 15, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c27;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parsestring_char();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsestring_char();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s32 = peg$c27;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_multiline_string() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 16, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 === peg$FAILED) {
              s22 = peg$c25;
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsemultiline_literal_char();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsemultiline_literal_char();
              }
              if (s32 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c29) {
                  s42 = peg$c29;
                  peg$currPos += 3;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesingle_quoted_single_line_string() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 17, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c31;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseliteral_char();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseliteral_char();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s32 = peg$c31;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c32);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c26(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsestring_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 18, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s22 = peg$c27;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            peg$silentFails--;
            if (s22 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s22 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseliteral_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 19, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 39) {
            s22 = peg$c31;
            peg$currPos++;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          peg$silentFails--;
          if (s22 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 20, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseESCAPED();
          if (s0 === peg$FAILED) {
            s0 = peg$parsemultiline_string_delim();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 3) === peg$c23) {
                s22 = peg$c23;
                peg$currPos += 3;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c24);
                }
              }
              peg$silentFails--;
              if (s22 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s22 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s22 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s22 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c34(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_string_delim() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 21, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c35;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c36);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseNL();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseNLS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseNLS();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c37();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsemultiline_literal_char() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 22, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 3) === peg$c29) {
            s22 = peg$c29;
            peg$currPos += 3;
          } else {
            s22 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          peg$silentFails--;
          if (s22 === peg$FAILED) {
            s1 = peg$c5;
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s22 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c33(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat() {
          var s0, s1, s22, s32;
          var key = peg$currPos * 49 + 23, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsefloat_text();
          if (s1 === peg$FAILED) {
            s1 = peg$parseinteger_text();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 101) {
              s22 = peg$c38;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c39);
              }
            }
            if (s22 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 69) {
                s22 = peg$c40;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c41);
                }
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parseinteger_text();
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c42(s1, s32);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c43(s1);
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsefloat_text() {
          var s0, s1, s22, s32, s42, s5;
          var key = peg$currPos * 49 + 24, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseDIGITS();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s42 = peg$c16;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseDIGITS();
                if (s5 !== peg$FAILED) {
                  s32 = [s32, s42, s5];
                  s22 = s32;
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c46(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$currPos;
              s32 = peg$parseDIGITS();
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s32 = [s32, s42, s5];
                    s22 = s32;
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c49(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger() {
          var s0, s1;
          var key = peg$currPos * 49 + 25, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parseinteger_text();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinteger_text() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 26, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c44;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$c25;
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              while (s32 !== peg$FAILED) {
                s22.push(s32);
                s32 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 46) {
                s42 = peg$c16;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c17);
                }
              }
              peg$silentFails--;
              if (s42 === peg$FAILED) {
                s32 = peg$c5;
              } else {
                peg$currPos = s32;
                s32 = peg$c2;
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c47;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = [];
              s32 = peg$parseDIGIT_OR_UNDER();
              if (s32 !== peg$FAILED) {
                while (s32 !== peg$FAILED) {
                  s22.push(s32);
                  s32 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                s32 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s42 = peg$c16;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s42 === peg$FAILED) {
                  s32 = peg$c5;
                } else {
                  peg$currPos = s32;
                  s32 = peg$c2;
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseboolean() {
          var s0, s1;
          var key = peg$currPos * 49 + 27, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c53();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c54) {
              s1 = peg$c54;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c55);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c56();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 28, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c7;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c8);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parsearray_sep();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parsearray_sep();
            }
            if (s22 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s32 = peg$c9;
                peg$currPos++;
              } else {
                s32 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c10);
                }
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c57();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsearray_value();
              if (s22 === peg$FAILED) {
                s22 = peg$c25;
              }
              if (s22 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s32 = peg$c9;
                  peg$currPos++;
                } else {
                  s32 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c58(s22);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s22 = [];
                s32 = peg$parsearray_value_list();
                if (s32 !== peg$FAILED) {
                  while (s32 !== peg$FAILED) {
                    s22.push(s32);
                    s32 = peg$parsearray_value_list();
                  }
                } else {
                  s22 = peg$c2;
                }
                if (s22 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s32 = peg$c9;
                    peg$currPos++;
                  } else {
                    s32 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s32 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c59(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s22 = [];
                  s32 = peg$parsearray_value_list();
                  if (s32 !== peg$FAILED) {
                    while (s32 !== peg$FAILED) {
                      s22.push(s32);
                      s32 = peg$parsearray_value_list();
                    }
                  } else {
                    s22 = peg$c2;
                  }
                  if (s22 !== peg$FAILED) {
                    s32 = peg$parsearray_value();
                    if (s32 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s42 = peg$c9;
                        peg$currPos++;
                      } else {
                        s42 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s42 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c60(s22, s32);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 29, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsearray_sep();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsevalue();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsearray_sep();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsearray_sep();
              }
              if (s32 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c61(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_value_list() {
          var s0, s1, s22, s32, s42, s5, s6;
          var key = peg$currPos * 49 + 30, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parsearray_sep();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parsearray_sep();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsevalue();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parsearray_sep();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parsearray_sep();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s42 = peg$c62;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c63);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parsearray_sep();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parsearray_sep();
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c61(s22);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsearray_sep() {
          var s0;
          var key = peg$currPos * 49 + 31, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parsecomment();
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table() {
          var s0, s1, s22, s32, s42, s5;
          var key = peg$currPos * 49 + 32, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c64;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c65);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = [];
            s32 = peg$parseS();
            while (s32 !== peg$FAILED) {
              s22.push(s32);
              s32 = peg$parseS();
            }
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseinline_table_assignment();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseinline_table_assignment();
              }
              if (s32 !== peg$FAILED) {
                s42 = [];
                s5 = peg$parseS();
                while (s5 !== peg$FAILED) {
                  s42.push(s5);
                  s5 = peg$parseS();
                }
                if (s42 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s5 = peg$c66;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c67);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c68(s32);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseinline_table_assignment() {
          var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 33, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseS();
          while (s22 !== peg$FAILED) {
            s1.push(s22);
            s22 = peg$parseS();
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parsekey();
            if (s22 !== peg$FAILED) {
              s32 = [];
              s42 = peg$parseS();
              while (s42 !== peg$FAILED) {
                s32.push(s42);
                s42 = peg$parseS();
              }
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s42 = peg$c18;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s42 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseS();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseS();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsevalue();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseS();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseS();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                          s8 = peg$c62;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c63);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = [];
                          s10 = peg$parseS();
                          while (s10 !== peg$FAILED) {
                            s9.push(s10);
                            s10 = peg$parseS();
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c69(s22, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s22 = peg$parseS();
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$parsekey();
              if (s22 !== peg$FAILED) {
                s32 = [];
                s42 = peg$parseS();
                while (s42 !== peg$FAILED) {
                  s32.push(s42);
                  s42 = peg$parseS();
                }
                if (s32 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s42 = peg$c18;
                    peg$currPos++;
                  } else {
                    s42 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s42 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c69(s22, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsesecfragment() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 34, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$parseDIGITS();
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c70(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedate() {
          var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11;
          var key = peg$currPos * 49 + 35, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseDIGIT_OR_UNDER();
              if (s42 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s6 = peg$c47;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c48);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDIGIT_OR_UNDER();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                          s9 = peg$c47;
                          peg$currPos++;
                        } else {
                          s9 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c48);
                          }
                        }
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseDIGIT_OR_UNDER();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseDIGIT_OR_UNDER();
                            if (s11 !== peg$FAILED) {
                              s22 = [s22, s32, s42, s5, s6, s7, s8, s9, s10, s11];
                              s1 = s22;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c71(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime() {
          var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 36, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c72;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            s22 = [s22, s32, s42, s5, s6, s7, s8, s9, s10];
                            s1 = s22;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsetime_with_offset() {
          var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
          var key = peg$currPos * 49 + 37, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$currPos;
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            s32 = peg$parseDIGIT_OR_UNDER();
            if (s32 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s42 = peg$c72;
                peg$currPos++;
              } else {
                s42 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c73);
                }
              }
              if (s42 !== peg$FAILED) {
                s5 = peg$parseDIGIT_OR_UNDER();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDIGIT_OR_UNDER();
                  if (s6 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c72;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c73);
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseDIGIT_OR_UNDER();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseDIGIT_OR_UNDER();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parsesecfragment();
                          if (s10 === peg$FAILED) {
                            s10 = peg$c25;
                          }
                          if (s10 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 45) {
                              s11 = peg$c47;
                              peg$currPos++;
                            } else {
                              s11 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c48);
                              }
                            }
                            if (s11 === peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 43) {
                                s11 = peg$c44;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c45);
                                }
                              }
                            }
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseDIGIT_OR_UNDER();
                              if (s12 !== peg$FAILED) {
                                s13 = peg$parseDIGIT_OR_UNDER();
                                if (s13 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 58) {
                                    s14 = peg$c72;
                                    peg$currPos++;
                                  } else {
                                    s14 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c73);
                                    }
                                  }
                                  if (s14 !== peg$FAILED) {
                                    s15 = peg$parseDIGIT_OR_UNDER();
                                    if (s15 !== peg$FAILED) {
                                      s16 = peg$parseDIGIT_OR_UNDER();
                                      if (s16 !== peg$FAILED) {
                                        s22 = [s22, s32, s42, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                        s1 = s22;
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c74(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parsedatetime() {
          var s0, s1, s22, s32, s42;
          var key = peg$currPos * 49 + 38, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = peg$parsedate();
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 84) {
              s22 = peg$c75;
              peg$currPos++;
            } else {
              s22 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c76);
              }
            }
            if (s22 !== peg$FAILED) {
              s32 = peg$parsetime();
              if (s32 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 90) {
                  s42 = peg$c77;
                  peg$currPos++;
                } else {
                  s42 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c78);
                  }
                }
                if (s42 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c79(s1, s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s22 = peg$c75;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s22 !== peg$FAILED) {
                s32 = peg$parsetime_with_offset();
                if (s32 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s32);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseS() {
          var s0;
          var key = peg$currPos * 49 + 39, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c81.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNL() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 40, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c83;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 13) {
              s1 = peg$c85;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c86);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s22 = peg$c83;
                peg$currPos++;
              } else {
                s22 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s22 !== peg$FAILED) {
                s1 = [s1, s22];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseNLS() {
          var s0;
          var key = peg$currPos * 49 + 41, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$parseNL();
          if (s0 === peg$FAILED) {
            s0 = peg$parseS();
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseEOF() {
          var s0, s1;
          var key = peg$currPos * 49 + 42, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          peg$silentFails++;
          if (input.length > peg$currPos) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c6);
            }
          }
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = peg$c5;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          var key = peg$currPos * 49 + 43, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c87.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGIT_OR_UNDER() {
          var s0, s1;
          var key = peg$currPos * 49 + 44, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c89.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 95) {
              s1 = peg$c91;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c92);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c93();
            }
            s0 = s1;
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseASCII_BASIC() {
          var s0;
          var key = peg$currPos * 49 + 45, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          if (peg$c94.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c95);
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseDIGITS() {
          var s0, s1, s22;
          var key = peg$currPos * 49 + 46, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          s1 = [];
          s22 = peg$parseDIGIT_OR_UNDER();
          if (s22 !== peg$FAILED) {
            while (s22 !== peg$FAILED) {
              s1.push(s22);
              s22 = peg$parseDIGIT_OR_UNDER();
            }
          } else {
            s1 = peg$c2;
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c96(s1);
          }
          s0 = s1;
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED() {
          var s0, s1;
          var key = peg$currPos * 49 + 47, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c99();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c100) {
              s1 = peg$c100;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c101);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c102();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c103) {
                s1 = peg$c103;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c104);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c105();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                  s1 = peg$c106;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c107);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c108();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c109) {
                    s1 = peg$c109;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c110);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c111();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c112) {
                      s1 = peg$c112;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c113);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c114();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c115) {
                        s1 = peg$c115;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c116);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c117();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseESCAPED_UNICODE();
                      }
                    }
                  }
                }
              }
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        function peg$parseESCAPED_UNICODE() {
          var s0, s1, s22, s32, s42, s5, s6, s7, s8, s9, s10;
          var key = peg$currPos * 49 + 48, cached = peg$cache[key];
          if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
          }
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c118) {
            s1 = peg$c118;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c119);
            }
          }
          if (s1 !== peg$FAILED) {
            s22 = peg$currPos;
            s32 = peg$parseHEX();
            if (s32 !== peg$FAILED) {
              s42 = peg$parseHEX();
              if (s42 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s32 = [s32, s42, s5, s6, s7, s8, s9, s10];
                            s22 = s32;
                          } else {
                            peg$currPos = s22;
                            s22 = peg$c2;
                          }
                        } else {
                          peg$currPos = s22;
                          s22 = peg$c2;
                        }
                      } else {
                        peg$currPos = s22;
                        s22 = peg$c2;
                      }
                    } else {
                      peg$currPos = s22;
                      s22 = peg$c2;
                    }
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
            } else {
              peg$currPos = s22;
              s22 = peg$c2;
            }
            if (s22 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c120(s22);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c121) {
              s1 = peg$c121;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c122);
              }
            }
            if (s1 !== peg$FAILED) {
              s22 = peg$currPos;
              s32 = peg$parseHEX();
              if (s32 !== peg$FAILED) {
                s42 = peg$parseHEX();
                if (s42 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s32 = [s32, s42, s5, s6];
                      s22 = s32;
                    } else {
                      peg$currPos = s22;
                      s22 = peg$c2;
                    }
                  } else {
                    peg$currPos = s22;
                    s22 = peg$c2;
                  }
                } else {
                  peg$currPos = s22;
                  s22 = peg$c2;
                }
              } else {
                peg$currPos = s22;
                s22 = peg$c2;
              }
              if (s22 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s22);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
          peg$cache[key] = { nextPos: peg$currPos, result: s0 };
          return s0;
        }
        var nodes = [];
        function genError(err, line2, col) {
          var ex = new Error(err);
          ex.line = line2;
          ex.column = col;
          throw ex;
        }
        function addNode(node3) {
          nodes.push(node3);
        }
        function node2(type, value, line2, column2, key) {
          var obj = { type, value, line: line2(), column: column2() };
          if (key)
            obj.key = key;
          return obj;
        }
        function convertCodePoint(str, line2, col) {
          var num = parseInt("0x" + str);
          if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
            genError("Invalid Unicode escape code: " + str, line2, col);
          } else {
            return fromCodePoint(num);
          }
        }
        function fromCodePoint() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index4 = -1;
          var length2 = arguments.length;
          if (!length2) {
            return "";
          }
          var result = "";
          while (++index4 < length2) {
            var codePoint = Number(arguments[index4]);
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index4 + 1 == length2 || codeUnits.length > MAX_SIZE) {
              result += String.fromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
        }
      }
      return {
        SyntaxError: SyntaxError2,
        parse: parse18
      };
    }();
  }
});

// node_modules/toml/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/toml/lib/compiler.js"(exports, module2) {
    "use strict";
    function compile(nodes) {
      var assignedPaths = [];
      var valueAssignments = [];
      var currentPath = "";
      var data = /* @__PURE__ */ Object.create(null);
      var context = data;
      var arrayMode = false;
      return reduce(nodes);
      function reduce(nodes2) {
        var node2;
        for (var i5 = 0; i5 < nodes2.length; i5++) {
          node2 = nodes2[i5];
          switch (node2.type) {
            case "Assign":
              assign(node2);
              break;
            case "ObjectPath":
              setPath(node2);
              break;
            case "ArrayPath":
              addTableArray(node2);
              break;
          }
        }
        return data;
      }
      function genError(err, line, col) {
        var ex = new Error(err);
        ex.line = line;
        ex.column = col;
        throw ex;
      }
      function assign(node2) {
        var key = node2.key;
        var value = node2.value;
        var line = node2.line;
        var column = node2.column;
        var fullPath;
        if (currentPath) {
          fullPath = currentPath + "." + key;
        } else {
          fullPath = key;
        }
        if (typeof context[key] !== "undefined") {
          genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
        }
        context[key] = reduceValueNode(value);
        if (!pathAssigned(fullPath)) {
          assignedPaths.push(fullPath);
          valueAssignments.push(fullPath);
        }
      }
      function pathAssigned(path) {
        return assignedPaths.indexOf(path) !== -1;
      }
      function reduceValueNode(node2) {
        if (node2.type === "Array") {
          return reduceArrayWithTypeChecking(node2.value);
        } else if (node2.type === "InlineTable") {
          return reduceInlineTableNode(node2.value);
        } else {
          return node2.value;
        }
      }
      function reduceInlineTableNode(values) {
        var obj = /* @__PURE__ */ Object.create(null);
        for (var i5 = 0; i5 < values.length; i5++) {
          var val = values[i5];
          if (val.value.type === "InlineTable") {
            obj[val.key] = reduceInlineTableNode(val.value.value);
          } else if (val.type === "InlineTableValue") {
            obj[val.key] = reduceValueNode(val.value);
          }
        }
        return obj;
      }
      function setPath(node2) {
        var path = node2.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node2.line;
        var column = node2.column;
        if (pathAssigned(quotedPath)) {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, /* @__PURE__ */ Object.create(null), line, column);
        currentPath = path;
      }
      function addTableArray(node2) {
        var path = node2.value;
        var quotedPath = path.map(quoteDottedString).join(".");
        var line = node2.line;
        var column = node2.column;
        if (!pathAssigned(quotedPath)) {
          assignedPaths.push(quotedPath);
        }
        assignedPaths = assignedPaths.filter(function(p7) {
          return p7.indexOf(quotedPath) !== 0;
        });
        assignedPaths.push(quotedPath);
        context = deepRef(data, path, [], line, column);
        currentPath = quotedPath;
        if (context instanceof Array) {
          var newObj = /* @__PURE__ */ Object.create(null);
          context.push(newObj);
          context = newObj;
        } else {
          genError("Cannot redefine existing key '" + path + "'.", line, column);
        }
      }
      function deepRef(start2, keys, value, line, column) {
        var traversed = [];
        var traversedPath = "";
        var path = keys.join(".");
        var ctx = start2;
        for (var i5 = 0; i5 < keys.length; i5++) {
          var key = keys[i5];
          traversed.push(key);
          traversedPath = traversed.join(".");
          if (typeof ctx[key] === "undefined") {
            if (i5 === keys.length - 1) {
              ctx[key] = value;
            } else {
              ctx[key] = /* @__PURE__ */ Object.create(null);
            }
          } else if (i5 !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
            genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
          }
          ctx = ctx[key];
          if (ctx instanceof Array && ctx.length && i5 < keys.length - 1) {
            ctx = ctx[ctx.length - 1];
          }
        }
        return ctx;
      }
      function reduceArrayWithTypeChecking(array) {
        var firstType = null;
        for (var i5 = 0; i5 < array.length; i5++) {
          var node2 = array[i5];
          if (firstType === null) {
            firstType = node2.type;
          } else {
            if (node2.type !== firstType) {
              genError("Cannot add value of type " + node2.type + " to array of type " + firstType + ".", node2.line, node2.column);
            }
          }
        }
        return array.map(reduceValueNode);
      }
      function quoteDottedString(str) {
        if (str.indexOf(".") > -1) {
          return '"' + str + '"';
        } else {
          return str;
        }
      }
    }
    module2.exports = {
      compile
    };
  }
});

// node_modules/toml/index.js
var require_toml = __commonJS({
  "node_modules/toml/index.js"(exports, module2) {
    var parser2 = require_parser();
    var compiler = require_compiler();
    module2.exports = {
      parse: function(input) {
        var nodes = parser2.parse(input.toString());
        return compiler.compile(nodes);
      }
    };
  }
});

// src/lib/codemirror.js
var require_codemirror = __commonJS({
  "src/lib/codemirror.js"(exports, module2) {
    module2.exports = CodeMirror;
  }
});

// src/mode/historica/historica.js
var require_historica = __commonJS({
  "src/mode/historica/historica.js"(exports, module2) {
    (function(mod) {
      if (typeof exports == "object" && typeof module2 == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineMode("historica", function() {
        return {
          startState: function() {
            return {
              inString: false,
              stringType: "",
              lhs: true,
              inArray: 0
            };
          },
          token: function(stream, state) {
            if (!state.inString && (stream.peek() == '"' || stream.peek() == "'")) {
              state.stringType = stream.peek();
              stream.next();
              state.inString = true;
            }
            if (stream.sol() && state.inArray === 0) {
              state.lhs = true;
            }
            if (state.inString) {
              while (state.inString && !stream.eol()) {
                if (stream.peek() === state.stringType) {
                  stream.next();
                  state.inString = false;
                } else if (stream.peek() === "\\") {
                  stream.next();
                  stream.next();
                } else {
                  stream.match(/^.[^\\\"\']*/);
                }
              }
              return state.lhs ? "property string" : "string";
            } else if (state.inArray && stream.peek() === "]") {
              stream.next();
              state.inArray--;
              return "bracket";
            } else if (state.lhs && stream.peek() === "[" && stream.skipTo("]")) {
              stream.next();
              if (stream.peek() === "]")
                stream.next();
              return "atom";
            } else if (stream.peek() === "#") {
              stream.skipToEnd();
              return "comment";
            } else if (stream.eatSpace()) {
              return null;
            } else if (state.lhs && stream.eatWhile(function(c5) {
              return c5 != "=" && c5 != " ";
            })) {
              return "property";
            } else if (state.lhs && stream.peek() === "=") {
              stream.next();
              state.lhs = false;
              return null;
            } else if (!state.lhs && stream.match(/^\d\d\d\d[\d\-\:\.T]*Z/)) {
              return "atom";
            } else if (!state.lhs && (stream.match("true") || stream.match("false"))) {
              return "atom";
            } else if (!state.lhs && stream.peek() === "[") {
              state.inArray++;
              stream.next();
              return "bracket";
            } else if (!state.lhs && stream.match(/^\-?\d+(?:\.\d+)?/)) {
              return "number";
            } else if (!stream.eatSpace()) {
              stream.next();
            }
            return null;
          }
        };
      });
      CodeMirror2.defineMIME("text/x-historica", "historica");
    });
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag2 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag2] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        while (++index4 < length2) {
          var value = array[index4];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        while (++index4 < length2) {
          if (iteratee(array[index4], index4, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        while (length2--) {
          if (iteratee(array[length2], length2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        while (++index4 < length2) {
          if (!predicate(array[index4], index4, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index4 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index4 < length2) {
          var value = array[index4];
          if (predicate(value, index4, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length2 = array == null ? 0 : array.length;
        return !!length2 && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        while (++index4 < length2) {
          if (comparator(value, array[index4])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index4 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
        while (++index4 < length2) {
          result[index4] = iteratee(array[index4], index4, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index4 = -1, length2 = values.length, offset2 = array.length;
        while (++index4 < length2) {
          array[offset2 + index4] = values[index4];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[++index4];
        }
        while (++index4 < length2) {
          accumulator = iteratee(accumulator, array[index4], index4, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array[length2], length2, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index4 = -1, length2 = array == null ? 0 : array.length;
        while (++index4 < length2) {
          if (predicate(array[index4], index4, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length2 = array.length, index4 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index4-- : ++index4 < length2) {
          if (predicate(array[index4], index4, array)) {
            return index4;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index4 = fromIndex - 1, length2 = array.length;
        while (++index4 < length2) {
          if (comparator(array[index4], value)) {
            return index4;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSum(array, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index4, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index4, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length2 = array.length;
        array.sort(comparer);
        while (length2--) {
          array[length2] = array[length2].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index4 = -1, length2 = array.length;
        while (++index4 < length2) {
          var current = iteratee(array[index4]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n5, iteratee) {
        var index4 = -1, result = Array(n5);
        while (++index4 < n5) {
          result[index4] = iteratee(index4);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache3, key) {
        return cache3.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index4 = -1, length2 = strSymbols.length;
        while (++index4 < length2 && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
        }
        return index4;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index4 = strSymbols.length;
        while (index4-- && baseIndexOf(chrSymbols, strSymbols[index4], 0) > -1) {
        }
        return index4;
      }
      function countHolders(array, placeholder) {
        var length2 = array.length, result = 0;
        while (length2--) {
          if (array[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index4 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index4] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index4 = -1, length2 = array.length, resIndex = 0, result = [];
        while (++index4 < length2) {
          var value = array[index4];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index4] = PLACEHOLDER;
            result[resIndex++] = index4;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index4 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index4] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index4 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index4] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index4 = fromIndex - 1, length2 = array.length;
        while (++index4 < length2) {
          if (array[index4] === value) {
            return index4;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index4 = fromIndex + 1;
        while (index4--) {
          if (array[index4] === value) {
            return index4;
          }
        }
        return index4;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index4 = string.length;
        while (index4-- && reWhitespace.test(string.charAt(index4))) {
        }
        return index4;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _4.defaults(root.Object(), context, _4.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e3) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray12(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject8(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray12(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length2 = end2 - start2, index4 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index4 += dir;
              var iterIndex = -1, value = array[index4];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index4 = assocIndexOf(data, key);
          if (index4 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index4 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index4, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index4 = assocIndexOf(data, key);
          return index4 < 0 ? undefined2 : data[index4][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index4 = assocIndexOf(data, key);
          if (index4 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index4][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index4 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index4 < length2) {
            var entry = entries[index4];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index4 = -1, length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index4 < length2) {
            this.add(values2[index4]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs3 = data.__data__;
            if (!Map2 || pairs3.length < LARGE_ARRAY_SIZE - 1) {
              pairs3.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs3);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray12(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length2 = array.length;
          return length2 ? array[baseRandom(0, length2 - 1)] : undefined2;
        }
        function arraySampleSize(array, n5) {
          return shuffleSelf(copyArray(array), baseClamp(n5, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length2 = array.length;
          while (length2--) {
            if (eq(array[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index4 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
          while (++index4 < length2) {
            result2[index4] = skip ? undefined2 : get(object, paths[index4]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject8(value)) {
            return value;
          }
          var isArr = isArray12(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag2]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag2, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length2 = props.length;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index4 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index4 < length2) {
              var value = array[index4], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index4, collection2) {
            result2 = !!predicate(value, index4, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index4 = -1, length2 = array.length;
          while (++index4 < length2) {
            var value = array[index4], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end2) {
          var length2 = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length2 ? 0 : length2 + start2;
          }
          end2 = end2 === undefined2 || end2 > length2 ? length2 : toInteger(end2);
          if (end2 < 0) {
            end2 += length2;
          }
          end2 = start2 > end2 ? 0 : toLength(end2);
          while (start2 < end2) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index4, collection2) {
            if (predicate(value, index4, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index4 = -1, length2 = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index4 < length2) {
            var value = array[index4];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index4 = 0, length2 = path.length;
          while (object != null && index4 < length2) {
            object = object[toKey(path[index4++])];
          }
          return index4 && index4 == length2 ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray12(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start2, end2) {
          return number >= nativeMin(start2, end2) && number < nativeMax(start2, end2);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index4 = -1, seen = caches[0];
          outer:
            while (++index4 < length2 && result2.length < maxLength) {
              var value = array[index4], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache3 = caches[othIndex];
                  if (!(cache3 ? cacheHas(cache3, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray12(object), othIsArr = isArray12(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index4 = matchData.length, length2 = index4, noCustomizer = !customizer;
          if (object == null) {
            return !length2;
          }
          object = Object2(object);
          while (index4--) {
            var data = matchData[index4];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index4 < length2) {
            data = matchData[index4];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject8(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag2;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray12(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject8(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index4 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index4] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject8(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray12(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray12(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject8(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n5) {
          var length2 = array.length;
          if (!length2) {
            return;
          }
          n5 += n5 < 0 ? length2 : 0;
          return isIndex(n5, length2) ? array[n5] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray12(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index4 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index4, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index4 = -1, length2 = paths.length, result2 = {};
          while (++index4 < length2) {
            var path = paths[index4], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index4 = -1, length2 = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index4 < length2) {
            var fromIndex = 0, value = values2[index4], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index4 = indexes[length2];
            if (length2 == lastIndex || index4 !== previous) {
              var previous = index4;
              if (isIndex(index4)) {
                splice.call(array, index4, 1);
              } else {
                baseUnset(array, index4);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end2, step, fromRight) {
          var index4 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index4] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string, n5) {
          var result2 = "";
          if (!string || n5 < 1 || n5 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n5 % 2) {
              result2 += string;
            }
            n5 = nativeFloor(n5 / 2);
            if (n5) {
              string += string;
            }
          } while (n5);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n5) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n5, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject8(object)) {
            return object;
          }
          path = castPath(path, object);
          var index4 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
          while (nested != null && ++index4 < length2) {
            var key = toKey(path[index4]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index4 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject8(objValue) ? objValue : isIndex(path[index4 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end2) {
          var index4 = -1, length2 = array.length;
          if (start2 < 0) {
            start2 = -start2 > length2 ? 0 : length2 + start2;
          }
          end2 = end2 > length2 ? length2 : end2;
          if (end2 < 0) {
            end2 += length2;
          }
          length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length2);
          while (++index4 < length2) {
            result2[index4] = array[index4 + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index4, collection2) {
            result2 = predicate(value, index4, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index4 = -1, length2 = array.length, resIndex = 0, result2 = [];
          while (++index4 < length2) {
            var value = array[index4], computed = iteratee2 ? iteratee2(value) : value;
            if (!index4 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray12(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index4 = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index4 < length2) {
              var value = array[index4], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length2 = array.length, index4 = fromRight ? length2 : -1;
          while ((fromRight ? index4-- : ++index4 < length2) && predicate(array[index4], index4, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index4, fromRight ? index4 + 1 : length2) : baseSlice(array, fromRight ? index4 + 1 : 0, fromRight ? length2 : index4);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index4 = -1, result2 = Array2(length2);
          while (++index4 < length2) {
            var array = arrays[index4], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index4) {
                result2[index4] = baseDifference(result2[index4] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index4 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
          while (++index4 < length2) {
            var value = index4 < valsLength ? values2[index4] : undefined2;
            assignFunc(result2, props[index4], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray12(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end2) {
          var length2 = array.length;
          end2 = end2 === undefined2 ? length2 : end2;
          return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index4 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index4 < length2) {
            var result2 = compareAscending(objCriteria[index4], othCriteria[index4]);
            if (result2) {
              if (index4 >= ordersLength) {
                return result2;
              }
              var order = orders[index4];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index4 = -1, length2 = source.length;
          array || (array = Array2(length2));
          while (++index4 < length2) {
            array[index4] = source[index4];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index4 = -1, length2 = props.length;
          while (++index4 < length2) {
            var key = props[index4];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray12(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index4 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined2 : customizer;
              length2 = 1;
            }
            object = Object2(object);
            while (++index4 < length2) {
              var source = sources[index4];
              if (source) {
                assigner(object, source, index4, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index4 = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index4-- : ++index4 < length2) {
              if (iteratee2(iterable[index4], index4, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index4 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index4];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject8(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index4 = length2, placeholder = getHolder(wrapper);
            while (index4--) {
              args[index4] = arguments[index4];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length2
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index4 = findIndexFunc(collection, predicate, fromIndex);
            return index4 > -1 ? iterable[iteratee2 ? collection[index4] : index4] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index4 = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index4--) {
              var func = funcs[index4];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index4 = wrapper ? index4 : length2;
            while (++index4 < length2) {
              func = funcs[index4];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData2(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray12(value)) {
                return wrapper.plant(value).value();
              }
              var index5 = 0, result2 = length2 ? funcs[index5].apply(this, args) : value;
              while (++index5 < length2) {
                result2 = funcs[index5].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length2 = arguments.length, args = Array2(length2), index4 = length2;
            while (index4--) {
              args[index4] = arguments[index4];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end2, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
              end2 = step = undefined2;
            }
            start2 = toFinite(start2);
            if (end2 === undefined2) {
              end2 = start2;
              start2 = 0;
            } else {
              end2 = toFinite(end2);
            }
            step = step === undefined2 ? start2 < end2 ? 1 : -1 : toFinite(step);
            return baseRange(start2, end2, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag2 = getTag(object);
            if (tag2 == mapTag) {
              return mapToArray(object);
            }
            if (tag2 == setTag2) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData2(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject8(objValue) && isObject8(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index4 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index4 < arrLength) {
            var arrValue = array[index4], othValue = other[index4];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index4, other, array, stack) : customizer(arrValue, othValue, index4, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
          switch (tag2) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert2 = mapToArray;
            case setTag2:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert2 || (convert2 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index4 = objLength;
          while (index4--) {
            var key = objProps[index4];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index4 < objLength) {
            key = objProps[index4];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData2 = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length2--) {
            var data = array[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e3) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag2;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag2 || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag2;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end2, transforms) {
          var index4 = -1, length2 = transforms.length;
          while (++index4 < length2) {
            var data = transforms[index4], size2 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end2 -= size2;
                break;
              case "take":
                end2 = nativeMin(end2, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end2 - size2);
                break;
            }
          }
          return { "start": start2, "end": end2 };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index4 = -1, length2 = path.length, result2 = false;
          while (++index4 < length2) {
            var key = toKey(path[index4]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index4 != length2) {
            return result2;
          }
          length2 = object == null ? 0 : object.length;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray12(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length2 = array.length, result2 = new array.constructor(length2);
          if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag2, isDeep) {
          var Ctor = object.constructor;
          switch (tag2) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag2:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray12(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length2) {
          var type = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index4, object) {
          if (!isObject8(object)) {
            return false;
          }
          var type = typeof index4;
          if (type == "number" ? isArrayLike(object) && isIndex(index4, object.length) : type == "string" && index4 in object) {
            return eq(object[index4], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray12(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData2(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject8(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache3.size === MAX_MEMOIZE_SIZE) {
              cache3.clear();
            }
            return key;
          });
          var cache3 = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform2) {
          start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index4 = -1, length2 = nativeMax(args.length - start2, 0), array = Array2(length2);
            while (++index4 < length2) {
              array[index4] = args[start2 + index4];
            }
            index4 = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index4 < start2) {
              otherArgs[index4] = args[index4];
            }
            otherArgs[start2] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length2--) {
            var index4 = indexes[length2];
            array[length2] = isIndex(index4, arrLength) ? oldArray[index4] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index4 = -1, length2 = array.length, lastIndex = length2 - 1;
          size2 = size2 === undefined2 ? length2 : size2;
          while (++index4 < size2) {
            var rand = baseRandom(index4, lastIndex), value = array[rand];
            array[rand] = array[index4];
            array[index4] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e3) {
            }
            try {
              return func + "";
            } catch (e3) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length2 = array == null ? 0 : array.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index4 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index4 < length2) {
            result2[resIndex++] = baseSlice(array, index4, index4 += size2);
          }
          return result2;
        }
        function compact2(array) {
          var index4 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index4 < length2) {
            var value = array[index4];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array = arguments[0], index4 = length2;
          while (index4--) {
            args[index4 - 1] = arguments[index4];
          }
          return arrayPush(isArray12(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n5, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          return baseSlice(array, n5 < 0 ? 0 : n5, length2);
        }
        function dropRight(array, n5, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          n5 = length2 - n5;
          return baseSlice(array, 0, n5 < 0 ? 0 : n5);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end2) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end2 = length2;
          }
          return baseFill(array, value, start2, end2);
        }
        function findIndex(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index4 < 0) {
            index4 = nativeMax(length2 + index4, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index4);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index4 = length2 - 1;
          if (fromIndex !== undefined2) {
            index4 = toInteger(fromIndex);
            index4 = fromIndex < 0 ? nativeMax(length2 + index4, 0) : nativeMin(index4, length2 - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index4, true);
        }
        function flatten(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs3) {
          var index4 = -1, length2 = pairs3 == null ? 0 : pairs3.length, result2 = {};
          while (++index4 < length2) {
            var pair = pairs3[index4];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index4 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index4 < 0) {
            index4 = nativeMax(length2 + index4, 0);
          }
          return baseIndexOf(array, value, index4);
        }
        function initial(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 0, -1) : [];
        }
        var intersection2 = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? array[length2 - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return -1;
          }
          var index4 = length2;
          if (fromIndex !== undefined2) {
            index4 = toInteger(fromIndex);
            index4 = index4 < 0 ? nativeMax(length2 + index4, 0) : nativeMin(index4, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index4) : baseFindIndex(array, baseIsNaN, index4, true);
        }
        function nth(array, n5) {
          return array && array.length ? baseNth(array, toInteger(n5)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index4) {
            return isIndex(index4, length2) ? +index4 : index4;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index4 = -1, indexes = [], length2 = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index4 < length2) {
            var value = array[index4];
            if (predicate(value, index4, array)) {
              result2.push(value);
              indexes.push(index4);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse3(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start2, end2) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
            start2 = 0;
            end2 = length2;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end2 = end2 === undefined2 ? length2 : toInteger(end2);
          }
          return baseSlice(array, start2, end2);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index4 = baseSortedIndex(array, value);
            if (index4 < length2 && eq(array[index4], value)) {
              return index4;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length2 = array == null ? 0 : array.length;
          if (length2) {
            var index4 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index4], value)) {
              return index4;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSlice(array, 1, length2) : [];
        }
        function take(array, n5, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          return baseSlice(array, 0, n5 < 0 ? 0 : n5);
        }
        function takeRight(array, n5, guard) {
          var length2 = array == null ? 0 : array.length;
          if (!length2) {
            return [];
          }
          n5 = guard || n5 === undefined2 ? 1 : toInteger(n5);
          n5 = length2 - n5;
          return baseSlice(array, n5 < 0 ? 0 : n5, length2);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length2 = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index4) {
            return arrayMap(array, baseProperty(index4));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length2 && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray5(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse3],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse3);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray12(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray12(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find8 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray12(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray12(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index4 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index4] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray12(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray12(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray12(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray12(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray12(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray12(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray12(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n5, guard) {
          if (guard ? isIterateeCall(collection, n5, guard) : n5 === undefined2) {
            n5 = 1;
          } else {
            n5 = toInteger(n5);
          }
          var func = isArray12(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n5);
        }
        function shuffle(collection) {
          var func = isArray12(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag2 = getTag(collection);
          if (tag2 == mapTag || tag2 == setTag2) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some2(collection, predicate, guard) {
          var func = isArray12(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after2(n5, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n5 = toInteger(n5);
          return function() {
            if (--n5 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n5, guard) {
          n5 = guard ? undefined2 : n5;
          n5 = func && n5 == null ? func.length : n5;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n5);
        }
        function before2(n5, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n5 = toInteger(n5);
          return function() {
            if (--n5 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n5 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject8(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
            if (cache3.has(key)) {
              return cache3.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache3.set(key, result2) || cache3;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before2(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray12(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index4 = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index4 < length2) {
              args[index4] = transforms[index4].call(this, args[index4]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject8(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap2(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray12(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt2 = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray12 = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray12(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag2 = getTag(value);
          if (tag2 == mapTag || tag2 == setTag2) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject8(value)) {
            return false;
          }
          var tag2 = baseGetTag(value);
          return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject8(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull2(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray12(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt2 = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray5(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag2 ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject8(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject8(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at2 = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults4 = baseRest(function(object, sources) {
          object = Object2(object);
          var index4 = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index4 < length2) {
            var source = sources[index4];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has2(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index4 = -1, length2 = path.length;
          if (!length2) {
            length2 = 1;
            object = undefined2;
          }
          while (++index4 < length2) {
            var value = object == null ? undefined2 : object[toKey(path[index4])];
            if (value === undefined2) {
              index4 = length2;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray12(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject8(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index4, object2) {
            return iteratee2(accumulator, value, index4, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start2, end2) {
          start2 = toFinite(start2);
          if (end2 === undefined2) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          number = toNumber(number);
          return baseInRange(number, start2, end2);
        }
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index4) {
          word = word.toLowerCase();
          return result2 + (index4 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length2 = string.length;
          position = position === undefined2 ? length2 : baseClamp(toInteger(position), 0, length2);
          var end2 = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end2) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          if (!length2 || strLength >= length2) {
            return string;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
        }
        function padStart(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
        }
        function parseInt4(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n5, guard) {
          if (guard ? isIterateeCall(string, n5, guard) : n5 === undefined2) {
            n5 = 1;
          } else {
            n5 = toInteger(n5);
          }
          return baseRepeat(toString(string), n5);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? "_" : "") + word.toLowerCase();
        });
        function split3(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options2, guard)) {
            options2 = undefined2;
          }
          string = toString(string);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index4 = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index4, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index4 = offset2 + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end2).join("");
        }
        function trimEnd2(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end2).join("");
        }
        function trimStart2(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate2(string, options2) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject8(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length2 = "length" in options2 ? toInteger(options2.length) : length2;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string;
          }
          var end2 = length2 - stringSize(omission);
          if (end2 < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end2 += result2.length - end2;
          }
          if (isRegExp(separator)) {
            if (string.slice(end2).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end2 : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end2) != end2) {
            var index4 = result2.lastIndexOf(separator);
            if (index4 > -1) {
              result2 = result2.slice(0, index4);
            }
          }
          return result2 + omission;
        }
        function unescape3(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index4) {
          return result2 + (index4 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e3) {
            return isError(e3) ? e3 : new Error2(e3);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs3) {
          var length2 = pairs3 == null ? 0 : pairs3.length, toIteratee = getIteratee();
          pairs3 = !length2 ? [] : arrayMap(pairs3, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index4 = -1;
            while (++index4 < length2) {
              var pair = pairs3[index4];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches3(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject8(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject8(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n5) {
          n5 = toInteger(n5);
          return baseRest(function(args) {
            return baseNth(args, n5);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n5, iteratee2) {
          n5 = toInteger(n5);
          if (n5 < 1 || n5 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index4 = MAX_ARRAY_LENGTH, length2 = nativeMin(n5, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n5 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index4 < n5) {
            iteratee2(index4);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray12(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix5) {
          var id = ++idCounter;
          return toString(prefix5) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max4(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min2(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round3 = createRound("round");
        var subtract2 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after2;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at2;
        lodash.before = before2;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact2;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults4;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection2;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches3;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge2;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse3;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split3;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray5;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap2;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find8;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach2;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt2;
        lodash.gte = gte;
        lodash.has = has2;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray12;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull2;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject8;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined2;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt2;
        lodash.lte = lte;
        lodash.max = max4;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min2;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt4;
        lodash.random = random2;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round3;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some2;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract2;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd2;
        lodash.trimStart = trimStart2;
        lodash.truncate = truncate2;
        lodash.unescape = unescape3;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach2;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index4) {
          LazyWrapper.prototype[methodName] = function(n5) {
            n5 = n5 === undefined2 ? 1 : nativeMax(toInteger(n5), 0);
            var result2 = this.__filtered__ && !index4 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n5, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n5, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n5) {
            return this.reverse()[methodName](n5).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index4) {
          var type = index4 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index4) {
          var takeName = "take" + (index4 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index4) {
          var dropName = "drop" + (index4 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end2) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end2 !== undefined2) {
            end2 = toInteger(end2);
            result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray12(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray12(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray12(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _4 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _4;
        define(function() {
          return _4;
        });
      } else if (freeModule) {
        (freeModule.exports = _4)._ = _4;
        freeExports._ = _4;
      } else {
        root._ = _4;
      }
    }).call(exports);
  }
});

// node_modules/json-2-csv/lib/constants.js
var require_constants = __commonJS({
  "node_modules/json-2-csv/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.excelBOM = exports.defaultCsv2JsonOptions = exports.defaultJson2CsvOptions = exports.errors = void 0;
    exports.errors = {
      optionsRequired: "Options were not passed and are required.",
      json2csv: {
        cannotCallOn: "Cannot call json2csv on",
        dataCheckFailure: "Data provided was not an array of documents.",
        notSameSchema: "Not all documents have the same schema."
      },
      csv2json: {
        cannotCallOn: "Cannot call csv2json on",
        dataCheckFailure: "CSV is not a string."
      }
    };
    exports.defaultJson2CsvOptions = {
      arrayIndexesAsKeys: false,
      checkSchemaDifferences: false,
      delimiter: {
        field: ",",
        wrap: '"',
        eol: "\n"
      },
      emptyFieldValue: void 0,
      escapeHeaderNestedDots: true,
      excelBOM: false,
      excludeKeys: [],
      expandNestedObjects: true,
      expandArrayObjects: false,
      prependHeader: true,
      preventCsvInjection: false,
      sortHeader: false,
      trimFieldValues: false,
      trimHeaderFields: false,
      unwindArrays: false,
      useDateIso8601Format: false,
      useLocaleFormat: false,
      wrapBooleans: false
    };
    exports.defaultCsv2JsonOptions = {
      delimiter: {
        field: ",",
        wrap: '"',
        eol: "\n"
      },
      excelBOM: false,
      preventCsvInjection: false,
      trimFieldValues: false,
      trimHeaderFields: false,
      wrapBooleans: false
    };
    exports.excelBOM = "\uFEFF";
  }
});

// node_modules/doc-path/lib/path.js
var require_path = __commonJS({
  "node_modules/doc-path/lib/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setPath = exports.evaluatePath = void 0;
    function evaluatePath(obj, kp) {
      if (!obj) {
        return null;
      }
      const { dotIndex, key, remaining } = state(kp);
      const kpVal = typeof obj === "object" && kp in obj ? obj[kp] : void 0;
      const keyVal = typeof obj === "object" && key in obj ? obj[key] : void 0;
      if (dotIndex >= 0 && typeof obj === "object" && !(kp in obj)) {
        const { key: nextKey } = state(remaining);
        const nextKeyAsInt = parseInt(nextKey);
        if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {
          return keyVal.map((doc) => evaluatePath(doc, remaining));
        }
        return evaluatePath(keyVal, remaining);
      } else if (Array.isArray(obj)) {
        const keyAsInt = parseInt(key);
        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {
          return keyVal;
        }
        return obj.map((doc) => evaluatePath(doc, kp));
      } else if (dotIndex >= 0 && kp !== key && typeof obj === "object" && key in obj) {
        return evaluatePath(keyVal, remaining);
      } else if (dotIndex === -1 && typeof obj === "object" && key in obj && !(kp in obj)) {
        return keyVal;
      }
      return kpVal;
    }
    exports.evaluatePath = evaluatePath;
    function setPath(obj, kp, v4) {
      if (!obj) {
        throw new Error("No object was provided.");
      } else if (!kp) {
        throw new Error("No keyPath was provided.");
      }
      return _sp(obj, kp, v4);
    }
    exports.setPath = setPath;
    function _sp(obj, kp, v4) {
      var _a2;
      const { dotIndex, key, remaining } = state(kp);
      if (kp.startsWith("__proto__") || kp.startsWith("constructor") || kp.startsWith("prototype")) {
        return obj;
      }
      if (dotIndex >= 0) {
        const keyAsInt = parseInt(key);
        if (typeof obj === "object" && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {
          obj[key] = (_a2 = obj[key]) != null ? _a2 : {};
          _sp(obj[key], remaining, v4);
          return obj;
        } else if (typeof obj === "object" && obj !== null && !(key in obj) && Array.isArray(obj)) {
          obj.forEach((doc) => _sp(doc, kp, v4));
          return obj;
        } else if (typeof obj === "object" && obj !== null && !(key in obj) && !Array.isArray(obj)) {
          const { key: nextKey } = state(remaining);
          const nextKeyAsInt = parseInt(nextKey);
          if (!isNaN(nextKeyAsInt)) {
            obj[key] = [];
          } else {
            obj[key] = {};
          }
        }
        _sp(obj[key], remaining, v4);
      } else if (Array.isArray(obj)) {
        const keyAsInt = parseInt(key);
        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {
          obj[key] = v4;
          return obj;
        }
        obj.forEach((doc) => _sp(doc, remaining, v4));
        return obj;
      } else {
        obj[key] = v4;
      }
      return obj;
    }
    function state(kp) {
      const dotIndex = findFirstNonEscapedDotIndex(kp);
      return {
        dotIndex,
        key: kp.slice(0, dotIndex >= 0 ? dotIndex : void 0).replace(/\\./g, "."),
        remaining: kp.slice(dotIndex + 1)
      };
    }
    function findFirstNonEscapedDotIndex(kp) {
      for (let i5 = 0; i5 < kp.length; i5++) {
        const previousChar = i5 > 0 ? kp[i5 - 1] : "", currentChar = kp[i5];
        if (currentChar === "." && previousChar !== "\\")
          return i5;
      }
      return -1;
    }
  }
});

// node_modules/deeks/lib/utils.js
var require_utils = __commonJS({
  "node_modules/deeks/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDocumentToRecurOn = exports.flatten = exports.unique = void 0;
    function unique2(array) {
      return [...new Set(array)];
    }
    exports.unique = unique2;
    function flatten(array) {
      return [].concat(...array);
    }
    exports.flatten = flatten;
    function isDocumentToRecurOn(val) {
      return typeof val === "object" && val !== null && !Array.isArray(val) && Object.keys(val).length;
    }
    exports.isDocumentToRecurOn = isDocumentToRecurOn;
  }
});

// node_modules/deeks/lib/types.js
var require_types = __commonJS({
  "node_modules/deeks/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/deeks/lib/deeks.js
var require_deeks = __commonJS({
  "node_modules/deeks/lib/deeks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m6, k3);
      if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m6[k3];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o4[k22] = m6[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    } : function(o4, v4) {
      o4["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m6, exports2) {
      for (var p7 in m6)
        if (p7 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p7))
          __createBinding(exports2, m6, p7);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepKeysFromList = exports.deepKeys = void 0;
    var utils2 = __importStar(require_utils());
    __exportStar(require_types(), exports);
    function deepKeys(object, options2) {
      const parsedOptions = mergeOptions(options2);
      if (typeof object === "object" && object !== null) {
        return generateDeepKeysList("", object, parsedOptions);
      }
      return [];
    }
    exports.deepKeys = deepKeys;
    function deepKeysFromList(list5, options2) {
      const parsedOptions = mergeOptions(options2);
      return list5.map((document2) => {
        if (typeof document2 === "object" && document2 !== null) {
          return deepKeys(document2, parsedOptions);
        }
        return [];
      });
    }
    exports.deepKeysFromList = deepKeysFromList;
    function generateDeepKeysList(heading2, data, options2) {
      const keys = Object.keys(data).map((currentKey) => {
        const keyName = buildKeyName(heading2, escapeNestedDotsIfSpecified(currentKey, options2));
        if (options2.expandNestedObjects && utils2.isDocumentToRecurOn(data[currentKey]) || options2.arrayIndexesAsKeys && Array.isArray(data[currentKey]) && data[currentKey].length) {
          return generateDeepKeysList(keyName, data[currentKey], options2);
        } else if (options2.expandArrayObjects && Array.isArray(data[currentKey])) {
          return processArrayKeys(data[currentKey], keyName, options2);
        } else if (options2.ignoreEmptyArrays && Array.isArray(data[currentKey]) && !data[currentKey].length) {
          return [];
        }
        return keyName;
      });
      return utils2.flatten(keys);
    }
    function processArrayKeys(subArray, currentKeyPath, options2) {
      let subArrayKeys = deepKeysFromList(subArray, options2);
      if (!subArray.length) {
        return options2.ignoreEmptyArraysWhenExpanding ? [] : [currentKeyPath];
      } else if (subArray.length && utils2.flatten(subArrayKeys).length === 0) {
        return [currentKeyPath];
      } else {
        subArrayKeys = subArrayKeys.map((schemaKeys) => {
          if (Array.isArray(schemaKeys) && schemaKeys.length === 0) {
            return [currentKeyPath];
          }
          return schemaKeys.map((subKey) => buildKeyName(currentKeyPath, escapeNestedDotsIfSpecified(subKey, options2)));
        });
        return utils2.unique(utils2.flatten(subArrayKeys));
      }
    }
    function escapeNestedDotsIfSpecified(key, options2) {
      if (options2.escapeNestedDots) {
        return key.replace(/\./g, "\\.");
      }
      return key;
    }
    function buildKeyName(upperKeyName, currentKeyName) {
      if (upperKeyName) {
        return upperKeyName + "." + currentKeyName;
      }
      return currentKeyName;
    }
    function mergeOptions(options2) {
      return {
        arrayIndexesAsKeys: false,
        expandNestedObjects: true,
        expandArrayObjects: false,
        ignoreEmptyArraysWhenExpanding: false,
        escapeNestedDots: false,
        ignoreEmptyArrays: false,
        ...options2 != null ? options2 : {}
      };
    }
  }
});

// node_modules/json-2-csv/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/json-2-csv/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInvalid = exports.flatten = exports.unique = exports.arrayDifference = exports.isError = exports.isUndefined = exports.isNull = exports.isObject = exports.isString = exports.isNumber = exports.unwind = exports.getNCharacters = exports.removeEmptyFields = exports.isEmptyField = exports.computeSchemaDifferences = exports.isDateRepresentation = exports.isStringRepresentation = exports.deepCopy = exports.validate = exports.buildC2JOptions = exports.buildJ2COptions = void 0;
    var doc_path_1 = require_path();
    var constants_1 = require_constants();
    var dateStringRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
    var MAX_ARRAY_LENGTH = 1e5;
    function buildJ2COptions(opts2) {
      var _a2, _b2, _c, _d;
      return {
        ...constants_1.defaultJson2CsvOptions,
        ...opts2,
        delimiter: {
          field: (_b2 = (_a2 = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _a2.field) != null ? _b2 : constants_1.defaultJson2CsvOptions.delimiter.field,
          wrap: ((_c = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _c.wrap) || constants_1.defaultJson2CsvOptions.delimiter.wrap,
          eol: ((_d = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _d.eol) || constants_1.defaultJson2CsvOptions.delimiter.eol
        },
        fieldTitleMap: /* @__PURE__ */ Object.create({})
      };
    }
    exports.buildJ2COptions = buildJ2COptions;
    function buildC2JOptions(opts2) {
      var _a2, _b2, _c, _d;
      return {
        ...constants_1.defaultCsv2JsonOptions,
        ...opts2,
        delimiter: {
          field: (_b2 = (_a2 = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _a2.field) != null ? _b2 : constants_1.defaultCsv2JsonOptions.delimiter.field,
          wrap: ((_c = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _c.wrap) || constants_1.defaultCsv2JsonOptions.delimiter.wrap,
          eol: ((_d = opts2 == null ? void 0 : opts2.delimiter) == null ? void 0 : _d.eol) || constants_1.defaultCsv2JsonOptions.delimiter.eol
        }
      };
    }
    exports.buildC2JOptions = buildC2JOptions;
    function validate2(data, validationFn, errorMessages) {
      if (!data)
        throw new Error(`${errorMessages.cannotCallOn} ${data}.`);
      if (!validationFn(data))
        throw new Error(errorMessages.dataCheckFailure);
      return true;
    }
    exports.validate = validate2;
    function deepCopy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    exports.deepCopy = deepCopy;
    function isStringRepresentation(fieldValue, options2) {
      const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];
      return firstChar === options2.delimiter.wrap && lastChar === options2.delimiter.wrap;
    }
    exports.isStringRepresentation = isStringRepresentation;
    function isDateRepresentation(fieldValue) {
      return dateStringRegex.test(fieldValue);
    }
    exports.isDateRepresentation = isDateRepresentation;
    function computeSchemaDifferences(schemaA, schemaB) {
      return arrayDifference(schemaA, schemaB).concat(arrayDifference(schemaB, schemaA));
    }
    exports.computeSchemaDifferences = computeSchemaDifferences;
    function isEmptyField(fieldValue) {
      return isUndefined2(fieldValue) || isNull2(fieldValue) || fieldValue === "";
    }
    exports.isEmptyField = isEmptyField;
    function removeEmptyFields(fields) {
      return fields.filter((field) => !isEmptyField(field));
    }
    exports.removeEmptyFields = removeEmptyFields;
    function getNCharacters(str, start2, n5) {
      return str.substring(start2, start2 + n5);
    }
    exports.getNCharacters = getNCharacters;
    function unwindItem(accumulator, item, fieldPath) {
      const valueToUnwind = (0, doc_path_1.evaluatePath)(item, fieldPath);
      let cloned = deepCopy(item);
      if (Array.isArray(valueToUnwind) && valueToUnwind.length) {
        valueToUnwind.forEach((val) => {
          cloned = deepCopy(item);
          accumulator.push((0, doc_path_1.setPath)(cloned, fieldPath, val));
        });
      } else if (Array.isArray(valueToUnwind) && valueToUnwind.length === 0) {
        (0, doc_path_1.setPath)(cloned, fieldPath, "");
        accumulator.push(cloned);
      } else {
        accumulator.push(cloned);
      }
    }
    function unwind(array, field) {
      const result = [];
      array.forEach((item) => {
        unwindItem(result, item, field);
      });
      return result;
    }
    exports.unwind = unwind;
    function isNumber2(value) {
      return !isNaN(Number(value));
    }
    exports.isNumber = isNumber2;
    function isString(value) {
      return typeof value === "string";
    }
    exports.isString = isString;
    function isObject8(value) {
      return typeof value === "object";
    }
    exports.isObject = isObject8;
    function isNull2(value) {
      return value === null;
    }
    exports.isNull = isNull2;
    function isUndefined2(value) {
      return typeof value === "undefined";
    }
    exports.isUndefined = isUndefined2;
    function isError(value) {
      return Object.prototype.toString.call(value) === "[object Error]";
    }
    exports.isError = isError;
    function arrayDifference(a4, b2) {
      return a4.filter((x2) => !b2.includes(x2));
    }
    exports.arrayDifference = arrayDifference;
    function unique2(array) {
      return [...new Set(array)];
    }
    exports.unique = unique2;
    function flatten(array) {
      if (array.flat) {
        return array.flat();
      }
      if (array.length > MAX_ARRAY_LENGTH) {
        let safeArray = [];
        for (let a4 = 0; a4 < array.length; a4 += MAX_ARRAY_LENGTH) {
          safeArray = safeArray.concat(...array.slice(a4, a4 + MAX_ARRAY_LENGTH));
        }
        return safeArray;
      }
      return array.reduce((accumulator, value) => accumulator.concat(value), []);
    }
    exports.flatten = flatten;
    function isInvalid(parsedJson) {
      return parsedJson === Infinity || parsedJson === -Infinity;
    }
    exports.isInvalid = isInvalid;
  }
});

// node_modules/json-2-csv/lib/json2csv.js
var require_json2csv = __commonJS({
  "node_modules/json-2-csv/lib/json2csv.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m6, k3);
      if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m6[k3];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o4[k22] = m6[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    } : function(o4, v4) {
      o4["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Json2Csv = void 0;
    var doc_path_1 = require_path();
    var deeks_1 = require_deeks();
    var constants_1 = require_constants();
    var utils2 = __importStar(require_utils2());
    var Json2Csv = function(options2) {
      const wrapDelimiterCheckRegex = new RegExp(options2.delimiter.wrap, "g"), crlfSearchRegex = /\r?\n|\r/, customValueParser = options2.parseValue && typeof options2.parseValue === "function" ? options2.parseValue : null, expandingWithoutUnwinding = options2.expandArrayObjects && !options2.unwindArrays, deeksOptions = {
        arrayIndexesAsKeys: options2.arrayIndexesAsKeys,
        expandNestedObjects: options2.expandNestedObjects,
        expandArrayObjects: expandingWithoutUnwinding,
        ignoreEmptyArraysWhenExpanding: expandingWithoutUnwinding,
        escapeNestedDots: true
      };
      function getFieldNameList(data) {
        return (0, deeks_1.deepKeysFromList)(data, deeksOptions);
      }
      function processSchemas(documentSchemas) {
        if (options2.checkSchemaDifferences) {
          return checkSchemaDifferences(documentSchemas);
        } else {
          const uniqueFieldNames = utils2.unique(utils2.flatten(documentSchemas));
          return uniqueFieldNames;
        }
      }
      function checkSchemaDifferences(documentSchemas) {
        const firstDocSchema = documentSchemas[0], restOfDocumentSchemas = documentSchemas.slice(1), schemaDifferences = computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas);
        if (schemaDifferences) {
          throw new Error(constants_1.errors.json2csv.notSameSchema);
        }
        return firstDocSchema;
      }
      function computeNumberOfSchemaDifferences(firstDocSchema, restOfDocumentSchemas) {
        return restOfDocumentSchemas.reduce((schemaDifferences, documentSchema) => {
          const numberOfDifferences = utils2.computeSchemaDifferences(firstDocSchema, documentSchema).length;
          return numberOfDifferences > 0 ? schemaDifferences + 1 : schemaDifferences;
        }, 0);
      }
      function filterExcludedKeys(keyPaths) {
        if (options2.excludeKeys) {
          return keyPaths.filter((keyPath) => {
            for (const excludedKey of options2.excludeKeys) {
              const regex = excludedKey instanceof RegExp ? excludedKey : new RegExp(`^${excludedKey}`);
              if (excludedKey === keyPath || keyPath.match(regex)) {
                return false;
              }
            }
            return true;
          });
        }
        return keyPaths;
      }
      function sortHeaderFields(fieldNames) {
        if (options2.sortHeader && typeof options2.sortHeader === "function") {
          return fieldNames.sort(options2.sortHeader);
        } else if (options2.sortHeader) {
          return fieldNames.sort();
        }
        return fieldNames;
      }
      function trimHeaderFields(params) {
        if (options2.trimHeaderFields) {
          params.headerFields = params.headerFields.map((field) => field.split(".").map((component) => component.trim()).join("."));
        }
        return params;
      }
      function wrapHeaderFields(params) {
        if (options2.prependHeader) {
          params.headerFields = params.headerFields.map(function(headingKey) {
            return wrapFieldValueIfNecessary(headingKey);
          });
        }
        return params;
      }
      function generateCsvHeader(params) {
        const fieldTitleMapKeys = Object.keys(options2.fieldTitleMap);
        params.header = params.headerFields.map(function(field) {
          let headerKey = field;
          if (fieldTitleMapKeys.includes(field)) {
            headerKey = options2.fieldTitleMap[field];
          } else if (!options2.escapeHeaderNestedDots) {
            headerKey = headerKey.replace(/\\\./g, ".");
          }
          return wrapFieldValueIfNecessary(headerKey);
        }).join(options2.delimiter.field);
        return params;
      }
      function convertKeysToHeaderFields() {
        if (!options2.keys)
          return [];
        return options2.keys.map((key) => {
          var _a2;
          if (typeof key === "object" && "field" in key) {
            options2.fieldTitleMap[key.field] = (_a2 = key.title) != null ? _a2 : key.field;
            return key.field;
          }
          return key;
        });
      }
      function extractWildcardMatchKeys() {
        if (!options2.keys)
          return [];
        return options2.keys.flatMap((item) => {
          if (typeof item === "string") {
            return [];
          } else if (item == null ? void 0 : item.wildcardMatch) {
            return item.field;
          }
          return [];
        });
      }
      function retrieveHeaderFields(data) {
        const wildcardMatchKeys = extractWildcardMatchKeys();
        const keyStrings = convertKeysToHeaderFields();
        const fieldNames = getFieldNameList(data);
        const processed = processSchemas(fieldNames);
        if (options2.keys) {
          options2.keys = keyStrings;
          const matchedKeys = keyStrings.flatMap((userProvidedKey) => {
            if (!wildcardMatchKeys.includes(userProvidedKey)) {
              return userProvidedKey;
            }
            const matches3 = [];
            const regex = new RegExp(`^${userProvidedKey}`);
            for (const detectedKey of processed) {
              if (userProvidedKey === detectedKey || detectedKey.match(regex)) {
                matches3.push(detectedKey);
              }
            }
            return matches3;
          });
          if (!options2.unwindArrays) {
            const filtered2 = filterExcludedKeys(matchedKeys);
            return sortHeaderFields(filtered2);
          }
        }
        const filtered = filterExcludedKeys(processed);
        return sortHeaderFields(filtered);
      }
      function unwindRecordsIfNecessary(params, finalPass = false) {
        if (options2.unwindArrays) {
          const originalRecordsLength = params.records.length;
          params.headerFields.forEach((headerField) => {
            params.records = utils2.unwind(params.records, headerField);
          });
          const headerFields = retrieveHeaderFields(params.records);
          params.headerFields = headerFields;
          if (originalRecordsLength !== params.records.length) {
            return unwindRecordsIfNecessary(params);
          }
          if (!finalPass) {
            return unwindRecordsIfNecessary(params, true);
          }
          if (options2.keys) {
            const userSelectedFields = convertKeysToHeaderFields();
            params.headerFields = filterExcludedKeys(userSelectedFields);
          }
          return params;
        }
        return params;
      }
      function processRecords(params) {
        params.recordString = params.records.map((record) => {
          const recordFieldData = retrieveRecordFieldData(record, params.headerFields), processedRecordData = recordFieldData.map((fieldValue) => {
            fieldValue = trimRecordFieldValue(fieldValue);
            fieldValue = preventCsvInjection(fieldValue);
            let stringified = customValueParser ? customValueParser(fieldValue, recordFieldValueToString) : recordFieldValueToString(fieldValue);
            stringified = wrapFieldValueIfNecessary(stringified);
            return stringified;
          });
          return generateCsvRowFromRecord(processedRecordData);
        }).join(options2.delimiter.eol);
        return params;
      }
      function processRecordFieldDataForExpandedArrayObject(recordFieldValue) {
        const filteredRecordFieldValue = utils2.removeEmptyFields(recordFieldValue);
        if (!recordFieldValue.length || !filteredRecordFieldValue.length) {
          return options2.emptyFieldValue || "";
        } else if (filteredRecordFieldValue.length === 1) {
          return filteredRecordFieldValue[0];
        }
        return recordFieldValue;
      }
      function retrieveRecordFieldData(record, fields) {
        const recordValues = [];
        fields.forEach((field) => {
          let recordFieldValue = (0, doc_path_1.evaluatePath)(record, field);
          if (!utils2.isUndefined(options2.emptyFieldValue) && utils2.isEmptyField(recordFieldValue)) {
            recordFieldValue = options2.emptyFieldValue;
          } else if (options2.expandArrayObjects && Array.isArray(recordFieldValue)) {
            recordFieldValue = processRecordFieldDataForExpandedArrayObject(recordFieldValue);
          }
          recordValues.push(recordFieldValue);
        });
        return recordValues;
      }
      function recordFieldValueToString(fieldValue) {
        const isDate = fieldValue instanceof Date;
        if (fieldValue === null || Array.isArray(fieldValue) || typeof fieldValue === "object" && !isDate) {
          return JSON.stringify(fieldValue);
        } else if (typeof fieldValue === "undefined") {
          return "undefined";
        } else if (isDate && options2.useDateIso8601Format) {
          return fieldValue.toISOString();
        } else {
          return !options2.useLocaleFormat ? fieldValue.toString() : fieldValue.toLocaleString();
        }
      }
      function trimRecordFieldValue(fieldValue) {
        if (options2.trimFieldValues) {
          if (Array.isArray(fieldValue)) {
            return fieldValue.map(trimRecordFieldValue);
          } else if (typeof fieldValue === "string") {
            return fieldValue.trim();
          }
          return fieldValue;
        }
        return fieldValue;
      }
      function preventCsvInjection(fieldValue) {
        if (options2.preventCsvInjection) {
          if (Array.isArray(fieldValue)) {
            return fieldValue.map(preventCsvInjection);
          } else if (typeof fieldValue === "string" && !utils2.isNumber(fieldValue)) {
            return fieldValue.replace(/^[=+\-@\t\r]+/g, "");
          }
          return fieldValue;
        }
        return fieldValue;
      }
      function wrapFieldValueIfNecessary(fieldValue) {
        const wrapDelimiter = options2.delimiter.wrap;
        if (fieldValue.includes(options2.delimiter.wrap)) {
          fieldValue = fieldValue.replace(wrapDelimiterCheckRegex, wrapDelimiter + wrapDelimiter);
        }
        if (fieldValue.includes(options2.delimiter.field) || fieldValue.includes(options2.delimiter.wrap) || fieldValue.match(crlfSearchRegex) || options2.wrapBooleans && (fieldValue === "true" || fieldValue === "false")) {
          fieldValue = wrapDelimiter + fieldValue + wrapDelimiter;
        }
        return fieldValue;
      }
      function generateCsvRowFromRecord(recordFieldValues) {
        return recordFieldValues.join(options2.delimiter.field);
      }
      function generateCsvFromComponents(params) {
        const header = params.header, records = params.recordString, csv = (options2.excelBOM ? constants_1.excelBOM : "") + (options2.prependHeader ? header + options2.delimiter.eol : "") + records;
        return csv;
      }
      function convert2(data) {
        if (utils2.isObject(data) && !data.length) {
          data = [data];
        }
        const headerFields = {
          headerFields: retrieveHeaderFields(data),
          records: data,
          header: "",
          recordString: ""
        };
        const unwinded = unwindRecordsIfNecessary(headerFields);
        const processed = processRecords(unwinded);
        const wrapped = wrapHeaderFields(processed);
        const trimmed = trimHeaderFields(wrapped);
        const generated = generateCsvHeader(trimmed);
        return generateCsvFromComponents(generated);
      }
      return {
        convert: convert2
      };
    };
    exports.Json2Csv = Json2Csv;
  }
});

// node_modules/json-2-csv/lib/csv2json.js
var require_csv2json = __commonJS({
  "node_modules/json-2-csv/lib/csv2json.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      var desc = Object.getOwnPropertyDescriptor(m6, k3);
      if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m6[k3];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    } : function(o4, m6, k3, k22) {
      if (k22 === void 0)
        k22 = k3;
      o4[k22] = m6[k3];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    } : function(o4, v4) {
      o4["default"] = v4;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k3 in mod)
          if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
            __createBinding(result, mod, k3);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Csv2Json = void 0;
    var doc_path_1 = require_path();
    var constants_1 = require_constants();
    var utils2 = __importStar(require_utils2());
    var Csv2Json = function(options2) {
      const escapedWrapDelimiterRegex = new RegExp(options2.delimiter.wrap + options2.delimiter.wrap, "g"), excelBOMRegex = new RegExp("^" + constants_1.excelBOM), valueParserFn = options2.parseValue && typeof options2.parseValue === "function" ? options2.parseValue : JSON.parse;
      function processHeaderKey(headerKey) {
        headerKey = removeWrapDelimitersFromValue(headerKey);
        if (options2.trimHeaderFields) {
          return headerKey.split(".").map((component) => component.trim()).join(".");
        }
        return headerKey;
      }
      function retrieveHeading(lines) {
        let headerFields = [];
        if (options2.headerFields) {
          headerFields = options2.headerFields.map((headerField, index4) => ({
            value: processHeaderKey(headerField),
            index: index4
          }));
        } else {
          const headerRow = lines[0];
          headerFields = headerRow.map((headerKey, index4) => ({
            value: processHeaderKey(headerKey),
            index: index4
          }));
          if (options2.keys) {
            const keys = options2.keys;
            headerFields = headerFields.filter((headerKey) => keys.includes(headerKey.value));
          }
        }
        return {
          lines,
          headerFields,
          recordLines: []
        };
      }
      function stripExcelBOM(csv) {
        if (options2.excelBOM) {
          return csv.replace(excelBOMRegex, "");
        }
        return csv;
      }
      function splitLines(csv) {
        const lines = [], lastCharacterIndex = csv.length - 1, eolDelimiterLength = options2.delimiter.eol.length, stateVariables = {
          insideWrapDelimiter: false,
          parsingValue: true,
          justParsedDoubleQuote: false,
          startIndex: 0
        };
        let splitLine = [], character, charBefore, charAfter, nextNChar, index4 = 0;
        while (index4 < csv.length) {
          character = csv[index4];
          charBefore = index4 ? csv[index4 - 1] : "";
          charAfter = index4 < lastCharacterIndex ? csv[index4 + 1] : "";
          nextNChar = utils2.getNCharacters(csv, index4, eolDelimiterLength);
          if ((nextNChar === options2.delimiter.eol && !stateVariables.insideWrapDelimiter || index4 === lastCharacterIndex) && charBefore === options2.delimiter.field) {
            if (nextNChar === options2.delimiter.eol && stateVariables.startIndex === index4) {
              splitLine.push("");
            } else if (character === options2.delimiter.field) {
              splitLine.push("");
            } else {
              splitLine.push(csv.substr(stateVariables.startIndex));
            }
            splitLine.push("");
            lines.push(splitLine);
            splitLine = [];
            stateVariables.startIndex = index4 + eolDelimiterLength;
            stateVariables.parsingValue = true;
            stateVariables.insideWrapDelimiter = charAfter === options2.delimiter.wrap;
          } else if (index4 === lastCharacterIndex && character === options2.delimiter.field) {
            const parsedValue = csv.substring(stateVariables.startIndex, index4);
            splitLine.push(parsedValue);
            splitLine.push("");
            lines.push(splitLine);
          } else if (index4 === lastCharacterIndex || nextNChar === options2.delimiter.eol && // if we aren't inside wrap delimiters or if we are but the character before was a wrap delimiter and we didn't just see two
          (!stateVariables.insideWrapDelimiter || stateVariables.insideWrapDelimiter && charBefore === options2.delimiter.wrap && !stateVariables.justParsedDoubleQuote)) {
            const toIndex = index4 !== lastCharacterIndex || charBefore === options2.delimiter.wrap ? index4 : void 0;
            splitLine.push(csv.substring(stateVariables.startIndex, toIndex));
            lines.push(splitLine);
            splitLine = [];
            stateVariables.startIndex = index4 + eolDelimiterLength;
            stateVariables.parsingValue = true;
            stateVariables.insideWrapDelimiter = charAfter === options2.delimiter.wrap;
          } else if (character === options2.delimiter.wrap && charBefore === options2.delimiter.field && !stateVariables.insideWrapDelimiter && !stateVariables.parsingValue) {
            stateVariables.startIndex = index4;
            stateVariables.insideWrapDelimiter = true;
            stateVariables.parsingValue = true;
            if (utils2.getNCharacters(csv, index4 + 1, eolDelimiterLength) === options2.delimiter.eol) {
              index4 += options2.delimiter.eol.length + 1;
            }
          } else if ((charBefore !== options2.delimiter.wrap || stateVariables.justParsedDoubleQuote && charBefore === options2.delimiter.wrap) && character === options2.delimiter.wrap && utils2.getNCharacters(csv, index4 + 1, eolDelimiterLength) === options2.delimiter.eol) {
            stateVariables.insideWrapDelimiter = false;
            stateVariables.parsingValue = false;
          } else if (character === options2.delimiter.wrap && (index4 === 0 || utils2.getNCharacters(csv, index4 - eolDelimiterLength, eolDelimiterLength) === options2.delimiter.eol && !stateVariables.insideWrapDelimiter)) {
            stateVariables.insideWrapDelimiter = true;
            stateVariables.parsingValue = true;
            stateVariables.startIndex = index4;
          } else if (character === options2.delimiter.wrap && charAfter === options2.delimiter.field) {
            splitLine.push(csv.substring(stateVariables.startIndex, index4 + 1));
            stateVariables.startIndex = index4 + 2;
            stateVariables.insideWrapDelimiter = false;
            stateVariables.parsingValue = false;
          } else if (character === options2.delimiter.wrap && charBefore === options2.delimiter.field && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {
            splitLine.push(csv.substring(stateVariables.startIndex, index4 - 1));
            stateVariables.insideWrapDelimiter = true;
            stateVariables.parsingValue = true;
            stateVariables.startIndex = index4;
          } else if (character === options2.delimiter.wrap && charAfter === options2.delimiter.wrap && index4 !== stateVariables.startIndex) {
            index4 += 2;
            stateVariables.justParsedDoubleQuote = true;
            continue;
          } else if (character === options2.delimiter.field && charBefore !== options2.delimiter.wrap && charAfter !== options2.delimiter.wrap && !stateVariables.insideWrapDelimiter && stateVariables.parsingValue) {
            splitLine.push(csv.substring(stateVariables.startIndex, index4));
            stateVariables.startIndex = index4 + 1;
          } else if (character === options2.delimiter.field && charBefore === options2.delimiter.wrap && charAfter !== options2.delimiter.wrap && !stateVariables.parsingValue) {
            stateVariables.insideWrapDelimiter = false;
            stateVariables.parsingValue = true;
            stateVariables.startIndex = index4 + 1;
          }
          index4++;
          stateVariables.justParsedDoubleQuote = false;
        }
        return lines;
      }
      function retrieveRecordLines(params) {
        if (options2.headerFields) {
          params.recordLines = params.lines;
        } else {
          params.recordLines = params.lines.splice(1);
        }
        return params;
      }
      function retrieveRecordValueFromLine(headerField, line) {
        const value = line[headerField.index];
        return processRecordValue(value);
      }
      function processRecordValue(fieldValue) {
        const parsedJson = parseValue(fieldValue);
        if (!utils2.isError(parsedJson) && !utils2.isInvalid(parsedJson)) {
          return parsedJson;
        } else if (fieldValue === "undefined") {
          return void 0;
        }
        return fieldValue;
      }
      function trimRecordValue(fieldValue) {
        if (options2.trimFieldValues && fieldValue !== null) {
          return fieldValue.trim();
        }
        return fieldValue;
      }
      function createDocument(headerFields, line) {
        return headerFields.reduce((document2, headerField) => {
          const value = retrieveRecordValueFromLine(headerField, line);
          try {
            return (0, doc_path_1.setPath)(document2, headerField.value, value);
          } catch (error) {
            return document2;
          }
        }, {});
      }
      function removeWrapDelimitersFromValue(fieldValue) {
        const firstChar = fieldValue[0], lastIndex = fieldValue.length - 1, lastChar = fieldValue[lastIndex];
        if (firstChar === options2.delimiter.wrap && lastChar === options2.delimiter.wrap) {
          return fieldValue.substr(1, lastIndex - 1);
        }
        return fieldValue;
      }
      function unescapeWrapDelimiterInField(fieldValue) {
        return fieldValue.replace(escapedWrapDelimiterRegex, options2.delimiter.wrap);
      }
      function transformRecordLines(params) {
        return params.recordLines.reduce((generatedJsonObjects, line) => {
          line = line.map((fieldValue) => {
            fieldValue = removeWrapDelimitersFromValue(fieldValue);
            fieldValue = unescapeWrapDelimiterInField(fieldValue);
            fieldValue = trimRecordValue(fieldValue);
            return fieldValue;
          });
          const generatedDocument = createDocument(params.headerFields, line);
          return generatedJsonObjects.concat(generatedDocument);
        }, []);
      }
      function parseValue(value) {
        try {
          if (utils2.isStringRepresentation(value, options2) && !utils2.isDateRepresentation(value)) {
            return value;
          }
          const parsedJson = valueParserFn(value);
          if (Array.isArray(parsedJson)) {
            return parsedJson.map(trimRecordValue);
          }
          return parsedJson;
        } catch (err) {
          return err;
        }
      }
      function convert2(data) {
        const stripped = stripExcelBOM(data);
        const split3 = splitLines(stripped);
        const heading2 = retrieveHeading(split3);
        const lines = retrieveRecordLines(heading2);
        return transformRecordLines(lines);
      }
      return {
        convert: convert2
      };
    };
    exports.Csv2Json = Csv2Json;
  }
});

// node_modules/json-2-csv/lib/converter.js
var require_converter = __commonJS({
  "node_modules/json-2-csv/lib/converter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.csv2json = exports.json2csv = void 0;
    var constants_1 = require_constants();
    var json2csv_1 = require_json2csv();
    var csv2json_1 = require_csv2json();
    var utils_1 = require_utils2();
    function json2csv2(data, options2) {
      const builtOptions = (0, utils_1.buildJ2COptions)(options2 != null ? options2 : {});
      (0, utils_1.validate)(data, utils_1.isObject, constants_1.errors.json2csv);
      return (0, json2csv_1.Json2Csv)(builtOptions).convert(data);
    }
    exports.json2csv = json2csv2;
    function csv2json(data, options2) {
      const builtOptions = (0, utils_1.buildC2JOptions)(options2 != null ? options2 : {});
      (0, utils_1.validate)(data, utils_1.isString, constants_1.errors.csv2json);
      return (0, csv2json_1.Csv2Json)(builtOptions).convert(data);
    }
    exports.csv2json = csv2json;
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module2) {
    !function(t5, n5) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = n5() : "function" == typeof define && define.amd ? define(n5) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs_plugin_quarterOfYear = n5();
    }(exports, function() {
      "use strict";
      var t5 = "month", n5 = "quarter";
      return function(e3, i5) {
        var r3 = i5.prototype;
        r3.quarter = function(t6) {
          return this.$utils().u(t6) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t6 - 1));
        };
        var s5 = r3.add;
        r3.add = function(e4, i6) {
          return e4 = Number(e4), this.$utils().p(i6) === n5 ? this.add(3 * e4, t5) : s5.bind(this)(e4, i6);
        };
        var u4 = r3.startOf;
        r3.startOf = function(e4, i6) {
          var r4 = this.$utils(), s6 = !!r4.u(i6) || i6;
          if (r4.p(e4) === n5) {
            var o4 = this.quarter() - 1;
            return s6 ? this.month(3 * o4).startOf(t5).startOf("day") : this.month(3 * o4 + 2).endOf(t5).endOf("day");
          }
          return u4.bind(this)(e4, i6);
        };
      };
    });
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t5, e3) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (t5 = "undefined" != typeof globalThis ? globalThis : t5 || self).dayjs = e3();
    }(exports, function() {
      "use strict";
      var t5 = 1e3, e3 = 6e4, n5 = 36e5, r3 = "millisecond", i5 = "second", s5 = "minute", u4 = "hour", a4 = "day", o4 = "week", c5 = "month", f5 = "quarter", h4 = "year", d3 = "date", l4 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t6) {
        var e4 = ["th", "st", "nd", "rd"], n6 = t6 % 100;
        return "[" + t6 + (e4[(n6 - 20) % 10] || e4[n6] || e4[0]) + "]";
      } }, m6 = function(t6, e4, n6) {
        var r4 = String(t6);
        return !r4 || r4.length >= e4 ? t6 : "" + Array(e4 + 1 - r4.length).join(n6) + t6;
      }, v4 = { s: m6, z: function(t6) {
        var e4 = -t6.utcOffset(), n6 = Math.abs(e4), r4 = Math.floor(n6 / 60), i6 = n6 % 60;
        return (e4 <= 0 ? "+" : "-") + m6(r4, 2, "0") + ":" + m6(i6, 2, "0");
      }, m: function t6(e4, n6) {
        if (e4.date() < n6.date())
          return -t6(n6, e4);
        var r4 = 12 * (n6.year() - e4.year()) + (n6.month() - e4.month()), i6 = e4.clone().add(r4, c5), s6 = n6 - i6 < 0, u5 = e4.clone().add(r4 + (s6 ? -1 : 1), c5);
        return +(-(r4 + (n6 - i6) / (s6 ? i6 - u5 : u5 - i6)) || 0);
      }, a: function(t6) {
        return t6 < 0 ? Math.ceil(t6) || 0 : Math.floor(t6);
      }, p: function(t6) {
        return { M: c5, y: h4, w: o4, d: a4, D: d3, h: u4, m: s5, s: i5, ms: r3, Q: f5 }[t6] || String(t6 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t6) {
        return void 0 === t6;
      } }, g5 = "en", D2 = {};
      D2[g5] = M2;
      var p7 = "$isDayjsObject", S2 = function(t6) {
        return t6 instanceof _4 || !(!t6 || !t6[p7]);
      }, w2 = function t6(e4, n6, r4) {
        var i6;
        if (!e4)
          return g5;
        if ("string" == typeof e4) {
          var s6 = e4.toLowerCase();
          D2[s6] && (i6 = s6), n6 && (D2[s6] = n6, i6 = s6);
          var u5 = e4.split("-");
          if (!i6 && u5.length > 1)
            return t6(u5[0]);
        } else {
          var a5 = e4.name;
          D2[a5] = e4, i6 = a5;
        }
        return !r4 && i6 && (g5 = i6), i6 || !r4 && g5;
      }, O3 = function(t6, e4) {
        if (S2(t6))
          return t6.clone();
        var n6 = "object" == typeof e4 ? e4 : {};
        return n6.date = t6, n6.args = arguments, new _4(n6);
      }, b2 = v4;
      b2.l = w2, b2.i = S2, b2.w = function(t6, e4) {
        return O3(t6, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
      };
      var _4 = function() {
        function M3(t6) {
          this.$L = w2(t6.locale, null, true), this.parse(t6), this.$x = this.$x || t6.x || {}, this[p7] = true;
        }
        var m7 = M3.prototype;
        return m7.parse = function(t6) {
          this.$d = function(t7) {
            var e4 = t7.date, n6 = t7.utc;
            if (null === e4)
              return new Date(NaN);
            if (b2.u(e4))
              return new Date();
            if (e4 instanceof Date)
              return new Date(e4);
            if ("string" == typeof e4 && !/Z$/i.test(e4)) {
              var r4 = e4.match($2);
              if (r4) {
                var i6 = r4[2] - 1 || 0, s6 = (r4[7] || "0").substring(0, 3);
                return n6 ? new Date(Date.UTC(r4[1], i6, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s6)) : new Date(r4[1], i6, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s6);
              }
            }
            return new Date(e4);
          }(t6), this.init();
        }, m7.init = function() {
          var t6 = this.$d;
          this.$y = t6.getFullYear(), this.$M = t6.getMonth(), this.$D = t6.getDate(), this.$W = t6.getDay(), this.$H = t6.getHours(), this.$m = t6.getMinutes(), this.$s = t6.getSeconds(), this.$ms = t6.getMilliseconds();
        }, m7.$utils = function() {
          return b2;
        }, m7.isValid = function() {
          return !(this.$d.toString() === l4);
        }, m7.isSame = function(t6, e4) {
          var n6 = O3(t6);
          return this.startOf(e4) <= n6 && n6 <= this.endOf(e4);
        }, m7.isAfter = function(t6, e4) {
          return O3(t6) < this.startOf(e4);
        }, m7.isBefore = function(t6, e4) {
          return this.endOf(e4) < O3(t6);
        }, m7.$g = function(t6, e4, n6) {
          return b2.u(t6) ? this[e4] : this.set(n6, t6);
        }, m7.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m7.valueOf = function() {
          return this.$d.getTime();
        }, m7.startOf = function(t6, e4) {
          var n6 = this, r4 = !!b2.u(e4) || e4, f6 = b2.p(t6), l5 = function(t7, e5) {
            var i6 = b2.w(n6.$u ? Date.UTC(n6.$y, e5, t7) : new Date(n6.$y, e5, t7), n6);
            return r4 ? i6 : i6.endOf(a4);
          }, $3 = function(t7, e5) {
            return b2.w(n6.toDate()[t7].apply(n6.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n6);
          }, y4 = this.$W, M4 = this.$M, m8 = this.$D, v5 = "set" + (this.$u ? "UTC" : "");
          switch (f6) {
            case h4:
              return r4 ? l5(1, 0) : l5(31, 11);
            case c5:
              return r4 ? l5(1, M4) : l5(0, M4 + 1);
            case o4:
              var g6 = this.$locale().weekStart || 0, D3 = (y4 < g6 ? y4 + 7 : y4) - g6;
              return l5(r4 ? m8 - D3 : m8 + (6 - D3), M4);
            case a4:
            case d3:
              return $3(v5 + "Hours", 0);
            case u4:
              return $3(v5 + "Minutes", 1);
            case s5:
              return $3(v5 + "Seconds", 2);
            case i5:
              return $3(v5 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m7.endOf = function(t6) {
          return this.startOf(t6, false);
        }, m7.$set = function(t6, e4) {
          var n6, o5 = b2.p(t6), f6 = "set" + (this.$u ? "UTC" : ""), l5 = (n6 = {}, n6[a4] = f6 + "Date", n6[d3] = f6 + "Date", n6[c5] = f6 + "Month", n6[h4] = f6 + "FullYear", n6[u4] = f6 + "Hours", n6[s5] = f6 + "Minutes", n6[i5] = f6 + "Seconds", n6[r3] = f6 + "Milliseconds", n6)[o5], $3 = o5 === a4 ? this.$D + (e4 - this.$W) : e4;
          if (o5 === c5 || o5 === h4) {
            var y4 = this.clone().set(d3, 1);
            y4.$d[l5]($3), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
          } else
            l5 && this.$d[l5]($3);
          return this.init(), this;
        }, m7.set = function(t6, e4) {
          return this.clone().$set(t6, e4);
        }, m7.get = function(t6) {
          return this[b2.p(t6)]();
        }, m7.add = function(r4, f6) {
          var d4, l5 = this;
          r4 = Number(r4);
          var $3 = b2.p(f6), y4 = function(t6) {
            var e4 = O3(l5);
            return b2.w(e4.date(e4.date() + Math.round(t6 * r4)), l5);
          };
          if ($3 === c5)
            return this.set(c5, this.$M + r4);
          if ($3 === h4)
            return this.set(h4, this.$y + r4);
          if ($3 === a4)
            return y4(1);
          if ($3 === o4)
            return y4(7);
          var M4 = (d4 = {}, d4[s5] = e3, d4[u4] = n5, d4[i5] = t5, d4)[$3] || 1, m8 = this.$d.getTime() + r4 * M4;
          return b2.w(m8, this);
        }, m7.subtract = function(t6, e4) {
          return this.add(-1 * t6, e4);
        }, m7.format = function(t6) {
          var e4 = this, n6 = this.$locale();
          if (!this.isValid())
            return n6.invalidDate || l4;
          var r4 = t6 || "YYYY-MM-DDTHH:mm:ssZ", i6 = b2.z(this), s6 = this.$H, u5 = this.$m, a5 = this.$M, o5 = n6.weekdays, c6 = n6.months, f6 = n6.meridiem, h5 = function(t7, n7, i7, s7) {
            return t7 && (t7[n7] || t7(e4, r4)) || i7[n7].slice(0, s7);
          }, d4 = function(t7) {
            return b2.s(s6 % 12 || 12, t7, "0");
          }, $3 = f6 || function(t7, e5, n7) {
            var r5 = t7 < 12 ? "AM" : "PM";
            return n7 ? r5.toLowerCase() : r5;
          };
          return r4.replace(y3, function(t7, r5) {
            return r5 || function(t8) {
              switch (t8) {
                case "YY":
                  return String(e4.$y).slice(-2);
                case "YYYY":
                  return b2.s(e4.$y, 4, "0");
                case "M":
                  return a5 + 1;
                case "MM":
                  return b2.s(a5 + 1, 2, "0");
                case "MMM":
                  return h5(n6.monthsShort, a5, c6, 3);
                case "MMMM":
                  return h5(c6, a5);
                case "D":
                  return e4.$D;
                case "DD":
                  return b2.s(e4.$D, 2, "0");
                case "d":
                  return String(e4.$W);
                case "dd":
                  return h5(n6.weekdaysMin, e4.$W, o5, 2);
                case "ddd":
                  return h5(n6.weekdaysShort, e4.$W, o5, 3);
                case "dddd":
                  return o5[e4.$W];
                case "H":
                  return String(s6);
                case "HH":
                  return b2.s(s6, 2, "0");
                case "h":
                  return d4(1);
                case "hh":
                  return d4(2);
                case "a":
                  return $3(s6, u5, true);
                case "A":
                  return $3(s6, u5, false);
                case "m":
                  return String(u5);
                case "mm":
                  return b2.s(u5, 2, "0");
                case "s":
                  return String(e4.$s);
                case "ss":
                  return b2.s(e4.$s, 2, "0");
                case "SSS":
                  return b2.s(e4.$ms, 3, "0");
                case "Z":
                  return i6;
              }
              return null;
            }(t7) || i6.replace(":", "");
          });
        }, m7.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m7.diff = function(r4, d4, l5) {
          var $3, y4 = this, M4 = b2.p(d4), m8 = O3(r4), v5 = (m8.utcOffset() - this.utcOffset()) * e3, g6 = this - m8, D3 = function() {
            return b2.m(y4, m8);
          };
          switch (M4) {
            case h4:
              $3 = D3() / 12;
              break;
            case c5:
              $3 = D3();
              break;
            case f5:
              $3 = D3() / 3;
              break;
            case o4:
              $3 = (g6 - v5) / 6048e5;
              break;
            case a4:
              $3 = (g6 - v5) / 864e5;
              break;
            case u4:
              $3 = g6 / n5;
              break;
            case s5:
              $3 = g6 / e3;
              break;
            case i5:
              $3 = g6 / t5;
              break;
            default:
              $3 = g6;
          }
          return l5 ? $3 : b2.a($3);
        }, m7.daysInMonth = function() {
          return this.endOf(c5).$D;
        }, m7.$locale = function() {
          return D2[this.$L];
        }, m7.locale = function(t6, e4) {
          if (!t6)
            return this.$L;
          var n6 = this.clone(), r4 = w2(t6, e4, true);
          return r4 && (n6.$L = r4), n6;
        }, m7.clone = function() {
          return b2.w(this.$d, this);
        }, m7.toDate = function() {
          return new Date(this.valueOf());
        }, m7.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m7.toISOString = function() {
          return this.$d.toISOString();
        }, m7.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k3 = _4.prototype;
      return O3.prototype = k3, [["$ms", r3], ["$s", i5], ["$m", s5], ["$H", u4], ["$W", a4], ["$M", c5], ["$y", h4], ["$D", d3]].forEach(function(t6) {
        k3[t6[1]] = function(e4) {
          return this.$g(e4, t6[0], t6[1]);
        };
      }), O3.extend = function(t6, e4) {
        return t6.$i || (t6(e4, _4, O3), t6.$i = true), O3;
      }, O3.locale = w2, O3.isDayjs = S2, O3.unix = function(t6) {
        return O3(1e3 * t6);
      }, O3.en = D2[g5], O3.Ls = D2, O3.p = {}, O3;
    });
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o4) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof(o4);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/html2canvas/dist/html2canvas.js
var require_html2canvas = __commonJS({
  "node_modules/html2canvas/dist/html2canvas.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.html2canvas = factory());
    })(exports, function() {
      "use strict";
      var extendStatics = function(d3, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
          d4.__proto__ = b3;
        } || function(d4, b3) {
          for (var p7 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p7))
              d4[p7] = b3[p7];
        };
        return extendStatics(d3, b2);
      };
      function __extends(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      }
      var __assign = function() {
        __assign = Object.assign || function __assign2(t5) {
          for (var s5, i6 = 1, n5 = arguments.length; i6 < n5; i6++) {
            s5 = arguments[i6];
            for (var p7 in s5)
              if (Object.prototype.hasOwnProperty.call(s5, p7))
                t5[p7] = s5[p7];
          }
          return t5;
        };
        return __assign.apply(this, arguments);
      };
      function __awaiter(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e4) {
              reject(e4);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e4) {
              reject(e4);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      }
      function __generator(thisArg, body) {
        var _4 = { label: 0, sent: function() {
          if (t5[0] & 1)
            throw t5[1];
          return t5[1];
        }, trys: [], ops: [] }, f6, y3, t5, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n5) {
          return function(v4) {
            return step([n5, v4]);
          };
        }
        function step(op) {
          if (f6)
            throw new TypeError("Generator is already executing.");
          while (_4)
            try {
              if (f6 = 1, y3 && (t5 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t5 = y3["return"]) && t5.call(y3), 0) : y3.next) && !(t5 = t5.call(y3, op[1])).done)
                return t5;
              if (y3 = 0, t5)
                op = [op[0] & 2, t5.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t5 = op;
                  break;
                case 4:
                  _4.label++;
                  return { value: op[1], done: false };
                case 5:
                  _4.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _4.ops.pop();
                  _4.trys.pop();
                  continue;
                default:
                  if (!(t5 = _4.trys, t5 = t5.length > 0 && t5[t5.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _4 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t5 || op[1] > t5[0] && op[1] < t5[3])) {
                    _4.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _4.label < t5[1]) {
                    _4.label = t5[1];
                    t5 = op;
                    break;
                  }
                  if (t5 && _4.label < t5[2]) {
                    _4.label = t5[2];
                    _4.ops.push(op);
                    break;
                  }
                  if (t5[2])
                    _4.ops.pop();
                  _4.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _4);
            } catch (e4) {
              op = [6, e4];
              y3 = 0;
            } finally {
              f6 = t5 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      }
      function __spreadArray(to, from, pack2) {
        if (pack2 || arguments.length === 2)
          for (var i6 = 0, l4 = from.length, ar; i6 < l4; i6++) {
            if (ar || !(i6 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i6);
              ar[i6] = from[i6];
            }
          }
        return to.concat(ar || from);
      }
      var Bounds = (
        /** @class */
        function() {
          function Bounds2(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
          }
          Bounds2.prototype.add = function(x2, y3, w2, h4) {
            return new Bounds2(this.left + x2, this.top + y3, this.width + w2, this.height + h4);
          };
          Bounds2.fromClientRect = function(context, clientRect) {
            return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
          };
          Bounds2.fromDOMRectList = function(context, domRectList) {
            var domRect = Array.from(domRectList).find(function(rect) {
              return rect.width !== 0;
            });
            return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
          };
          Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
          return Bounds2;
        }()
      );
      var parseBounds = function(context, node2) {
        return Bounds.fromClientRect(context, node2.getBoundingClientRect());
      };
      var parseDocumentSize = function(document2) {
        var body = document2.body;
        var documentElement = document2.documentElement;
        if (!body || !documentElement) {
          throw new Error("Unable to get document size");
        }
        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
        return new Bounds(0, 0, width, height);
      };
      var toCodePoints$1 = function(str) {
        var codePoints = [];
        var i6 = 0;
        var length2 = str.length;
        while (i6 < length2) {
          var value = str.charCodeAt(i6++);
          if (value >= 55296 && value <= 56319 && i6 < length2) {
            var extra = str.charCodeAt(i6++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i6--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint$1 = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length2 = codePoints.length;
        if (!length2) {
          return "";
        }
        var codeUnits = [];
        var index4 = -1;
        var result = "";
        while (++index4 < length2) {
          var codePoint = codePoints[index4];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index4 + 1 === length2 || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
      }
      var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
      }
      var decode$1 = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i6, p7 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i6 = 0; i6 < len; i6 += 4) {
          encoded1 = lookup$1$1[base642.charCodeAt(i6)];
          encoded2 = lookup$1$1[base642.charCodeAt(i6 + 1)];
          encoded3 = lookup$1$1[base642.charCodeAt(i6 + 2)];
          encoded4 = lookup$1$1[base642.charCodeAt(i6 + 3)];
          bytes[p7++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p7++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p7++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array$1 = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i6 = 0; i6 < length2; i6 += 2) {
          bytes.push(buffer[i6 + 1] << 8 | buffer[i6]);
        }
        return bytes;
      };
      var polyUint32Array$1 = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i6 = 0; i6 < length2; i6 += 4) {
          bytes.push(buffer[i6 + 3] << 24 | buffer[i6 + 2] << 16 | buffer[i6 + 1] << 8 | buffer[i6]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2$1 = 5;
      var UTRIE2_SHIFT_1$1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT$1 = 2;
      var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
      var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
      var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
      var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
      var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
      var slice16$1 = function(view, start2, end2) {
        if (view.slice) {
          return view.slice(start2, end2);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start2, end2));
      };
      var slice32$1 = function(view, start2, end2) {
        if (view.slice) {
          return view.slice(start2, end2);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start2, end2));
      };
      var createTrieFromBase64$1 = function(base642, _byteLength) {
        var buffer = decode$1(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index4 = slice16$1(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index4, data);
      };
      var Trie$1 = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index4, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index4;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
      }
      var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
      var LETTER_NUMBER_MODIFIER = 50;
      var BK = 1;
      var CR$1 = 2;
      var LF$1 = 3;
      var CM = 4;
      var NL = 5;
      var WJ = 7;
      var ZW = 8;
      var GL = 9;
      var SP = 10;
      var ZWJ$1 = 11;
      var B2 = 12;
      var BA = 13;
      var BB = 14;
      var HY = 15;
      var CB = 16;
      var CL = 17;
      var CP = 18;
      var EX = 19;
      var IN = 20;
      var NS = 21;
      var OP = 22;
      var QU = 23;
      var IS = 24;
      var NU = 25;
      var PO = 26;
      var PR = 27;
      var SY = 28;
      var AI = 29;
      var AL = 30;
      var CJ = 31;
      var EB = 32;
      var EM = 33;
      var H2 = 34;
      var H3 = 35;
      var HL = 36;
      var ID = 37;
      var JL = 38;
      var JV = 39;
      var JT = 40;
      var RI$1 = 41;
      var SA = 42;
      var XX = 43;
      var ea_OP = [9001, 65288];
      var BREAK_MANDATORY = "!";
      var BREAK_NOT_ALLOWED$1 = "\xD7";
      var BREAK_ALLOWED$1 = "\xF7";
      var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
      var ALPHABETICS = [AL, HL];
      var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
      var SPACE$1 = [SP, ZW];
      var PREFIX_POSTFIX = [PR, PO];
      var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
      var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
      var HYPHEN = [HY, BA];
      var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
        if (lineBreak2 === void 0) {
          lineBreak2 = "strict";
        }
        var types = [];
        var indices = [];
        var categories = [];
        codePoints.forEach(function(codePoint, index4) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
          } else {
            categories.push(false);
          }
          if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
            if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
              indices.push(index4);
              return types.push(CB);
            }
          }
          if (classType === CM || classType === ZWJ$1) {
            if (index4 === 0) {
              indices.push(index4);
              return types.push(AL);
            }
            var prev = types[index4 - 1];
            if (LINE_BREAKS.indexOf(prev) === -1) {
              indices.push(indices[index4 - 1]);
              return types.push(prev);
            }
            indices.push(index4);
            return types.push(AL);
          }
          indices.push(index4);
          if (classType === CJ) {
            return types.push(lineBreak2 === "strict" ? NS : ID);
          }
          if (classType === SA) {
            return types.push(AL);
          }
          if (classType === AI) {
            return types.push(AL);
          }
          if (classType === XX) {
            if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
              return types.push(ID);
            } else {
              return types.push(AL);
            }
          }
          types.push(classType);
        });
        return [indices, types, categories];
      };
      var isAdjacentWithSpaceIgnored = function(a5, b2, currentIndex, classTypes) {
        var current = classTypes[currentIndex];
        if (Array.isArray(a5) ? a5.indexOf(current) !== -1 : a5 === current) {
          var i6 = currentIndex;
          while (i6 <= classTypes.length) {
            i6++;
            var next = classTypes[i6];
            if (next === b2) {
              return true;
            }
            if (next !== SP) {
              break;
            }
          }
        }
        if (current === SP) {
          var i6 = currentIndex;
          while (i6 > 0) {
            i6--;
            var prev = classTypes[i6];
            if (Array.isArray(a5) ? a5.indexOf(prev) !== -1 : a5 === prev) {
              var n5 = currentIndex;
              while (n5 <= classTypes.length) {
                n5++;
                var next = classTypes[n5];
                if (next === b2) {
                  return true;
                }
                if (next !== SP) {
                  break;
                }
              }
            }
            if (prev !== SP) {
              break;
            }
          }
        }
        return false;
      };
      var previousNonSpaceClassType = function(currentIndex, classTypes) {
        var i6 = currentIndex;
        while (i6 >= 0) {
          var type = classTypes[i6];
          if (type === SP) {
            i6--;
          } else {
            return type;
          }
        }
        return 0;
      };
      var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index4, forbiddenBreaks) {
        if (indicies[index4] === 0) {
          return BREAK_NOT_ALLOWED$1;
        }
        var currentIndex = index4 - 1;
        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
        }
        var beforeIndex = currentIndex - 1;
        var afterIndex = currentIndex + 1;
        var current = classTypes[currentIndex];
        var before2 = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
        var next = classTypes[afterIndex];
        if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
        }
        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
        }
        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SP) {
          return BREAK_ALLOWED$1;
        }
        if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
        }
        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (before2 === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (
          // (PR | PO) × ( OP | HY )? NU
          [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
          [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
          current === NU && [NU, SY, IS].indexOf(next) !== -1
        ) {
          return BREAK_NOT_ALLOWED$1;
        }
        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
              return BREAK_NOT_ALLOWED$1;
            } else if ([SY, IS].indexOf(type) !== -1) {
              prevIndex--;
            } else {
              break;
            }
          }
        }
        if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
          return BREAK_NOT_ALLOWED$1;
        }
        if (current === RI$1 && next === RI$1) {
          var i6 = indicies[currentIndex];
          var count = 1;
          while (i6 > 0) {
            i6--;
            if (classTypes[i6] === RI$1) {
              count++;
            } else {
              break;
            }
          }
          if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED$1;
          }
        }
        if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
        }
        return BREAK_ALLOWED$1;
      };
      var cssFormattedClasses = function(codePoints, options2) {
        if (!options2) {
          options2 = { lineBreak: "normal", wordBreak: "normal" };
        }
        var _a2 = codePointsToCharacterClasses(codePoints, options2.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
        if (options2.wordBreak === "break-all" || options2.wordBreak === "break-word") {
          classTypes = classTypes.map(function(type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
          });
        }
        var forbiddenBreakpoints = options2.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i6) {
          return letterNumber && codePoints[i6] >= 19968 && codePoints[i6] <= 40959;
        }) : void 0;
        return [indicies, classTypes, forbiddenBreakpoints];
      };
      var Break = (
        /** @class */
        function() {
          function Break2(codePoints, lineBreak2, start2, end2) {
            this.codePoints = codePoints;
            this.required = lineBreak2 === BREAK_MANDATORY;
            this.start = start2;
            this.end = end2;
          }
          Break2.prototype.slice = function() {
            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
          };
          return Break2;
        }()
      );
      var LineBreaker = function(str, options2) {
        var codePoints = toCodePoints$1(str);
        var _a2 = cssFormattedClasses(codePoints, options2), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
        var length2 = codePoints.length;
        var lastEnd = 0;
        var nextIndex = 0;
        return {
          next: function() {
            if (nextIndex >= length2) {
              return { done: true, value: null };
            }
            var lineBreak2 = BREAK_NOT_ALLOWED$1;
            while (nextIndex < length2 && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
            }
            if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length2) {
              var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
              lastEnd = nextIndex;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var FLAG_UNRESTRICTED = 1 << 0;
      var FLAG_ID = 1 << 1;
      var FLAG_INTEGER = 1 << 2;
      var FLAG_NUMBER = 1 << 3;
      var LINE_FEED = 10;
      var SOLIDUS = 47;
      var REVERSE_SOLIDUS = 92;
      var CHARACTER_TABULATION = 9;
      var SPACE = 32;
      var QUOTATION_MARK = 34;
      var EQUALS_SIGN = 61;
      var NUMBER_SIGN = 35;
      var DOLLAR_SIGN = 36;
      var PERCENTAGE_SIGN = 37;
      var APOSTROPHE = 39;
      var LEFT_PARENTHESIS = 40;
      var RIGHT_PARENTHESIS = 41;
      var LOW_LINE = 95;
      var HYPHEN_MINUS = 45;
      var EXCLAMATION_MARK = 33;
      var LESS_THAN_SIGN = 60;
      var GREATER_THAN_SIGN = 62;
      var COMMERCIAL_AT = 64;
      var LEFT_SQUARE_BRACKET = 91;
      var RIGHT_SQUARE_BRACKET = 93;
      var CIRCUMFLEX_ACCENT = 61;
      var LEFT_CURLY_BRACKET = 123;
      var QUESTION_MARK = 63;
      var RIGHT_CURLY_BRACKET = 125;
      var VERTICAL_LINE = 124;
      var TILDE = 126;
      var CONTROL = 128;
      var REPLACEMENT_CHARACTER = 65533;
      var ASTERISK = 42;
      var PLUS_SIGN = 43;
      var COMMA = 44;
      var COLON = 58;
      var SEMICOLON = 59;
      var FULL_STOP = 46;
      var NULL = 0;
      var BACKSPACE = 8;
      var LINE_TABULATION = 11;
      var SHIFT_OUT = 14;
      var INFORMATION_SEPARATOR_ONE = 31;
      var DELETE = 127;
      var EOF = -1;
      var ZERO = 48;
      var a4 = 97;
      var e3 = 101;
      var f5 = 102;
      var u4 = 117;
      var z2 = 122;
      var A2 = 65;
      var E2 = 69;
      var F2 = 70;
      var U2 = 85;
      var Z2 = 90;
      var isDigit = function(codePoint) {
        return codePoint >= ZERO && codePoint <= 57;
      };
      var isSurrogateCodePoint = function(codePoint) {
        return codePoint >= 55296 && codePoint <= 57343;
      };
      var isHex = function(codePoint) {
        return isDigit(codePoint) || codePoint >= A2 && codePoint <= F2 || codePoint >= a4 && codePoint <= f5;
      };
      var isLowerCaseLetter = function(codePoint) {
        return codePoint >= a4 && codePoint <= z2;
      };
      var isUpperCaseLetter = function(codePoint) {
        return codePoint >= A2 && codePoint <= Z2;
      };
      var isLetter2 = function(codePoint) {
        return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
      };
      var isNonASCIICodePoint = function(codePoint) {
        return codePoint >= CONTROL;
      };
      var isWhiteSpace = function(codePoint) {
        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
      };
      var isNameStartCodePoint = function(codePoint) {
        return isLetter2(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
      };
      var isNameCodePoint = function(codePoint) {
        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
      };
      var isNonPrintableCodePoint = function(codePoint) {
        return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
      };
      var isValidEscape = function(c1, c22) {
        if (c1 !== REVERSE_SOLIDUS) {
          return false;
        }
        return c22 !== LINE_FEED;
      };
      var isIdentifierStart = function(c1, c22, c32) {
        if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c22) || isValidEscape(c22, c32);
        } else if (isNameStartCodePoint(c1)) {
          return true;
        } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c22)) {
          return true;
        }
        return false;
      };
      var isNumberStart = function(c1, c22, c32) {
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c22)) {
            return true;
          }
          return c22 === FULL_STOP && isDigit(c32);
        }
        if (c1 === FULL_STOP) {
          return isDigit(c22);
        }
        return isDigit(c1);
      };
      var stringToNumber = function(codePoints) {
        var c5 = 0;
        var sign = 1;
        if (codePoints[c5] === PLUS_SIGN || codePoints[c5] === HYPHEN_MINUS) {
          if (codePoints[c5] === HYPHEN_MINUS) {
            sign = -1;
          }
          c5++;
        }
        var integers = [];
        while (isDigit(codePoints[c5])) {
          integers.push(codePoints[c5++]);
        }
        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
        if (codePoints[c5] === FULL_STOP) {
          c5++;
        }
        var fraction = [];
        while (isDigit(codePoints[c5])) {
          fraction.push(codePoints[c5++]);
        }
        var fracd = fraction.length;
        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
        if (codePoints[c5] === E2 || codePoints[c5] === e3) {
          c5++;
        }
        var expsign = 1;
        if (codePoints[c5] === PLUS_SIGN || codePoints[c5] === HYPHEN_MINUS) {
          if (codePoints[c5] === HYPHEN_MINUS) {
            expsign = -1;
          }
          c5++;
        }
        var exponent = [];
        while (isDigit(codePoints[c5])) {
          exponent.push(codePoints[c5++]);
        }
        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
      };
      var LEFT_PARENTHESIS_TOKEN = {
        type: 2
        /* LEFT_PARENTHESIS_TOKEN */
      };
      var RIGHT_PARENTHESIS_TOKEN = {
        type: 3
        /* RIGHT_PARENTHESIS_TOKEN */
      };
      var COMMA_TOKEN = {
        type: 4
        /* COMMA_TOKEN */
      };
      var SUFFIX_MATCH_TOKEN = {
        type: 13
        /* SUFFIX_MATCH_TOKEN */
      };
      var PREFIX_MATCH_TOKEN = {
        type: 8
        /* PREFIX_MATCH_TOKEN */
      };
      var COLUMN_TOKEN = {
        type: 21
        /* COLUMN_TOKEN */
      };
      var DASH_MATCH_TOKEN = {
        type: 9
        /* DASH_MATCH_TOKEN */
      };
      var INCLUDE_MATCH_TOKEN = {
        type: 10
        /* INCLUDE_MATCH_TOKEN */
      };
      var LEFT_CURLY_BRACKET_TOKEN = {
        type: 11
        /* LEFT_CURLY_BRACKET_TOKEN */
      };
      var RIGHT_CURLY_BRACKET_TOKEN = {
        type: 12
        /* RIGHT_CURLY_BRACKET_TOKEN */
      };
      var SUBSTRING_MATCH_TOKEN = {
        type: 14
        /* SUBSTRING_MATCH_TOKEN */
      };
      var BAD_URL_TOKEN = {
        type: 23
        /* BAD_URL_TOKEN */
      };
      var BAD_STRING_TOKEN = {
        type: 1
        /* BAD_STRING_TOKEN */
      };
      var CDO_TOKEN = {
        type: 25
        /* CDO_TOKEN */
      };
      var CDC_TOKEN = {
        type: 24
        /* CDC_TOKEN */
      };
      var COLON_TOKEN = {
        type: 26
        /* COLON_TOKEN */
      };
      var SEMICOLON_TOKEN = {
        type: 27
        /* SEMICOLON_TOKEN */
      };
      var LEFT_SQUARE_BRACKET_TOKEN = {
        type: 28
        /* LEFT_SQUARE_BRACKET_TOKEN */
      };
      var RIGHT_SQUARE_BRACKET_TOKEN = {
        type: 29
        /* RIGHT_SQUARE_BRACKET_TOKEN */
      };
      var WHITESPACE_TOKEN = {
        type: 31
        /* WHITESPACE_TOKEN */
      };
      var EOF_TOKEN = {
        type: 32
        /* EOF_TOKEN */
      };
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2() {
            this._value = [];
          }
          Tokenizer2.prototype.write = function(chunk) {
            this._value = this._value.concat(toCodePoints$1(chunk));
          };
          Tokenizer2.prototype.read = function() {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
            }
            return tokens;
          };
          Tokenizer2.prototype.consumeToken = function() {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
              case QUOTATION_MARK:
                return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                var c1 = this.peekCodePoint(0);
                var c22 = this.peekCodePoint(1);
                var c32 = this.peekCodePoint(2);
                if (isNameCodePoint(c1) || isValidEscape(c22, c32)) {
                  var flags = isIdentifierStart(c1, c22, c32) ? FLAG_ID : FLAG_UNRESTRICTED;
                  var value = this.consumeName();
                  return { type: 5, value, flags };
                }
                break;
              case DOLLAR_SIGN:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUFFIX_MATCH_TOKEN;
                }
                break;
              case APOSTROPHE:
                return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return SUBSTRING_MATCH_TOKEN;
                }
                break;
              case PLUS_SIGN:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case COMMA:
                return COMMA_TOKEN;
              case HYPHEN_MINUS:
                var e1 = codePoint;
                var e22 = this.peekCodePoint(0);
                var e32 = this.peekCodePoint(1);
                if (isNumberStart(e1, e22, e32)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                if (isIdentifierStart(e1, e22, e32)) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                if (e22 === HYPHEN_MINUS && e32 === GREATER_THAN_SIGN) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDC_TOKEN;
                }
                break;
              case FULL_STOP:
                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeNumericToken();
                }
                break;
              case SOLIDUS:
                if (this.peekCodePoint(0) === ASTERISK) {
                  this.consumeCodePoint();
                  while (true) {
                    var c5 = this.consumeCodePoint();
                    if (c5 === ASTERISK) {
                      c5 = this.consumeCodePoint();
                      if (c5 === SOLIDUS) {
                        return this.consumeToken();
                      }
                    }
                    if (c5 === EOF) {
                      return this.consumeToken();
                    }
                  }
                }
                break;
              case COLON:
                return COLON_TOKEN;
              case SEMICOLON:
                return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                  this.consumeCodePoint();
                  this.consumeCodePoint();
                  return CDO_TOKEN;
                }
                break;
              case COMMERCIAL_AT:
                var a1 = this.peekCodePoint(0);
                var a22 = this.peekCodePoint(1);
                var a32 = this.peekCodePoint(2);
                if (isIdentifierStart(a1, a22, a32)) {
                  var value = this.consumeName();
                  return { type: 7, value };
                }
                break;
              case LEFT_SQUARE_BRACKET:
                return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
                }
                break;
              case RIGHT_SQUARE_BRACKET:
                return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return PREFIX_MATCH_TOKEN;
                }
                break;
              case LEFT_CURLY_BRACKET:
                return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                return RIGHT_CURLY_BRACKET_TOKEN;
              case u4:
              case U2:
                var u1 = this.peekCodePoint(0);
                var u22 = this.peekCodePoint(1);
                if (u1 === PLUS_SIGN && (isHex(u22) || u22 === QUESTION_MARK)) {
                  this.consumeCodePoint();
                  this.consumeUnicodeRangeToken();
                }
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return DASH_MATCH_TOKEN;
                }
                if (this.peekCodePoint(0) === VERTICAL_LINE) {
                  this.consumeCodePoint();
                  return COLUMN_TOKEN;
                }
                break;
              case TILDE:
                if (this.peekCodePoint(0) === EQUALS_SIGN) {
                  this.consumeCodePoint();
                  return INCLUDE_MATCH_TOKEN;
                }
                break;
              case EOF:
                return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            return { type: 6, value: fromCodePoint$1(codePoint) };
          };
          Tokenizer2.prototype.consumeCodePoint = function() {
            var value = this._value.shift();
            return typeof value === "undefined" ? -1 : value;
          };
          Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
            this._value.unshift(codePoint);
          };
          Tokenizer2.prototype.peekCodePoint = function(delta) {
            if (delta >= this._value.length) {
              return -1;
            }
            return this._value[delta];
          };
          Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
            }
            if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? ZERO : digit;
              })), 16);
              var end2 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
                return digit === QUESTION_MARK ? F2 : digit;
              })), 16);
              return { type: 30, start: start_1, end: end2 };
            }
            var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                endDigits.push(codePoint);
                codePoint = this.consumeCodePoint();
              }
              var end2 = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30, start: start2, end: end2 };
            } else {
              return { type: 30, start: start2, end: start2 };
            }
          };
          Tokenizer2.prototype.consumeIdentLikeToken = function() {
            var value = this.consumeName();
            if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
            } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19, value };
            }
            return { type: 20, value };
          };
          Tokenizer2.prototype.consumeUrlToken = function() {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
              return { type: 22, value: "" };
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: stringToken.value };
                }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
              } else if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                  this.consumeCodePoint();
                  return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              } else if (codePoint === REVERSE_SOLIDUS) {
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  value.push(this.consumeEscapedCodePoint());
                } else {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
                }
              } else {
                value.push(codePoint);
              }
            }
          };
          Tokenizer2.prototype.consumeWhiteSpace = function() {
            while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
          };
          Tokenizer2.prototype.consumeBadUrlRemnants = function() {
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.consumeEscapedCodePoint();
              }
            }
          };
          Tokenizer2.prototype.consumeStringSlice = function(count) {
            var SLICE_STACK_SIZE = 5e4;
            var value = "";
            while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
            }
            this._value.shift();
            return value;
          };
          Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
            var value = "";
            var i6 = 0;
            do {
              var codePoint = this._value[i6];
              if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
                value += this.consumeStringSlice(i6);
                return { type: 0, value };
              }
              if (codePoint === LINE_FEED) {
                this._value.splice(0, i6);
                return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                var next = this._value[i6 + 1];
                if (next !== EOF && next !== void 0) {
                  if (next === LINE_FEED) {
                    value += this.consumeStringSlice(i6);
                    i6 = -1;
                    this._value.shift();
                  } else if (isValidEscape(codePoint, next)) {
                    value += this.consumeStringSlice(i6);
                    value += fromCodePoint$1(this.consumeEscapedCodePoint());
                    i6 = -1;
                  }
                }
              }
              i6++;
            } while (true);
          };
          Tokenizer2.prototype.consumeNumber = function() {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c22)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            c1 = this.peekCodePoint(0);
            c22 = this.peekCodePoint(1);
            var c32 = this.peekCodePoint(2);
            if ((c1 === E2 || c1 === e3) && ((c22 === PLUS_SIGN || c22 === HYPHEN_MINUS) && isDigit(c32) || isDigit(c22))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
              }
            }
            return [stringToNumber(repr), type];
          };
          Tokenizer2.prototype.consumeNumericToken = function() {
            var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
            var c1 = this.peekCodePoint(0);
            var c22 = this.peekCodePoint(1);
            var c32 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c22, c32)) {
              var unit = this.consumeName();
              return { type: 15, number, flags, unit };
            }
            if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16, number, flags };
            }
            return { type: 17, number, flags };
          };
          Tokenizer2.prototype.consumeEscapedCodePoint = function() {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
                return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
            }
            if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
            }
            return codePoint;
          };
          Tokenizer2.prototype.consumeName = function() {
            var result = "";
            while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                result += fromCodePoint$1(codePoint);
              } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                result += fromCodePoint$1(this.consumeEscapedCodePoint());
              } else {
                this.reconsumeCodePoint(codePoint);
                return result;
              }
            }
          };
          return Tokenizer2;
        }()
      );
      var Parser2 = (
        /** @class */
        function() {
          function Parser3(tokens) {
            this._tokens = tokens;
          }
          Parser3.create = function(value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser3(tokenizer.read());
          };
          Parser3.parseValue = function(value) {
            return Parser3.create(value).parseComponentValue();
          };
          Parser3.parseValues = function(value) {
            return Parser3.create(value).parseComponentValues();
          };
          Parser3.prototype.parseComponentValue = function() {
            var token = this.consumeToken();
            while (token.type === 31) {
              token = this.consumeToken();
            }
            if (token.type === 32) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
              token = this.consumeToken();
            } while (token.type === 31);
            if (token.type === 32) {
              return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
          };
          Parser3.prototype.parseComponentValues = function() {
            var values = [];
            while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32) {
                return values;
              }
              values.push(value);
              values.push();
            }
          };
          Parser3.prototype.consumeComponentValue = function() {
            var token = this.consumeToken();
            switch (token.type) {
              case 11:
              case 28:
              case 2:
                return this.consumeSimpleBlock(token.type);
              case 19:
                return this.consumeFunction(token);
            }
            return token;
          };
          Parser3.prototype.consumeSimpleBlock = function(type) {
            var block2 = { type, values: [] };
            var token = this.consumeToken();
            while (true) {
              if (token.type === 32 || isEndingTokenFor(token, type)) {
                return block2;
              }
              this.reconsumeToken(token);
              block2.values.push(this.consumeComponentValue());
              token = this.consumeToken();
            }
          };
          Parser3.prototype.consumeFunction = function(functionToken) {
            var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18
              /* FUNCTION */
            };
            while (true) {
              var token = this.consumeToken();
              if (token.type === 32 || token.type === 3) {
                return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
            }
          };
          Parser3.prototype.consumeToken = function() {
            var token = this._tokens.shift();
            return typeof token === "undefined" ? EOF_TOKEN : token;
          };
          Parser3.prototype.reconsumeToken = function(token) {
            this._tokens.unshift(token);
          };
          return Parser3;
        }()
      );
      var isDimensionToken = function(token) {
        return token.type === 15;
      };
      var isNumberToken = function(token) {
        return token.type === 17;
      };
      var isIdentToken = function(token) {
        return token.type === 20;
      };
      var isStringToken = function(token) {
        return token.type === 0;
      };
      var isIdentWithValue = function(token, value) {
        return isIdentToken(token) && token.value === value;
      };
      var nonWhiteSpace = function(token) {
        return token.type !== 31;
      };
      var nonFunctionArgSeparator = function(token) {
        return token.type !== 31 && token.type !== 4;
      };
      var parseFunctionArgs = function(tokens) {
        var args = [];
        var arg = [];
        tokens.forEach(function(token) {
          if (token.type === 4) {
            if (arg.length === 0) {
              throw new Error("Error parsing function args, zero tokens for arg");
            }
            args.push(arg);
            arg = [];
            return;
          }
          if (token.type !== 31) {
            arg.push(token);
          }
        });
        if (arg.length) {
          args.push(arg);
        }
        return args;
      };
      var isEndingTokenFor = function(token, type) {
        if (type === 11 && token.type === 12) {
          return true;
        }
        if (type === 28 && token.type === 29) {
          return true;
        }
        return type === 2 && token.type === 3;
      };
      var isLength = function(token) {
        return token.type === 17 || token.type === 15;
      };
      var isLengthPercentage = function(token) {
        return token.type === 16 || isLength(token);
      };
      var parseLengthPercentageTuple = function(tokens) {
        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
      };
      var ZERO_LENGTH = {
        type: 17,
        number: 0,
        flags: FLAG_INTEGER
      };
      var FIFTY_PERCENT = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var HUNDRED_PERCENT = {
        type: 16,
        number: 100,
        flags: FLAG_INTEGER
      };
      var getAbsoluteValueForTuple = function(tuple, width, height) {
        var x2 = tuple[0], y3 = tuple[1];
        return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y3 !== "undefined" ? y3 : x2, height)];
      };
      var getAbsoluteValue = function(token, parent) {
        if (token.type === 16) {
          return token.number / 100 * parent;
        }
        if (isDimensionToken(token)) {
          switch (token.unit) {
            case "rem":
            case "em":
              return 16 * token.number;
            case "px":
            default:
              return token.number;
          }
        }
        return token.number;
      };
      var DEG = "deg";
      var GRAD = "grad";
      var RAD = "rad";
      var TURN = "turn";
      var angle = {
        name: "angle",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit) {
              case DEG:
                return Math.PI * value.number / 180;
              case GRAD:
                return Math.PI / 200 * value.number;
              case RAD:
                return value.number;
              case TURN:
                return Math.PI * 2 * value.number;
            }
          }
          throw new Error("Unsupported angle type");
        }
      };
      var isAngle = function(value) {
        if (value.type === 15) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
            return true;
          }
        }
        return false;
      };
      var parseNamedSide = function(tokens) {
        var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
          return ident.value;
        }).join(" ");
        switch (sideOrCorner) {
          case "to bottom right":
          case "to right bottom":
          case "left top":
          case "top left":
            return [ZERO_LENGTH, ZERO_LENGTH];
          case "to top":
          case "bottom":
            return deg(0);
          case "to bottom left":
          case "to left bottom":
          case "right top":
          case "top right":
            return [ZERO_LENGTH, HUNDRED_PERCENT];
          case "to right":
          case "left":
            return deg(90);
          case "to top left":
          case "to left top":
          case "right bottom":
          case "bottom right":
            return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case "to bottom":
          case "top":
            return deg(180);
          case "to top right":
          case "to right top":
          case "left bottom":
          case "bottom left":
            return [HUNDRED_PERCENT, ZERO_LENGTH];
          case "to left":
          case "right":
            return deg(270);
        }
        return 0;
      };
      var deg = function(deg2) {
        return Math.PI * deg2 / 180;
      };
      var color$1 = {
        name: "color",
        parse: function(context, value) {
          if (value.type === 18) {
            var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
            if (typeof colorFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
            }
            return colorFunction(context, value.values);
          }
          if (value.type === 5) {
            if (value.value.length === 3) {
              var r3 = value.value.substring(0, 1);
              var g5 = value.value.substring(1, 2);
              var b2 = value.value.substring(2, 3);
              return pack(parseInt(r3 + r3, 16), parseInt(g5 + g5, 16), parseInt(b2 + b2, 16), 1);
            }
            if (value.value.length === 4) {
              var r3 = value.value.substring(0, 1);
              var g5 = value.value.substring(1, 2);
              var b2 = value.value.substring(2, 3);
              var a5 = value.value.substring(3, 4);
              return pack(parseInt(r3 + r3, 16), parseInt(g5 + g5, 16), parseInt(b2 + b2, 16), parseInt(a5 + a5, 16) / 255);
            }
            if (value.value.length === 6) {
              var r3 = value.value.substring(0, 2);
              var g5 = value.value.substring(2, 4);
              var b2 = value.value.substring(4, 6);
              return pack(parseInt(r3, 16), parseInt(g5, 16), parseInt(b2, 16), 1);
            }
            if (value.value.length === 8) {
              var r3 = value.value.substring(0, 2);
              var g5 = value.value.substring(2, 4);
              var b2 = value.value.substring(4, 6);
              var a5 = value.value.substring(6, 8);
              return pack(parseInt(r3, 16), parseInt(g5, 16), parseInt(b2, 16), parseInt(a5, 16) / 255);
            }
          }
          if (value.type === 20) {
            var namedColor = COLORS[value.value.toUpperCase()];
            if (typeof namedColor !== "undefined") {
              return namedColor;
            }
          }
          return COLORS.TRANSPARENT;
        }
      };
      var isTransparent = function(color2) {
        return (255 & color2) === 0;
      };
      var asString = function(color2) {
        var alpha2 = 255 & color2;
        var blue = 255 & color2 >> 8;
        var green = 255 & color2 >> 16;
        var red = 255 & color2 >> 24;
        return alpha2 < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha2 / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
      };
      var pack = function(r3, g5, b2, a5) {
        return (r3 << 24 | g5 << 16 | b2 << 8 | Math.round(a5 * 255) << 0) >>> 0;
      };
      var getTokenColorValue = function(token, i6) {
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 16) {
          var max4 = i6 === 3 ? 1 : 255;
          return i6 === 3 ? token.number / 100 * max4 : Math.round(token.number / 100 * max4);
        }
        return 0;
      };
      var rgb = function(_context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        if (tokens.length === 3) {
          var _a2 = tokens.map(getTokenColorValue), r3 = _a2[0], g5 = _a2[1], b2 = _a2[2];
          return pack(r3, g5, b2, 1);
        }
        if (tokens.length === 4) {
          var _b2 = tokens.map(getTokenColorValue), r3 = _b2[0], g5 = _b2[1], b2 = _b2[2], a5 = _b2[3];
          return pack(r3, g5, b2, a5);
        }
        return 0;
      };
      function hue2rgb(t1, t22, hue) {
        if (hue < 0) {
          hue += 1;
        }
        if (hue >= 1) {
          hue -= 1;
        }
        if (hue < 1 / 6) {
          return (t22 - t1) * hue * 6 + t1;
        } else if (hue < 1 / 2) {
          return t22;
        } else if (hue < 2 / 3) {
          return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
        } else {
          return t1;
        }
      }
      var hsl = function(context, args) {
        var tokens = args.filter(nonFunctionArgSeparator);
        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha2 = tokens[3];
        var h4 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
        var s5 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
        var l4 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
        var a5 = typeof alpha2 !== "undefined" && isLengthPercentage(alpha2) ? getAbsoluteValue(alpha2, 1) : 1;
        if (s5 === 0) {
          return pack(l4 * 255, l4 * 255, l4 * 255, 1);
        }
        var t22 = l4 <= 0.5 ? l4 * (s5 + 1) : l4 + s5 - l4 * s5;
        var t1 = l4 * 2 - t22;
        var r3 = hue2rgb(t1, t22, h4 + 1 / 3);
        var g5 = hue2rgb(t1, t22, h4);
        var b2 = hue2rgb(t1, t22, h4 - 1 / 3);
        return pack(r3 * 255, g5 * 255, b2 * 255, a5);
      };
      var SUPPORTED_COLOR_FUNCTIONS = {
        hsl,
        hsla: hsl,
        rgb,
        rgba: rgb
      };
      var parseColor = function(context, value) {
        return color$1.parse(context, Parser2.create(value).parseComponentValue());
      };
      var COLORS = {
        ALICEBLUE: 4042850303,
        ANTIQUEWHITE: 4209760255,
        AQUA: 16777215,
        AQUAMARINE: 2147472639,
        AZURE: 4043309055,
        BEIGE: 4126530815,
        BISQUE: 4293182719,
        BLACK: 255,
        BLANCHEDALMOND: 4293643775,
        BLUE: 65535,
        BLUEVIOLET: 2318131967,
        BROWN: 2771004159,
        BURLYWOOD: 3736635391,
        CADETBLUE: 1604231423,
        CHARTREUSE: 2147418367,
        CHOCOLATE: 3530104575,
        CORAL: 4286533887,
        CORNFLOWERBLUE: 1687547391,
        CORNSILK: 4294499583,
        CRIMSON: 3692313855,
        CYAN: 16777215,
        DARKBLUE: 35839,
        DARKCYAN: 9145343,
        DARKGOLDENROD: 3095837695,
        DARKGRAY: 2846468607,
        DARKGREEN: 6553855,
        DARKGREY: 2846468607,
        DARKKHAKI: 3182914559,
        DARKMAGENTA: 2332068863,
        DARKOLIVEGREEN: 1433087999,
        DARKORANGE: 4287365375,
        DARKORCHID: 2570243327,
        DARKRED: 2332033279,
        DARKSALMON: 3918953215,
        DARKSEAGREEN: 2411499519,
        DARKSLATEBLUE: 1211993087,
        DARKSLATEGRAY: 793726975,
        DARKSLATEGREY: 793726975,
        DARKTURQUOISE: 13554175,
        DARKVIOLET: 2483082239,
        DEEPPINK: 4279538687,
        DEEPSKYBLUE: 12582911,
        DIMGRAY: 1768516095,
        DIMGREY: 1768516095,
        DODGERBLUE: 512819199,
        FIREBRICK: 2988581631,
        FLORALWHITE: 4294635775,
        FORESTGREEN: 579543807,
        FUCHSIA: 4278255615,
        GAINSBORO: 3705462015,
        GHOSTWHITE: 4177068031,
        GOLD: 4292280575,
        GOLDENROD: 3668254975,
        GRAY: 2155905279,
        GREEN: 8388863,
        GREENYELLOW: 2919182335,
        GREY: 2155905279,
        HONEYDEW: 4043305215,
        HOTPINK: 4285117695,
        INDIANRED: 3445382399,
        INDIGO: 1258324735,
        IVORY: 4294963455,
        KHAKI: 4041641215,
        LAVENDER: 3873897215,
        LAVENDERBLUSH: 4293981695,
        LAWNGREEN: 2096890111,
        LEMONCHIFFON: 4294626815,
        LIGHTBLUE: 2916673279,
        LIGHTCORAL: 4034953471,
        LIGHTCYAN: 3774873599,
        LIGHTGOLDENRODYELLOW: 4210742015,
        LIGHTGRAY: 3553874943,
        LIGHTGREEN: 2431553791,
        LIGHTGREY: 3553874943,
        LIGHTPINK: 4290167295,
        LIGHTSALMON: 4288707327,
        LIGHTSEAGREEN: 548580095,
        LIGHTSKYBLUE: 2278488831,
        LIGHTSLATEGRAY: 2005441023,
        LIGHTSLATEGREY: 2005441023,
        LIGHTSTEELBLUE: 2965692159,
        LIGHTYELLOW: 4294959359,
        LIME: 16711935,
        LIMEGREEN: 852308735,
        LINEN: 4210091775,
        MAGENTA: 4278255615,
        MAROON: 2147483903,
        MEDIUMAQUAMARINE: 1724754687,
        MEDIUMBLUE: 52735,
        MEDIUMORCHID: 3126187007,
        MEDIUMPURPLE: 2473647103,
        MEDIUMSEAGREEN: 1018393087,
        MEDIUMSLATEBLUE: 2070474495,
        MEDIUMSPRINGGREEN: 16423679,
        MEDIUMTURQUOISE: 1221709055,
        MEDIUMVIOLETRED: 3340076543,
        MIDNIGHTBLUE: 421097727,
        MINTCREAM: 4127193855,
        MISTYROSE: 4293190143,
        MOCCASIN: 4293178879,
        NAVAJOWHITE: 4292783615,
        NAVY: 33023,
        OLDLACE: 4260751103,
        OLIVE: 2155872511,
        OLIVEDRAB: 1804477439,
        ORANGE: 4289003775,
        ORANGERED: 4282712319,
        ORCHID: 3664828159,
        PALEGOLDENROD: 4008225535,
        PALEGREEN: 2566625535,
        PALETURQUOISE: 2951671551,
        PALEVIOLETRED: 3681588223,
        PAPAYAWHIP: 4293907967,
        PEACHPUFF: 4292524543,
        PERU: 3448061951,
        PINK: 4290825215,
        PLUM: 3718307327,
        POWDERBLUE: 2967529215,
        PURPLE: 2147516671,
        REBECCAPURPLE: 1714657791,
        RED: 4278190335,
        ROSYBROWN: 3163525119,
        ROYALBLUE: 1097458175,
        SADDLEBROWN: 2336560127,
        SALMON: 4202722047,
        SANDYBROWN: 4104413439,
        SEAGREEN: 780883967,
        SEASHELL: 4294307583,
        SIENNA: 2689740287,
        SILVER: 3233857791,
        SKYBLUE: 2278484991,
        SLATEBLUE: 1784335871,
        SLATEGRAY: 1887473919,
        SLATEGREY: 1887473919,
        SNOW: 4294638335,
        SPRINGGREEN: 16744447,
        STEELBLUE: 1182971135,
        TAN: 3535047935,
        TEAL: 8421631,
        THISTLE: 3636451583,
        TOMATO: 4284696575,
        TRANSPARENT: 0,
        TURQUOISE: 1088475391,
        VIOLET: 4001558271,
        WHEAT: 4125012991,
        WHITE: 4294967295,
        WHITESMOKE: 4126537215,
        YELLOW: 4294902015,
        YELLOWGREEN: 2597139199
      };
      var backgroundClip = {
        name: "background-clip",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundColor = {
        name: "background-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var parseColorStop = function(context, args) {
        var color2 = color$1.parse(context, args[0]);
        var stop = args[1];
        return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
      };
      var processColorStops = function(stops, lineLength) {
        var first = stops[0];
        var last = stops[stops.length - 1];
        if (first.stop === null) {
          first.stop = ZERO_LENGTH;
        }
        if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
        }
        var processStops = [];
        var previous = 0;
        for (var i6 = 0; i6 < stops.length; i6++) {
          var stop_1 = stops[i6].stop;
          if (stop_1 !== null) {
            var absoluteValue = getAbsoluteValue(stop_1, lineLength);
            if (absoluteValue > previous) {
              processStops.push(absoluteValue);
            } else {
              processStops.push(previous);
            }
            previous = absoluteValue;
          } else {
            processStops.push(null);
          }
        }
        var gapBegin = null;
        for (var i6 = 0; i6 < processStops.length; i6++) {
          var stop_2 = processStops[i6];
          if (stop_2 === null) {
            if (gapBegin === null) {
              gapBegin = i6;
            }
          } else if (gapBegin !== null) {
            var gapLength = i6 - gapBegin;
            var beforeGap = processStops[gapBegin - 1];
            var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
            for (var g5 = 1; g5 <= gapLength; g5++) {
              processStops[gapBegin + g5 - 1] = gapValue * g5;
            }
            gapBegin = null;
          }
        }
        return stops.map(function(_a2, i7) {
          var color2 = _a2.color;
          return { color: color2, stop: Math.max(Math.min(1, processStops[i7] / lineLength), 0) };
        });
      };
      var getAngleFromCorner = function(corner, width, height) {
        var centerX = width / 2;
        var centerY = height / 2;
        var x2 = getAbsoluteValue(corner[0], width) - centerX;
        var y3 = centerY - getAbsoluteValue(corner[1], height);
        return (Math.atan2(y3, x2) + Math.PI * 2) % (Math.PI * 2);
      };
      var calculateGradientDirection = function(angle2, width, height) {
        var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfLineLength = lineLength / 2;
        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
      };
      var distance = function(a5, b2) {
        return Math.sqrt(a5 * a5 + b2 * b2);
      };
      var findCorner = function(width, height, x2, y3, closest) {
        var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
        ];
        return corners.reduce(function(stat, corner) {
          var cx = corner[0], cy = corner[1];
          var d3 = distance(x2 - cx, y3 - cy);
          if (closest ? d3 < stat.optimumDistance : d3 > stat.optimumDistance) {
            return {
              optimumCorner: corner,
              optimumDistance: d3
            };
          }
          return stat;
        }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
        }).optimumCorner;
      };
      var calculateRadius = function(gradient, x2, y3, width, height) {
        var rx = 0;
        var ry = 0;
        switch (gradient.size) {
          case 0:
            if (gradient.shape === 0) {
              rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y3), Math.abs(y3 - height));
            } else if (gradient.shape === 1) {
              rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
              ry = Math.min(Math.abs(y3), Math.abs(y3 - height));
            }
            break;
          case 2:
            if (gradient.shape === 0) {
              rx = ry = Math.min(distance(x2, y3), distance(x2, y3 - height), distance(x2 - width, y3), distance(x2 - width, y3 - height));
            } else if (gradient.shape === 1) {
              var c5 = Math.min(Math.abs(y3), Math.abs(y3 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
              var _a2 = findCorner(width, height, x2, y3, true), cx = _a2[0], cy = _a2[1];
              rx = distance(cx - x2, (cy - y3) / c5);
              ry = c5 * rx;
            }
            break;
          case 1:
            if (gradient.shape === 0) {
              rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y3), Math.abs(y3 - height));
            } else if (gradient.shape === 1) {
              rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
              ry = Math.max(Math.abs(y3), Math.abs(y3 - height));
            }
            break;
          case 3:
            if (gradient.shape === 0) {
              rx = ry = Math.max(distance(x2, y3), distance(x2, y3 - height), distance(x2 - width, y3), distance(x2 - width, y3 - height));
            } else if (gradient.shape === 1) {
              var c5 = Math.max(Math.abs(y3), Math.abs(y3 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
              var _b2 = findCorner(width, height, x2, y3, false), cx = _b2[0], cy = _b2[1];
              rx = distance(cx - x2, (cy - y3) / c5);
              ry = c5 * rx;
            }
            break;
        }
        if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
        }
        return [rx, ry];
      };
      var linearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i6) {
          if (i6 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && firstToken.value === "to") {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = angle.parse(context, firstToken);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var prefixLinearGradient = function(context, tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function(arg, i6) {
          if (i6 === 0) {
            var firstToken = arg[0];
            if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
              angle$1 = parseNamedSide(arg);
              return;
            } else if (isAngle(firstToken)) {
              angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
              return;
            }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        });
        return {
          angle: angle$1,
          stops,
          type: 1
          /* LINEAR_GRADIENT */
        };
      };
      var webkitGradient = function(context, tokens) {
        var angle2 = deg(180);
        var stops = [];
        var type = 1;
        var shape = 0;
        var size = 3;
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i6) {
          var firstToken = arg[0];
          if (i6 === 0) {
            if (isIdentToken(firstToken) && firstToken.value === "linear") {
              type = 1;
              return;
            } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
              type = 2;
              return;
            }
          }
          if (firstToken.type === 18) {
            if (firstToken.name === "from") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: ZERO_LENGTH, color: color2 });
            } else if (firstToken.name === "to") {
              var color2 = color$1.parse(context, firstToken.values[0]);
              stops.push({ stop: HUNDRED_PERCENT, color: color2 });
            } else if (firstToken.name === "color-stop") {
              var values = firstToken.values.filter(nonFunctionArgSeparator);
              if (values.length === 2) {
                var color2 = color$1.parse(context, values[1]);
                var stop_1 = values[0];
                if (isNumberToken(stop_1)) {
                  stops.push({
                    stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                    color: color2
                  });
                }
              }
            }
          }
        });
        return type === 1 ? {
          angle: (angle2 + deg(180)) % deg(360),
          stops,
          type
        } : { size, shape, stops, position: position2, type };
      };
      var CLOSEST_SIDE = "closest-side";
      var FARTHEST_SIDE = "farthest-side";
      var CLOSEST_CORNER = "closest-corner";
      var FARTHEST_CORNER = "farthest-corner";
      var CIRCLE = "circle";
      var ELLIPSE = "ellipse";
      var COVER = "cover";
      var CONTAIN = "contain";
      var radialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i6) {
          var isColorStop = true;
          if (i6 === 0) {
            var isAtPosition_1 = false;
            isColorStop = arg.reduce(function(acc, token) {
              if (isAtPosition_1) {
                if (isIdentToken(token)) {
                  switch (token.value) {
                    case "center":
                      position2.push(FIFTY_PERCENT);
                      return acc;
                    case "top":
                    case "left":
                      position2.push(ZERO_LENGTH);
                      return acc;
                    case "right":
                    case "bottom":
                      position2.push(HUNDRED_PERCENT);
                      return acc;
                  }
                } else if (isLengthPercentage(token) || isLength(token)) {
                  position2.push(token);
                }
              } else if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case "at":
                    isAtPosition_1 = true;
                    return false;
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case COVER:
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var prefixRadialGradient = function(context, tokens) {
        var shape = 0;
        var size = 3;
        var stops = [];
        var position2 = [];
        parseFunctionArgs(tokens).forEach(function(arg, i6) {
          var isColorStop = true;
          if (i6 === 0) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return false;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return false;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return false;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          } else if (i6 === 1) {
            isColorStop = arg.reduce(function(acc, token) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case CIRCLE:
                    shape = 0;
                    return false;
                  case ELLIPSE:
                    shape = 1;
                    return false;
                  case CONTAIN:
                  case CLOSEST_SIDE:
                    size = 0;
                    return false;
                  case FARTHEST_SIDE:
                    size = 1;
                    return false;
                  case CLOSEST_CORNER:
                    size = 2;
                    return false;
                  case COVER:
                  case FARTHEST_CORNER:
                    size = 3;
                    return false;
                }
              } else if (isLength(token) || isLengthPercentage(token)) {
                if (!Array.isArray(size)) {
                  size = [];
                }
                size.push(token);
                return false;
              }
              return acc;
            }, isColorStop);
          }
          if (isColorStop) {
            var colorStop = parseColorStop(context, arg);
            stops.push(colorStop);
          }
        });
        return {
          size,
          shape,
          stops,
          position: position2,
          type: 2
          /* RADIAL_GRADIENT */
        };
      };
      var isLinearGradient = function(background) {
        return background.type === 1;
      };
      var isRadialGradient = function(background) {
        return background.type === 2;
      };
      var image = {
        name: "image",
        parse: function(context, value) {
          if (value.type === 22) {
            var image_1 = {
              url: value.value,
              type: 0
              /* URL */
            };
            context.cache.addImage(value.value);
            return image_1;
          }
          if (value.type === 18) {
            var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
            if (typeof imageFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
            }
            return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
        }
      };
      function isSupportedImage(value) {
        return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
      }
      var SUPPORTED_IMAGE_FUNCTIONS = {
        "linear-gradient": linearGradient,
        "-moz-linear-gradient": prefixLinearGradient,
        "-ms-linear-gradient": prefixLinearGradient,
        "-o-linear-gradient": prefixLinearGradient,
        "-webkit-linear-gradient": prefixLinearGradient,
        "radial-gradient": radialGradient,
        "-moz-radial-gradient": prefixRadialGradient,
        "-ms-radial-gradient": prefixRadialGradient,
        "-o-radial-gradient": prefixRadialGradient,
        "-webkit-radial-gradient": prefixRadialGradient,
        "-webkit-gradient": webkitGradient
      };
      var backgroundImage = {
        name: "background-image",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens.filter(function(value) {
            return nonFunctionArgSeparator(value) && isSupportedImage(value);
          }).map(function(value) {
            return image.parse(context, value);
          });
        }
      };
      var backgroundOrigin = {
        name: "background-origin",
        initialValue: "border-box",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.map(function(token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "padding-box":
                  return 1;
                case "content-box":
                  return 2;
              }
            }
            return 0;
          });
        }
      };
      var backgroundPosition = {
        name: "background-position",
        initialValue: "0% 0%",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isLengthPercentage);
          }).map(parseLengthPercentageTuple);
        }
      };
      var backgroundRepeat = {
        name: "background-repeat",
        initialValue: "repeat",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isIdentToken).map(function(token) {
              return token.value;
            }).join(" ");
          }).map(parseBackgroundRepeat);
        }
      };
      var parseBackgroundRepeat = function(value) {
        switch (value) {
          case "no-repeat":
            return 1;
          case "repeat-x":
          case "repeat no-repeat":
            return 2;
          case "repeat-y":
          case "no-repeat repeat":
            return 3;
          case "repeat":
          default:
            return 0;
        }
      };
      var BACKGROUND_SIZE;
      (function(BACKGROUND_SIZE2) {
        BACKGROUND_SIZE2["AUTO"] = "auto";
        BACKGROUND_SIZE2["CONTAIN"] = "contain";
        BACKGROUND_SIZE2["COVER"] = "cover";
      })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
      var backgroundSize = {
        name: "background-size",
        initialValue: "0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseFunctionArgs(tokens).map(function(values) {
            return values.filter(isBackgroundSizeInfoToken);
          });
        }
      };
      var isBackgroundSizeInfoToken = function(value) {
        return isIdentToken(value) || isLengthPercentage(value);
      };
      var borderColorForSide = function(side) {
        return {
          name: "border-" + side + "-color",
          initialValue: "transparent",
          prefix: false,
          type: 3,
          format: "color"
        };
      };
      var borderTopColor = borderColorForSide("top");
      var borderRightColor = borderColorForSide("right");
      var borderBottomColor = borderColorForSide("bottom");
      var borderLeftColor = borderColorForSide("left");
      var borderRadiusForSide = function(side) {
        return {
          name: "border-radius-" + side,
          initialValue: "0 0",
          prefix: false,
          type: 1,
          parse: function(_context, tokens) {
            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
          }
        };
      };
      var borderTopLeftRadius = borderRadiusForSide("top-left");
      var borderTopRightRadius = borderRadiusForSide("top-right");
      var borderBottomRightRadius = borderRadiusForSide("bottom-right");
      var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
      var borderStyleForSide = function(side) {
        return {
          name: "border-" + side + "-style",
          initialValue: "solid",
          prefix: false,
          type: 2,
          parse: function(_context, style) {
            switch (style) {
              case "none":
                return 0;
              case "dashed":
                return 2;
              case "dotted":
                return 3;
              case "double":
                return 4;
            }
            return 1;
          }
        };
      };
      var borderTopStyle = borderStyleForSide("top");
      var borderRightStyle = borderStyleForSide("right");
      var borderBottomStyle = borderStyleForSide("bottom");
      var borderLeftStyle = borderStyleForSide("left");
      var borderWidthForSide = function(side) {
        return {
          name: "border-" + side + "-width",
          initialValue: "0",
          type: 0,
          prefix: false,
          parse: function(_context, token) {
            if (isDimensionToken(token)) {
              return token.number;
            }
            return 0;
          }
        };
      };
      var borderTopWidth = borderWidthForSide("top");
      var borderRightWidth = borderWidthForSide("right");
      var borderBottomWidth = borderWidthForSide("bottom");
      var borderLeftWidth = borderWidthForSide("left");
      var color = {
        name: "color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var direction = {
        name: "direction",
        initialValue: "ltr",
        prefix: false,
        type: 2,
        parse: function(_context, direction2) {
          switch (direction2) {
            case "rtl":
              return 1;
            case "ltr":
            default:
              return 0;
          }
        }
      };
      var display = {
        name: "display",
        initialValue: "inline-block",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).reduce(
            function(bit, token) {
              return bit | parseDisplayValue(token.value);
            },
            0
            /* NONE */
          );
        }
      };
      var parseDisplayValue = function(display2) {
        switch (display2) {
          case "block":
          case "-webkit-box":
            return 2;
          case "inline":
            return 4;
          case "run-in":
            return 8;
          case "flow":
            return 16;
          case "flow-root":
            return 32;
          case "table":
            return 64;
          case "flex":
          case "-webkit-flex":
            return 128;
          case "grid":
          case "-ms-grid":
            return 256;
          case "ruby":
            return 512;
          case "subgrid":
            return 1024;
          case "list-item":
            return 2048;
          case "table-row-group":
            return 4096;
          case "table-header-group":
            return 8192;
          case "table-footer-group":
            return 16384;
          case "table-row":
            return 32768;
          case "table-cell":
            return 65536;
          case "table-column-group":
            return 131072;
          case "table-column":
            return 262144;
          case "table-caption":
            return 524288;
          case "ruby-base":
            return 1048576;
          case "ruby-text":
            return 2097152;
          case "ruby-base-container":
            return 4194304;
          case "ruby-text-container":
            return 8388608;
          case "contents":
            return 16777216;
          case "inline-block":
            return 33554432;
          case "inline-list-item":
            return 67108864;
          case "inline-table":
            return 134217728;
          case "inline-flex":
            return 268435456;
          case "inline-grid":
            return 536870912;
        }
        return 0;
      };
      var float = {
        name: "float",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, float2) {
          switch (float2) {
            case "left":
              return 1;
            case "right":
              return 2;
            case "inline-start":
              return 3;
            case "inline-end":
              return 4;
          }
          return 0;
        }
      };
      var letterSpacing = {
        name: "letter-spacing",
        initialValue: "0",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "normal") {
            return 0;
          }
          if (token.type === 17) {
            return token.number;
          }
          if (token.type === 15) {
            return token.number;
          }
          return 0;
        }
      };
      var LINE_BREAK;
      (function(LINE_BREAK2) {
        LINE_BREAK2["NORMAL"] = "normal";
        LINE_BREAK2["STRICT"] = "strict";
      })(LINE_BREAK || (LINE_BREAK = {}));
      var lineBreak = {
        name: "line-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, lineBreak2) {
          switch (lineBreak2) {
            case "strict":
              return LINE_BREAK.STRICT;
            case "normal":
            default:
              return LINE_BREAK.NORMAL;
          }
        }
      };
      var lineHeight = {
        name: "line-height",
        initialValue: "normal",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
      var computeLineHeight = function(token, fontSize2) {
        if (isIdentToken(token) && token.value === "normal") {
          return 1.2 * fontSize2;
        } else if (token.type === 17) {
          return fontSize2 * token.number;
        } else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize2);
        }
        return fontSize2;
      };
      var listStyleImage = {
        name: "list-style-image",
        initialValue: "none",
        type: 0,
        prefix: false,
        parse: function(context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          return image.parse(context, token);
        }
      };
      var listStylePosition = {
        name: "list-style-position",
        initialValue: "outside",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "inside":
              return 0;
            case "outside":
            default:
              return 1;
          }
        }
      };
      var listStyleType = {
        name: "list-style-type",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, type) {
          switch (type) {
            case "disc":
              return 0;
            case "circle":
              return 1;
            case "square":
              return 2;
            case "decimal":
              return 3;
            case "cjk-decimal":
              return 4;
            case "decimal-leading-zero":
              return 5;
            case "lower-roman":
              return 6;
            case "upper-roman":
              return 7;
            case "lower-greek":
              return 8;
            case "lower-alpha":
              return 9;
            case "upper-alpha":
              return 10;
            case "arabic-indic":
              return 11;
            case "armenian":
              return 12;
            case "bengali":
              return 13;
            case "cambodian":
              return 14;
            case "cjk-earthly-branch":
              return 15;
            case "cjk-heavenly-stem":
              return 16;
            case "cjk-ideographic":
              return 17;
            case "devanagari":
              return 18;
            case "ethiopic-numeric":
              return 19;
            case "georgian":
              return 20;
            case "gujarati":
              return 21;
            case "gurmukhi":
              return 22;
            case "hebrew":
              return 22;
            case "hiragana":
              return 23;
            case "hiragana-iroha":
              return 24;
            case "japanese-formal":
              return 25;
            case "japanese-informal":
              return 26;
            case "kannada":
              return 27;
            case "katakana":
              return 28;
            case "katakana-iroha":
              return 29;
            case "khmer":
              return 30;
            case "korean-hangul-formal":
              return 31;
            case "korean-hanja-formal":
              return 32;
            case "korean-hanja-informal":
              return 33;
            case "lao":
              return 34;
            case "lower-armenian":
              return 35;
            case "malayalam":
              return 36;
            case "mongolian":
              return 37;
            case "myanmar":
              return 38;
            case "oriya":
              return 39;
            case "persian":
              return 40;
            case "simp-chinese-formal":
              return 41;
            case "simp-chinese-informal":
              return 42;
            case "tamil":
              return 43;
            case "telugu":
              return 44;
            case "thai":
              return 45;
            case "tibetan":
              return 46;
            case "trad-chinese-formal":
              return 47;
            case "trad-chinese-informal":
              return 48;
            case "upper-armenian":
              return 49;
            case "disclosure-open":
              return 50;
            case "disclosure-closed":
              return 51;
            case "none":
            default:
              return -1;
          }
        }
      };
      var marginForSide = function(side) {
        return {
          name: "margin-" + side,
          initialValue: "0",
          prefix: false,
          type: 4
          /* TOKEN_VALUE */
        };
      };
      var marginTop = marginForSide("top");
      var marginRight = marginForSide("right");
      var marginBottom = marginForSide("bottom");
      var marginLeft = marginForSide("left");
      var overflow = {
        name: "overflow",
        initialValue: "visible",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(overflow2) {
            switch (overflow2.value) {
              case "hidden":
                return 1;
              case "scroll":
                return 2;
              case "clip":
                return 3;
              case "auto":
                return 4;
              case "visible":
              default:
                return 0;
            }
          });
        }
      };
      var overflowWrap = {
        name: "overflow-wrap",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "break-word":
              return "break-word";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var paddingForSide = function(side) {
        return {
          name: "padding-" + side,
          initialValue: "0",
          prefix: false,
          type: 3,
          format: "length-percentage"
        };
      };
      var paddingTop = paddingForSide("top");
      var paddingRight = paddingForSide("right");
      var paddingBottom = paddingForSide("bottom");
      var paddingLeft = paddingForSide("left");
      var textAlign = {
        name: "text-align",
        initialValue: "left",
        prefix: false,
        type: 2,
        parse: function(_context, textAlign2) {
          switch (textAlign2) {
            case "right":
              return 2;
            case "center":
            case "justify":
              return 1;
            case "left":
            default:
              return 0;
          }
        }
      };
      var position = {
        name: "position",
        initialValue: "static",
        prefix: false,
        type: 2,
        parse: function(_context, position2) {
          switch (position2) {
            case "relative":
              return 1;
            case "absolute":
              return 2;
            case "fixed":
              return 3;
            case "sticky":
              return 4;
          }
          return 0;
        }
      };
      var textShadow = {
        name: "text-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: COLORS.TRANSPARENT,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH
            };
            var c5 = 0;
            for (var i6 = 0; i6 < values.length; i6++) {
              var token = values[i6];
              if (isLength(token)) {
                if (c5 === 0) {
                  shadow.offsetX = token;
                } else if (c5 === 1) {
                  shadow.offsetY = token;
                } else {
                  shadow.blur = token;
                }
                c5++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var textTransform = {
        name: "text-transform",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, textTransform2) {
          switch (textTransform2) {
            case "uppercase":
              return 2;
            case "lowercase":
              return 1;
            case "capitalize":
              return 3;
          }
          return 0;
        }
      };
      var transform$1 = {
        name: "transform",
        initialValue: "none",
        prefix: true,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20 && token.value === "none") {
            return null;
          }
          if (token.type === 18) {
            var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
            if (typeof transformFunction === "undefined") {
              throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
            }
            return transformFunction(token.values);
          }
          return null;
        }
      };
      var matrix = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        return values.length === 6 ? values : null;
      };
      var matrix3d = function(args) {
        var values = args.filter(function(arg) {
          return arg.type === 17;
        }).map(function(arg) {
          return arg.number;
        });
        var a1 = values[0], b1 = values[1];
        values[2];
        values[3];
        var a22 = values[4], b2 = values[5];
        values[6];
        values[7];
        values[8];
        values[9];
        values[10];
        values[11];
        var a42 = values[12], b4 = values[13];
        values[14];
        values[15];
        return values.length === 16 ? [a1, b1, a22, b2, a42, b4] : null;
      };
      var SUPPORTED_TRANSFORM_FUNCTIONS = {
        matrix,
        matrix3d
      };
      var DEFAULT_VALUE = {
        type: 16,
        number: 50,
        flags: FLAG_INTEGER
      };
      var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
      var transformOrigin = {
        name: "transform-origin",
        initialValue: "50% 50%",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
            return DEFAULT;
          }
          return [origins[0], origins[1]];
        }
      };
      var visibility = {
        name: "visible",
        initialValue: "none",
        prefix: false,
        type: 2,
        parse: function(_context, visibility2) {
          switch (visibility2) {
            case "hidden":
              return 1;
            case "collapse":
              return 2;
            case "visible":
            default:
              return 0;
          }
        }
      };
      var WORD_BREAK;
      (function(WORD_BREAK2) {
        WORD_BREAK2["NORMAL"] = "normal";
        WORD_BREAK2["BREAK_ALL"] = "break-all";
        WORD_BREAK2["KEEP_ALL"] = "keep-all";
      })(WORD_BREAK || (WORD_BREAK = {}));
      var wordBreak = {
        name: "word-break",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, wordBreak2) {
          switch (wordBreak2) {
            case "break-all":
              return WORD_BREAK.BREAK_ALL;
            case "keep-all":
              return WORD_BREAK.KEEP_ALL;
            case "normal":
            default:
              return WORD_BREAK.NORMAL;
          }
        }
      };
      var zIndex = {
        name: "z-index",
        initialValue: "auto",
        prefix: false,
        type: 0,
        parse: function(_context, token) {
          if (token.type === 20) {
            return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
            return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
        }
      };
      var time = {
        name: "time",
        parse: function(_context, value) {
          if (value.type === 15) {
            switch (value.unit.toLowerCase()) {
              case "s":
                return 1e3 * value.number;
              case "ms":
                return value.number;
            }
          }
          throw new Error("Unsupported time type");
        }
      };
      var opacity = {
        name: "opacity",
        initialValue: "1",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          return 1;
        }
      };
      var textDecorationColor = {
        name: "text-decoration-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
      var textDecorationLine = {
        name: "text-decoration-line",
        initialValue: "none",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            switch (token.value) {
              case "underline":
                return 1;
              case "overline":
                return 2;
              case "line-through":
                return 3;
              case "none":
                return 4;
            }
            return 0;
          }).filter(function(line) {
            return line !== 0;
          });
        }
      };
      var fontFamily = {
        name: "font-family",
        initialValue: "",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function(token) {
            switch (token.type) {
              case 20:
              case 0:
                accumulator.push(token.value);
                break;
              case 17:
                accumulator.push(token.number.toString());
                break;
              case 4:
                results.push(accumulator.join(" "));
                accumulator.length = 0;
                break;
            }
          });
          if (accumulator.length) {
            results.push(accumulator.join(" "));
          }
          return results.map(function(result) {
            return result.indexOf(" ") === -1 ? result : "'" + result + "'";
          });
        }
      };
      var fontSize = {
        name: "font-size",
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length"
      };
      var fontWeight = {
        name: "font-weight",
        initialValue: "normal",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isNumberToken(token)) {
            return token.number;
          }
          if (isIdentToken(token)) {
            switch (token.value) {
              case "bold":
                return 700;
              case "normal":
              default:
                return 400;
            }
          }
          return 400;
        }
      };
      var fontVariant = {
        name: "font-variant",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          return tokens.filter(isIdentToken).map(function(token) {
            return token.value;
          });
        }
      };
      var fontStyle = {
        name: "font-style",
        initialValue: "normal",
        prefix: false,
        type: 2,
        parse: function(_context, overflow2) {
          switch (overflow2) {
            case "oblique":
              return "oblique";
            case "italic":
              return "italic";
            case "normal":
            default:
              return "normal";
          }
        }
      };
      var contains = function(bit, value) {
        return (bit & value) !== 0;
      };
      var content = {
        name: "content",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return [];
          }
          return tokens;
        }
      };
      var counterIncrement = {
        name: "counter-increment",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i6 = 0; i6 < filtered.length; i6++) {
            var counter = filtered[i6];
            var next = filtered[i6 + 1];
            if (counter.type === 20) {
              var increment = next && isNumberToken(next) ? next.number : 1;
              increments.push({ counter: counter.value, increment });
            }
          }
          return increments;
        }
      };
      var counterReset = {
        name: "counter-reset",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i6 = 0; i6 < filtered.length; i6++) {
            var counter = filtered[i6];
            var next = filtered[i6 + 1];
            if (isIdentToken(counter) && counter.value !== "none") {
              var reset2 = next && isNumberToken(next) ? next.number : 0;
              resets.push({ counter: counter.value, reset: reset2 });
            }
          }
          return resets;
        }
      };
      var duration = {
        name: "duration",
        initialValue: "0s",
        prefix: false,
        type: 1,
        parse: function(context, tokens) {
          return tokens.filter(isDimensionToken).map(function(token) {
            return time.parse(context, token);
          });
        }
      };
      var quotes = {
        name: "quotes",
        initialValue: "none",
        prefix: true,
        type: 1,
        parse: function(_context, tokens) {
          if (tokens.length === 0) {
            return null;
          }
          var first = tokens[0];
          if (first.type === 20 && first.value === "none") {
            return null;
          }
          var quotes2 = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
            return null;
          }
          for (var i6 = 0; i6 < filtered.length; i6 += 2) {
            var open_1 = filtered[i6].value;
            var close_1 = filtered[i6 + 1].value;
            quotes2.push({ open: open_1, close: close_1 });
          }
          return quotes2;
        }
      };
      var getQuote = function(quotes2, depth, open2) {
        if (!quotes2) {
          return "";
        }
        var quote = quotes2[Math.min(depth, quotes2.length - 1)];
        if (!quote) {
          return "";
        }
        return open2 ? quote.open : quote.close;
      };
      var boxShadow = {
        name: "box-shadow",
        initialValue: "none",
        type: 1,
        prefix: false,
        parse: function(context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
            return [];
          }
          return parseFunctionArgs(tokens).map(function(values) {
            var shadow = {
              color: 255,
              offsetX: ZERO_LENGTH,
              offsetY: ZERO_LENGTH,
              blur: ZERO_LENGTH,
              spread: ZERO_LENGTH,
              inset: false
            };
            var c5 = 0;
            for (var i6 = 0; i6 < values.length; i6++) {
              var token = values[i6];
              if (isIdentWithValue(token, "inset")) {
                shadow.inset = true;
              } else if (isLength(token)) {
                if (c5 === 0) {
                  shadow.offsetX = token;
                } else if (c5 === 1) {
                  shadow.offsetY = token;
                } else if (c5 === 2) {
                  shadow.blur = token;
                } else {
                  shadow.spread = token;
                }
                c5++;
              } else {
                shadow.color = color$1.parse(context, token);
              }
            }
            return shadow;
          });
        }
      };
      var paintOrder = {
        name: "paint-order",
        initialValue: "normal",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          var DEFAULT_VALUE2 = [
            0,
            1,
            2
            /* MARKERS */
          ];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function(token) {
            switch (token.value) {
              case "stroke":
                layers.push(
                  1
                  /* STROKE */
                );
                break;
              case "fill":
                layers.push(
                  0
                  /* FILL */
                );
                break;
              case "markers":
                layers.push(
                  2
                  /* MARKERS */
                );
                break;
            }
          });
          DEFAULT_VALUE2.forEach(function(value) {
            if (layers.indexOf(value) === -1) {
              layers.push(value);
            }
          });
          return layers;
        }
      };
      var webkitTextStrokeColor = {
        name: "-webkit-text-stroke-color",
        initialValue: "currentcolor",
        prefix: false,
        type: 3,
        format: "color"
      };
      var webkitTextStrokeWidth = {
        name: "-webkit-text-stroke-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
      var CSSParsedDeclaration = (
        /** @class */
        function() {
          function CSSParsedDeclaration2(context, declaration) {
            var _a2, _b2;
            this.animationDuration = parse18(context, duration, declaration.animationDuration);
            this.backgroundClip = parse18(context, backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse18(context, backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse18(context, backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse18(context, backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse18(context, backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse18(context, backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse18(context, backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse18(context, borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse18(context, borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse18(context, borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse18(context, borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse18(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse18(context, borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse18(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse18(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse18(context, borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse18(context, borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse18(context, borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse18(context, borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse18(context, borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse18(context, borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse18(context, borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse18(context, borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse18(context, boxShadow, declaration.boxShadow);
            this.color = parse18(context, color, declaration.color);
            this.direction = parse18(context, direction, declaration.direction);
            this.display = parse18(context, display, declaration.display);
            this.float = parse18(context, float, declaration.cssFloat);
            this.fontFamily = parse18(context, fontFamily, declaration.fontFamily);
            this.fontSize = parse18(context, fontSize, declaration.fontSize);
            this.fontStyle = parse18(context, fontStyle, declaration.fontStyle);
            this.fontVariant = parse18(context, fontVariant, declaration.fontVariant);
            this.fontWeight = parse18(context, fontWeight, declaration.fontWeight);
            this.letterSpacing = parse18(context, letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse18(context, lineBreak, declaration.lineBreak);
            this.lineHeight = parse18(context, lineHeight, declaration.lineHeight);
            this.listStyleImage = parse18(context, listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse18(context, listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse18(context, listStyleType, declaration.listStyleType);
            this.marginTop = parse18(context, marginTop, declaration.marginTop);
            this.marginRight = parse18(context, marginRight, declaration.marginRight);
            this.marginBottom = parse18(context, marginBottom, declaration.marginBottom);
            this.marginLeft = parse18(context, marginLeft, declaration.marginLeft);
            this.opacity = parse18(context, opacity, declaration.opacity);
            var overflowTuple = parse18(context, overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse18(context, overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse18(context, paddingTop, declaration.paddingTop);
            this.paddingRight = parse18(context, paddingRight, declaration.paddingRight);
            this.paddingBottom = parse18(context, paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse18(context, paddingLeft, declaration.paddingLeft);
            this.paintOrder = parse18(context, paintOrder, declaration.paintOrder);
            this.position = parse18(context, position, declaration.position);
            this.textAlign = parse18(context, textAlign, declaration.textAlign);
            this.textDecorationColor = parse18(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
            this.textDecorationLine = parse18(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
            this.textShadow = parse18(context, textShadow, declaration.textShadow);
            this.textTransform = parse18(context, textTransform, declaration.textTransform);
            this.transform = parse18(context, transform$1, declaration.transform);
            this.transformOrigin = parse18(context, transformOrigin, declaration.transformOrigin);
            this.visibility = parse18(context, visibility, declaration.visibility);
            this.webkitTextStrokeColor = parse18(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
            this.webkitTextStrokeWidth = parse18(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
            this.wordBreak = parse18(context, wordBreak, declaration.wordBreak);
            this.zIndex = parse18(context, zIndex, declaration.zIndex);
          }
          CSSParsedDeclaration2.prototype.isVisible = function() {
            return this.display > 0 && this.opacity > 0 && this.visibility === 0;
          };
          CSSParsedDeclaration2.prototype.isTransparent = function() {
            return isTransparent(this.backgroundColor);
          };
          CSSParsedDeclaration2.prototype.isTransformed = function() {
            return this.transform !== null;
          };
          CSSParsedDeclaration2.prototype.isPositioned = function() {
            return this.position !== 0;
          };
          CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
            return this.isPositioned() && !this.zIndex.auto;
          };
          CSSParsedDeclaration2.prototype.isFloating = function() {
            return this.float !== 0;
          };
          CSSParsedDeclaration2.prototype.isInlineLevel = function() {
            return contains(
              this.display,
              4
              /* INLINE */
            ) || contains(
              this.display,
              33554432
              /* INLINE_BLOCK */
            ) || contains(
              this.display,
              268435456
              /* INLINE_FLEX */
            ) || contains(
              this.display,
              536870912
              /* INLINE_GRID */
            ) || contains(
              this.display,
              67108864
              /* INLINE_LIST_ITEM */
            ) || contains(
              this.display,
              134217728
              /* INLINE_TABLE */
            );
          };
          return CSSParsedDeclaration2;
        }()
      );
      var CSSParsedPseudoDeclaration = (
        /** @class */
        function() {
          function CSSParsedPseudoDeclaration2(context, declaration) {
            this.content = parse18(context, content, declaration.content);
            this.quotes = parse18(context, quotes, declaration.quotes);
          }
          return CSSParsedPseudoDeclaration2;
        }()
      );
      var CSSParsedCounterDeclaration = (
        /** @class */
        function() {
          function CSSParsedCounterDeclaration2(context, declaration) {
            this.counterIncrement = parse18(context, counterIncrement, declaration.counterIncrement);
            this.counterReset = parse18(context, counterReset, declaration.counterReset);
          }
          return CSSParsedCounterDeclaration2;
        }()
      );
      var parse18 = function(context, descriptor, style) {
        var tokenizer = new Tokenizer();
        var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
        tokenizer.write(value);
        var parser2 = new Parser2(tokenizer.read());
        switch (descriptor.type) {
          case 2:
            var token = parser2.parseComponentValue();
            return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0:
            return descriptor.parse(context, parser2.parseComponentValue());
          case 1:
            return descriptor.parse(context, parser2.parseComponentValues());
          case 4:
            return parser2.parseComponentValue();
          case 3:
            switch (descriptor.format) {
              case "angle":
                return angle.parse(context, parser2.parseComponentValue());
              case "color":
                return color$1.parse(context, parser2.parseComponentValue());
              case "image":
                return image.parse(context, parser2.parseComponentValue());
              case "length":
                var length_1 = parser2.parseComponentValue();
                return isLength(length_1) ? length_1 : ZERO_LENGTH;
              case "length-percentage":
                var value_1 = parser2.parseComponentValue();
                return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
              case "time":
                return time.parse(context, parser2.parseComponentValue());
            }
            break;
        }
      };
      var elementDebuggerAttribute = "data-html2canvas-debug";
      var getElementDebugType = function(element) {
        var attribute = element.getAttribute(elementDebuggerAttribute);
        switch (attribute) {
          case "all":
            return 1;
          case "clone":
            return 2;
          case "parse":
            return 3;
          case "render":
            return 4;
          default:
            return 0;
        }
      };
      var isDebugging = function(element, type) {
        var elementType = getElementDebugType(element);
        return elementType === 1 || type === elementType;
      };
      var ElementContainer = (
        /** @class */
        function() {
          function ElementContainer2(context, element) {
            this.context = context;
            this.textNodes = [];
            this.elements = [];
            this.flags = 0;
            if (isDebugging(
              element,
              3
              /* PARSE */
            )) {
              debugger;
            }
            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
            if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function(duration2) {
                return duration2 > 0;
              })) {
                element.style.animationDuration = "0s";
              }
              if (this.styles.transform !== null) {
                element.style.transform = "none";
              }
            }
            this.bounds = parseBounds(this.context, element);
            if (isDebugging(
              element,
              4
              /* RENDER */
            )) {
              this.flags |= 16;
            }
          }
          return ElementContainer2;
        }()
      );
      var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
      var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
      }
      var decode = function(base642) {
        var bufferLength = base642.length * 0.75, len = base642.length, i6, p7 = 0, encoded1, encoded2, encoded3, encoded4;
        if (base642[base642.length - 1] === "=") {
          bufferLength--;
          if (base642[base642.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i6 = 0; i6 < len; i6 += 4) {
          encoded1 = lookup$1[base642.charCodeAt(i6)];
          encoded2 = lookup$1[base642.charCodeAt(i6 + 1)];
          encoded3 = lookup$1[base642.charCodeAt(i6 + 2)];
          encoded4 = lookup$1[base642.charCodeAt(i6 + 3)];
          bytes[p7++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p7++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p7++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      };
      var polyUint16Array = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i6 = 0; i6 < length2; i6 += 2) {
          bytes.push(buffer[i6 + 1] << 8 | buffer[i6]);
        }
        return bytes;
      };
      var polyUint32Array = function(buffer) {
        var length2 = buffer.length;
        var bytes = [];
        for (var i6 = 0; i6 < length2; i6 += 4) {
          bytes.push(buffer[i6 + 3] << 24 | buffer[i6 + 2] << 16 | buffer[i6 + 1] << 8 | buffer[i6]);
        }
        return bytes;
      };
      var UTRIE2_SHIFT_2 = 5;
      var UTRIE2_SHIFT_1 = 6 + 5;
      var UTRIE2_INDEX_SHIFT = 2;
      var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
      var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
      var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
      var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
      var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
      var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
      var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
      var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
      var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
      var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
      var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
      var slice16 = function(view, start2, end2) {
        if (view.slice) {
          return view.slice(start2, end2);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start2, end2));
      };
      var slice32 = function(view, start2, end2) {
        if (view.slice) {
          return view.slice(start2, end2);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start2, end2));
      };
      var createTrieFromBase64 = function(base642, _byteLength) {
        var buffer = decode(base642);
        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index4 = slice16(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie(view32[0], view32[1], view32[2], view32[3], index4, data);
      };
      var Trie = (
        /** @class */
        function() {
          function Trie2(initialValue, errorValue, highStart, highValueIndex, index4, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index4;
            this.data = data;
          }
          Trie2.prototype.get = function(codePoint) {
            var ix;
            if (codePoint >= 0) {
              if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
                ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 65535) {
                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint < this.highStart) {
                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                ix = this.index[ix];
                ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                ix = this.index[ix];
                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                return this.data[ix];
              }
              if (codePoint <= 1114111) {
                return this.data[this.highValueIndex];
              }
            }
            return this.errorValue;
          };
          return Trie2;
        }()
      );
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i5 = 0; i5 < chars.length; i5++) {
        lookup[chars.charCodeAt(i5)] = i5;
      }
      var Prepend = 1;
      var CR = 2;
      var LF = 3;
      var Control = 4;
      var Extend = 5;
      var SpacingMark = 7;
      var L2 = 8;
      var V2 = 9;
      var T3 = 10;
      var LV = 11;
      var LVT = 12;
      var ZWJ = 13;
      var Extended_Pictographic = 14;
      var RI = 15;
      var toCodePoints = function(str) {
        var codePoints = [];
        var i6 = 0;
        var length2 = str.length;
        while (i6 < length2) {
          var value = str.charCodeAt(i6++);
          if (value >= 55296 && value <= 56319 && i6 < length2) {
            var extra = str.charCodeAt(i6++);
            if ((extra & 64512) === 56320) {
              codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              codePoints.push(value);
              i6--;
            }
          } else {
            codePoints.push(value);
          }
        }
        return codePoints;
      };
      var fromCodePoint = function() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
        }
        var length2 = codePoints.length;
        if (!length2) {
          return "";
        }
        var codeUnits = [];
        var index4 = -1;
        var result = "";
        while (++index4 < length2) {
          var codePoint = codePoints[index4];
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
          }
          if (index4 + 1 === length2 || codeUnits.length > 16384) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      var UnicodeTrie = createTrieFromBase64(base64);
      var BREAK_NOT_ALLOWED = "\xD7";
      var BREAK_ALLOWED = "\xF7";
      var codePointToClass = function(codePoint) {
        return UnicodeTrie.get(codePoint);
      };
      var _graphemeBreakAtIndex = function(_codePoints, classTypes, index4) {
        var prevIndex = index4 - 2;
        var prev = classTypes[prevIndex];
        var current = classTypes[index4 - 1];
        var next = classTypes[index4];
        if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
        }
        if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
        }
        if (current === L2 && [L2, V2, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LV || current === V2) && (next === V2 || next === T3)) {
          return BREAK_NOT_ALLOWED;
        }
        if ((current === LVT || current === T3) && next === T3) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
        }
        if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
        }
        if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
            prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
            return BREAK_NOT_ALLOWED;
          }
        }
        if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
            countRI++;
            prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
            return BREAK_NOT_ALLOWED;
          }
        }
        return BREAK_ALLOWED;
      };
      var GraphemeBreaker = function(str) {
        var codePoints = toCodePoints(str);
        var length2 = codePoints.length;
        var index4 = 0;
        var lastEnd = 0;
        var classTypes = codePoints.map(codePointToClass);
        return {
          next: function() {
            if (index4 >= length2) {
              return { done: true, value: null };
            }
            var graphemeBreak = BREAK_NOT_ALLOWED;
            while (index4 < length2 && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index4)) === BREAK_NOT_ALLOWED) {
            }
            if (graphemeBreak !== BREAK_NOT_ALLOWED || index4 === length2) {
              var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index4));
              lastEnd = index4;
              return { value, done: false };
            }
            return { done: true, value: null };
          }
        };
      };
      var splitGraphemes = function(str) {
        var breaker = GraphemeBreaker(str);
        var graphemes = [];
        var bk;
        while (!(bk = breaker.next()).done) {
          if (bk.value) {
            graphemes.push(bk.value.slice());
          }
        }
        return graphemes;
      };
      var testRangeBounds = function(document2) {
        var TEST_HEIGHT = 123;
        if (document2.createRange) {
          var range = document2.createRange();
          if (range.getBoundingClientRect) {
            var testElement = document2.createElement("boundtest");
            testElement.style.height = TEST_HEIGHT + "px";
            testElement.style.display = "block";
            document2.body.appendChild(testElement);
            range.selectNode(testElement);
            var rangeBounds = range.getBoundingClientRect();
            var rangeHeight = Math.round(rangeBounds.height);
            document2.body.removeChild(testElement);
            if (rangeHeight === TEST_HEIGHT) {
              return true;
            }
          }
        }
        return false;
      };
      var testIOSLineBreak = function(document2) {
        var testElement = document2.createElement("boundtest");
        testElement.style.width = "50px";
        testElement.style.display = "block";
        testElement.style.fontSize = "12px";
        testElement.style.letterSpacing = "0px";
        testElement.style.wordSpacing = "0px";
        document2.body.appendChild(testElement);
        var range = document2.createRange();
        testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
        var node2 = testElement.firstChild;
        var textList = toCodePoints$1(node2.data).map(function(i6) {
          return fromCodePoint$1(i6);
        });
        var offset2 = 0;
        var prev = {};
        var supports = textList.every(function(text, i6) {
          range.setStart(node2, offset2);
          range.setEnd(node2, offset2 + text.length);
          var rect = range.getBoundingClientRect();
          offset2 += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i6 === 0) {
            return true;
          }
          return boundAhead;
        });
        document2.body.removeChild(testElement);
        return supports;
      };
      var testCORS = function() {
        return typeof new Image().crossOrigin !== "undefined";
      };
      var testResponseType = function() {
        return typeof new XMLHttpRequest().responseType === "string";
      };
      var testSVG = function(document2) {
        var img = new Image();
        var canvas = document2.createElement("canvas");
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return false;
        }
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
        } catch (e4) {
          return false;
        }
        return true;
      };
      var isGreenPixel = function(data) {
        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
      };
      var testForeignObject = function(document2) {
        var canvas = document2.createElement("canvas");
        var size = 100;
        canvas.width = size;
        canvas.height = size;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return Promise.reject(false);
        }
        ctx.fillStyle = "rgb(0, 255, 0)";
        ctx.fillRect(0, 0, size, size);
        var img = new Image();
        var greenImageSrc = canvas.toDataURL();
        img.src = greenImageSrc;
        var svg = createForeignObjectSVG(size, size, 0, 0, img);
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size, size);
        return loadSerializedSVG$1(svg).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = "red";
          ctx.fillRect(0, 0, size, size);
          var node2 = document2.createElement("div");
          node2.style.backgroundImage = "url(" + greenImageSrc + ")";
          node2.style.height = size + "px";
          return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
        }).then(function(img2) {
          ctx.drawImage(img2, 0, 0);
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
        }).catch(function() {
          return false;
        });
      };
      var createForeignObjectSVG = function(width, height, x2, y3, node2) {
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(xmlns, "svg");
        var foreignObject = document.createElementNS(xmlns, "foreignObject");
        svg.setAttributeNS(null, "width", width.toString());
        svg.setAttributeNS(null, "height", height.toString());
        foreignObject.setAttributeNS(null, "width", "100%");
        foreignObject.setAttributeNS(null, "height", "100%");
        foreignObject.setAttributeNS(null, "x", x2.toString());
        foreignObject.setAttributeNS(null, "y", y3.toString());
        foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node2);
        return svg;
      };
      var loadSerializedSVG$1 = function(svg) {
        return new Promise(function(resolve, reject) {
          var img = new Image();
          img.onload = function() {
            return resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var FEATURES = {
        get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
          return value;
        },
        get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
          return value;
        },
        get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
          return value;
        },
        get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
          Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
          return value;
        },
        get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
          return value;
        },
        get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
          return value;
        },
        get SUPPORT_CORS_XHR() {
          var value = "withCredentials" in new XMLHttpRequest();
          Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
          return value;
        },
        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
          Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
          return value;
        }
      };
      var TextBounds = (
        /** @class */
        function() {
          function TextBounds2(text, bounds) {
            this.text = text;
            this.bounds = bounds;
          }
          return TextBounds2;
        }()
      );
      var parseTextBounds = function(context, value, styles, node2) {
        var textList = breakText(value, styles);
        var textBounds = [];
        var offset2 = 0;
        textList.forEach(function(text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
            if (FEATURES.SUPPORT_RANGE_BOUNDS) {
              var clientRects = createRange(node2, offset2, text.length).getClientRects();
              if (clientRects.length > 1) {
                var subSegments = segmentGraphemes(text);
                var subOffset_1 = 0;
                subSegments.forEach(function(subSegment) {
                  textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset2, subSegment.length).getClientRects())));
                  subOffset_1 += subSegment.length;
                });
              } else {
                textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
              }
            } else {
              var replacementNode = node2.splitText(text.length);
              textBounds.push(new TextBounds(text, getWrapperBounds(context, node2)));
              node2 = replacementNode;
            }
          } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
            node2 = node2.splitText(text.length);
          }
          offset2 += text.length;
        });
        return textBounds;
      };
      var getWrapperBounds = function(context, node2) {
        var ownerDocument = node2.ownerDocument;
        if (ownerDocument) {
          var wrapper = ownerDocument.createElement("html2canvaswrapper");
          wrapper.appendChild(node2.cloneNode(true));
          var parentNode = node2.parentNode;
          if (parentNode) {
            parentNode.replaceChild(wrapper, node2);
            var bounds = parseBounds(context, wrapper);
            if (wrapper.firstChild) {
              parentNode.replaceChild(wrapper.firstChild, wrapper);
            }
            return bounds;
          }
        }
        return Bounds.EMPTY;
      };
      var createRange = function(node2, offset2, length2) {
        var ownerDocument = node2.ownerDocument;
        if (!ownerDocument) {
          throw new Error("Node has no owner document");
        }
        var range = ownerDocument.createRange();
        range.setStart(node2, offset2);
        range.setEnd(node2, offset2 + length2);
        return range;
      };
      var segmentGraphemes = function(value) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return splitGraphemes(value);
      };
      var segmentWords = function(value, styles) {
        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          var segmenter = new Intl.Segmenter(void 0, {
            granularity: "word"
          });
          return Array.from(segmenter.segment(value)).map(function(segment) {
            return segment.segment;
          });
        }
        return breakWords(value, styles);
      };
      var breakText = function(value, styles) {
        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
      };
      var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
      var breakWords = function(str, styles) {
        var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
        });
        var words = [];
        var bk;
        var _loop_1 = function() {
          if (bk.value) {
            var value = bk.value.slice();
            var codePoints = toCodePoints$1(value);
            var word_1 = "";
            codePoints.forEach(function(codePoint) {
              if (wordSeparators.indexOf(codePoint) === -1) {
                word_1 += fromCodePoint$1(codePoint);
              } else {
                if (word_1.length) {
                  words.push(word_1);
                }
                words.push(fromCodePoint$1(codePoint));
                word_1 = "";
              }
            });
            if (word_1.length) {
              words.push(word_1);
            }
          }
        };
        while (!(bk = breaker.next()).done) {
          _loop_1();
        }
        return words;
      };
      var TextContainer = (
        /** @class */
        function() {
          function TextContainer2(context, node2, styles) {
            this.text = transform(node2.data, styles.textTransform);
            this.textBounds = parseTextBounds(context, this.text, styles, node2);
          }
          return TextContainer2;
        }()
      );
      var transform = function(text, transform2) {
        switch (transform2) {
          case 1:
            return text.toLowerCase();
          case 3:
            return text.replace(CAPITALIZE, capitalize);
          case 2:
            return text.toUpperCase();
          default:
            return text;
        }
      };
      var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
      var capitalize = function(m6, p1, p22) {
        if (m6.length > 0) {
          return p1 + p22.toUpperCase();
        }
        return m6;
      };
      var ImageElementContainer = (
        /** @class */
        function(_super) {
          __extends(ImageElementContainer2, _super);
          function ImageElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            _this.context.cache.addImage(_this.src);
            return _this;
          }
          return ImageElementContainer2;
        }(ElementContainer)
      );
      var CanvasElementContainer = (
        /** @class */
        function(_super) {
          __extends(CanvasElementContainer2, _super);
          function CanvasElementContainer2(context, canvas) {
            var _this = _super.call(this, context, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
          }
          return CanvasElementContainer2;
        }(ElementContainer)
      );
      var SVGElementContainer = (
        /** @class */
        function(_super) {
          __extends(SVGElementContainer2, _super);
          function SVGElementContainer2(context, img) {
            var _this = _super.call(this, context, img) || this;
            var s5 = new XMLSerializer();
            var bounds = parseBounds(context, img);
            img.setAttribute("width", bounds.width + "px");
            img.setAttribute("height", bounds.height + "px");
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s5.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            _this.context.cache.addImage(_this.svg);
            return _this;
          }
          return SVGElementContainer2;
        }(ElementContainer)
      );
      var LIElementContainer = (
        /** @class */
        function(_super) {
          __extends(LIElementContainer2, _super);
          function LIElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return LIElementContainer2;
        }(ElementContainer)
      );
      var OLElementContainer = (
        /** @class */
        function(_super) {
          __extends(OLElementContainer2, _super);
          function OLElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.start = element.start;
            _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
            return _this;
          }
          return OLElementContainer2;
        }(ElementContainer)
      );
      var CHECKBOX_BORDER_RADIUS = [
        {
          type: 15,
          flags: 0,
          unit: "px",
          number: 3
        }
      ];
      var RADIO_BORDER_RADIUS = [
        {
          type: 16,
          flags: 0,
          number: 50
        }
      ];
      var reformatInputBounds = function(bounds) {
        if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
        } else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
        }
        return bounds;
      };
      var getInputValue = function(node2) {
        var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("\u2022") : node2.value;
        return value.length === 0 ? node2.placeholder || "" : value;
      };
      var CHECKBOX = "checkbox";
      var RADIO = "radio";
      var PASSWORD = "password";
      var INPUT_COLOR = 707406591;
      var InputElementContainer = (
        /** @class */
        function(_super) {
          __extends(InputElementContainer2, _super);
          function InputElementContainer2(context, input) {
            var _this = _super.call(this, context, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 3739148031;
              _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
              _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
              _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
              _this.styles.backgroundClip = [
                0
                /* BORDER_BOX */
              ];
              _this.styles.backgroundOrigin = [
                0
                /* BORDER_BOX */
              ];
              _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
              case CHECKBOX:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                break;
              case RADIO:
                _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                break;
            }
            return _this;
          }
          return InputElementContainer2;
        }(ElementContainer)
      );
      var SelectElementContainer = (
        /** @class */
        function(_super) {
          __extends(SelectElementContainer2, _super);
          function SelectElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            var option = element.options[element.selectedIndex || 0];
            _this.value = option ? option.text || "" : "";
            return _this;
          }
          return SelectElementContainer2;
        }(ElementContainer)
      );
      var TextareaElementContainer = (
        /** @class */
        function(_super) {
          __extends(TextareaElementContainer2, _super);
          function TextareaElementContainer2(context, element) {
            var _this = _super.call(this, context, element) || this;
            _this.value = element.value;
            return _this;
          }
          return TextareaElementContainer2;
        }(ElementContainer)
      );
      var IFrameElementContainer = (
        /** @class */
        function(_super) {
          __extends(IFrameElementContainer2, _super);
          function IFrameElementContainer2(context, iframe) {
            var _this = _super.call(this, context, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10) || 0;
            _this.height = parseInt(iframe.height, 10) || 0;
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
              if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
                _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
                var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
                _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
              }
            } catch (e4) {
            }
            return _this;
          }
          return IFrameElementContainer2;
        }(ElementContainer)
      );
      var LIST_OWNERS = ["OL", "UL", "MENU"];
      var parseNodeTree = function(context, node2, parent, root) {
        for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
            parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          } else if (isElementNode(childNode)) {
            if (isSlotElement2(childNode) && childNode.assignedNodes) {
              childNode.assignedNodes().forEach(function(childNode2) {
                return parseNodeTree(context, childNode2, parent, root);
              });
            } else {
              var container = createContainer(context, childNode);
              if (container.styles.isVisible()) {
                if (createsRealStackingContext(childNode, container, root)) {
                  container.flags |= 4;
                } else if (createsStackingContext(container.styles)) {
                  container.flags |= 2;
                }
                if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                  container.flags |= 8;
                }
                parent.elements.push(container);
                childNode.slot;
                if (childNode.shadowRoot) {
                  parseNodeTree(context, childNode.shadowRoot, container, root);
                } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                  parseNodeTree(context, childNode, container, root);
                }
              }
            }
          }
        }
      };
      var createContainer = function(context, element) {
        if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
        }
        if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
        }
        if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
        }
        if (isLIElement(element)) {
          return new LIElementContainer(context, element);
        }
        if (isOLElement(element)) {
          return new OLElementContainer(context, element);
        }
        if (isInputElement(element)) {
          return new InputElementContainer(context, element);
        }
        if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
        }
        if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
        }
        if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
        }
        return new ElementContainer(context, element);
      };
      var parseTree = function(context, element) {
        var container = createContainer(context, element);
        container.flags |= 4;
        parseNodeTree(context, element, container, container);
        return container;
      };
      var createsRealStackingContext = function(node2, container, root) {
        return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root.styles.isTransparent();
      };
      var createsStackingContext = function(styles) {
        return styles.isPositioned() || styles.isFloating();
      };
      var isTextNode = function(node2) {
        return node2.nodeType === Node.TEXT_NODE;
      };
      var isElementNode = function(node2) {
        return node2.nodeType === Node.ELEMENT_NODE;
      };
      var isHTMLElementNode = function(node2) {
        return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
      };
      var isSVGElementNode = function(element) {
        return typeof element.className === "object";
      };
      var isLIElement = function(node2) {
        return node2.tagName === "LI";
      };
      var isOLElement = function(node2) {
        return node2.tagName === "OL";
      };
      var isInputElement = function(node2) {
        return node2.tagName === "INPUT";
      };
      var isHTMLElement = function(node2) {
        return node2.tagName === "HTML";
      };
      var isSVGElement = function(node2) {
        return node2.tagName === "svg";
      };
      var isBodyElement = function(node2) {
        return node2.tagName === "BODY";
      };
      var isCanvasElement = function(node2) {
        return node2.tagName === "CANVAS";
      };
      var isVideoElement = function(node2) {
        return node2.tagName === "VIDEO";
      };
      var isImageElement = function(node2) {
        return node2.tagName === "IMG";
      };
      var isIFrameElement = function(node2) {
        return node2.tagName === "IFRAME";
      };
      var isStyleElement = function(node2) {
        return node2.tagName === "STYLE";
      };
      var isScriptElement = function(node2) {
        return node2.tagName === "SCRIPT";
      };
      var isTextareaElement = function(node2) {
        return node2.tagName === "TEXTAREA";
      };
      var isSelectElement = function(node2) {
        return node2.tagName === "SELECT";
      };
      var isSlotElement2 = function(node2) {
        return node2.tagName === "SLOT";
      };
      var isCustomElement = function(node2) {
        return node2.tagName.indexOf("-") > 0;
      };
      var CounterState = (
        /** @class */
        function() {
          function CounterState2() {
            this.counters = {};
          }
          CounterState2.prototype.getCounterValue = function(name) {
            var counter = this.counters[name];
            if (counter && counter.length) {
              return counter[counter.length - 1];
            }
            return 1;
          };
          CounterState2.prototype.getCounterValues = function(name) {
            var counter = this.counters[name];
            return counter ? counter : [];
          };
          CounterState2.prototype.pop = function(counters) {
            var _this = this;
            counters.forEach(function(counter) {
              return _this.counters[counter].pop();
            });
          };
          CounterState2.prototype.parse = function(style) {
            var _this = this;
            var counterIncrement2 = style.counterIncrement;
            var counterReset2 = style.counterReset;
            var canReset = true;
            if (counterIncrement2 !== null) {
              counterIncrement2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                if (counter && entry.increment !== 0) {
                  canReset = false;
                  if (!counter.length) {
                    counter.push(1);
                  }
                  counter[Math.max(0, counter.length - 1)] += entry.increment;
                }
              });
            }
            var counterNames = [];
            if (canReset) {
              counterReset2.forEach(function(entry) {
                var counter = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter) {
                  counter = _this.counters[entry.counter] = [];
                }
                counter.push(entry.reset);
              });
            }
            return counterNames;
          };
          return CounterState2;
        }()
      );
      var ROMAN_UPPER = {
        integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
        values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
      };
      var ARMENIAN = {
        integers: [
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u0554",
          "\u0553",
          "\u0552",
          "\u0551",
          "\u0550",
          "\u054F",
          "\u054E",
          "\u054D",
          "\u054C",
          "\u054B",
          "\u054A",
          "\u0549",
          "\u0548",
          "\u0547",
          "\u0546",
          "\u0545",
          "\u0544",
          "\u0543",
          "\u0542",
          "\u0541",
          "\u0540",
          "\u053F",
          "\u053E",
          "\u053D",
          "\u053C",
          "\u053B",
          "\u053A",
          "\u0539",
          "\u0538",
          "\u0537",
          "\u0536",
          "\u0535",
          "\u0534",
          "\u0533",
          "\u0532",
          "\u0531"
        ]
      };
      var HEBREW = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          19,
          18,
          17,
          16,
          15,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u05D9\u05F3",
          "\u05D8\u05F3",
          "\u05D7\u05F3",
          "\u05D6\u05F3",
          "\u05D5\u05F3",
          "\u05D4\u05F3",
          "\u05D3\u05F3",
          "\u05D2\u05F3",
          "\u05D1\u05F3",
          "\u05D0\u05F3",
          "\u05EA",
          "\u05E9",
          "\u05E8",
          "\u05E7",
          "\u05E6",
          "\u05E4",
          "\u05E2",
          "\u05E1",
          "\u05E0",
          "\u05DE",
          "\u05DC",
          "\u05DB",
          "\u05D9\u05D8",
          "\u05D9\u05D7",
          "\u05D9\u05D6",
          "\u05D8\u05D6",
          "\u05D8\u05D5",
          "\u05D9",
          "\u05D8",
          "\u05D7",
          "\u05D6",
          "\u05D5",
          "\u05D4",
          "\u05D3",
          "\u05D2",
          "\u05D1",
          "\u05D0"
        ]
      };
      var GEORGIAN = {
        integers: [
          1e4,
          9e3,
          8e3,
          7e3,
          6e3,
          5e3,
          4e3,
          3e3,
          2e3,
          1e3,
          900,
          800,
          700,
          600,
          500,
          400,
          300,
          200,
          100,
          90,
          80,
          70,
          60,
          50,
          40,
          30,
          20,
          10,
          9,
          8,
          7,
          6,
          5,
          4,
          3,
          2,
          1
        ],
        values: [
          "\u10F5",
          "\u10F0",
          "\u10EF",
          "\u10F4",
          "\u10EE",
          "\u10ED",
          "\u10EC",
          "\u10EB",
          "\u10EA",
          "\u10E9",
          "\u10E8",
          "\u10E7",
          "\u10E6",
          "\u10E5",
          "\u10E4",
          "\u10F3",
          "\u10E2",
          "\u10E1",
          "\u10E0",
          "\u10DF",
          "\u10DE",
          "\u10DD",
          "\u10F2",
          "\u10DC",
          "\u10DB",
          "\u10DA",
          "\u10D9",
          "\u10D8",
          "\u10D7",
          "\u10F1",
          "\u10D6",
          "\u10D5",
          "\u10D4",
          "\u10D3",
          "\u10D2",
          "\u10D1",
          "\u10D0"
        ]
      };
      var createAdditiveCounter = function(value, min2, max4, symbols2, fallback2, suffix) {
        if (value < min2 || value > max4) {
          return createCounterText(value, fallback2, suffix.length > 0);
        }
        return symbols2.integers.reduce(function(string, integer, index4) {
          while (value >= integer) {
            value -= integer;
            string += symbols2.values[index4];
          }
          return string;
        }, "") + suffix;
      };
      var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
        var string = "";
        do {
          if (!isNumeric) {
            value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
        } while (value * codePointRangeLength >= codePointRangeLength);
        return string;
      };
      var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
        return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
          return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
        }) + suffix);
      };
      var createCounterStyleFromSymbols = function(value, symbols2, suffix) {
        if (suffix === void 0) {
          suffix = ". ";
        }
        var codePointRangeLength = symbols2.length;
        return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
          return symbols2[Math.floor(codePoint % codePointRangeLength)];
        }) + suffix;
      };
      var CJK_ZEROS = 1 << 0;
      var CJK_TEN_COEFFICIENTS = 1 << 1;
      var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
      var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
      var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
        if (value < -9999 || value > 9999) {
          return createCounterText(value, 4, suffix.length > 0);
        }
        var tmp = Math.abs(value);
        var string = suffix;
        if (tmp === 0) {
          return numbers[0] + string;
        }
        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
            string = numbers[coefficient] + string;
          } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
            string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
          } else if (coefficient === 1 && digit > 0) {
            string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
        }
        return (value < 0 ? negativeSign : "") + string;
      };
      var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
      var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
      var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
      var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
      var createCounterText = function(value, type, appendSuffix) {
        var defaultSuffix = appendSuffix ? ". " : "";
        var cjkSuffix = appendSuffix ? "\u3001" : "";
        var koreanSuffix = appendSuffix ? ", " : "";
        var spaceSuffix = appendSuffix ? " " : "";
        switch (type) {
          case 0:
            return "\u2022" + spaceSuffix;
          case 1:
            return "\u25E6" + spaceSuffix;
          case 2:
            return "\u25FE" + spaceSuffix;
          case 5:
            var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            return string.length < 4 ? "0" + string : string;
          case 4:
            return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
          case 6:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
          case 7:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
          case 8:
            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9:
            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10:
            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11:
            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12:
          case 49:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
          case 35:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
          case 13:
            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14:
          case 30:
            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15:
            return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
          case 16:
            return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
          case 17:
          case 48:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41:
            return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26:
            return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25:
            return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31:
            return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33:
            return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32:
            return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18:
            return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
          case 20:
            return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
          case 21:
            return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
          case 22:
            return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
          case 22:
            return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
          case 23:
            return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
          case 24:
            return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
          case 27:
            return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
          case 28:
            return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
          case 29:
            return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
          case 34:
            return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
          case 37:
            return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
          case 38:
            return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
          case 39:
            return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
          case 40:
            return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
          case 43:
            return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
          case 44:
            return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
          case 45:
            return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
          case 46:
            return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
          case 3:
          default:
            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        }
      };
      var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
      var DocumentCloner = (
        /** @class */
        function() {
          function DocumentCloner2(context, element, options2) {
            this.context = context;
            this.options = options2;
            this.scrolledElements = [];
            this.referenceElement = element;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element.ownerDocument) {
              throw new Error("Cloned element does not have an owner document");
            }
            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
          }
          DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            var iframeLoad = iframeLoader(iframe).then(function() {
              return __awaiter(_this, void 0, void 0, function() {
                var onclone, referenceElement;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      this.scrolledElements.forEach(restoreNodeScroll);
                      if (cloneWindow) {
                        cloneWindow.scrollTo(windowSize.left, windowSize.top);
                        if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                          this.context.logger.warn("Unable to restore scroll position for cloned document");
                          this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                        }
                      }
                      onclone = this.options.onclone;
                      referenceElement = this.clonedReferenceElement;
                      if (typeof referenceElement === "undefined") {
                        return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                      }
                      if (!(documentClone.fonts && documentClone.fonts.ready))
                        return [3, 2];
                      return [4, documentClone.fonts.ready];
                    case 1:
                      _a2.sent();
                      _a2.label = 2;
                    case 2:
                      if (!/(AppleWebKit)/g.test(navigator.userAgent))
                        return [3, 4];
                      return [4, imagesReady(documentClone)];
                    case 3:
                      _a2.sent();
                      _a2.label = 4;
                    case 4:
                      if (typeof onclone === "function") {
                        return [2, Promise.resolve().then(function() {
                          return onclone(documentClone, referenceElement);
                        }).then(function() {
                          return iframe;
                        })];
                      }
                      return [2, iframe];
                  }
                });
              });
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
          };
          DocumentCloner2.prototype.createElementClone = function(node2) {
            if (isDebugging(
              node2,
              2
              /* CLONE */
            )) {
              debugger;
            }
            if (isCanvasElement(node2)) {
              return this.createCanvasClone(node2);
            }
            if (isVideoElement(node2)) {
              return this.createVideoClone(node2);
            }
            if (isStyleElement(node2)) {
              return this.createStyleClone(node2);
            }
            var clone = node2.cloneNode(false);
            if (isImageElement(clone)) {
              if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
                clone.src = node2.currentSrc;
                clone.srcset = "";
              }
              if (clone.loading === "lazy") {
                clone.loading = "eager";
              }
            }
            if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
            }
            return clone;
          };
          DocumentCloner2.prototype.createCustomElementClone = function(node2) {
            var clone = document.createElement("html2canvascustomelement");
            copyCSSStyles(node2.style, clone);
            return clone;
          };
          DocumentCloner2.prototype.createStyleClone = function(node2) {
            try {
              var sheet = node2.sheet;
              if (sheet && sheet.cssRules) {
                var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                  if (rule && typeof rule.cssText === "string") {
                    return css2 + rule.cssText;
                  }
                  return css2;
                }, "");
                var style = node2.cloneNode(false);
                style.textContent = css;
                return style;
              }
            } catch (e4) {
              this.context.logger.error("Unable to access cssRules property", e4);
              if (e4.name !== "SecurityError") {
                throw e4;
              }
            }
            return node2.cloneNode(false);
          };
          DocumentCloner2.prototype.createCanvasClone = function(canvas) {
            var _a2;
            if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement("img");
              try {
                img.src = canvas.toDataURL();
                return img;
              } catch (e4) {
                this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext("2d");
              var clonedCtx = clonedCanvas.getContext("2d");
              if (clonedCtx) {
                if (!this.options.allowTaint && ctx) {
                  clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                } else {
                  var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                  if (gl) {
                    var attribs = gl.getContextAttributes();
                    if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                      this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                    }
                  }
                  clonedCtx.drawImage(canvas, 0, 0);
                }
              }
              return clonedCanvas;
            } catch (e4) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
            }
            return clonedCanvas;
          };
          DocumentCloner2.prototype.createVideoClone = function(video) {
            var canvas = video.ownerDocument.createElement("canvas");
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            var ctx = canvas.getContext("2d");
            try {
              if (ctx) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                if (!this.options.allowTaint) {
                  ctx.getImageData(0, 0, canvas.width, canvas.height);
                }
              }
              return canvas;
            } catch (e4) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
            }
            var blankCanvas = video.ownerDocument.createElement("canvas");
            blankCanvas.width = video.offsetWidth;
            blankCanvas.height = video.offsetHeight;
            return blankCanvas;
          };
          DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
            if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                clone.appendChild(this.cloneNode(child, copyStyles));
              }
            }
          };
          DocumentCloner2.prototype.cloneChildNodes = function(node2, clone, copyStyles) {
            var _this = this;
            for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement2(child) && typeof child.assignedNodes === "function") {
                var assignedNodes = child.assignedNodes();
                if (assignedNodes.length) {
                  assignedNodes.forEach(function(assignedNode) {
                    return _this.appendChildNode(clone, assignedNode, copyStyles);
                  });
                }
              } else {
                this.appendChildNode(clone, child, copyStyles);
              }
            }
          };
          DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
            if (isTextNode(node2)) {
              return document.createTextNode(node2.data);
            }
            if (!node2.ownerDocument) {
              return node2.cloneNode(false);
            }
            var window2 = node2.ownerDocument.defaultView;
            if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
              var clone = this.createElementClone(node2);
              clone.style.transitionProperty = "none";
              var style = window2.getComputedStyle(node2);
              var styleBefore = window2.getComputedStyle(node2, ":before");
              var styleAfter = window2.getComputedStyle(node2, ":after");
              if (this.referenceElement === node2 && isHTMLElementNode(clone)) {
                this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before2 = this.resolvePseudoContent(node2, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node2)) {
                copyStyles = true;
              }
              if (!isVideoElement(node2)) {
                this.cloneChildNodes(node2, clone, copyStyles);
              }
              if (before2) {
                clone.insertBefore(before2, clone.firstChild);
              }
              var after2 = this.resolvePseudoContent(node2, clone, styleAfter, PseudoElementType.AFTER);
              if (after2) {
                clone.appendChild(after2);
              }
              this.counters.pop(counters);
              if (style && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
                copyCSSStyles(style, clone);
              }
              if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
                this.scrolledElements.push([clone, node2.scrollLeft, node2.scrollTop]);
              }
              if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone) || isSelectElement(clone))) {
                clone.value = node2.value;
              }
              return clone;
            }
            return node2.cloneNode(false);
          };
          DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone, style, pseudoElt) {
            var _this = this;
            if (!style) {
              return;
            }
            var value = style.content;
            var document2 = clone.ownerDocument;
            if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
              return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
            var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function(token) {
              if (token.type === 0) {
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              } else if (token.type === 22) {
                var img = document2.createElement("img");
                img.src = token.value;
                img.style.opacity = "1";
                anonymousReplacedElement.appendChild(img);
              } else if (token.type === 18) {
                if (token.name === "attr") {
                  var attr = token.values.filter(isIdentToken);
                  if (attr.length) {
                    anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
                  }
                } else if (token.name === "counter") {
                  var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
                  if (counter && isIdentToken(counter)) {
                    var counterState = _this.counters.getCounterValue(counter.value);
                    var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                  }
                } else if (token.name === "counters") {
                  var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
                  if (counter && isIdentToken(counter)) {
                    var counterStates = _this.counters.getCounterValues(counter.value);
                    var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                    var separator = delim && delim.type === 0 ? delim.value : "";
                    var text = counterStates.map(function(value2) {
                      return createCounterText(value2, counterType_1, false);
                    }).join(separator);
                    anonymousReplacedElement.appendChild(document2.createTextNode(text));
                  }
                } else
                  ;
              } else if (token.type === 20) {
                switch (token.value) {
                  case "open-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                    break;
                  case "close-quote":
                    anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                    break;
                  default:
                    anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
                }
              }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
            } else {
              clone.className += newClassName;
            }
            return anonymousReplacedElement;
          };
          DocumentCloner2.destroy = function(container) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
            }
            return false;
          };
          return DocumentCloner2;
        }()
      );
      var PseudoElementType;
      (function(PseudoElementType2) {
        PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
        PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
      })(PseudoElementType || (PseudoElementType = {}));
      var createIFrameContainer = function(ownerDocument, bounds) {
        var cloneIframeContainer = ownerDocument.createElement("iframe");
        cloneIframeContainer.className = "html2canvas-container";
        cloneIframeContainer.style.visibility = "hidden";
        cloneIframeContainer.style.position = "fixed";
        cloneIframeContainer.style.left = "-10000px";
        cloneIframeContainer.style.top = "0px";
        cloneIframeContainer.style.border = "0";
        cloneIframeContainer.width = bounds.width.toString();
        cloneIframeContainer.height = bounds.height.toString();
        cloneIframeContainer.scrolling = "no";
        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
        ownerDocument.body.appendChild(cloneIframeContainer);
        return cloneIframeContainer;
      };
      var imageReady = function(img) {
        return new Promise(function(resolve) {
          if (img.complete) {
            resolve();
            return;
          }
          if (!img.src) {
            resolve();
            return;
          }
          img.onload = resolve;
          img.onerror = resolve;
        });
      };
      var imagesReady = function(document2) {
        return Promise.all([].slice.call(document2.images, 0).map(imageReady));
      };
      var iframeLoader = function(iframe) {
        return new Promise(function(resolve, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
            return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function() {
            cloneWindow.onload = iframe.onload = null;
            var interval = setInterval(function() {
              if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
                clearInterval(interval);
                resolve(iframe);
              }
            }, 50);
          };
        });
      };
      var ignoredStyleProperties = [
        "all",
        "d",
        "content"
        // Safari shows pseudoelements if content is set
      ];
      var copyCSSStyles = function(style, target) {
        for (var i6 = style.length - 1; i6 >= 0; i6--) {
          var property = style.item(i6);
          if (ignoredStyleProperties.indexOf(property) === -1) {
            target.style.setProperty(property, style.getPropertyValue(property));
          }
        }
        return target;
      };
      var serializeDoctype = function(doctype) {
        var str = "";
        if (doctype) {
          str += "<!DOCTYPE ";
          if (doctype.name) {
            str += doctype.name;
          }
          if (doctype.internalSubset) {
            str += doctype.internalSubset;
          }
          if (doctype.publicId) {
            str += '"' + doctype.publicId + '"';
          }
          if (doctype.systemId) {
            str += '"' + doctype.systemId + '"';
          }
          str += ">";
        }
        return str;
      };
      var restoreOwnerScroll = function(ownerDocument, x2, y3) {
        if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y3 !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x2, y3);
        }
      };
      var restoreNodeScroll = function(_a2) {
        var element = _a2[0], x2 = _a2[1], y3 = _a2[2];
        element.scrollLeft = x2;
        element.scrollTop = y3;
      };
      var PSEUDO_BEFORE = ":before";
      var PSEUDO_AFTER = ":after";
      var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
      var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
      var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
      var createPseudoHideStyles = function(body) {
        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
      };
      var createStyles = function(body, styles) {
        var document2 = body.ownerDocument;
        if (document2) {
          var style = document2.createElement("style");
          style.textContent = styles;
          body.appendChild(style);
        }
      };
      var CacheStorage = (
        /** @class */
        function() {
          function CacheStorage2() {
          }
          CacheStorage2.getOrigin = function(url) {
            var link2 = CacheStorage2._link;
            if (!link2) {
              return "about:blank";
            }
            link2.href = url;
            link2.href = link2.href;
            return link2.protocol + link2.hostname + link2.port;
          };
          CacheStorage2.isSameOrigin = function(src) {
            return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
          };
          CacheStorage2.setContext = function(window2) {
            CacheStorage2._link = window2.document.createElement("a");
            CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
          };
          CacheStorage2._origin = "about:blank";
          return CacheStorage2;
        }()
      );
      var Cache = (
        /** @class */
        function() {
          function Cache2(context, _options) {
            this.context = context;
            this._options = _options;
            this._cache = {};
          }
          Cache2.prototype.addImage = function(src) {
            var result = Promise.resolve();
            if (this.has(src)) {
              return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function() {
              });
              return result;
            }
            return result;
          };
          Cache2.prototype.match = function(src) {
            return this._cache[src];
          };
          Cache2.prototype.loadImage = function(key) {
            return __awaiter(this, void 0, void 0, function() {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isSameOrigin = CacheStorage.isSameOrigin(key);
                    useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                    useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                    if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    src = key;
                    if (!useProxy)
                      return [3, 2];
                    return [4, this.proxy(src)];
                  case 1:
                    src = _a2.sent();
                    _a2.label = 2;
                  case 2:
                    this.context.logger.debug("Added image " + key.substring(0, 256));
                    return [4, new Promise(function(resolve, reject) {
                      var img = new Image();
                      img.onload = function() {
                        return resolve(img);
                      };
                      img.onerror = reject;
                      if (isInlineBase64Image(src) || useCORS) {
                        img.crossOrigin = "anonymous";
                      }
                      img.src = src;
                      if (img.complete === true) {
                        setTimeout(function() {
                          return resolve(img);
                        }, 500);
                      }
                      if (_this._options.imageTimeout > 0) {
                        setTimeout(function() {
                          return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                        }, _this._options.imageTimeout);
                      }
                    })];
                  case 3:
                    return [2, _a2.sent()];
                }
              });
            });
          };
          Cache2.prototype.has = function(key) {
            return typeof this._cache[key] !== "undefined";
          };
          Cache2.prototype.keys = function() {
            return Promise.resolve(Object.keys(this._cache));
          };
          Cache2.prototype.proxy = function(src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
              throw new Error("No proxy defined");
            }
            var key = src.substring(0, 256);
            return new Promise(function(resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
              var xhr = new XMLHttpRequest();
              xhr.onload = function() {
                if (xhr.status === 200) {
                  if (responseType === "text") {
                    resolve(xhr.response);
                  } else {
                    var reader_1 = new FileReader();
                    reader_1.addEventListener("load", function() {
                      return resolve(reader_1.result);
                    }, false);
                    reader_1.addEventListener("error", function(e4) {
                      return reject(e4);
                    }, false);
                    reader_1.readAsDataURL(xhr.response);
                  }
                } else {
                  reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                }
              };
              xhr.onerror = reject;
              var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
              xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
                xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                var timeout_1 = _this._options.imageTimeout;
                xhr.timeout = timeout_1;
                xhr.ontimeout = function() {
                  return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
                };
              }
              xhr.send();
            });
          };
          return Cache2;
        }()
      );
      var INLINE_SVG = /^data:image\/svg\+xml/i;
      var INLINE_BASE64 = /^data:image\/.*;base64,/i;
      var INLINE_IMG = /^data:image\/.*/i;
      var isRenderable = function(src) {
        return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
      };
      var isInlineImage = function(src) {
        return INLINE_IMG.test(src);
      };
      var isInlineBase64Image = function(src) {
        return INLINE_BASE64.test(src);
      };
      var isBlobImage = function(src) {
        return src.substr(0, 4) === "blob";
      };
      var isSVG = function(src) {
        return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
      };
      var Vector = (
        /** @class */
        function() {
          function Vector2(x2, y3) {
            this.type = 0;
            this.x = x2;
            this.y = y3;
          }
          Vector2.prototype.add = function(deltaX, deltaY) {
            return new Vector2(this.x + deltaX, this.y + deltaY);
          };
          return Vector2;
        }()
      );
      var lerp = function(a5, b2, t5) {
        return new Vector(a5.x + (b2.x - a5.x) * t5, a5.y + (b2.y - a5.y) * t5);
      };
      var BezierCurve = (
        /** @class */
        function() {
          function BezierCurve2(start2, startControl, endControl, end2) {
            this.type = 1;
            this.start = start2;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end2;
          }
          BezierCurve2.prototype.subdivide = function(t5, firstHalf) {
            var ab = lerp(this.start, this.startControl, t5);
            var bc = lerp(this.startControl, this.endControl, t5);
            var cd = lerp(this.endControl, this.end, t5);
            var abbc = lerp(ab, bc, t5);
            var bccd = lerp(bc, cd, t5);
            var dest = lerp(abbc, bccd, t5);
            return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
          };
          BezierCurve2.prototype.add = function(deltaX, deltaY) {
            return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
          };
          BezierCurve2.prototype.reverse = function() {
            return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
          };
          return BezierCurve2;
        }()
      );
      var isBezierCurve = function(path) {
        return path.type === 1;
      };
      var BoundCurves = (
        /** @class */
        function() {
          function BoundCurves2(element) {
            var styles = element.styles;
            var bounds = element.bounds;
            var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
            var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth2 = styles.borderTopWidth;
            var borderRightWidth2 = styles.borderRightWidth;
            var borderBottomWidth2 = styles.borderBottomWidth;
            var borderLeftWidth2 = styles.borderLeftWidth;
            var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
            var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
            var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
            var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
            this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
            this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
            this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
            this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
            this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
            this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
            this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
            this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
            this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
            this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
            this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
            this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
            this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          }
          return BoundCurves2;
        }()
      );
      var CORNER;
      (function(CORNER2) {
        CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
        CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
        CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
        CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
      })(CORNER || (CORNER = {}));
      var getCurvePoints = function(x2, y3, r1, r22, position2) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = r1 * kappa;
        var oy = r22 * kappa;
        var xm = x2 + r1;
        var ym = y3 + r22;
        switch (position2) {
          case CORNER.TOP_LEFT:
            return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y3), new Vector(xm, y3));
          case CORNER.TOP_RIGHT:
            return new BezierCurve(new Vector(x2, y3), new Vector(x2 + ox, y3), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
            return new BezierCurve(new Vector(xm, y3), new Vector(xm, y3 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
          case CORNER.BOTTOM_LEFT:
          default:
            return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y3 + oy), new Vector(x2, y3));
        }
      };
      var calculateBorderBoxPath = function(curves) {
        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
      };
      var calculateContentBoxPath = function(curves) {
        return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
        ];
      };
      var calculatePaddingBoxPath = function(curves) {
        return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
        ];
      };
      var TransformEffect = (
        /** @class */
        function() {
          function TransformEffect2(offsetX, offsetY, matrix2) {
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix2;
            this.type = 0;
            this.target = 2 | 4;
          }
          return TransformEffect2;
        }()
      );
      var ClipEffect = (
        /** @class */
        function() {
          function ClipEffect2(path, target) {
            this.path = path;
            this.target = target;
            this.type = 1;
          }
          return ClipEffect2;
        }()
      );
      var OpacityEffect = (
        /** @class */
        function() {
          function OpacityEffect2(opacity2) {
            this.opacity = opacity2;
            this.type = 2;
            this.target = 2 | 4;
          }
          return OpacityEffect2;
        }()
      );
      var isTransformEffect = function(effect) {
        return effect.type === 0;
      };
      var isClipEffect = function(effect) {
        return effect.type === 1;
      };
      var isOpacityEffect = function(effect) {
        return effect.type === 2;
      };
      var equalPath = function(a5, b2) {
        if (a5.length === b2.length) {
          return a5.some(function(v4, i6) {
            return v4 === b2[i6];
          });
        }
        return false;
      };
      var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
        return path.map(function(point, index4) {
          switch (index4) {
            case 0:
              return point.add(deltaX, deltaY);
            case 1:
              return point.add(deltaX + deltaW, deltaY);
            case 2:
              return point.add(deltaX + deltaW, deltaY + deltaH);
            case 3:
              return point.add(deltaX, deltaY + deltaH);
          }
          return point;
        });
      };
      var StackingContext = (
        /** @class */
        function() {
          function StackingContext2(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
          }
          return StackingContext2;
        }()
      );
      var ElementPaint = (
        /** @class */
        function() {
          function ElementPaint2(container, parent) {
            this.container = container;
            this.parent = parent;
            this.effects = [];
            this.curves = new BoundCurves(this.container);
            if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
            }
            if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix2 = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
            }
            if (this.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox2 = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox2)) {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2 | 4
                  /* CONTENT */
                ));
              } else {
                this.effects.push(new ClipEffect(
                  borderBox,
                  2
                  /* BACKGROUND_BORDERS */
                ));
                this.effects.push(new ClipEffect(
                  paddingBox2,
                  4
                  /* CONTENT */
                ));
              }
            }
          }
          ElementPaint2.prototype.getEffects = function(target) {
            var inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(this.container.styles.position) === -1;
            var parent = this.parent;
            var effects = this.effects.slice(0);
            while (parent) {
              var croplessEffects = parent.effects.filter(function(effect) {
                return !isClipEffect(effect);
              });
              if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
                effects.unshift.apply(effects, croplessEffects);
                inFlow = [
                  2,
                  3
                  /* FIXED */
                ].indexOf(parent.container.styles.position) === -1;
                if (parent.container.styles.overflowX !== 0) {
                  var borderBox = calculateBorderBoxPath(parent.curves);
                  var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                  if (!equalPath(borderBox, paddingBox2)) {
                    effects.unshift(new ClipEffect(
                      paddingBox2,
                      2 | 4
                      /* CONTENT */
                    ));
                  }
                }
              } else {
                effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
            }
            return effects.filter(function(effect) {
              return contains(effect.target, target);
            });
          };
          return ElementPaint2;
        }()
      );
      var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
        parent.container.elements.forEach(function(child) {
          var treatAsRealStackingContext = contains(
            child.flags,
            4
            /* CREATES_REAL_STACKING_CONTEXT */
          );
          var createsStackingContext2 = contains(
            child.flags,
            2
            /* CREATES_STACKING_CONTEXT */
          );
          var paintContainer = new ElementPaint(child, parent);
          if (contains(
            child.styles.display,
            2048
            /* LIST_ITEM */
          )) {
            listItems.push(paintContainer);
          }
          var listOwnerItems = contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          ) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext2) {
            var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
            var stack = new StackingContext(paintContainer);
            if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
              var order_1 = child.styles.zIndex.order;
              if (order_1 < 0) {
                var index_1 = 0;
                parentStack.negativeZIndex.some(function(current, i6) {
                  if (order_1 > current.element.container.styles.zIndex.order) {
                    index_1 = i6;
                    return false;
                  } else if (index_1 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.negativeZIndex.splice(index_1, 0, stack);
              } else if (order_1 > 0) {
                var index_2 = 0;
                parentStack.positiveZIndex.some(function(current, i6) {
                  if (order_1 >= current.element.container.styles.zIndex.order) {
                    index_2 = i6 + 1;
                    return false;
                  } else if (index_2 > 0) {
                    return true;
                  }
                  return false;
                });
                parentStack.positiveZIndex.splice(index_2, 0, stack);
              } else {
                parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
              }
            } else {
              if (child.styles.isFloating()) {
                parentStack.nonPositionedFloats.push(stack);
              } else {
                parentStack.nonPositionedInlineLevel.push(stack);
              }
            }
            parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          } else {
            if (child.styles.isInlineLevel()) {
              stackingContext.inlineLevel.push(paintContainer);
            } else {
              stackingContext.nonInlineLevel.push(paintContainer);
            }
            parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(
            child.flags,
            8
            /* IS_LIST_OWNER */
          )) {
            processListItems(child, listOwnerItems);
          }
        });
      };
      var processListItems = function(owner, elements2) {
        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
        for (var i6 = 0; i6 < elements2.length; i6++) {
          var item = elements2[i6];
          if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
            numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
        }
      };
      var parseStackingContexts = function(container) {
        var paintContainer = new ElementPaint(container, null);
        var root = new StackingContext(paintContainer);
        var listItems = [];
        parseStackTree(paintContainer, root, root, listItems);
        processListItems(paintContainer.container, listItems);
        return root;
      };
      var parsePathForBorder = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderDoubleOuter = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
        }
      };
      var parsePathForBorderDoubleInner = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
            return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
            return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
            return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
        }
      };
      var parsePathForBorderStroke = function(curves, borderSide) {
        switch (borderSide) {
          case 0:
            return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
            return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
            return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
            return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
        }
      };
      var createStrokePathFromCurves = function(outer1, outer2) {
        var path = [];
        if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
        } else {
          path.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
        } else {
          path.push(outer2);
        }
        return path;
      };
      var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
        var path = [];
        if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
        } else {
          path.push(outer1);
        }
        if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
        } else {
          path.push(outer2);
        }
        if (isBezierCurve(inner2)) {
          path.push(inner2.subdivide(0.5, true).reverse());
        } else {
          path.push(inner2);
        }
        if (isBezierCurve(inner1)) {
          path.push(inner1.subdivide(0.5, false).reverse());
        } else {
          path.push(inner1);
        }
        return path;
      };
      var paddingBox = function(element) {
        var bounds = element.bounds;
        var styles = element.styles;
        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
      };
      var contentBox = function(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
        return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
      };
      var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
        if (backgroundOrigin2 === 0) {
          return element.bounds;
        }
        if (backgroundOrigin2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
        if (backgroundClip2 === 0) {
          return element.bounds;
        }
        if (backgroundClip2 === 2) {
          return contentBox(element);
        }
        return paddingBox(element);
      };
      var calculateBackgroundRendering = function(container, index4, intrinsicSize) {
        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index4), container);
        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index4), container);
        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index4), intrinsicSize, backgroundPositioningArea);
        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
        var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index4), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index4), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
        var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
        var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
      };
      var isAuto = function(token) {
        return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
      };
      var hasIntrinsicValue = function(value) {
        return typeof value === "number";
      };
      var calculateBackgroundSize = function(size, _a2, bounds) {
        var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
        var first = size[0], second = size[1];
        if (!first) {
          return [0, 0];
        }
        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
        }
        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
            var targetRatio = bounds.width / bounds.height;
            return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
        }
        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
        if (isAuto(first) && (!second || isAuto(second))) {
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
            return [intrinsicWidth, intrinsicHeight];
          }
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
            return [bounds.width, bounds.height];
          }
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
            var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
            var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
            return [width_1, height_1];
          }
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
        }
        if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
            width_3 = getAbsoluteValue(first, bounds.width);
          } else if (isLengthPercentage(second)) {
            height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
            width_3 = height_3 * intrinsicProportion;
          } else if (!second || isAuto(second)) {
            height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
        }
        var width = null;
        var height = null;
        if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
        } else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
        }
        if (width !== null && (!second || isAuto(second))) {
          height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
        }
        if (height !== null && isAuto(first)) {
          width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
        }
        if (width !== null && height !== null) {
          return [width, height];
        }
        throw new Error("Unable to calculate background-size for element");
      };
      var getBackgroundValueForIndex = function(values, index4) {
        var value = values[index4];
        if (typeof value === "undefined") {
          return values[0];
        }
        return value;
      };
      var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
        var x2 = _a2[0], y3 = _a2[1];
        var width = _b2[0], height = _b2[1];
        switch (repeat) {
          case 2:
            return [
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y3))
            ];
          case 3:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
            ];
          case 1:
            return [
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y3)),
              new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y3 + height)),
              new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y3 + height))
            ];
          default:
            return [
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
              new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
            ];
        }
      };
      var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
      var SAMPLE_TEXT = "Hidden Text";
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(document2) {
            this._data = {};
            this._document = document2;
          }
          FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
            var container = this._document.createElement("div");
            var img = this._document.createElement("img");
            var span = this._document.createElement("span");
            var body = this._document.body;
            container.style.visibility = "hidden";
            container.style.fontFamily = fontFamily2;
            container.style.fontSize = fontSize2;
            container.style.margin = "0";
            container.style.padding = "0";
            container.style.whiteSpace = "nowrap";
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = "0";
            img.style.padding = "0";
            img.style.verticalAlign = "baseline";
            span.style.fontFamily = fontFamily2;
            span.style.fontSize = fontSize2;
            span.style.margin = "0";
            span.style.padding = "0";
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = "normal";
            img.style.verticalAlign = "super";
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return { baseline, middle };
          };
          FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
            var key = fontFamily2 + " " + fontSize2;
            if (typeof this._data[key] === "undefined") {
              this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
            }
            return this._data[key];
          };
          return FontMetrics2;
        }()
      );
      var Renderer = (
        /** @class */
        function() {
          function Renderer2(context, options2) {
            this.context = context;
            this.options = options2;
          }
          return Renderer2;
        }()
      );
      var MASK_OFFSET = 1e4;
      var CanvasRenderer = (
        /** @class */
        function(_super) {
          __extends(CanvasRenderer2, _super);
          function CanvasRenderer2(context, options2) {
            var _this = _super.call(this, context, options2) || this;
            _this._activeEffects = [];
            _this.canvas = options2.canvas ? options2.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            if (!options2.canvas) {
              _this.canvas.width = Math.floor(options2.width * options2.scale);
              _this.canvas.height = Math.floor(options2.height * options2.scale);
              _this.canvas.style.width = options2.width + "px";
              _this.canvas.style.height = options2.height + "px";
            }
            _this.fontMetrics = new FontMetrics(document);
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options2.x, -options2.y);
            _this.ctx.textBaseline = "bottom";
            _this._activeEffects = [];
            _this.context.logger.debug("Canvas renderer initialized (" + options2.width + "x" + options2.height + ") with scale " + options2.scale);
            return _this;
          }
          CanvasRenderer2.prototype.applyEffects = function(effects) {
            var _this = this;
            while (this._activeEffects.length) {
              this.popEffect();
            }
            effects.forEach(function(effect) {
              return _this.applyEffect(effect);
            });
          };
          CanvasRenderer2.prototype.applyEffect = function(effect) {
            this.ctx.save();
            if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
            }
            if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
            }
            this._activeEffects.push(effect);
          };
          CanvasRenderer2.prototype.popEffect = function() {
            this._activeEffects.pop();
            this.ctx.restore();
          };
          CanvasRenderer2.prototype.renderStack = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var styles;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    styles = stack.element.container.styles;
                    if (!styles.isVisible())
                      return [3, 2];
                    return [4, this.renderStackContent(stack)];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNode = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (contains(
                      paint.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    if (!paint.container.styles.isVisible())
                      return [3, 3];
                    return [4, this.renderNodeBackgroundAndBorders(paint)];
                  case 1:
                    _a2.sent();
                    return [4, this.renderNodeContent(paint)];
                  case 2:
                    _a2.sent();
                    _a2.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
            var _this = this;
            if (letterSpacing2 === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
            } else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function(left, letter) {
                _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
            }
          };
          CanvasRenderer2.prototype.createFontStyle = function(styles) {
            var fontVariant2 = styles.fontVariant.filter(function(variant) {
              return variant === "normal" || variant === "small-caps";
            }).join("");
            var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
            var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
            return [
              [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
              fontFamily2,
              fontSize2
            ];
          };
          CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
              var _this = this;
              return __generator(this, function(_c) {
                _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
                this.ctx.font = font;
                this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
                this.ctx.textAlign = "left";
                this.ctx.textBaseline = "alphabetic";
                _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
                paintOrder2 = styles.paintOrder;
                text.textBounds.forEach(function(text2) {
                  paintOrder2.forEach(function(paintOrderLayer) {
                    switch (paintOrderLayer) {
                      case 0:
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text2.text.trim().length) {
                          textShadows.slice(0).reverse().forEach(function(textShadow2) {
                            _this.ctx.shadowColor = asString(textShadow2.color);
                            _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                            _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                            _this.ctx.shadowBlur = textShadow2.blur.number;
                            _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                          });
                          _this.ctx.shadowColor = "";
                          _this.ctx.shadowOffsetX = 0;
                          _this.ctx.shadowOffsetY = 0;
                          _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                          _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                          styles.textDecorationLine.forEach(function(textDecorationLine2) {
                            switch (textDecorationLine2) {
                              case 1:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                                break;
                              case 2:
                                _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                                break;
                              case 3:
                                _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                                break;
                            }
                          });
                        }
                        break;
                      case 1:
                        if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                          _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                          _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                          _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                          _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                        }
                        _this.ctx.strokeStyle = "";
                        _this.ctx.lineWidth = 0;
                        _this.ctx.lineJoin = "miter";
                        break;
                    }
                  });
                });
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
            if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
            }
          };
          CanvasRenderer2.prototype.renderNodeContent = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      4
                      /* CONTENT */
                    ));
                    container = paint.container;
                    curves = paint.curves;
                    styles = container.styles;
                    _i = 0, _a2 = container.textNodes;
                    _c.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    child = _a2[_i];
                    return [4, this.renderTextNode(child, styles)];
                  case 2:
                    _c.sent();
                    _c.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (!(container instanceof ImageElementContainer))
                      return [3, 8];
                    _c.label = 5;
                  case 5:
                    _c.trys.push([5, 7, , 8]);
                    return [4, this.context.cache.match(container.src)];
                  case 6:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 8];
                  case 7:
                    _c.sent();
                    this.context.logger.error("Error loading image " + container.src);
                    return [3, 8];
                  case 8:
                    if (container instanceof CanvasElementContainer) {
                      this.renderReplacedElement(container, curves, container.canvas);
                    }
                    if (!(container instanceof SVGElementContainer))
                      return [3, 12];
                    _c.label = 9;
                  case 9:
                    _c.trys.push([9, 11, , 12]);
                    return [4, this.context.cache.match(container.svg)];
                  case 10:
                    image2 = _c.sent();
                    this.renderReplacedElement(container, curves, image2);
                    return [3, 12];
                  case 11:
                    _c.sent();
                    this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                    return [3, 12];
                  case 12:
                    if (!(container instanceof IFrameElementContainer && container.tree))
                      return [3, 14];
                    iframeRenderer = new CanvasRenderer2(this.context, {
                      scale: this.options.scale,
                      backgroundColor: container.backgroundColor,
                      x: 0,
                      y: 0,
                      width: container.width,
                      height: container.height
                    });
                    return [4, iframeRenderer.render(container.tree)];
                  case 13:
                    canvas = _c.sent();
                    if (container.width && container.height) {
                      this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                    }
                    _c.label = 14;
                  case 14:
                    if (container instanceof InputElementContainer) {
                      size = Math.min(container.bounds.width, container.bounds.height);
                      if (container.type === CHECKBOX) {
                        if (container.checked) {
                          this.ctx.save();
                          this.path([
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                          ]);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      } else if (container.type === RADIO) {
                        if (container.checked) {
                          this.ctx.save();
                          this.ctx.beginPath();
                          this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                          this.ctx.fillStyle = asString(INPUT_COLOR);
                          this.ctx.fill();
                          this.ctx.restore();
                        }
                      }
                    }
                    if (isTextInputElement(container) && container.value.length) {
                      _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                      baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                      bounds = contentBox(container);
                      x2 = 0;
                      switch (container.styles.textAlign) {
                        case 1:
                          x2 += bounds.width / 2;
                          break;
                        case 2:
                          x2 += bounds.width;
                          break;
                      }
                      textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                      this.ctx.save();
                      this.path([
                        new Vector(bounds.left, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top),
                        new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                        new Vector(bounds.left, bounds.top + bounds.height)
                      ]);
                      this.ctx.clip();
                      this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                      this.ctx.restore();
                      this.ctx.textBaseline = "alphabetic";
                      this.ctx.textAlign = "left";
                    }
                    if (!contains(
                      container.styles.display,
                      2048
                      /* LIST_ITEM */
                    ))
                      return [3, 20];
                    if (!(container.styles.listStyleImage !== null))
                      return [3, 19];
                    img = container.styles.listStyleImage;
                    if (!(img.type === 0))
                      return [3, 18];
                    image2 = void 0;
                    url = img.url;
                    _c.label = 15;
                  case 15:
                    _c.trys.push([15, 17, , 18]);
                    return [4, this.context.cache.match(url)];
                  case 16:
                    image2 = _c.sent();
                    this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                    return [3, 18];
                  case 17:
                    _c.sent();
                    this.context.logger.error("Error loading list-style-image " + url);
                    return [3, 18];
                  case 18:
                    return [3, 20];
                  case 19:
                    if (paint.listValue && container.styles.listStyleType !== -1) {
                      fontFamily2 = this.createFontStyle(styles)[0];
                      this.ctx.font = fontFamily2;
                      this.ctx.fillStyle = asString(styles.color);
                      this.ctx.textBaseline = "middle";
                      this.ctx.textAlign = "right";
                      bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                      this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                      this.ctx.textBaseline = "bottom";
                      this.ctx.textAlign = "left";
                    }
                    _c.label = 20;
                  case 20:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderStackContent = function(stack) {
            return __awaiter(this, void 0, void 0, function() {
              var _i, _a2, child, _b2, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function(_p) {
                switch (_p.label) {
                  case 0:
                    if (contains(
                      stack.element.container.flags,
                      16
                      /* DEBUG_RENDER */
                    )) {
                      debugger;
                    }
                    return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                  case 1:
                    _p.sent();
                    _i = 0, _a2 = stack.negativeZIndex;
                    _p.label = 2;
                  case 2:
                    if (!(_i < _a2.length))
                      return [3, 5];
                    child = _a2[_i];
                    return [4, this.renderStack(child)];
                  case 3:
                    _p.sent();
                    _p.label = 4;
                  case 4:
                    _i++;
                    return [3, 2];
                  case 5:
                    return [4, this.renderNodeContent(stack.element)];
                  case 6:
                    _p.sent();
                    _b2 = 0, _c = stack.nonInlineLevel;
                    _p.label = 7;
                  case 7:
                    if (!(_b2 < _c.length))
                      return [3, 10];
                    child = _c[_b2];
                    return [4, this.renderNode(child)];
                  case 8:
                    _p.sent();
                    _p.label = 9;
                  case 9:
                    _b2++;
                    return [3, 7];
                  case 10:
                    _d = 0, _e = stack.nonPositionedFloats;
                    _p.label = 11;
                  case 11:
                    if (!(_d < _e.length))
                      return [3, 14];
                    child = _e[_d];
                    return [4, this.renderStack(child)];
                  case 12:
                    _p.sent();
                    _p.label = 13;
                  case 13:
                    _d++;
                    return [3, 11];
                  case 14:
                    _f = 0, _g = stack.nonPositionedInlineLevel;
                    _p.label = 15;
                  case 15:
                    if (!(_f < _g.length))
                      return [3, 18];
                    child = _g[_f];
                    return [4, this.renderStack(child)];
                  case 16:
                    _p.sent();
                    _p.label = 17;
                  case 17:
                    _f++;
                    return [3, 15];
                  case 18:
                    _h = 0, _j = stack.inlineLevel;
                    _p.label = 19;
                  case 19:
                    if (!(_h < _j.length))
                      return [3, 22];
                    child = _j[_h];
                    return [4, this.renderNode(child)];
                  case 20:
                    _p.sent();
                    _p.label = 21;
                  case 21:
                    _h++;
                    return [3, 19];
                  case 22:
                    _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                    _p.label = 23;
                  case 23:
                    if (!(_k < _l.length))
                      return [3, 26];
                    child = _l[_k];
                    return [4, this.renderStack(child)];
                  case 24:
                    _p.sent();
                    _p.label = 25;
                  case 25:
                    _k++;
                    return [3, 23];
                  case 26:
                    _m = 0, _o = stack.positiveZIndex;
                    _p.label = 27;
                  case 27:
                    if (!(_m < _o.length))
                      return [3, 30];
                    child = _o[_m];
                    return [4, this.renderStack(child)];
                  case 28:
                    _p.sent();
                    _p.label = 29;
                  case 29:
                    _m++;
                    return [3, 27];
                  case 30:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.mask = function(paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.path = function(paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
          };
          CanvasRenderer2.prototype.formatPath = function(paths) {
            var _this = this;
            paths.forEach(function(point, index4) {
              var start2 = isBezierCurve(point) ? point.start : point;
              if (index4 === 0) {
                _this.ctx.moveTo(start2.x, start2.y);
              } else {
                _this.ctx.lineTo(start2.x, start2.y);
              }
              if (isBezierCurve(point)) {
                _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
            });
          };
          CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
          };
          CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
            var _a2;
            if (image2.width === width && image2.height === height) {
              return image2;
            }
            var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
            var canvas = ownerDocument.createElement("canvas");
            canvas.width = Math.max(1, width);
            canvas.height = Math.max(1, height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
            return canvas;
          };
          CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
            return __awaiter(this, void 0, void 0, function() {
              var index4, _loop_1, this_1, _i, _a2, backgroundImage2;
              return __generator(this, function(_b2) {
                switch (_b2.label) {
                  case 0:
                    index4 = container.styles.backgroundImage.length - 1;
                    _loop_1 = function(backgroundImage3) {
                      var image2, url, _c, path, x2, y3, width, height, pattern, _d, path, x2, y3, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y3, _g, rx, ry, radialGradient_1, midX, midY, f6, invF;
                      return __generator(this, function(_h) {
                        switch (_h.label) {
                          case 0:
                            if (!(backgroundImage3.type === 0))
                              return [3, 5];
                            image2 = void 0;
                            url = backgroundImage3.url;
                            _h.label = 1;
                          case 1:
                            _h.trys.push([1, 3, , 4]);
                            return [4, this_1.context.cache.match(url)];
                          case 2:
                            image2 = _h.sent();
                            return [3, 4];
                          case 3:
                            _h.sent();
                            this_1.context.logger.error("Error loading background-image " + url);
                            return [3, 4];
                          case 4:
                            if (image2) {
                              _c = calculateBackgroundRendering(container, index4, [
                                image2.width,
                                image2.height,
                                image2.width / image2.height
                              ]), path = _c[0], x2 = _c[1], y3 = _c[2], width = _c[3], height = _c[4];
                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                              this_1.renderRepeat(path, pattern, x2, y3);
                            }
                            return [3, 6];
                          case 5:
                            if (isLinearGradient(backgroundImage3)) {
                              _d = calculateBackgroundRendering(container, index4, [null, null, null]), path = _d[0], x2 = _d[1], y3 = _d[2], width = _d[3], height = _d[4];
                              _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                              canvas = document.createElement("canvas");
                              canvas.width = width;
                              canvas.height = height;
                              ctx = canvas.getContext("2d");
                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                              processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                                return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              ctx.fillStyle = gradient_1;
                              ctx.fillRect(0, 0, width, height);
                              if (width > 0 && height > 0) {
                                pattern = this_1.ctx.createPattern(canvas, "repeat");
                                this_1.renderRepeat(path, pattern, x2, y3);
                              }
                            } else if (isRadialGradient(backgroundImage3)) {
                              _f = calculateBackgroundRendering(container, index4, [
                                null,
                                null,
                                null
                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                              position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                              x2 = getAbsoluteValue(position2[0], width);
                              y3 = getAbsoluteValue(position2[position2.length - 1], height);
                              _g = calculateRadius(backgroundImage3, x2, y3, width, height), rx = _g[0], ry = _g[1];
                              if (rx > 0 && ry > 0) {
                                radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y3, 0, left + x2, top_1 + y3, rx);
                                processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                  return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                });
                                this_1.path(path);
                                this_1.ctx.fillStyle = radialGradient_1;
                                if (rx !== ry) {
                                  midX = container.bounds.left + 0.5 * container.bounds.width;
                                  midY = container.bounds.top + 0.5 * container.bounds.height;
                                  f6 = ry / rx;
                                  invF = 1 / f6;
                                  this_1.ctx.save();
                                  this_1.ctx.translate(midX, midY);
                                  this_1.ctx.transform(1, 0, 0, f6, 0, 0);
                                  this_1.ctx.translate(-midX, -midY);
                                  this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                  this_1.ctx.restore();
                                } else {
                                  this_1.ctx.fill();
                                }
                              }
                            }
                            _h.label = 6;
                          case 6:
                            index4--;
                            return [
                              2
                              /*return*/
                            ];
                        }
                      });
                    };
                    this_1 = this;
                    _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                    _b2.label = 1;
                  case 1:
                    if (!(_i < _a2.length))
                      return [3, 4];
                    backgroundImage2 = _a2[_i];
                    return [5, _loop_1(backgroundImage2)];
                  case 2:
                    _b2.sent();
                    _b2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.path(parsePathForBorder(curvePoints, side));
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function() {
              var outerPaths, innerPaths;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (!(width < 3))
                      return [3, 2];
                    return [4, this.renderSolidBorder(color2, side, curvePoints)];
                  case 1:
                    _a2.sent();
                    return [
                      2
                      /*return*/
                    ];
                  case 2:
                    outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                    this.path(outerPaths);
                    this.ctx.fillStyle = asString(color2);
                    this.ctx.fill();
                    innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                    this.path(innerPaths);
                    this.ctx.fill();
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
            return __awaiter(this, void 0, void 0, function() {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.applyEffects(paint.getEffects(
                      2
                      /* BACKGROUND_BORDERS */
                    ));
                    styles = paint.container.styles;
                    hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                    borders = [
                      { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                      { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                      { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                      { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                    ];
                    backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                    if (!(hasBackground || styles.boxShadow.length))
                      return [3, 2];
                    this.ctx.save();
                    this.path(backgroundPaintingArea);
                    this.ctx.clip();
                    if (!isTransparent(styles.backgroundColor)) {
                      this.ctx.fillStyle = asString(styles.backgroundColor);
                      this.ctx.fill();
                    }
                    return [4, this.renderBackgroundImage(paint.container)];
                  case 1:
                    _a2.sent();
                    this.ctx.restore();
                    styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                      _this.ctx.save();
                      var borderBoxArea = calculateBorderBoxPath(paint.curves);
                      var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                      var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                      if (shadow.inset) {
                        _this.path(borderBoxArea);
                        _this.ctx.clip();
                        _this.mask(shadowPaintingArea);
                      } else {
                        _this.mask(borderBoxArea);
                        _this.ctx.clip();
                        _this.path(shadowPaintingArea);
                      }
                      _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                      _this.ctx.shadowOffsetY = shadow.offsetY.number;
                      _this.ctx.shadowColor = asString(shadow.color);
                      _this.ctx.shadowBlur = shadow.blur.number;
                      _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                      _this.ctx.fill();
                      _this.ctx.restore();
                    });
                    _a2.label = 2;
                  case 2:
                    side = 0;
                    _i = 0, borders_1 = borders;
                    _a2.label = 3;
                  case 3:
                    if (!(_i < borders_1.length))
                      return [3, 13];
                    border = borders_1[_i];
                    if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                      return [3, 11];
                    if (!(border.style === 2))
                      return [3, 5];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      2
                      /* DASHED */
                    )];
                  case 4:
                    _a2.sent();
                    return [3, 11];
                  case 5:
                    if (!(border.style === 3))
                      return [3, 7];
                    return [4, this.renderDashedDottedBorder(
                      border.color,
                      border.width,
                      side,
                      paint.curves,
                      3
                      /* DOTTED */
                    )];
                  case 6:
                    _a2.sent();
                    return [3, 11];
                  case 7:
                    if (!(border.style === 4))
                      return [3, 9];
                    return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                  case 8:
                    _a2.sent();
                    return [3, 11];
                  case 9:
                    return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                  case 10:
                    _a2.sent();
                    _a2.label = 11;
                  case 11:
                    side++;
                    _a2.label = 12;
                  case 12:
                    _i++;
                    return [3, 3];
                  case 13:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
            return __awaiter(this, void 0, void 0, function() {
              var strokePaths, boxPaths, startX, startY, endX, endY, length2, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function(_a2) {
                this.ctx.save();
                strokePaths = parsePathForBorderStroke(curvePoints, side);
                boxPaths = parsePathForBorder(curvePoints, side);
                if (style === 2) {
                  this.path(boxPaths);
                  this.ctx.clip();
                }
                if (isBezierCurve(boxPaths[0])) {
                  startX = boxPaths[0].start.x;
                  startY = boxPaths[0].start.y;
                } else {
                  startX = boxPaths[0].x;
                  startY = boxPaths[0].y;
                }
                if (isBezierCurve(boxPaths[1])) {
                  endX = boxPaths[1].end.x;
                  endY = boxPaths[1].end.y;
                } else {
                  endX = boxPaths[1].x;
                  endY = boxPaths[1].y;
                }
                if (side === 0 || side === 2) {
                  length2 = Math.abs(startX - endX);
                } else {
                  length2 = Math.abs(startY - endY);
                }
                this.ctx.beginPath();
                if (style === 3) {
                  this.formatPath(strokePaths);
                } else {
                  this.formatPath(boxPaths.slice(0, 2));
                }
                dashLength = width < 3 ? width * 3 : width * 2;
                spaceLength = width < 3 ? width * 2 : width;
                if (style === 3) {
                  dashLength = width;
                  spaceLength = width;
                }
                useLineDash = true;
                if (length2 <= dashLength * 2) {
                  useLineDash = false;
                } else if (length2 <= dashLength * 2 + spaceLength) {
                  multiplier = length2 / (2 * dashLength + spaceLength);
                  dashLength *= multiplier;
                  spaceLength *= multiplier;
                } else {
                  numberOfDashes = Math.floor((length2 + spaceLength) / (dashLength + spaceLength));
                  minSpace = (length2 - numberOfDashes * dashLength) / (numberOfDashes - 1);
                  maxSpace = (length2 - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                  spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
                }
                if (useLineDash) {
                  if (style === 3) {
                    this.ctx.setLineDash([0, dashLength + spaceLength]);
                  } else {
                    this.ctx.setLineDash([dashLength, spaceLength]);
                  }
                }
                if (style === 3) {
                  this.ctx.lineCap = "round";
                  this.ctx.lineWidth = width;
                } else {
                  this.ctx.lineWidth = width * 2 + 1.1;
                }
                this.ctx.strokeStyle = asString(color2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                if (style === 2) {
                  if (isBezierCurve(boxPaths[0])) {
                    path1 = boxPaths[3];
                    path2 = boxPaths[0];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                  if (isBezierCurve(boxPaths[1])) {
                    path1 = boxPaths[1];
                    path2 = boxPaths[2];
                    this.ctx.beginPath();
                    this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                    this.ctx.stroke();
                  }
                }
                this.ctx.restore();
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CanvasRenderer2.prototype.render = function(element) {
            return __awaiter(this, void 0, void 0, function() {
              var stack;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                    }
                    stack = parseStackingContexts(element);
                    return [4, this.renderStack(stack)];
                  case 1:
                    _a2.sent();
                    this.applyEffects([]);
                    return [2, this.canvas];
                }
              });
            });
          };
          return CanvasRenderer2;
        }(Renderer)
      );
      var isTextInputElement = function(container) {
        if (container instanceof TextareaElementContainer) {
          return true;
        } else if (container instanceof SelectElementContainer) {
          return true;
        } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
        }
        return false;
      };
      var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
        switch (clip) {
          case 0:
            return calculateBorderBoxPath(curves);
          case 2:
            return calculateContentBoxPath(curves);
          case 1:
          default:
            return calculatePaddingBoxPath(curves);
        }
      };
      var canvasTextAlign = function(textAlign2) {
        switch (textAlign2) {
          case 1:
            return "center";
          case 2:
            return "right";
          case 0:
          default:
            return "left";
        }
      };
      var iOSBrokenFonts = ["-apple-system", "system-ui"];
      var fixIOSSystemFonts = function(fontFamilies) {
        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
          return iOSBrokenFonts.indexOf(fontFamily2) === -1;
        }) : fontFamilies;
      };
      var ForeignObjectRenderer = (
        /** @class */
        function(_super) {
          __extends(ForeignObjectRenderer2, _super);
          function ForeignObjectRenderer2(context, options2) {
            var _this = _super.call(this, context, options2) || this;
            _this.canvas = options2.canvas ? options2.canvas : document.createElement("canvas");
            _this.ctx = _this.canvas.getContext("2d");
            _this.options = options2;
            _this.canvas.width = Math.floor(options2.width * options2.scale);
            _this.canvas.height = Math.floor(options2.height * options2.scale);
            _this.canvas.style.width = options2.width + "px";
            _this.canvas.style.height = options2.height + "px";
            _this.ctx.scale(_this.options.scale, _this.options.scale);
            _this.ctx.translate(-options2.x, -options2.y);
            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options2.width + "x" + options2.height + " at " + options2.x + "," + options2.y + ") with scale " + options2.scale);
            return _this;
          }
          ForeignObjectRenderer2.prototype.render = function(element) {
            return __awaiter(this, void 0, void 0, function() {
              var svg, img;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                    return [4, loadSerializedSVG(svg)];
                  case 1:
                    img = _a2.sent();
                    if (this.options.backgroundColor) {
                      this.ctx.fillStyle = asString(this.options.backgroundColor);
                      this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                    }
                    this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                    return [2, this.canvas];
                }
              });
            });
          };
          return ForeignObjectRenderer2;
        }(Renderer)
      );
      var loadSerializedSVG = function(svg) {
        return new Promise(function(resolve, reject) {
          var img = new Image();
          img.onload = function() {
            resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
      };
      var Logger = (
        /** @class */
        function() {
          function Logger2(_a2) {
            var id = _a2.id, enabled = _a2.enabled;
            this.id = id;
            this.enabled = enabled;
            this.start = Date.now();
          }
          Logger2.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
                console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.getTime = function() {
            return Date.now() - this.start;
          };
          Logger2.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
                console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
            }
          };
          Logger2.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
                console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.prototype.error = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (this.enabled) {
              if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
                console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              } else {
                this.info.apply(this, args);
              }
            }
          };
          Logger2.instances = {};
          return Logger2;
        }()
      );
      var Context = (
        /** @class */
        function() {
          function Context2(options2, windowBounds) {
            var _a2;
            this.windowBounds = windowBounds;
            this.instanceName = "#" + Context2.instanceCount++;
            this.logger = new Logger({ id: this.instanceName, enabled: options2.logging });
            this.cache = (_a2 = options2.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options2);
          }
          Context2.instanceCount = 1;
          return Context2;
        }()
      );
      var html2canvas = function(element, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return renderElement(element, options2);
      };
      if (typeof window !== "undefined") {
        CacheStorage.setContext(window);
      }
      var renderElement = function(element, opts2) {
        return __awaiter(void 0, void 0, void 0, function() {
          var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
          var _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
          return __generator(this, function(_u) {
            switch (_u.label) {
              case 0:
                if (!element || typeof element !== "object") {
                  return [2, Promise.reject("Invalid element provided as first argument")];
                }
                ownerDocument = element.ownerDocument;
                if (!ownerDocument) {
                  throw new Error("Element is not attached to a Document");
                }
                defaultView = ownerDocument.defaultView;
                if (!defaultView) {
                  throw new Error("Document is not attached to a Window");
                }
                resourceOptions = {
                  allowTaint: (_b2 = opts2.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
                  imageTimeout: (_c = opts2.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                  proxy: opts2.proxy,
                  useCORS: (_d = opts2.useCORS) !== null && _d !== void 0 ? _d : false
                };
                contextOptions = __assign({ logging: (_e = opts2.logging) !== null && _e !== void 0 ? _e : true, cache: opts2.cache }, resourceOptions);
                windowOptions = {
                  windowWidth: (_f = opts2.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                  windowHeight: (_g = opts2.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                  scrollX: (_h = opts2.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                  scrollY: (_j = opts2.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                };
                windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                context = new Context(contextOptions, windowBounds);
                foreignObjectRendering = (_k = opts2.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                cloneOptions = {
                  allowTaint: (_l = opts2.allowTaint) !== null && _l !== void 0 ? _l : false,
                  onclone: opts2.onclone,
                  ignoreElements: opts2.ignoreElements,
                  inlineImages: foreignObjectRendering,
                  copyStyles: foreignObjectRendering
                };
                context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                documentCloner = new DocumentCloner(context, element, cloneOptions);
                clonedElement = documentCloner.clonedReferenceElement;
                if (!clonedElement) {
                  return [2, Promise.reject("Unable to find element in cloned iframe")];
                }
                return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                container = _u.sent();
                _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
                backgroundColor2 = parseBackgroundColor(context, clonedElement, opts2.backgroundColor);
                renderOptions = {
                  canvas: opts2.canvas,
                  backgroundColor: backgroundColor2,
                  scale: (_o = (_m = opts2.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                  x: ((_p = opts2.x) !== null && _p !== void 0 ? _p : 0) + left,
                  y: ((_q = opts2.y) !== null && _q !== void 0 ? _q : 0) + top,
                  width: (_r = opts2.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                  height: (_s = opts2.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                };
                if (!foreignObjectRendering)
                  return [3, 3];
                context.logger.debug("Document cloned, using foreign object rendering");
                renderer = new ForeignObjectRenderer(context, renderOptions);
                return [4, renderer.render(clonedElement)];
              case 2:
                canvas = _u.sent();
                return [3, 5];
              case 3:
                context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                context.logger.debug("Starting DOM parsing");
                root = parseTree(context, clonedElement);
                if (backgroundColor2 === root.styles.backgroundColor) {
                  root.styles.backgroundColor = COLORS.TRANSPARENT;
                }
                context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                renderer = new CanvasRenderer(context, renderOptions);
                return [4, renderer.render(root)];
              case 4:
                canvas = _u.sent();
                _u.label = 5;
              case 5:
                if ((_t2 = opts2.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
                  if (!DocumentCloner.destroy(container)) {
                    context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                  }
                }
                context.logger.debug("Finished rendering");
                return [2, canvas];
            }
          });
        });
      };
      var parseBackgroundColor = function(context, element, backgroundColorOverride) {
        var ownerDocument = element.ownerDocument;
        var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
        var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
        return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
      };
      return html2canvas;
    });
  }
});

// node_modules/dompurify/dist/purify.js
var require_purify = __commonJS({
  "node_modules/dompurify/dist/purify.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.DOMPurify = factory());
    })(exports, function() {
      "use strict";
      function _typeof3(obj) {
        "@babel/helpers - typeof";
        return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof3(obj);
      }
      function _setPrototypeOf(o4, p7) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o5, p8) {
          o5.__proto__ = p8;
          return o5;
        };
        return _setPrototypeOf(o4, p7);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e3) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a4 = [null];
            a4.push.apply(a4, args2);
            var Constructor = Function.bind.apply(Parent2, a4);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
          return Array.from(iter);
      }
      function _unsupportedIterableToArray(o4, minLen) {
        if (!o4)
          return;
        if (typeof o4 === "string")
          return _arrayLikeToArray(o4, minLen);
        var n5 = Object.prototype.toString.call(o4).slice(8, -1);
        if (n5 === "Object" && o4.constructor)
          n5 = o4.constructor.name;
        if (n5 === "Map" || n5 === "Set")
          return Array.from(o4);
        if (n5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5))
          return _arrayLikeToArray(o4, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i5 = 0, arr2 = new Array(len); i5 < len; i5++)
          arr2[i5] = arr[i5];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze, seal = Object.seal, create = Object.create;
      var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
      if (!apply) {
        apply = function apply2(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!construct) {
        construct = function construct2(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return construct(func, args);
        };
      }
      function addToSet(set, array, transformCaseFunc) {
        var _transformCaseFunc;
        transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set, null);
        }
        var l4 = array.length;
        while (l4--) {
          var element = array[l4];
          if (typeof element === "string") {
            var lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
              if (!isFrozen(array)) {
                array[l4] = lcElement;
              }
              element = lcElement;
            }
          }
          set[element] = true;
        }
        return set;
      }
      function clone(object) {
        var newObject = create(null);
        var property;
        for (property in object) {
          if (apply(hasOwnProperty, object, [property]) === true) {
            newObject[property] = object[property];
          }
        }
        return newObject;
      }
      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object = getPrototypeOf(object);
        }
        function fallbackValue(element) {
          console.warn("fallback value for", element);
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text = freeze(["#text"]);
      var html3 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
      var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var getGlobal = function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
        if (_typeof3(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        var suffix = null;
        var ATTR_NAME = "data-tt-policy-suffix";
        if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document2.currentScript.getAttribute(ATTR_NAME);
        }
        var policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html4) {
              return html4;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_4) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      function createDOMPurify() {
        var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
        var DOMPurify = function DOMPurify2(root) {
          return createDOMPurify(root);
        };
        DOMPurify.version = "2.4.7";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== 9) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        var originalDocument = window2.document;
        var document2 = window2.document;
        var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element3 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
        var ElementPrototype = Element3.prototype;
        var cloneNode2 = lookupGetter(ElementPrototype, "cloneNode");
        var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        var getParentNode = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          var template = document2.createElement("template");
          if (template.content && template.content.ownerDocument) {
            document2 = template.content.ownerDocument;
          }
        }
        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
        var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};
        try {
          documentMode = clone(document2).documentMode ? document2.documentMode : {};
        } catch (_4) {
        }
        var hooks2 = {};
        DOMPurify.isSupported = typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0 && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, TMPLIT_EXPR$1 = TMPLIT_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html3), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        var FORBID_TAGS = null;
        var FORBID_ATTR = null;
        var ALLOW_ARIA_ATTR = true;
        var ALLOW_DATA_ATTR = true;
        var ALLOW_UNKNOWN_PROTOCOLS = false;
        var ALLOW_SELF_CLOSE_IN_ATTR = true;
        var SAFE_FOR_TEMPLATES = false;
        var WHOLE_DOCUMENT = false;
        var SET_CONFIG = false;
        var FORCE_BODY = false;
        var RETURN_DOM = false;
        var RETURN_DOM_FRAGMENT = false;
        var RETURN_TRUSTED_TYPE = false;
        var SANITIZE_DOM = true;
        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        var KEEP_CONTENT = true;
        var IN_PLACE = false;
        var USE_PROFILES = {};
        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        var ALLOWED_NAMESPACES = null;
        var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        var transformCaseFunc;
        var CONFIG = null;
        var formElement = document2.createElement("form");
        var isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        var _parseConfig = function _parseConfig2(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || _typeof3(cfg) !== "object") {
            cfg = {};
          }
          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
            clone(DEFAULT_URI_SAFE_ATTRIBUTES),
            // eslint-disable-line indent
            cfg.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
            clone(DEFAULT_DATA_URI_TAGS),
            // eslint-disable-line indent
            cfg.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            transformCaseFunc
            // eslint-disable-line indent
          ) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html3);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }
            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }
          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }
            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        var _checkValidNamespace = function _checkValidNamespace2(element) {
          var parent = getParentNode(element);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }
          if (element.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          }
          return false;
        };
        var _forceRemove = function _forceRemove2(node2) {
          arrayPush(DOMPurify.removed, {
            element: node2
          });
          try {
            node2.parentNode.removeChild(node2);
          } catch (_4) {
            try {
              node2.outerHTML = emptyHTML;
            } catch (_5) {
              node2.remove();
            }
          }
        };
        var _removeAttribute = function _removeAttribute2(name, node2) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node2.getAttributeNode(name),
              from: node2
            });
          } catch (_4) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node2
            });
          }
          node2.removeAttribute(name);
          if (name === "is" && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node2);
              } catch (_4) {
              }
            } else {
              try {
                node2.setAttribute(name, "");
              } catch (_4) {
              }
            }
          }
        };
        var _initDocument = function _initDocument2(dirty) {
          var doc;
          var leadingWhitespace;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            var matches3 = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches3 && matches3[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_4) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_4) {
            }
          }
          var body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        var _createIterator = function _createIterator2(root) {
          return createNodeIterator.call(
            root.ownerDocument || root,
            root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
            null,
            false
          );
        };
        var _isClobbered = function _isClobbered2(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
        };
        var _isNode = function _isNode2(object) {
          return _typeof3(Node2) === "object" ? object instanceof Node2 : object && _typeof3(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
        };
        var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
          if (!hooks2[entryPoint]) {
            return;
          }
          arrayForEach(hooks2[entryPoint], function(hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        var _sanitizeElements = function _sanitizeElements2(currentNode) {
          var content;
          _executeHook("beforeSanitizeElements", currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);
            return true;
          }
          var tagName = transformCaseFunc(currentNode.nodeName);
          _executeHook("uponSanitizeElement", currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                return false;
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                var childCount = childNodes.length;
                for (var i5 = childCount - 1; i5 >= 0; --i5) {
                  parentNode.insertBefore(cloneNode2(childNodes[i5], true), getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, " ");
            content = stringReplace(content, ERB_EXPR$1, " ");
            content = stringReplace(content, TMPLIT_EXPR$1, " ");
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          _executeHook("afterSanitizeElements", currentNode, null);
          return false;
        };
        var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
            ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
            ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
            )
              ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName])
            ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
            ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
            ;
          else if (value) {
            return false;
          } else
            ;
          return true;
        };
        var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
          return tagName.indexOf("-") > 0;
        };
        var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          var attr;
          var value;
          var lcName;
          var l4;
          _executeHook("beforeSanitizeAttributes", currentNode, null);
          var attributes = currentNode.attributes;
          if (!attributes) {
            return;
          }
          var hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l4 = attributes.length;
          while (l4--) {
            attr = attributes[l4];
            var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
            value = name === "value" ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            _removeAttribute(name, currentNode);
            if (!hookEvent.keepAttr) {
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, " ");
              value = stringReplace(value, ERB_EXPR$1, " ");
              value = stringReplace(value, TMPLIT_EXPR$1, " ");
            }
            var lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (trustedTypesPolicy && _typeof3(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI)
                ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                currentNode.setAttribute(name, value);
              }
              arrayPop(DOMPurify.removed);
            } catch (_4) {
            }
          }
          _executeHook("afterSanitizeAttributes", currentNode, null);
        };
        var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          var shadowNode;
          var shadowIterator = _createIterator(fragment);
          _executeHook("beforeSanitizeShadowDOM", fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHook("uponSanitizeShadowNode", shadowNode, null);
            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
            _sanitizeAttributes(shadowNode);
          }
          _executeHook("afterSanitizeShadowDOM", fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            if (_typeof3(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
              if (typeof dirty === "string") {
                return window2.toStaticHTML(dirty);
              }
              if (_isNode(dirty)) {
                return window2.toStaticHTML(dirty.outerHTML);
              }
            }
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node2) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            if (_sanitizeElements(currentNode)) {
              continue;
            }
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            _sanitizeAttributes(currentNode);
            oldNode = currentNode;
          }
          oldNode = null;
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, " ");
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function(cfg) {
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag2, attr, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          var lcTag = transformCaseFunc(tag2);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          hooks2[entryPoint] = hooks2[entryPoint] || [];
          arrayPush(hooks2[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint) {
          if (hooks2[entryPoint]) {
            return arrayPop(hooks2[entryPoint]);
          }
        };
        DOMPurify.removeHooks = function(entryPoint) {
          if (hooks2[entryPoint]) {
            hooks2[entryPoint] = [];
          }
        };
        DOMPurify.removeAllHooks = function() {
          hooks2 = {};
        };
        return DOMPurify;
      }
      var purify = createDOMPurify();
      return purify;
    });
  }
});

// node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js/internals/global.js"(exports, module2) {
    "use strict";
    var check = function(it2) {
      return it2 && it2.Math === Math && it2;
    };
    module2.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js/internals/fails.js"(exports, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/internals/descriptors.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js/internals/function-bind-native.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js/internals/function-call.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module2.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
      var descriptor = getOwnPropertyDescriptor(this, V2);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js/internals/create-property-descriptor.js"(exports, module2) {
    "use strict";
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js/internals/classof-raw.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module2.exports = function(it2) {
      return stringSlice(toString(it2), 8, -1);
    };
  }
});

// node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js/internals/indexed-object.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split3 = uncurryThis("".split);
    module2.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it2) {
      return classof(it2) === "String" ? split3(it2, "") : $Object(it2);
    } : $Object;
  }
});

// node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module2) {
    "use strict";
    module2.exports = function(it2) {
      return it2 === null || it2 === void 0;
    };
  }
});

// node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js/internals/require-object-coercible.js"(exports, module2) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module2.exports = function(it2) {
      if (isNullOrUndefined(it2))
        throw new $TypeError("Can't call method on " + it2);
      return it2;
    };
  }
});

// node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js/internals/to-indexed-object.js"(exports, module2) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module2.exports = function(it2) {
      return IndexedObject(requireObjectCoercible(it2));
    };
  }
});

// node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js/internals/is-callable.js"(exports, module2) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module2.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/internals/is-object.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(it2) {
      return typeof it2 == "object" ? it2 !== null : isCallable(it2);
    };
  }
});

// node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js/internals/get-built-in.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(argument) {
      return isCallable(argument) ? argument : void 0;
    };
    module2.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
    };
  }
});

// node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js/internals/engine-user-agent.js"(exports, module2) {
    "use strict";
    module2.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});

// node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js/internals/engine-v8-version.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno2 = global2.Deno;
    var versions = process2 && process2.versions || Deno2 && Deno2.version;
    var v8 = versions && versions.v8;
    var match2;
    var version;
    if (v8) {
      match2 = v8.split(".");
      version = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
    }
    if (!version && userAgent) {
      match2 = userAgent.match(/Edge\/(\d+)/);
      if (!match2 || match2[1] >= 74) {
        match2 = userAgent.match(/Chrome\/(\d+)/);
        if (match2)
          version = +match2[1];
      }
    }
    module2.exports = version;
  }
});

// node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module2) {
    "use strict";
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    var global2 = require_global();
    var $String = global2.String;
    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module2) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js/internals/is-symbol.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module2.exports = USE_SYMBOL_AS_UID ? function(it2) {
      return typeof it2 == "symbol";
    } : function(it2) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
    };
  }
});

// node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js/internals/try-to-string.js"(exports, module2) {
    "use strict";
    var $String = String;
    module2.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js/internals/a-callable.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js/internals/get-method.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module2.exports = function(V2, P2) {
      var func = V2[P2];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject8 = require_is_object();
    var $TypeError = TypeError;
    module2.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject8(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject8(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject8(val = call(fn, input)))
        return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js/internals/is-pure.js"(exports, module2) {
    "use strict";
    module2.exports = false;
  }
});

// node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js/internals/define-global-property.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module2.exports = function(key, value) {
      try {
        defineProperty(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js/internals/shared-store.js"(exports, module2) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.36.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2024 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.36.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js/internals/shared.js"(exports, module2) {
    "use strict";
    var store = require_shared_store();
    module2.exports = function(key, value) {
      return store[key] || (store[key] = value || {});
    };
  }
});

// node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/internals/to-object.js"(exports, module2) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module2.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js/internals/has-own-property.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject2 = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module2.exports = Object.hasOwn || function hasOwn(it2, key) {
      return hasOwnProperty(toObject2(it2), key);
    };
  }
});

// node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js/internals/uid.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1 .toString);
    module2.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js/internals/well-known-symbol.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = global2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module2.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/internals/to-primitive.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var isObject8 = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module2.exports = function(input, pref) {
      if (!isObject8(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject8(result) || isSymbol(result))
          return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js/internals/to-property-key.js"(exports, module2) {
    "use strict";
    var toPrimitive2 = require_to_primitive();
    var isSymbol = require_is_symbol();
    module2.exports = function(argument) {
      var key = toPrimitive2(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js/internals/document-create-element.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isObject8 = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject8(document2) && isObject8(document2.createElement);
    module2.exports = function(it2) {
      return EXISTS ? document2.createElement(it2) : {};
    };
  }
});

// node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/internals/ie8-dom-define.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module2.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey2 = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O3, P2) {
      O3 = toIndexedObject(O3);
      P2 = toPropertyKey2(P2);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O3, P2);
        } catch (error) {
        }
      if (hasOwn(O3, P2))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O3, P2), O3[P2]);
    };
  }
});

// node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module2.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/internals/an-object.js"(exports, module2) {
    "use strict";
    var isObject8 = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isObject8(argument))
        return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey2 = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O3, P2, Attributes) {
      anObject(O3);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (typeof O3 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O3, P2);
        if (current && current[WRITABLE]) {
          O3[P2] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O3, P2, Attributes);
    } : $defineProperty : function defineProperty(O3, P2, Attributes) {
      anObject(O3);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O3, P2, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw new $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O3[P2] = Attributes.value;
      return O3;
    };
  }
});

// node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module2.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js/internals/function-name.js"(exports, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module2.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js/internals/inspect-source.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it2) {
        return functionToString(it2);
      };
    }
    module2.exports = store.inspectSource;
  }
});

// node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap = global2.WeakMap;
    module2.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
  }
});

// node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/internals/shared-key.js"(exports, module2) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module2.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js/internals/hidden-keys.js"(exports, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js/internals/internal-state.js"(exports, module2) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject8 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap = global2.WeakMap;
    var set;
    var get;
    var has2;
    var enforce = function(it2) {
      return has2(it2) ? get(it2) : set(it2, {});
    };
    var getterFor = function(TYPE) {
      return function(it2) {
        var state;
        if (!isObject8(it2) || (state = get(it2)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it2, metadata) {
        if (store.has(it2))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        store.set(it2, metadata);
        return metadata;
      };
      get = function(it2) {
        return store.get(it2) || {};
      };
      has2 = function(it2) {
        return store.has(it2);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it2, metadata) {
        if (hasOwn(it2, STATE))
          throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        createNonEnumerableProperty(it2, STATE, metadata);
        return metadata;
      };
      get = function(it2) {
        return hasOwn(it2, STATE) ? it2[STATE] : {};
      };
      has2 = function(it2) {
        return hasOwn(it2, STATE);
      };
    }
    var store;
    var STATE;
    module2.exports = {
      set,
      get,
      has: has2,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "node_modules/core-js/internals/make-built-in.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis("".slice);
    var replace = uncurryThis("".replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module2.exports = function(value, name, options2) {
      if (stringSlice($String(name), 0, 7) === "Symbol(") {
        name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
      }
      if (options2 && options2.getter)
        name = "get " + name;
      if (options2 && options2.setter)
        name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options2 && hasOwn(options2, "arity") && value.length !== options2.arity) {
        defineProperty(value, "length", { value: options2.arity });
      }
      try {
        if (options2 && hasOwn(options2, "constructor") && options2.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString");
  }
});

// node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js/internals/define-built-in.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module2.exports = function(O3, key, value, options2) {
      if (!options2)
        options2 = {};
      var simple4 = options2.enumerable;
      var name = options2.name !== void 0 ? options2.name : key;
      if (isCallable(value))
        makeBuiltIn(value, name, options2);
      if (options2.global) {
        if (simple4)
          O3[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options2.unsafe)
            delete O3[key];
          else if (O3[key])
            simple4 = true;
        } catch (error) {
        }
        if (simple4)
          O3[key] = value;
        else
          definePropertyModule.f(O3, key, {
            value,
            enumerable: false,
            configurable: !options2.nonConfigurable,
            writable: !options2.nonWritable
          });
      }
      return O3;
    };
  }
});

// node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js/internals/math-trunc.js"(exports, module2) {
    "use strict";
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = Math.trunc || function trunc(x2) {
      var n5 = +x2;
      return (n5 > 0 ? floor : ceil)(n5);
    };
  }
});

// node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module2) {
    "use strict";
    var trunc = require_math_trunc();
    module2.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/internals/to-absolute-index.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max4 = Math.max;
    var min2 = Math.min;
    module2.exports = function(index4, length2) {
      var integer = toIntegerOrInfinity(index4);
      return integer < 0 ? max4(integer + length2, 0) : min2(integer, length2);
    };
  }
});

// node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/internals/to-length.js"(exports, module2) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min2 = Math.min;
    module2.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min2(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js/internals/length-of-array-like.js"(exports, module2) {
    "use strict";
    var toLength = require_to_length();
    module2.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/internals/array-includes.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O3 = toIndexedObject($this);
        var length2 = lengthOfArrayLike(O3);
        if (length2 === 0)
          return !IS_INCLUDES && -1;
        var index4 = toAbsoluteIndex(fromIndex, length2);
        var value;
        if (IS_INCLUDES && el !== el)
          while (length2 > index4) {
            value = O3[index4++];
            if (value !== value)
              return true;
          }
        else
          for (; length2 > index4; index4++) {
            if ((IS_INCLUDES || index4 in O3) && O3[index4] === el)
              return IS_INCLUDES || index4 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module2.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/internals/object-keys-internal.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module2.exports = function(object, names) {
      var O3 = toIndexedObject(object);
      var i5 = 0;
      var result = [];
      var key;
      for (key in O3)
        !hasOwn(hiddenKeys, key) && hasOwn(O3, key) && push(result, key);
      while (names.length > i5)
        if (hasOwn(O3, key = names[i5++])) {
          ~indexOf(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/internals/enum-bug-keys.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O3) {
      return internalObjectKeys(O3, hiddenKeys);
    };
  }
});

// node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js/internals/own-keys.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
      var keys = getOwnPropertyNamesModule.f(anObject(it2));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it2)) : keys;
    };
  }
});

// node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module2) {
    "use strict";
    var hasOwn = require_has_own_property();
    var ownKeys2 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module2.exports = function(target, source, exceptions4) {
      var keys = ownKeys2(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i5 = 0; i5 < keys.length; i5++) {
        var key = keys[i5];
        if (!hasOwn(target, key) && !(exceptions4 && hasOwn(exceptions4, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js/internals/is-forced.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize2(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize2 = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module2.exports = isForced;
  }
});

// node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js/internals/export.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module2.exports = function(options2, source) {
      var TARGET = options2.target;
      var GLOBAL = options2.global;
      var STATIC = options2.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = global2[TARGET] && global2[TARGET].prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options2.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options2.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options2);
        }
    };
  }
});

// node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js/internals/engine-is-node.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var classof = require_classof_raw();
    module2.exports = classof(global2.process) === "process";
  }
});

// node_modules/core-js/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module2.exports = function(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js/internals/is-possible-prototype.js"(exports, module2) {
    "use strict";
    var isObject8 = require_is_object();
    module2.exports = function(argument) {
      return isObject8(argument) || argument === null;
    };
  }
});

// node_modules/core-js/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js/internals/a-possible-prototype.js"(exports, module2) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isPossiblePrototype(argument))
        return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module2) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O3, proto) {
        anObject(O3);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O3, proto);
        else
          O3.__proto__ = proto;
        return O3;
      };
    }() : void 0);
  }
});

// node_modules/core-js/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/internals/set-to-string-tag.js"(exports, module2) {
    "use strict";
    var defineProperty = require_object_define_property().f;
    var hasOwn = require_has_own_property();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module2.exports = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
    };
  }
});

// node_modules/core-js/internals/define-built-in-accessor.js
var require_define_built_in_accessor = __commonJS({
  "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module2) {
    "use strict";
    var makeBuiltIn = require_make_built_in();
    var defineProperty = require_object_define_property();
    module2.exports = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty.f(target, name, descriptor);
    };
  }
});

// node_modules/core-js/internals/set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/internals/set-species.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var defineBuiltInAccessor = require_define_built_in_accessor();
    var wellKnownSymbol = require_well_known_symbol();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
  }
});

// node_modules/core-js/internals/an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/internals/an-instance.js"(exports, module2) {
    "use strict";
    var isPrototypeOf = require_object_is_prototype_of();
    var $TypeError = TypeError;
    module2.exports = function(it2, Prototype) {
      if (isPrototypeOf(Prototype, it2))
        return it2;
      throw new $TypeError("Incorrect invocation");
    };
  }
});

// node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js/internals/to-string-tag-support.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module2.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js/internals/classof.js"(exports, module2) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it2, key) {
      try {
        return it2[key];
      } catch (error) {
      }
    };
    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
      var O3, tag2, result;
      return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag2 = tryGet(O3 = $Object(it2), TO_STRING_TAG)) == "string" ? tag2 : CORRECT_ARGUMENTS ? classofRaw(O3) : (result = classofRaw(O3)) === "Object" && isCallable(O3.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js/internals/is-constructor.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop3 = function() {
    };
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop3);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop3, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module2.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js/internals/a-constructor.js
var require_a_constructor = __commonJS({
  "node_modules/core-js/internals/a-constructor.js"(exports, module2) {
    "use strict";
    var isConstructor = require_is_constructor();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module2.exports = function(argument) {
      if (isConstructor(argument))
        return argument;
      throw new $TypeError(tryToString(argument) + " is not a constructor");
    };
  }
});

// node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "node_modules/core-js/internals/species-constructor.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var aConstructor = require_a_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    module2.exports = function(O3, defaultConstructor) {
      var C2 = anObject(O3).constructor;
      var S2;
      return C2 === void 0 || isNullOrUndefined(S2 = anObject(C2)[SPECIES]) ? defaultConstructor : aConstructor(S2);
    };
  }
});

// node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js/internals/function-apply.js"(exports, module2) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module2) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module2.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// node_modules/core-js/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js/internals/function-bind-context.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module2.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js/internals/html.js"(exports, module2) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module2.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js/internals/array-slice.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module2.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports, module2) {
    "use strict";
    var $TypeError = TypeError;
    module2.exports = function(passed, required) {
      if (passed < required)
        throw new $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js/internals/engine-is-ios.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html3 = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global2.setImmediate;
    var clear = global2.clearImmediate;
    var process2 = global2.process;
    var Dispatch = global2.Dispatch;
    var Function2 = global2.Function;
    var MessageChannel = global2.MessageChannel;
    var String2 = global2.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var $location;
    var defer;
    var channel;
    var port;
    fails(function() {
      $location = global2.location;
    });
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var eventListener = function(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function(id) {
      global2.postMessage(String2(id), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function2(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process2.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global2.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html3.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html3.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module2.exports = {
      set,
      clear
    };
  }
});

// node_modules/core-js/internals/safe-get-built-in.js
var require_safe_get_built_in = __commonJS({
  "node_modules/core-js/internals/safe-get-built-in.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var DESCRIPTORS = require_descriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    module2.exports = function(name) {
      if (!DESCRIPTORS)
        return global2[name];
      var descriptor = getOwnPropertyDescriptor(global2, name);
      return descriptor && descriptor.value;
    };
  }
});

// node_modules/core-js/internals/queue.js
var require_queue = __commonJS({
  "node_modules/core-js/internals/queue.js"(exports, module2) {
    "use strict";
    var Queue = function() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    module2.exports = Queue;
  }
});

// node_modules/core-js/internals/engine-is-ios-pebble.js
var require_engine_is_ios_pebble = __commonJS({
  "node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  }
});

// node_modules/core-js/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module2) {
    "use strict";
    var userAgent = require_engine_user_agent();
    module2.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "node_modules/core-js/internals/microtask.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var safeGetBuiltIn = require_safe_get_built_in();
    var bind = require_function_bind_context();
    var macrotask = require_task().set;
    var Queue = require_queue();
    var IS_IOS = require_engine_is_ios();
    var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var microtask = safeGetBuiltIn("queueMicrotask");
    var notify;
    var toggle;
    var node2;
    var promise;
    var then;
    if (!microtask) {
      queue = new Queue();
      flush = function() {
        var parent, fn;
        if (IS_NODE && (parent = process2.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node2 = document2.createTextNode("");
        new MutationObserver(flush).observe(node2, { characterData: true });
        notify = function() {
          node2.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        promise.constructor = Promise2;
        then = bind(promise.then, promise);
        notify = function() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function() {
          process2.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, global2);
        notify = function() {
          macrotask(flush);
        };
      }
      microtask = function(fn) {
        if (!queue.head)
          notify();
        queue.add(fn);
      };
    }
    var queue;
    var flush;
    module2.exports = microtask;
  }
});

// node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "node_modules/core-js/internals/host-report-errors.js"(exports, module2) {
    "use strict";
    module2.exports = function(a4, b2) {
      try {
        arguments.length === 1 ? console.error(a4) : console.error(a4, b2);
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "node_modules/core-js/internals/perform.js"(exports, module2) {
    "use strict";
    module2.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// node_modules/core-js/internals/promise-native-constructor.js
var require_promise_native_constructor = __commonJS({
  "node_modules/core-js/internals/promise-native-constructor.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    module2.exports = global2.Promise;
  }
});

// node_modules/core-js/internals/engine-is-deno.js
var require_engine_is_deno = __commonJS({
  "node_modules/core-js/internals/engine-is-deno.js"(exports, module2) {
    "use strict";
    module2.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
  }
});

// node_modules/core-js/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "node_modules/core-js/internals/engine-is-browser.js"(exports, module2) {
    "use strict";
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    module2.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
  }
});

// node_modules/core-js/internals/promise-constructor-detection.js
var require_promise_constructor_detection = __commonJS({
  "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module2) {
    "use strict";
    var global2 = require_global();
    var NativePromiseConstructor = require_promise_native_constructor();
    var isCallable = require_is_callable();
    var isForced = require_is_forced();
    var inspectSource = require_inspect_source();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_BROWSER = require_engine_is_browser();
    var IS_DENO = require_engine_is_deno();
    var IS_PURE = require_is_pure();
    var V8_VERSION = require_engine_v8_version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol("species");
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"]))
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function(resolve) {
          resolve(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    module2.exports = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING
    };
  }
});

// node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "node_modules/core-js/internals/new-promise-capability.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var $TypeError = TypeError;
    var PromiseCapability = function(C2) {
      var resolve, reject;
      this.promise = new C2(function($$resolve, $$reject) {
        if (resolve !== void 0 || reject !== void 0)
          throw new $TypeError("Bad Promise constructor");
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    module2.exports.f = function(C2) {
      return new PromiseCapability(C2);
    };
  }
});

// node_modules/core-js/modules/es.promise.constructor.js
var require_es_promise_constructor = __commonJS({
  "node_modules/core-js/modules/es.promise.constructor.js"() {
    "use strict";
    var $2 = require_export();
    var IS_PURE = require_is_pure();
    var IS_NODE = require_engine_is_node();
    var global2 = require_global();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var setSpecies = require_set_species();
    var aCallable = require_a_callable();
    var isCallable = require_is_callable();
    var isObject8 = require_is_object();
    var anInstance = require_an_instance();
    var speciesConstructor = require_species_constructor();
    var task = require_task().set;
    var microtask = require_microtask();
    var hostReportErrors = require_host_report_errors();
    var perform = require_perform();
    var Queue = require_queue();
    var InternalStateModule = require_internal_state();
    var NativePromiseConstructor = require_promise_native_constructor();
    var PromiseConstructorDetection = require_promise_constructor_detection();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var PROMISE = "Promise";
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError2 = global2.TypeError;
    var document2 = global2.document;
    var process2 = global2.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
    var UNHANDLED_REJECTION = "unhandledrejection";
    var REJECTION_HANDLED = "rejectionhandled";
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal;
    var OwnPromiseCapability;
    var PromiseWrapper;
    var nativeThen;
    var isThenable = function(it2) {
      var then;
      return isObject8(it2) && isCallable(then = it2.then) ? then : false;
    };
    var callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError2("Promise-chain cycle"));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else
            resolve(result);
        } else
          reject(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject(error);
      }
    };
    var notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    var dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document2.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global2.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global2["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    var onUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process2.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    var isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function(state) {
      call(task, global2, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process2.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw new TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call(
                then,
                value,
                bind(internalResolve, wrapper, state),
                bind(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process2.domain : void 0;
        if (state.state === PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
        return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
  }
});

// node_modules/core-js/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/internals/iterators.js"(exports, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module2.exports = function(it2) {
      return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module2) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module2.exports = function(it2) {
      if (!isNullOrUndefined(it2))
        return getMethod(it2, ITERATOR) || getMethod(it2, "@@iterator") || Iterators[classof(it2)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module2.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module2.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module2) {
    "use strict";
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module2.exports = function(iterable, unboundFunction, options2) {
      var that = options2 && options2.that;
      var AS_ENTRIES = !!(options2 && options2.AS_ENTRIES);
      var IS_RECORD = !!(options2 && options2.IS_RECORD);
      var IS_ITERATOR = !!(options2 && options2.IS_ITERATOR);
      var INTERRUPTED = !!(options2 && options2.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index4, length2, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index4 = 0, length2 = lengthOfArrayLike(iterable); length2 > index4; index4++) {
            result = callFn(iterable[index4]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module2.exports = function(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js/internals/promise-statics-incorrect-iteration.js
var require_promise_statics_incorrect_iteration = __commonJS({
  "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module2) {
    "use strict";
    var NativePromiseConstructor = require_promise_native_constructor();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    module2.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor.all(iterable).then(void 0, function() {
      });
    });
  }
});

// node_modules/core-js/modules/es.promise.all.js
var require_es_promise_all = __commonJS({
  "node_modules/core-js/modules/es.promise.all.js"() {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      all: function all4(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C2.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index4 = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C2, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index4] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.catch.js
var require_es_promise_catch = __commonJS({
  "node_modules/core-js/modules/es.promise.catch.js"() {
    "use strict";
    var $2 = require_export();
    var IS_PURE = require_is_pure();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var NativePromiseConstructor = require_promise_native_constructor();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var defineBuiltIn = require_define_built_in();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      method = getBuiltIn("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    var method;
  }
});

// node_modules/core-js/modules/es.promise.race.js
var require_es_promise_race = __commonJS({
  "node_modules/core-js/modules/es.promise.race.js"() {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var perform = require_perform();
    var iterate = require_iterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
    $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C2 = this;
        var capability = newPromiseCapabilityModule.f(C2);
        var reject = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable(C2.resolve);
          iterate(iterable, function(promise) {
            call($promiseResolve, C2, promise).then(capability.resolve, reject);
          });
        });
        if (result.error)
          reject(result.value);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.reject.js
var require_es_promise_reject = __commonJS({
  "node_modules/core-js/modules/es.promise.reject.js"() {
    "use strict";
    var $2 = require_export();
    var newPromiseCapabilityModule = require_new_promise_capability();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      reject: function reject(r3) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r3);
        return capability.promise;
      }
    });
  }
});

// node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "node_modules/core-js/internals/promise-resolve.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var isObject8 = require_is_object();
    var newPromiseCapability = require_new_promise_capability();
    module2.exports = function(C2, x2) {
      anObject(C2);
      if (isObject8(x2) && x2.constructor === C2)
        return x2;
      var promiseCapability = newPromiseCapability.f(C2);
      var resolve = promiseCapability.resolve;
      resolve(x2);
      return promiseCapability.promise;
    };
  }
});

// node_modules/core-js/modules/es.promise.resolve.js
var require_es_promise_resolve = __commonJS({
  "node_modules/core-js/modules/es.promise.resolve.js"() {
    "use strict";
    var $2 = require_export();
    var getBuiltIn = require_get_built_in();
    var IS_PURE = require_is_pure();
    var NativePromiseConstructor = require_promise_native_constructor();
    var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
    var promiseResolve = require_promise_resolve();
    var PromiseConstructorWrapper = getBuiltIn("Promise");
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x2) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
      }
    });
  }
});

// node_modules/core-js/modules/es.promise.js
var require_es_promise = __commonJS({
  "node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    require_es_promise_constructor();
    require_es_promise_all();
    require_es_promise_catch();
    require_es_promise_race();
    require_es_promise_reject();
    require_es_promise_resolve();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js/internals/to-string.js"(exports, module2) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module2.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    module2.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re2 = $RegExp("a", "y");
      re2.lastIndex = 2;
      return re2.exec("abcd") !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re2 = $RegExp("^r", "gy");
      re2.lastIndex = 2;
      return re2.exec("str") !== null;
    });
    module2.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/internals/object-keys.js"(exports, module2) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || function keys(O3) {
      return internalObjectKeys(O3, enumBugKeys);
    };
  }
});

// node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O3, Properties) {
      anObject(O3);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length2 = keys.length;
      var index4 = 0;
      var key;
      while (length2 > index4)
        definePropertyModule.f(O3, key = keys[index4++], props[key]);
      return O3;
    };
  }
});

// node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/internals/object-create.js"(exports, module2) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html3 = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html3.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length2 = enumBugKeys.length;
      while (length2--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module2.exports = Object.create || function create(O3, Properties) {
      var result;
      if (O3 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O3);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O3;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module2.exports = fails(function() {
      var re2 = $RegExp(".", "s");
      return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
    });
  }
});

// node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module2.exports = fails(function() {
      var re2 = $RegExp("(?<a>b)", "g");
      return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
    });
  }
});

// node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "node_modules/core-js/internals/regexp-exec.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re2 = this;
        var state = getInternalState(re2);
        var str = toString(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match2, i5, object, group;
        if (raw) {
          raw.lastIndex = re2.lastIndex;
          result = call(patchedExec, raw, str);
          re2.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re2.sticky;
        var flags = call(regexpFlags, re2);
        var source = re2.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re2.lastIndex);
          if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re2.lastIndex;
        match2 = call(nativeExec, sticky ? reCopy : re2, strCopy);
        if (sticky) {
          if (match2) {
            match2.input = stringSlice(match2.input, charsAdded);
            match2[0] = stringSlice(match2[0], charsAdded);
            match2.index = re2.lastIndex;
            re2.lastIndex += match2[0].length;
          } else
            re2.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match2) {
          re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match2 && match2.length > 1) {
          call(nativeReplace, match2[0], reCopy, function() {
            for (i5 = 1; i5 < arguments.length - 2; i5++) {
              if (arguments[i5] === void 0)
                match2[i5] = void 0;
            }
          });
        }
        if (match2 && groups) {
          match2.groups = object = create(null);
          for (i5 = 0; i5 < groups.length; i5++) {
            group = groups[i5];
            object[group[0]] = match2[group[1]];
          }
        }
        return match2;
      };
    }
    module2.exports = patchedExec;
  }
});

// node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    var $2 = require_export();
    var exec = require_regexp_exec();
    $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module2) {
    "use strict";
    require_es_regexp_exec();
    var call = require_function_call();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module2.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O3 = {};
        O3[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O3) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re2 = /a/;
        if (KEY === "split") {
          re2 = {};
          re2.constructor = {};
          re2.constructor[SPECIES] = function() {
            return re2;
          };
          re2.flags = "";
          re2[SYMBOL] = /./[SYMBOL];
        }
        re2.exec = function() {
          execCalled = true;
          return null;
        };
        re2[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods17 = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
            }
            return { done: true, value: call(nativeMethod, str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods17[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods17[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js/internals/string-multibyte.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S2.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module2.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "node_modules/core-js/internals/advance-string-index.js"(exports, module2) {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    module2.exports = function(S2, index4, unicode2) {
      return index4 + (unicode2 ? charAt(S2, index4).length : 1);
    };
  }
});

// node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module2.exports = function(R2, S2) {
      var exec = R2.exec;
      if (isCallable(exec)) {
        var result = call(exec, R2, S2);
        if (result !== null)
          anObject(result);
        return result;
      }
      if (classof(R2) === "RegExp")
        return call(regexpExec, R2, S2);
      throw new $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// node_modules/core-js/modules/es.string.match.js
var require_es_string_match = __commonJS({
  "node_modules/core-js/modules/es.string.match.js"() {
    "use strict";
    var call = require_function_call();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var getMethod = require_get_method();
    var advanceStringIndex = require_advance_string_index();
    var regExpExec = require_regexp_exec_abstract();
    fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
      return [
        // `String.prototype.match` method
        // https://tc39.es/ecma262/#sec-string.prototype.match
        function match2(regexp) {
          var O3 = requireObjectCoercible(this);
          var matcher2 = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, MATCH);
          return matcher2 ? call(matcher2, regexp, O3) : new RegExp(regexp)[MATCH](toString(O3));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
        function(string) {
          var rx = anObject(this);
          var S2 = toString(string);
          var res = maybeCallNative(nativeMatch, rx, S2);
          if (res.done)
            return res.value;
          if (!rx.global)
            return regExpExec(rx, S2);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A2 = [];
          var n5 = 0;
          var result;
          while ((result = regExpExec(rx, S2)) !== null) {
            var matchStr = toString(result[0]);
            A2[n5] = matchStr;
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
            n5++;
          }
          return n5 === 0 ? null : A2;
        }
      ];
    });
  }
});

// node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "node_modules/core-js/internals/get-substitution.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject2 = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m6 = captures.length;
      var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject2(namedCaptures);
        symbols2 = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols2, function(match2, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n5 = +ch;
            if (n5 === 0)
              return match2;
            if (n5 > m6) {
              var f5 = floor(n5 / 10);
              if (f5 === 0)
                return match2;
              if (f5 <= m6)
                return captures[f5 - 1] === void 0 ? charAt(ch, 1) : captures[f5 - 1] + charAt(ch, 1);
              return match2;
            }
            capture = captures[n5 - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max4 = Math.max;
    var min2 = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = function(it2) {
      return it2 === void 0 ? it2 : String(it2);
    };
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re2 = /./;
      re2.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re2, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_4, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        // `String.prototype.replace` method
        // https://tc39.es/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
          var O3 = requireObjectCoercible(this);
          var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O3, replaceValue) : call(nativeReplace, toString(O3), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        function(string, replaceValue) {
          var rx = anObject(this);
          var S2 = toString(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString(replaceValue);
          var global2 = rx.global;
          var fullUnicode;
          if (global2) {
            fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          var result;
          while (true) {
            result = regExpExec(rx, S2);
            if (result === null)
              break;
            push(results, result);
            if (!global2)
              break;
            var matchStr = toString(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i5 = 0; i5 < results.length; i5++) {
            result = results[i5];
            var matched = toString(result[0]);
            var position = max4(min2(toIntegerOrInfinity(result.index), S2.length), 0);
            var captures = [];
            var replacement;
            for (var j3 = 1; j3 < result.length; j3++)
              push(captures, maybeToString(result[j3]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S2);
              if (namedCaptures !== void 0)
                push(replacerArgs, namedCaptures);
              replacement = toString(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S2, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "node_modules/core-js/internals/is-regexp.js"(exports, module2) {
    "use strict";
    var isObject8 = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module2.exports = function(it2) {
      var isRegExp;
      return isObject8(it2) && ((isRegExp = it2[MATCH]) !== void 0 ? !!isRegExp : classof(it2) === "RegExp");
    };
  }
});

// node_modules/core-js/internals/not-a-regexp.js
var require_not_a_regexp = __commonJS({
  "node_modules/core-js/internals/not-a-regexp.js"(exports, module2) {
    "use strict";
    var isRegExp = require_is_regexp();
    var $TypeError = TypeError;
    module2.exports = function(it2) {
      if (isRegExp(it2)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it2;
    };
  }
});

// node_modules/core-js/internals/correct-is-regexp-logic.js
var require_correct_is_regexp_logic = __commonJS({
  "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module2.exports = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
  }
});

// node_modules/core-js/modules/es.string.starts-with.js
var require_es_string_starts_with = __commonJS({
  "node_modules/core-js/modules/es.string.starts-with.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var stringSlice = uncurryThis("".slice);
    var min2 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index4 = toLength(min2(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString(searchString);
        return stringSlice(that, index4, index4 + search.length) === search;
      }
    });
  }
});

// node_modules/core-js/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/internals/add-to-unscopables.js"(exports, module2) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var create = require_object_create();
    var defineProperty = require_object_define_property().f;
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === void 0) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    module2.exports = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
  }
});

// node_modules/core-js/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = !fails(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
  }
});

// node_modules/core-js/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module2) {
    "use strict";
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject2 = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O3) {
      var object = toObject2(O3);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js/internals/iterators-core.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject8 = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject8(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module2.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module2) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module2.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js/internals/iterator-define.js"(exports, module2) {
    "use strict";
    var $2 = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods17, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods17 = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods17) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods17[KEY]);
            }
          }
        else
          $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods17);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods17;
    };
  }
});

// node_modules/core-js/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js/internals/create-iter-result-object.js"(exports, module2) {
    "use strict";
    module2.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js/modules/es.array.iterator.js"(exports, module2) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var index4 = state.index++;
      if (!target || index4 >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      switch (state.kind) {
        case "keys":
          return createIterResultObject(index4, false);
        case "values":
          return createIterResultObject(target[index4], false);
      }
      return createIterResultObject([index4, target[index4]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// node_modules/core-js/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js/internals/dom-iterables.js"(exports, module2) {
    "use strict";
    module2.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js/internals/dom-token-list-prototype.js
var require_dom_token_list_prototype = __commonJS({
  "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module2) {
    "use strict";
    var documentCreateElement = require_document_create_element();
    var classList = documentCreateElement("span").classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    module2.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  }
});

// node_modules/core-js/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
    "use strict";
    var global2 = require_global();
    var DOMIterables = require_dom_iterables();
    var DOMTokenListPrototype = require_dom_token_list_prototype();
    var ArrayIteratorMethods = require_es_array_iterator();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var setToStringTag = require_set_to_string_tag();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues)
          try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
        setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
        if (DOMIterables[COLLECTION_NAME2])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    var COLLECTION_NAME;
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t5, r3) {
  if ("object" != _typeof(t5) || !t5)
    return t5;
  var e3 = t5[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i5 = e3.call(t5, r3 || "default");
    if ("object" != _typeof(i5))
      return i5;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r3 ? String : Number)(t5);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t5) {
  var i5 = toPrimitive(t5, "string");
  return "symbol" == _typeof(i5) ? i5 : String(i5);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/core-js/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js/internals/array-reduce.js"(exports, module2) {
    "use strict";
    var aCallable = require_a_callable();
    var toObject2 = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = "Reduce of empty array with no initial value";
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        var O3 = toObject2(that);
        var self2 = IndexedObject(O3);
        var length2 = lengthOfArrayLike(O3);
        aCallable(callbackfn);
        if (length2 === 0 && argumentsLength < 2)
          throw new $TypeError(REDUCE_EMPTY);
        var index4 = IS_RIGHT ? length2 - 1 : 0;
        var i5 = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index4 in self2) {
              memo = self2[index4];
              index4 += i5;
              break;
            }
            index4 += i5;
            if (IS_RIGHT ? index4 < 0 : length2 <= index4) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
        for (; IS_RIGHT ? index4 >= 0 : length2 > index4; index4 += i5)
          if (index4 in self2) {
            memo = callbackfn(memo, self2[index4], index4, O3);
          }
        return memo;
      };
    };
    module2.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js/internals/array-method-is-strict.js"(exports, module2) {
    "use strict";
    var fails = require_fails();
    module2.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js/modules/es.array.reduce.js"() {
    "use strict";
    var $2 = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length2 = arguments.length;
        return $reduce(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.ends-with.js
var require_es_string_ends_with = __commonJS({
  "node_modules/core-js/modules/es.string.ends-with.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var toLength = require_to_length();
    var toString = require_to_string();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var IS_PURE = require_is_pure();
    var slice = uncurryThis("".slice);
    var min2 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
      return descriptor && !descriptor.writable;
    }();
    $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      endsWith: function endsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : void 0;
        var len = that.length;
        var end2 = endPosition === void 0 ? len : min2(toLength(endPosition), len);
        var search = toString(searchString);
        return slice(that, end2 - search.length, end2) === search;
      }
    });
  }
});

// node_modules/core-js/modules/es.string.split.js
var require_es_string_split = __commonJS({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var anObject = require_an_object();
    var isNullOrUndefined = require_is_null_or_undefined();
    var requireObjectCoercible = require_require_object_coercible();
    var speciesConstructor = require_species_constructor();
    var advanceStringIndex = require_advance_string_index();
    var toLength = require_to_length();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var regExpExec = require_regexp_exec_abstract();
    var stickyHelpers = require_regexp_sticky_helpers();
    var fails = require_fails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 4294967295;
    var min2 = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis("".slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re2 = /(?:)/;
      var originalExec = re2.exec;
      re2.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re2);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
    "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    ".".split(/()()/).length > 1 || "".split(/.?/).length;
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
        return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [
        // `String.prototype.split` method
        // https://tc39.es/ecma262/#sec-string.prototype.split
        function split3(separator, limit) {
          var O3 = requireObjectCoercible(this);
          var splitter = isNullOrUndefined(separator) ? void 0 : getMethod(separator, SPLIT);
          return splitter ? call(splitter, separator, O3, limit) : call(internalSplit, toString(O3), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(string, limit) {
          var rx = anObject(this);
          var S2 = toString(string);
          if (!BUGGY) {
            var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
            if (res.done)
              return res.value;
          }
          var C2 = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S2.length === 0)
            return regExpExec(splitter, S2) === null ? [S2] : [];
          var p7 = 0;
          var q2 = 0;
          var A2 = [];
          while (q2 < S2.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
            var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
            var e3;
            if (z2 === null || (e3 = min2(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p7) {
              q2 = advanceStringIndex(S2, q2, unicodeMatching);
            } else {
              push(A2, stringSlice(S2, p7, q2));
              if (A2.length === lim)
                return A2;
              for (var i5 = 1; i5 <= z2.length - 1; i5++) {
                push(A2, z2[i5]);
                if (A2.length === lim)
                  return A2;
              }
              q2 = p7 = e3;
            }
          }
          push(A2, stringSlice(S2, p7));
          return A2;
        }
      ];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr2;
          hr2 = hrtime();
          return hr2[0] * 1e9 + hr2[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports);
  }
});

// node_modules/raf/index.js
var require_raf = __commonJS({
  "node_modules/raf/index.js"(exports, module2) {
    var now2 = require_performance_now();
    var root = typeof window === "undefined" ? global : window;
    var vendors = ["moz", "webkit"];
    var suffix = "AnimationFrame";
    var raf = root["request" + suffix];
    var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (i5 = 0; !raf && i5 < vendors.length; i5++) {
      raf = root[vendors[i5] + "Request" + suffix];
      caf = root[vendors[i5] + "Cancel" + suffix] || root[vendors[i5] + "CancelRequest" + suffix];
    }
    var i5;
    if (!raf || !caf) {
      last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf = function(callback) {
        if (queue.length === 0) {
          var _now = now2(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i6 = 0; i6 < cp.length; i6++) {
              if (!cp[i6].cancelled) {
                try {
                  cp[i6].callback(last);
                } catch (e3) {
                  setTimeout(function() {
                    throw e3;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i6 = 0; i6 < queue.length; i6++) {
          if (queue[i6].handle === handle) {
            queue[i6].cancelled = true;
          }
        }
      };
    }
    var last;
    var id;
    var queue;
    var frameDuration;
    module2.exports = function(fn) {
      return raf.call(root, fn);
    };
    module2.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    module2.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf;
      object.cancelAnimationFrame = caf;
    };
  }
});

// node_modules/core-js/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js/internals/whitespaces.js"(exports, module2) {
    "use strict";
    module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js/internals/string-trim.js"(exports, module2) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var ltrim = RegExp("^[" + whitespaces + "]+");
    var rtrim2 = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE & 1)
          string = replace(string, ltrim, "");
        if (TYPE & 2)
          string = replace(string, rtrim2, "$1");
        return string;
      };
    };
    module2.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js/internals/string-trim-forced.js
var require_string_trim_forced = __commonJS({
  "node_modules/core-js/internals/string-trim-forced.js"(exports, module2) {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var fails = require_fails();
    var whitespaces = require_whitespaces();
    var non = "\u200B\x85\u180E";
    module2.exports = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
  }
});

// node_modules/core-js/modules/es.string.trim.js
var require_es_string_trim = __commonJS({
  "node_modules/core-js/modules/es.string.trim.js"() {
    "use strict";
    var $2 = require_export();
    var $trim = require_string_trim().trim;
    var forcedStringTrimMethod = require_string_trim_forced();
    $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim() {
        return $trim(this);
      }
    });
  }
});

// node_modules/rgbcolor/index.js
var require_rgbcolor = __commonJS({
  "node_modules/rgbcolor/index.js"(exports, module2) {
    module2.exports = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
          example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3]),
              parseFloat(bits3[4])
            ];
          }
        },
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits3) {
            return [
              parseInt(bits3[1]),
              parseInt(bits3[2]),
              parseInt(bits3[3])
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits3) {
            return [
              parseInt(bits3[1], 16),
              parseInt(bits3[2], 16),
              parseInt(bits3[3], 16)
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits3) {
            return [
              parseInt(bits3[1] + bits3[1], 16),
              parseInt(bits3[2] + bits3[2], 16),
              parseInt(bits3[3] + bits3[3], 16)
            ];
          }
        }
      ];
      for (var i5 = 0; i5 < color_defs.length; i5++) {
        var re2 = color_defs[i5].re;
        var processor = color_defs[i5].process;
        var bits2 = re2.exec(color_string);
        if (bits2) {
          var channels = processor(bits2);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r3 = this.r.toString(16);
        var g5 = this.g.toString(16);
        var b2 = this.b.toString(16);
        if (r3.length == 1)
          r3 = "0" + r3;
        if (g5.length == 1)
          g5 = "0" + g5;
        if (b2.length == 1)
          b2 = "0" + b2;
        return "#" + r3 + g5 + b2;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i6 = 0; i6 < color_defs.length; i6++) {
          var example = color_defs[i6].example;
          for (var j3 = 0; j3 < example.length; j3++) {
            examples[examples.length] = example[j3];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml = document.createElement("ul");
        xml.setAttribute("id", "rgbcolor-examples");
        for (var i6 = 0; i6 < examples.length; i6++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i6]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(
              " " + examples[i6] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
            );
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml.appendChild(list_item);
          } catch (e3) {
          }
        }
        return xml;
      };
    };
  }
});

// node_modules/core-js/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js/modules/es.array.index-of.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $2({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js/modules/es.string.includes.js
var require_es_string_includes = __commonJS({
  "node_modules/core-js/modules/es.string.includes.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this();
    var notARegExp = require_not_a_regexp();
    var requireObjectCoercible = require_require_object_coercible();
    var toString = require_to_string();
    var correctIsRegExpLogic = require_correct_is_regexp_logic();
    var stringIndexOf = uncurryThis("".indexOf);
    $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(
          toString(requireObjectCoercible(this)),
          toString(notARegExp(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
  }
});

// node_modules/core-js/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/internals/is-array.js"(exports, module2) {
    "use strict";
    var classof = require_classof_raw();
    module2.exports = Array.isArray || function isArray12(argument) {
      return classof(argument) === "Array";
    };
  }
});

// node_modules/core-js/modules/es.array.reverse.js
var require_es_array_reverse = __commonJS({
  "node_modules/core-js/modules/es.array.reverse.js"() {
    "use strict";
    var $2 = require_export();
    var uncurryThis = require_function_uncurry_this();
    var isArray12 = require_is_array();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $2({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
      reverse: function reverse3() {
        if (isArray12(this))
          this.length = this.length;
        return nativeReverse(this);
      }
    });
  }
});

// node_modules/svg-pathdata/lib/SVGPathData.module.js
function r2(r3, e3) {
  if ("function" != typeof e3 && null !== e3)
    throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
  function i5() {
    this.constructor = r3;
  }
  t3(r3, e3), r3.prototype = null === e3 ? Object.create(e3) : (i5.prototype = e3.prototype, new i5());
}
function e2(t5) {
  var r3 = "";
  Array.isArray(t5) || (t5 = [t5]);
  for (var e3 = 0; e3 < t5.length; e3++) {
    var i5 = t5[e3];
    if (i5.type === _2.CLOSE_PATH)
      r3 += "z";
    else if (i5.type === _2.HORIZ_LINE_TO)
      r3 += (i5.relative ? "h" : "H") + i5.x;
    else if (i5.type === _2.VERT_LINE_TO)
      r3 += (i5.relative ? "v" : "V") + i5.y;
    else if (i5.type === _2.MOVE_TO)
      r3 += (i5.relative ? "m" : "M") + i5.x + " " + i5.y;
    else if (i5.type === _2.LINE_TO)
      r3 += (i5.relative ? "l" : "L") + i5.x + " " + i5.y;
    else if (i5.type === _2.CURVE_TO)
      r3 += (i5.relative ? "c" : "C") + i5.x1 + " " + i5.y1 + " " + i5.x2 + " " + i5.y2 + " " + i5.x + " " + i5.y;
    else if (i5.type === _2.SMOOTH_CURVE_TO)
      r3 += (i5.relative ? "s" : "S") + i5.x2 + " " + i5.y2 + " " + i5.x + " " + i5.y;
    else if (i5.type === _2.QUAD_TO)
      r3 += (i5.relative ? "q" : "Q") + i5.x1 + " " + i5.y1 + " " + i5.x + " " + i5.y;
    else if (i5.type === _2.SMOOTH_QUAD_TO)
      r3 += (i5.relative ? "t" : "T") + i5.x + " " + i5.y;
    else {
      if (i5.type !== _2.ARC)
        throw new Error('Unexpected command type "' + i5.type + '" at index ' + e3 + ".");
      r3 += (i5.relative ? "a" : "A") + i5.rX + " " + i5.rY + " " + i5.xRot + " " + +i5.lArcFlag + " " + +i5.sweepFlag + " " + i5.x + " " + i5.y;
    }
  }
  return r3;
}
function i3(t5, r3) {
  var e3 = t5[0], i5 = t5[1];
  return [e3 * Math.cos(r3) - i5 * Math.sin(r3), e3 * Math.sin(r3) + i5 * Math.cos(r3)];
}
function a2() {
  for (var t5 = [], r3 = 0; r3 < arguments.length; r3++)
    t5[r3] = arguments[r3];
  for (var e3 = 0; e3 < t5.length; e3++)
    if ("number" != typeof t5[e3])
      throw new Error("assertNumbers arguments[" + e3 + "] is not a number. " + typeof t5[e3] + " == typeof " + t5[e3]);
  return true;
}
function o2(t5, r3, e3) {
  t5.lArcFlag = 0 === t5.lArcFlag ? 0 : 1, t5.sweepFlag = 0 === t5.sweepFlag ? 0 : 1;
  var a4 = t5.rX, o4 = t5.rY, s5 = t5.x, u4 = t5.y;
  a4 = Math.abs(t5.rX), o4 = Math.abs(t5.rY);
  var h4 = i3([(r3 - s5) / 2, (e3 - u4) / 2], -t5.xRot / 180 * n3), c5 = h4[0], y3 = h4[1], p7 = Math.pow(c5, 2) / Math.pow(a4, 2) + Math.pow(y3, 2) / Math.pow(o4, 2);
  1 < p7 && (a4 *= Math.sqrt(p7), o4 *= Math.sqrt(p7)), t5.rX = a4, t5.rY = o4;
  var m6 = Math.pow(a4, 2) * Math.pow(y3, 2) + Math.pow(o4, 2) * Math.pow(c5, 2), O3 = (t5.lArcFlag !== t5.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a4, 2) * Math.pow(o4, 2) - m6) / m6)), l4 = a4 * y3 / o4 * O3, T3 = -o4 * c5 / a4 * O3, v4 = i3([l4, T3], t5.xRot / 180 * n3);
  t5.cX = v4[0] + (r3 + s5) / 2, t5.cY = v4[1] + (e3 + u4) / 2, t5.phi1 = Math.atan2((y3 - T3) / o4, (c5 - l4) / a4), t5.phi2 = Math.atan2((-y3 - T3) / o4, (-c5 - l4) / a4), 0 === t5.sweepFlag && t5.phi2 > t5.phi1 && (t5.phi2 -= 2 * n3), 1 === t5.sweepFlag && t5.phi2 < t5.phi1 && (t5.phi2 += 2 * n3), t5.phi1 *= 180 / n3, t5.phi2 *= 180 / n3;
}
function s3(t5, r3, e3) {
  a2(t5, r3, e3);
  var i5 = t5 * t5 + r3 * r3 - e3 * e3;
  if (0 > i5)
    return [];
  if (0 === i5)
    return [[t5 * e3 / (t5 * t5 + r3 * r3), r3 * e3 / (t5 * t5 + r3 * r3)]];
  var n5 = Math.sqrt(i5);
  return [[(t5 * e3 + r3 * n5) / (t5 * t5 + r3 * r3), (r3 * e3 - t5 * n5) / (t5 * t5 + r3 * r3)], [(t5 * e3 - r3 * n5) / (t5 * t5 + r3 * r3), (r3 * e3 + t5 * n5) / (t5 * t5 + r3 * r3)]];
}
function c2(t5, r3, e3) {
  return (1 - e3) * t5 + e3 * r3;
}
function y(t5, r3, e3, i5) {
  return t5 + Math.cos(i5 / 180 * n3) * r3 + Math.sin(i5 / 180 * n3) * e3;
}
function p5(t5, r3, e3, i5) {
  var a4 = 1e-6, n5 = r3 - t5, o4 = e3 - r3, s5 = 3 * n5 + 3 * (i5 - e3) - 6 * o4, u4 = 6 * (o4 - n5), h4 = 3 * n5;
  return Math.abs(s5) < a4 ? [-h4 / u4] : function(t6, r4, e4) {
    void 0 === e4 && (e4 = 1e-6);
    var i6 = t6 * t6 / 4 - r4;
    if (i6 < -e4)
      return [];
    if (i6 <= e4)
      return [-t6 / 2];
    var a5 = Math.sqrt(i6);
    return [-t6 / 2 - a5, -t6 / 2 + a5];
  }(u4 / s5, h4 / s5, a4);
}
function m3(t5, r3, e3, i5, a4) {
  var n5 = 1 - a4;
  return t5 * (n5 * n5 * n5) + r3 * (3 * n5 * n5 * a4) + e3 * (3 * n5 * a4 * a4) + i5 * (a4 * a4 * a4);
}
var t3, n3, u2, h2, O, l2, T, v2, f3, _2, N;
var init_SVGPathData_module = __esm({
  "node_modules/svg-pathdata/lib/SVGPathData.module.js"() {
    t3 = function(r3, e3) {
      return (t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t5, r4) {
        t5.__proto__ = r4;
      } || function(t5, r4) {
        for (var e4 in r4)
          Object.prototype.hasOwnProperty.call(r4, e4) && (t5[e4] = r4[e4]);
      })(r3, e3);
    };
    n3 = Math.PI;
    h2 = Math.PI / 180;
    !function(t5) {
      function r3() {
        return u4(function(t6, r4, e4) {
          return t6.relative && (void 0 !== t6.x1 && (t6.x1 += r4), void 0 !== t6.y1 && (t6.y1 += e4), void 0 !== t6.x2 && (t6.x2 += r4), void 0 !== t6.y2 && (t6.y2 += e4), void 0 !== t6.x && (t6.x += r4), void 0 !== t6.y && (t6.y += e4), t6.relative = false), t6;
        });
      }
      function e3() {
        var t6 = NaN, r4 = NaN, e4 = NaN, i5 = NaN;
        return u4(function(a4, n6, o4) {
          return a4.type & _2.SMOOTH_CURVE_TO && (a4.type = _2.CURVE_TO, t6 = isNaN(t6) ? n6 : t6, r4 = isNaN(r4) ? o4 : r4, a4.x1 = a4.relative ? n6 - t6 : 2 * n6 - t6, a4.y1 = a4.relative ? o4 - r4 : 2 * o4 - r4), a4.type & _2.CURVE_TO ? (t6 = a4.relative ? n6 + a4.x2 : a4.x2, r4 = a4.relative ? o4 + a4.y2 : a4.y2) : (t6 = NaN, r4 = NaN), a4.type & _2.SMOOTH_QUAD_TO && (a4.type = _2.QUAD_TO, e4 = isNaN(e4) ? n6 : e4, i5 = isNaN(i5) ? o4 : i5, a4.x1 = a4.relative ? n6 - e4 : 2 * n6 - e4, a4.y1 = a4.relative ? o4 - i5 : 2 * o4 - i5), a4.type & _2.QUAD_TO ? (e4 = a4.relative ? n6 + a4.x1 : a4.x1, i5 = a4.relative ? o4 + a4.y1 : a4.y1) : (e4 = NaN, i5 = NaN), a4;
        });
      }
      function n5() {
        var t6 = NaN, r4 = NaN;
        return u4(function(e4, i5, a4) {
          if (e4.type & _2.SMOOTH_QUAD_TO && (e4.type = _2.QUAD_TO, t6 = isNaN(t6) ? i5 : t6, r4 = isNaN(r4) ? a4 : r4, e4.x1 = e4.relative ? i5 - t6 : 2 * i5 - t6, e4.y1 = e4.relative ? a4 - r4 : 2 * a4 - r4), e4.type & _2.QUAD_TO) {
            t6 = e4.relative ? i5 + e4.x1 : e4.x1, r4 = e4.relative ? a4 + e4.y1 : e4.y1;
            var n6 = e4.x1, o4 = e4.y1;
            e4.type = _2.CURVE_TO, e4.x1 = ((e4.relative ? 0 : i5) + 2 * n6) / 3, e4.y1 = ((e4.relative ? 0 : a4) + 2 * o4) / 3, e4.x2 = (e4.x + 2 * n6) / 3, e4.y2 = (e4.y + 2 * o4) / 3;
          } else
            t6 = NaN, r4 = NaN;
          return e4;
        });
      }
      function u4(t6) {
        var r4 = 0, e4 = 0, i5 = NaN, a4 = NaN;
        return function(n6) {
          if (isNaN(i5) && !(n6.type & _2.MOVE_TO))
            throw new Error("path must start with moveto");
          var o4 = t6(n6, r4, e4, i5, a4);
          return n6.type & _2.CLOSE_PATH && (r4 = i5, e4 = a4), void 0 !== n6.x && (r4 = n6.relative ? r4 + n6.x : n6.x), void 0 !== n6.y && (e4 = n6.relative ? e4 + n6.y : n6.y), n6.type & _2.MOVE_TO && (i5 = r4, a4 = e4), o4;
        };
      }
      function O3(t6, r4, e4, i5, n6, o4) {
        return a2(t6, r4, e4, i5, n6, o4), u4(function(a4, s5, u5, h4) {
          var c5 = a4.x1, y3 = a4.x2, p7 = a4.relative && !isNaN(h4), m6 = void 0 !== a4.x ? a4.x : p7 ? 0 : s5, O4 = void 0 !== a4.y ? a4.y : p7 ? 0 : u5;
          function l5(t7) {
            return t7 * t7;
          }
          a4.type & _2.HORIZ_LINE_TO && 0 !== r4 && (a4.type = _2.LINE_TO, a4.y = a4.relative ? 0 : u5), a4.type & _2.VERT_LINE_TO && 0 !== e4 && (a4.type = _2.LINE_TO, a4.x = a4.relative ? 0 : s5), void 0 !== a4.x && (a4.x = a4.x * t6 + O4 * e4 + (p7 ? 0 : n6)), void 0 !== a4.y && (a4.y = m6 * r4 + a4.y * i5 + (p7 ? 0 : o4)), void 0 !== a4.x1 && (a4.x1 = a4.x1 * t6 + a4.y1 * e4 + (p7 ? 0 : n6)), void 0 !== a4.y1 && (a4.y1 = c5 * r4 + a4.y1 * i5 + (p7 ? 0 : o4)), void 0 !== a4.x2 && (a4.x2 = a4.x2 * t6 + a4.y2 * e4 + (p7 ? 0 : n6)), void 0 !== a4.y2 && (a4.y2 = y3 * r4 + a4.y2 * i5 + (p7 ? 0 : o4));
          var T3 = t6 * i5 - r4 * e4;
          if (void 0 !== a4.xRot && (1 !== t6 || 0 !== r4 || 0 !== e4 || 1 !== i5))
            if (0 === T3)
              delete a4.rX, delete a4.rY, delete a4.xRot, delete a4.lArcFlag, delete a4.sweepFlag, a4.type = _2.LINE_TO;
            else {
              var v4 = a4.xRot * Math.PI / 180, f5 = Math.sin(v4), N3 = Math.cos(v4), x2 = 1 / l5(a4.rX), d3 = 1 / l5(a4.rY), E2 = l5(N3) * x2 + l5(f5) * d3, A2 = 2 * f5 * N3 * (x2 - d3), C2 = l5(f5) * x2 + l5(N3) * d3, M2 = E2 * i5 * i5 - A2 * r4 * i5 + C2 * r4 * r4, R2 = A2 * (t6 * i5 + r4 * e4) - 2 * (E2 * e4 * i5 + C2 * t6 * r4), g5 = E2 * e4 * e4 - A2 * t6 * e4 + C2 * t6 * t6, I2 = (Math.atan2(R2, M2 - g5) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
              a4.rX = Math.abs(T3) / Math.sqrt(M2 * l5(L2) + R2 * S2 * L2 + g5 * l5(S2)), a4.rY = Math.abs(T3) / Math.sqrt(M2 * l5(S2) - R2 * S2 * L2 + g5 * l5(L2)), a4.xRot = 180 * I2 / Math.PI;
            }
          return void 0 !== a4.sweepFlag && 0 > T3 && (a4.sweepFlag = +!a4.sweepFlag), a4;
        });
      }
      function l4() {
        return function(t6) {
          var r4 = {};
          for (var e4 in t6)
            r4[e4] = t6[e4];
          return r4;
        };
      }
      t5.ROUND = function(t6) {
        function r4(r5) {
          return Math.round(r5 * t6) / t6;
        }
        return void 0 === t6 && (t6 = 1e13), a2(t6), function(t7) {
          return void 0 !== t7.x1 && (t7.x1 = r4(t7.x1)), void 0 !== t7.y1 && (t7.y1 = r4(t7.y1)), void 0 !== t7.x2 && (t7.x2 = r4(t7.x2)), void 0 !== t7.y2 && (t7.y2 = r4(t7.y2)), void 0 !== t7.x && (t7.x = r4(t7.x)), void 0 !== t7.y && (t7.y = r4(t7.y)), void 0 !== t7.rX && (t7.rX = r4(t7.rX)), void 0 !== t7.rY && (t7.rY = r4(t7.rY)), t7;
        };
      }, t5.TO_ABS = r3, t5.TO_REL = function() {
        return u4(function(t6, r4, e4) {
          return t6.relative || (void 0 !== t6.x1 && (t6.x1 -= r4), void 0 !== t6.y1 && (t6.y1 -= e4), void 0 !== t6.x2 && (t6.x2 -= r4), void 0 !== t6.y2 && (t6.y2 -= e4), void 0 !== t6.x && (t6.x -= r4), void 0 !== t6.y && (t6.y -= e4), t6.relative = true), t6;
        });
      }, t5.NORMALIZE_HVZ = function(t6, r4, e4) {
        return void 0 === t6 && (t6 = true), void 0 === r4 && (r4 = true), void 0 === e4 && (e4 = true), u4(function(i5, a4, n6, o4, s5) {
          if (isNaN(o4) && !(i5.type & _2.MOVE_TO))
            throw new Error("path must start with moveto");
          return r4 && i5.type & _2.HORIZ_LINE_TO && (i5.type = _2.LINE_TO, i5.y = i5.relative ? 0 : n6), e4 && i5.type & _2.VERT_LINE_TO && (i5.type = _2.LINE_TO, i5.x = i5.relative ? 0 : a4), t6 && i5.type & _2.CLOSE_PATH && (i5.type = _2.LINE_TO, i5.x = i5.relative ? o4 - a4 : o4, i5.y = i5.relative ? s5 - n6 : s5), i5.type & _2.ARC && (0 === i5.rX || 0 === i5.rY) && (i5.type = _2.LINE_TO, delete i5.rX, delete i5.rY, delete i5.xRot, delete i5.lArcFlag, delete i5.sweepFlag), i5;
        });
      }, t5.NORMALIZE_ST = e3, t5.QT_TO_C = n5, t5.INFO = u4, t5.SANITIZE = function(t6) {
        void 0 === t6 && (t6 = 0), a2(t6);
        var r4 = NaN, e4 = NaN, i5 = NaN, n6 = NaN;
        return u4(function(a4, o4, s5, u5, h4) {
          var c5 = Math.abs, y3 = false, p7 = 0, m6 = 0;
          if (a4.type & _2.SMOOTH_CURVE_TO && (p7 = isNaN(r4) ? 0 : o4 - r4, m6 = isNaN(e4) ? 0 : s5 - e4), a4.type & (_2.CURVE_TO | _2.SMOOTH_CURVE_TO) ? (r4 = a4.relative ? o4 + a4.x2 : a4.x2, e4 = a4.relative ? s5 + a4.y2 : a4.y2) : (r4 = NaN, e4 = NaN), a4.type & _2.SMOOTH_QUAD_TO ? (i5 = isNaN(i5) ? o4 : 2 * o4 - i5, n6 = isNaN(n6) ? s5 : 2 * s5 - n6) : a4.type & _2.QUAD_TO ? (i5 = a4.relative ? o4 + a4.x1 : a4.x1, n6 = a4.relative ? s5 + a4.y1 : a4.y2) : (i5 = NaN, n6 = NaN), a4.type & _2.LINE_COMMANDS || a4.type & _2.ARC && (0 === a4.rX || 0 === a4.rY || !a4.lArcFlag) || a4.type & _2.CURVE_TO || a4.type & _2.SMOOTH_CURVE_TO || a4.type & _2.QUAD_TO || a4.type & _2.SMOOTH_QUAD_TO) {
            var O4 = void 0 === a4.x ? 0 : a4.relative ? a4.x : a4.x - o4, l5 = void 0 === a4.y ? 0 : a4.relative ? a4.y : a4.y - s5;
            p7 = isNaN(i5) ? void 0 === a4.x1 ? p7 : a4.relative ? a4.x : a4.x1 - o4 : i5 - o4, m6 = isNaN(n6) ? void 0 === a4.y1 ? m6 : a4.relative ? a4.y : a4.y1 - s5 : n6 - s5;
            var T3 = void 0 === a4.x2 ? 0 : a4.relative ? a4.x : a4.x2 - o4, v4 = void 0 === a4.y2 ? 0 : a4.relative ? a4.y : a4.y2 - s5;
            c5(O4) <= t6 && c5(l5) <= t6 && c5(p7) <= t6 && c5(m6) <= t6 && c5(T3) <= t6 && c5(v4) <= t6 && (y3 = true);
          }
          return a4.type & _2.CLOSE_PATH && c5(o4 - u5) <= t6 && c5(s5 - h4) <= t6 && (y3 = true), y3 ? [] : a4;
        });
      }, t5.MATRIX = O3, t5.ROTATE = function(t6, r4, e4) {
        void 0 === r4 && (r4 = 0), void 0 === e4 && (e4 = 0), a2(t6, r4, e4);
        var i5 = Math.sin(t6), n6 = Math.cos(t6);
        return O3(n6, i5, -i5, n6, r4 - r4 * n6 + e4 * i5, e4 - r4 * i5 - e4 * n6);
      }, t5.TRANSLATE = function(t6, r4) {
        return void 0 === r4 && (r4 = 0), a2(t6, r4), O3(1, 0, 0, 1, t6, r4);
      }, t5.SCALE = function(t6, r4) {
        return void 0 === r4 && (r4 = t6), a2(t6, r4), O3(t6, 0, 0, r4, 0, 0);
      }, t5.SKEW_X = function(t6) {
        return a2(t6), O3(1, 0, Math.atan(t6), 1, 0, 0);
      }, t5.SKEW_Y = function(t6) {
        return a2(t6), O3(1, Math.atan(t6), 0, 1, 0, 0);
      }, t5.X_AXIS_SYMMETRY = function(t6) {
        return void 0 === t6 && (t6 = 0), a2(t6), O3(-1, 0, 0, 1, t6, 0);
      }, t5.Y_AXIS_SYMMETRY = function(t6) {
        return void 0 === t6 && (t6 = 0), a2(t6), O3(1, 0, 0, -1, 0, t6);
      }, t5.A_TO_C = function() {
        return u4(function(t6, r4, e4) {
          return _2.ARC === t6.type ? function(t7, r5, e5) {
            var a4, n6, s5, u5;
            t7.cX || o2(t7, r5, e5);
            for (var y3 = Math.min(t7.phi1, t7.phi2), p7 = Math.max(t7.phi1, t7.phi2) - y3, m6 = Math.ceil(p7 / 90), O4 = new Array(m6), l5 = r5, T3 = e5, v4 = 0; v4 < m6; v4++) {
              var f5 = c2(t7.phi1, t7.phi2, v4 / m6), N3 = c2(t7.phi1, t7.phi2, (v4 + 1) / m6), x2 = N3 - f5, d3 = 4 / 3 * Math.tan(x2 * h2 / 4), E2 = [Math.cos(f5 * h2) - d3 * Math.sin(f5 * h2), Math.sin(f5 * h2) + d3 * Math.cos(f5 * h2)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N3 * h2), Math.sin(N3 * h2)], R2 = M2[0], g5 = M2[1], I2 = [R2 + d3 * Math.sin(N3 * h2), g5 - d3 * Math.cos(N3 * h2)], S2 = I2[0], L2 = I2[1];
              O4[v4] = { relative: t7.relative, type: _2.CURVE_TO };
              var H2 = function(r6, e6) {
                var a5 = i3([r6 * t7.rX, e6 * t7.rY], t7.xRot), n7 = a5[0], o4 = a5[1];
                return [t7.cX + n7, t7.cY + o4];
              };
              a4 = H2(A2, C2), O4[v4].x1 = a4[0], O4[v4].y1 = a4[1], n6 = H2(S2, L2), O4[v4].x2 = n6[0], O4[v4].y2 = n6[1], s5 = H2(R2, g5), O4[v4].x = s5[0], O4[v4].y = s5[1], t7.relative && (O4[v4].x1 -= l5, O4[v4].y1 -= T3, O4[v4].x2 -= l5, O4[v4].y2 -= T3, O4[v4].x -= l5, O4[v4].y -= T3), l5 = (u5 = [O4[v4].x, O4[v4].y])[0], T3 = u5[1];
            }
            return O4;
          }(t6, t6.relative ? 0 : r4, t6.relative ? 0 : e4) : t6;
        });
      }, t5.ANNOTATE_ARCS = function() {
        return u4(function(t6, r4, e4) {
          return t6.relative && (r4 = 0, e4 = 0), _2.ARC === t6.type && o2(t6, r4, e4), t6;
        });
      }, t5.CLONE = l4, t5.CALCULATE_BOUNDS = function() {
        var t6 = function(t7) {
          var r4 = {};
          for (var e4 in t7)
            r4[e4] = t7[e4];
          return r4;
        }, i5 = r3(), a4 = n5(), h4 = e3(), c5 = u4(function(r4, e4, n6) {
          var u5 = h4(a4(i5(t6(r4))));
          function O4(t7) {
            t7 > c5.maxX && (c5.maxX = t7), t7 < c5.minX && (c5.minX = t7);
          }
          function l5(t7) {
            t7 > c5.maxY && (c5.maxY = t7), t7 < c5.minY && (c5.minY = t7);
          }
          if (u5.type & _2.DRAWING_COMMANDS && (O4(e4), l5(n6)), u5.type & _2.HORIZ_LINE_TO && O4(u5.x), u5.type & _2.VERT_LINE_TO && l5(u5.y), u5.type & _2.LINE_TO && (O4(u5.x), l5(u5.y)), u5.type & _2.CURVE_TO) {
            O4(u5.x), l5(u5.y);
            for (var T3 = 0, v4 = p5(e4, u5.x1, u5.x2, u5.x); T3 < v4.length; T3++) {
              0 < (w2 = v4[T3]) && 1 > w2 && O4(m3(e4, u5.x1, u5.x2, u5.x, w2));
            }
            for (var f5 = 0, N3 = p5(n6, u5.y1, u5.y2, u5.y); f5 < N3.length; f5++) {
              0 < (w2 = N3[f5]) && 1 > w2 && l5(m3(n6, u5.y1, u5.y2, u5.y, w2));
            }
          }
          if (u5.type & _2.ARC) {
            O4(u5.x), l5(u5.y), o2(u5, e4, n6);
            for (var x2 = u5.xRot / 180 * Math.PI, d3 = Math.cos(x2) * u5.rX, E2 = Math.sin(x2) * u5.rX, A2 = -Math.sin(x2) * u5.rY, C2 = Math.cos(x2) * u5.rY, M2 = u5.phi1 < u5.phi2 ? [u5.phi1, u5.phi2] : -180 > u5.phi2 ? [u5.phi2 + 360, u5.phi1 + 360] : [u5.phi2, u5.phi1], R2 = M2[0], g5 = M2[1], I2 = function(t7) {
              var r5 = t7[0], e5 = t7[1], i6 = 180 * Math.atan2(e5, r5) / Math.PI;
              return i6 < R2 ? i6 + 360 : i6;
            }, S2 = 0, L2 = s3(A2, -d3, 0).map(I2); S2 < L2.length; S2++) {
              (w2 = L2[S2]) > R2 && w2 < g5 && O4(y(u5.cX, d3, A2, w2));
            }
            for (var H2 = 0, U2 = s3(C2, -E2, 0).map(I2); H2 < U2.length; H2++) {
              var w2;
              (w2 = U2[H2]) > R2 && w2 < g5 && l5(y(u5.cY, E2, C2, w2));
            }
          }
          return r4;
        });
        return c5.minX = 1 / 0, c5.maxX = -1 / 0, c5.minY = 1 / 0, c5.maxY = -1 / 0, c5;
      };
    }(u2 || (u2 = {}));
    l2 = function() {
      function t5() {
      }
      return t5.prototype.round = function(t6) {
        return this.transform(u2.ROUND(t6));
      }, t5.prototype.toAbs = function() {
        return this.transform(u2.TO_ABS());
      }, t5.prototype.toRel = function() {
        return this.transform(u2.TO_REL());
      }, t5.prototype.normalizeHVZ = function(t6, r3, e3) {
        return this.transform(u2.NORMALIZE_HVZ(t6, r3, e3));
      }, t5.prototype.normalizeST = function() {
        return this.transform(u2.NORMALIZE_ST());
      }, t5.prototype.qtToC = function() {
        return this.transform(u2.QT_TO_C());
      }, t5.prototype.aToC = function() {
        return this.transform(u2.A_TO_C());
      }, t5.prototype.sanitize = function(t6) {
        return this.transform(u2.SANITIZE(t6));
      }, t5.prototype.translate = function(t6, r3) {
        return this.transform(u2.TRANSLATE(t6, r3));
      }, t5.prototype.scale = function(t6, r3) {
        return this.transform(u2.SCALE(t6, r3));
      }, t5.prototype.rotate = function(t6, r3, e3) {
        return this.transform(u2.ROTATE(t6, r3, e3));
      }, t5.prototype.matrix = function(t6, r3, e3, i5, a4, n5) {
        return this.transform(u2.MATRIX(t6, r3, e3, i5, a4, n5));
      }, t5.prototype.skewX = function(t6) {
        return this.transform(u2.SKEW_X(t6));
      }, t5.prototype.skewY = function(t6) {
        return this.transform(u2.SKEW_Y(t6));
      }, t5.prototype.xSymmetry = function(t6) {
        return this.transform(u2.X_AXIS_SYMMETRY(t6));
      }, t5.prototype.ySymmetry = function(t6) {
        return this.transform(u2.Y_AXIS_SYMMETRY(t6));
      }, t5.prototype.annotateArcs = function() {
        return this.transform(u2.ANNOTATE_ARCS());
      }, t5;
    }();
    T = function(t5) {
      return " " === t5 || "	" === t5 || "\r" === t5 || "\n" === t5;
    };
    v2 = function(t5) {
      return "0".charCodeAt(0) <= t5.charCodeAt(0) && t5.charCodeAt(0) <= "9".charCodeAt(0);
    };
    f3 = function(t5) {
      function e3() {
        var r3 = t5.call(this) || this;
        return r3.curNumber = "", r3.curCommandType = -1, r3.curCommandRelative = false, r3.canParseCommandOrComma = true, r3.curNumberHasExp = false, r3.curNumberHasExpDigits = false, r3.curNumberHasDecimal = false, r3.curArgs = [], r3;
      }
      return r2(e3, t5), e3.prototype.finish = function(t6) {
        if (void 0 === t6 && (t6 = []), this.parse(" ", t6), 0 !== this.curArgs.length || !this.canParseCommandOrComma)
          throw new SyntaxError("Unterminated command at the path end.");
        return t6;
      }, e3.prototype.parse = function(t6, r3) {
        var e4 = this;
        void 0 === r3 && (r3 = []);
        for (var i5 = function(t7) {
          r3.push(t7), e4.curArgs.length = 0, e4.canParseCommandOrComma = true;
        }, a4 = 0; a4 < t6.length; a4++) {
          var n5 = t6[a4], o4 = !(this.curCommandType !== _2.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s5 = v2(n5) && ("0" === this.curNumber && "0" === n5 || o4);
          if (!v2(n5) || s5)
            if ("e" !== n5 && "E" !== n5)
              if ("-" !== n5 && "+" !== n5 || !this.curNumberHasExp || this.curNumberHasExpDigits)
                if ("." !== n5 || this.curNumberHasExp || this.curNumberHasDecimal || o4) {
                  if (this.curNumber && -1 !== this.curCommandType) {
                    var u4 = Number(this.curNumber);
                    if (isNaN(u4))
                      throw new SyntaxError("Invalid number ending at " + a4);
                    if (this.curCommandType === _2.ARC) {
                      if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                        if (0 > u4)
                          throw new SyntaxError('Expected positive number, got "' + u4 + '" at index "' + a4 + '"');
                      } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber)
                        throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a4 + '"');
                    }
                    this.curArgs.push(u4), this.curArgs.length === N[this.curCommandType] && (_2.HORIZ_LINE_TO === this.curCommandType ? i5({ type: _2.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u4 }) : _2.VERT_LINE_TO === this.curCommandType ? i5({ type: _2.VERT_LINE_TO, relative: this.curCommandRelative, y: u4 }) : this.curCommandType === _2.MOVE_TO || this.curCommandType === _2.LINE_TO || this.curCommandType === _2.SMOOTH_QUAD_TO ? (i5({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _2.MOVE_TO === this.curCommandType && (this.curCommandType = _2.LINE_TO)) : this.curCommandType === _2.CURVE_TO ? i5({ type: _2.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _2.SMOOTH_CURVE_TO ? i5({ type: _2.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _2.QUAD_TO ? i5({ type: _2.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _2.ARC && i5({ type: _2.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
                  }
                  if (!T(n5))
                    if ("," === n5 && this.canParseCommandOrComma)
                      this.canParseCommandOrComma = false;
                    else if ("+" !== n5 && "-" !== n5 && "." !== n5)
                      if (s5)
                        this.curNumber = n5, this.curNumberHasDecimal = false;
                      else {
                        if (0 !== this.curArgs.length)
                          throw new SyntaxError("Unterminated command at index " + a4 + ".");
                        if (!this.canParseCommandOrComma)
                          throw new SyntaxError('Unexpected character "' + n5 + '" at index ' + a4 + ". Command cannot follow comma");
                        if (this.canParseCommandOrComma = false, "z" !== n5 && "Z" !== n5)
                          if ("h" === n5 || "H" === n5)
                            this.curCommandType = _2.HORIZ_LINE_TO, this.curCommandRelative = "h" === n5;
                          else if ("v" === n5 || "V" === n5)
                            this.curCommandType = _2.VERT_LINE_TO, this.curCommandRelative = "v" === n5;
                          else if ("m" === n5 || "M" === n5)
                            this.curCommandType = _2.MOVE_TO, this.curCommandRelative = "m" === n5;
                          else if ("l" === n5 || "L" === n5)
                            this.curCommandType = _2.LINE_TO, this.curCommandRelative = "l" === n5;
                          else if ("c" === n5 || "C" === n5)
                            this.curCommandType = _2.CURVE_TO, this.curCommandRelative = "c" === n5;
                          else if ("s" === n5 || "S" === n5)
                            this.curCommandType = _2.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n5;
                          else if ("q" === n5 || "Q" === n5)
                            this.curCommandType = _2.QUAD_TO, this.curCommandRelative = "q" === n5;
                          else if ("t" === n5 || "T" === n5)
                            this.curCommandType = _2.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n5;
                          else {
                            if ("a" !== n5 && "A" !== n5)
                              throw new SyntaxError('Unexpected character "' + n5 + '" at index ' + a4 + ".");
                            this.curCommandType = _2.ARC, this.curCommandRelative = "a" === n5;
                          }
                        else
                          r3.push({ type: _2.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
                      }
                    else
                      this.curNumber = n5, this.curNumberHasDecimal = "." === n5;
                } else
                  this.curNumber += n5, this.curNumberHasDecimal = true;
              else
                this.curNumber += n5;
            else
              this.curNumber += n5, this.curNumberHasExp = true;
          else
            this.curNumber += n5, this.curNumberHasExpDigits = this.curNumberHasExp;
        }
        return r3;
      }, e3.prototype.transform = function(t6) {
        return Object.create(this, { parse: { value: function(r3, e4) {
          void 0 === e4 && (e4 = []);
          for (var i5 = 0, a4 = Object.getPrototypeOf(this).parse.call(this, r3); i5 < a4.length; i5++) {
            var n5 = a4[i5], o4 = t6(n5);
            Array.isArray(o4) ? e4.push.apply(e4, o4) : e4.push(o4);
          }
          return e4;
        } } });
      }, e3;
    }(l2);
    _2 = function(t5) {
      function i5(r3) {
        var e3 = t5.call(this) || this;
        return e3.commands = "string" == typeof r3 ? i5.parse(r3) : r3, e3;
      }
      return r2(i5, t5), i5.prototype.encode = function() {
        return i5.encode(this.commands);
      }, i5.prototype.getBounds = function() {
        var t6 = u2.CALCULATE_BOUNDS();
        return this.transform(t6), t6;
      }, i5.prototype.transform = function(t6) {
        for (var r3 = [], e3 = 0, i6 = this.commands; e3 < i6.length; e3++) {
          var a4 = t6(i6[e3]);
          Array.isArray(a4) ? r3.push.apply(r3, a4) : r3.push(a4);
        }
        return this.commands = r3, this;
      }, i5.encode = function(t6) {
        return e2(t6);
      }, i5.parse = function(t6) {
        var r3 = new f3(), e3 = [];
        return r3.parse(t6, e3), r3.finish(e3), e3;
      }, i5.CLOSE_PATH = 1, i5.MOVE_TO = 2, i5.HORIZ_LINE_TO = 4, i5.VERT_LINE_TO = 8, i5.LINE_TO = 16, i5.CURVE_TO = 32, i5.SMOOTH_CURVE_TO = 64, i5.QUAD_TO = 128, i5.SMOOTH_QUAD_TO = 256, i5.ARC = 512, i5.LINE_COMMANDS = i5.LINE_TO | i5.HORIZ_LINE_TO | i5.VERT_LINE_TO, i5.DRAWING_COMMANDS = i5.HORIZ_LINE_TO | i5.VERT_LINE_TO | i5.LINE_TO | i5.CURVE_TO | i5.SMOOTH_CURVE_TO | i5.QUAD_TO | i5.SMOOTH_QUAD_TO | i5.ARC, i5;
    }(l2);
    N = ((O = {})[_2.MOVE_TO] = 2, O[_2.LINE_TO] = 2, O[_2.HORIZ_LINE_TO] = 1, O[_2.VERT_LINE_TO] = 1, O[_2.CLOSE_PATH] = 0, O[_2.QUAD_TO] = 4, O[_2.SMOOTH_QUAD_TO] = 2, O[_2.CURVE_TO] = 6, O[_2.SMOOTH_CURVE_TO] = 4, O[_2.ARC] = 7, O);
  }
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js/internals/regexp-get-flags.js"(exports, module2) {
    "use strict";
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module2.exports = function(R2) {
      var flags = R2.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R2, "flags") && isPrototypeOf(RegExpPrototype, R2) ? call(regExpFlags, R2) : flags;
    };
  }
});

// node_modules/core-js/modules/es.regexp.to-string.js
var require_es_regexp_to_string = __commonJS({
  "node_modules/core-js/modules/es.regexp.to-string.js"() {
    "use strict";
    var PROPER_FUNCTION_NAME = require_function_name().PROPER;
    var defineBuiltIn = require_define_built_in();
    var anObject = require_an_object();
    var $toString = require_to_string();
    var fails = require_fails();
    var getRegExpFlags = require_regexp_get_flags();
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
        var R2 = anObject(this);
        var pattern = $toString(R2.source);
        var flags = $toString(getRegExpFlags(R2));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
  }
});

// node_modules/stackblur-canvas/dist/stackblur-es.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof2(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e3) {
    throw new Error("unable to access image data: " + e3);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i5 = 1; i5 < div; i5++) {
    stack = stack.next = new BlurStack();
    if (i5 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y3 = 0; y3 < height; y3++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p7 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r3 = pixels[p7], g5 = pixels[p7 + 1], b2 = pixels[p7 + 2], a4 = pixels[p7 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r3) * rbs;
      gSum += (stack.g = g5) * rbs;
      bSum += (stack.b = b2) * rbs;
      aSum += (stack.a = a4) * rbs;
      rInSum += r3;
      gInSum += g5;
      bInSum += b2;
      aInSum += a4;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width; x2++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var mulTable, shgTable, BlurStack;
var init_stackblur_es = __esm({
  "node_modules/stackblur-canvas/dist/stackblur-es.js"() {
    mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    BlurStack = /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    };
  }
});

// node_modules/canvg/lib/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  AElement: () => AElement,
  AnimateColorElement: () => AnimateColorElement,
  AnimateElement: () => AnimateElement,
  AnimateTransformElement: () => AnimateTransformElement,
  BoundingBox: () => BoundingBox,
  CB1: () => CB1,
  CB2: () => CB2,
  CB3: () => CB3,
  CB4: () => CB4,
  Canvg: () => Canvg,
  CircleElement: () => CircleElement,
  ClipPathElement: () => ClipPathElement,
  DefsElement: () => DefsElement,
  DescElement: () => DescElement,
  Document: () => Document,
  Element: () => Element2,
  EllipseElement: () => EllipseElement,
  FeColorMatrixElement: () => FeColorMatrixElement,
  FeCompositeElement: () => FeCompositeElement,
  FeDropShadowElement: () => FeDropShadowElement,
  FeGaussianBlurElement: () => FeGaussianBlurElement,
  FeMorphologyElement: () => FeMorphologyElement,
  FilterElement: () => FilterElement,
  Font: () => Font,
  FontElement: () => FontElement,
  FontFaceElement: () => FontFaceElement,
  GElement: () => GElement,
  GlyphElement: () => GlyphElement,
  GradientElement: () => GradientElement,
  ImageElement: () => ImageElement,
  LineElement: () => LineElement,
  LinearGradientElement: () => LinearGradientElement,
  MarkerElement: () => MarkerElement,
  MaskElement: () => MaskElement,
  Matrix: () => Matrix,
  MissingGlyphElement: () => MissingGlyphElement,
  Mouse: () => Mouse,
  PSEUDO_ZERO: () => PSEUDO_ZERO,
  Parser: () => Parser,
  PathElement: () => PathElement,
  PathParser: () => PathParser,
  PatternElement: () => PatternElement,
  Point: () => Point,
  PolygonElement: () => PolygonElement,
  PolylineElement: () => PolylineElement,
  Property: () => Property,
  QB1: () => QB1,
  QB2: () => QB2,
  QB3: () => QB3,
  RadialGradientElement: () => RadialGradientElement,
  RectElement: () => RectElement,
  RenderedElement: () => RenderedElement,
  Rotate: () => Rotate,
  SVGElement: () => SVGElement,
  SVGFontLoader: () => SVGFontLoader,
  Scale: () => Scale,
  Screen: () => Screen,
  Skew: () => Skew,
  SkewX: () => SkewX,
  SkewY: () => SkewY,
  StopElement: () => StopElement,
  StyleElement: () => StyleElement,
  SymbolElement: () => SymbolElement,
  TRefElement: () => TRefElement,
  TSpanElement: () => TSpanElement,
  TextElement: () => TextElement,
  TextPathElement: () => TextPathElement,
  TitleElement: () => TitleElement,
  Transform: () => Transform,
  Translate: () => Translate,
  UnknownElement: () => UnknownElement,
  UseElement: () => UseElement,
  ViewPort: () => ViewPort,
  compressSpaces: () => compressSpaces,
  default: () => Canvg,
  getSelectorSpecificity: () => getSelectorSpecificity,
  normalizeAttributeName: () => normalizeAttributeName,
  normalizeColor: () => normalizeColor,
  parseExternalUrl: () => parseExternalUrl,
  presets: () => index3,
  toNumbers: () => toNumbers,
  trimLeft: () => trimLeft,
  trimRight: () => trimRight,
  vectorMagnitude: () => vectorMagnitude,
  vectorsAngle: () => vectorsAngle,
  vectorsRatio: () => vectorsRatio
});
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches3 = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches3.map(parseFloat);
}
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color) {
  if (!color.startsWith("rgb")) {
    return color;
  }
  var rgbParts = 3;
  var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
function findSelectorMatch(selector, regex) {
  var matches3 = regex.exec(selector);
  if (!matches3) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches3.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
function vectorMagnitude(v4) {
  return Math.sqrt(Math.pow(v4[0], 2) + Math.pow(v4[1], 2));
}
function vectorsRatio(u4, v4) {
  return (u4[0] * v4[0] + u4[1] * v4[1]) / (vectorMagnitude(u4) * vectorMagnitude(v4));
}
function vectorsAngle(u4, v4) {
  return (u4[0] * v4[1] < u4[1] * v4[0] ? -1 : 1) * Math.acos(vectorsRatio(u4, v4));
}
function CB1(t5) {
  return t5 * t5 * t5;
}
function CB2(t5) {
  return 3 * t5 * t5 * (1 - t5);
}
function CB3(t5) {
  return 3 * t5 * (1 - t5) * (1 - t5);
}
function CB4(t5) {
  return (1 - t5) * (1 - t5) * (1 - t5);
}
function QB1(t5) {
  return t5 * t5;
}
function QB2(t5) {
  return 2 * t5 * (1 - t5);
}
function QB3(t5) {
  return (1 - t5) * (1 - t5);
}
function parseTransforms(transform) {
  return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform) {
  var [type, value] = transform.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
function wrapFontFamily(fontFamily) {
  var trimmed = fontFamily.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily) {
  return typeof process === "undefined" ? fontFamily : fontFamily.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle) {
  if (!fontStyle) {
    return "";
  }
  var targetFontStyle = fontStyle.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight) {
  if (!fontWeight) {
    return "";
  }
  var targetFontWeight = fontWeight.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = arguments[i5] != null ? arguments[i5] : {};
    if (i5 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function imGet(img, x2, y3, width, _height, rgba) {
  return img[y3 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y3, width, _height, rgba, val) {
  img[y3 * width * 4 + x2 * 4 + rgba] = val;
}
function m4(matrix, i5, v4) {
  var mi = matrix[i5];
  return mi * v4;
}
function c3(a4, m1, m22, m32) {
  return m1 + Math.cos(a4) * m22 + Math.sin(a4) * m32;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = arguments[i5] != null ? arguments[i5] : {};
    if (i5 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage2(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image = document.createElement("img");
    if (anonymousCrossOrigin) {
      image.crossOrigin = "Anonymous";
    }
    return new Promise((resolve, reject) => {
      image.onload = () => {
        resolve(image);
      };
      image.onerror = (_event, _source, _lineno, _colno, error) => {
        reject(error);
      };
      image.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols2);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = arguments[i5] != null ? arguments[i5] : {};
    if (i5 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_es_promise, import_es_string_match, import_es_string_replace, import_es_string_starts_with, import_es_array_iterator, import_web_dom_collections_iterator, import_es_array_reduce, import_es_string_ends_with, import_es_string_split, import_raf, import_es_string_trim, import_rgbcolor, import_es_array_index_of, import_es_string_includes, import_es_array_reverse, import_es_regexp_to_string, index3, allUppercase, attributeRegex, idRegex, classRegex, pseudoElementRegex, pseudoClassWithBracketsRegex, pseudoClassRegex, elementRegex, PSEUDO_ZERO, Property, ViewPort, Point, Mouse, defaultWindow, defaultFetch$1, Screen, defaultFetch, DefaultDOMParser, Parser, Translate, Rotate, Scale, Matrix, Skew, SkewX, SkewY, Transform, Element2, UnknownElement, Font, BoundingBox, PathParser, RenderedElement, PathElement, GlyphElement, TextElement, TSpanElement, TextNode, SVGElement, RectElement, CircleElement, EllipseElement, LineElement, PolylineElement, PolygonElement, PatternElement, MarkerElement, DefsElement, GElement, GradientElement, LinearGradientElement, RadialGradientElement, StopElement, AnimateElement, AnimateColorElement, AnimateTransformElement, FontElement, FontFaceElement, MissingGlyphElement, TRefElement, AElement, TextPathElement, dataUriRegex, ImageElement, SymbolElement, SVGFontLoader, StyleElement, UseElement, FeColorMatrixElement, MaskElement, noop2, ClipPathElement, FilterElement, FeDropShadowElement, FeMorphologyElement, FeCompositeElement, FeGaussianBlurElement, TitleElement, DescElement, elements, Document, Canvg;
var init_index_es = __esm({
  "node_modules/canvg/lib/index.es.js"() {
    import_es_promise = __toESM(require_es_promise(), 1);
    init_asyncToGenerator();
    import_es_string_match = __toESM(require_es_string_match(), 1);
    import_es_string_replace = __toESM(require_es_string_replace(), 1);
    import_es_string_starts_with = __toESM(require_es_string_starts_with(), 1);
    import_es_array_iterator = __toESM(require_es_array_iterator(), 1);
    import_web_dom_collections_iterator = __toESM(require_web_dom_collections_iterator(), 1);
    init_defineProperty();
    import_es_array_reduce = __toESM(require_es_array_reduce(), 1);
    import_es_string_ends_with = __toESM(require_es_string_ends_with(), 1);
    import_es_string_split = __toESM(require_es_string_split(), 1);
    import_raf = __toESM(require_raf(), 1);
    import_es_string_trim = __toESM(require_es_string_trim(), 1);
    import_rgbcolor = __toESM(require_rgbcolor(), 1);
    import_es_array_index_of = __toESM(require_es_array_index_of(), 1);
    import_es_string_includes = __toESM(require_es_string_includes(), 1);
    import_es_array_reverse = __toESM(require_es_array_reverse(), 1);
    init_SVGPathData_module();
    import_es_regexp_to_string = __toESM(require_es_regexp_to_string(), 1);
    init_stackblur_es();
    index3 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      offscreen,
      node
    });
    allUppercase = /^[A-Z-]+$/;
    attributeRegex = /(\[[^\]]+\])/g;
    idRegex = /(#[^\s+>~.[:]+)/g;
    classRegex = /(\.[^\s+>~.[:]+)/g;
    pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
    pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
    pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
    elementRegex = /([^\s+>~.[:]+)/g;
    PSEUDO_ZERO = 1e-8;
    Property = class {
      constructor(document2, name, value) {
        this.document = document2;
        this.name = name;
        this.value = value;
        this.isNormalizedColor = false;
      }
      static empty(document2) {
        return new Property(document2, "EMPTY", "");
      }
      split() {
        var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
        var {
          document: document2,
          name
        } = this;
        return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
      }
      hasValue(zeroIsValue) {
        var {
          value
        } = this;
        return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
      }
      isString(regexp) {
        var {
          value
        } = this;
        var result = typeof value === "string";
        if (!result || !regexp) {
          return result;
        }
        return regexp.test(value);
      }
      isUrlDefinition() {
        return this.isString(/^url\(/);
      }
      isPixels() {
        if (!this.hasValue()) {
          return false;
        }
        var asString = this.getString();
        switch (true) {
          case asString.endsWith("px"):
          case /^[0-9]+$/.test(asString):
            return true;
          default:
            return false;
        }
      }
      setValue(value) {
        this.value = value;
        return this;
      }
      getValue(def2) {
        if (typeof def2 === "undefined" || this.hasValue()) {
          return this.value;
        }
        return def2;
      }
      getNumber(def2) {
        if (!this.hasValue()) {
          if (typeof def2 === "undefined") {
            return 0;
          }
          return parseFloat(def2);
        }
        var {
          value
        } = this;
        var n5 = parseFloat(value);
        if (this.isString(/%$/)) {
          n5 /= 100;
        }
        return n5;
      }
      getString(def2) {
        if (typeof def2 === "undefined" || this.hasValue()) {
          return typeof this.value === "undefined" ? "" : String(this.value);
        }
        return String(def2);
      }
      getColor(def2) {
        var color = this.getString(def2);
        if (this.isNormalizedColor) {
          return color;
        }
        this.isNormalizedColor = true;
        color = normalizeColor(color);
        this.value = color;
        return color;
      }
      getDpi() {
        return 96;
      }
      getRem() {
        return this.document.rootEmSize;
      }
      getEm() {
        return this.document.emSize;
      }
      getUnits() {
        return this.getString().replace(/[0-9.-]/g, "");
      }
      getPixels(axisOrIsFontSize) {
        var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this.hasValue()) {
          return 0;
        }
        var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
        var {
          viewPort
        } = this.document.screen;
        switch (true) {
          case this.isString(/vmin$/):
            return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vmax$/):
            return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
          case this.isString(/vw$/):
            return this.getNumber() / 100 * viewPort.computeSize("x");
          case this.isString(/vh$/):
            return this.getNumber() / 100 * viewPort.computeSize("y");
          case this.isString(/rem$/):
            return this.getNumber() * this.getRem();
          case this.isString(/em$/):
            return this.getNumber() * this.getEm();
          case this.isString(/ex$/):
            return this.getNumber() * this.getEm() / 2;
          case this.isString(/px$/):
            return this.getNumber();
          case this.isString(/pt$/):
            return this.getNumber() * this.getDpi() * (1 / 72);
          case this.isString(/pc$/):
            return this.getNumber() * 15;
          case this.isString(/cm$/):
            return this.getNumber() * this.getDpi() / 2.54;
          case this.isString(/mm$/):
            return this.getNumber() * this.getDpi() / 25.4;
          case this.isString(/in$/):
            return this.getNumber() * this.getDpi();
          case (this.isString(/%$/) && isFontSize):
            return this.getNumber() * this.getEm();
          case this.isString(/%$/):
            return this.getNumber() * viewPort.computeSize(axis);
          default: {
            var n5 = this.getNumber();
            if (processPercent && n5 < 1) {
              return n5 * viewPort.computeSize(axis);
            }
            return n5;
          }
        }
      }
      getMilliseconds() {
        if (!this.hasValue()) {
          return 0;
        }
        if (this.isString(/ms$/)) {
          return this.getNumber();
        }
        return this.getNumber() * 1e3;
      }
      getRadians() {
        if (!this.hasValue()) {
          return 0;
        }
        switch (true) {
          case this.isString(/deg$/):
            return this.getNumber() * (Math.PI / 180);
          case this.isString(/grad$/):
            return this.getNumber() * (Math.PI / 200);
          case this.isString(/rad$/):
            return this.getNumber();
          default:
            return this.getNumber() * (Math.PI / 180);
        }
      }
      getDefinition() {
        var asString = this.getString();
        var name = /#([^)'"]+)/.exec(asString);
        if (name) {
          name = name[1];
        }
        if (!name) {
          name = asString;
        }
        return this.document.definitions[name];
      }
      getFillStyleDefinition(element, opacity) {
        var def2 = this.getDefinition();
        if (!def2) {
          return null;
        }
        if (typeof def2.createGradient === "function") {
          return def2.createGradient(this.document.ctx, element, opacity);
        }
        if (typeof def2.createPattern === "function") {
          if (def2.getHrefAttribute().hasValue()) {
            var patternTransform = def2.getAttribute("patternTransform");
            def2 = def2.getHrefAttribute().getDefinition();
            if (patternTransform.hasValue()) {
              def2.getAttribute("patternTransform", true).setValue(patternTransform.value);
            }
          }
          return def2.createPattern(this.document.ctx, element, opacity);
        }
        return null;
      }
      getTextBaseline() {
        if (!this.hasValue()) {
          return null;
        }
        return Property.textBaselineMapping[this.getString()];
      }
      addOpacity(opacity) {
        var value = this.getColor();
        var len = value.length;
        var commas = 0;
        for (var i5 = 0; i5 < len; i5++) {
          if (value[i5] === ",") {
            commas++;
          }
          if (commas === 3) {
            break;
          }
        }
        if (opacity.hasValue() && this.isString() && commas !== 3) {
          var color = new import_rgbcolor.default(value);
          if (color.ok) {
            color.alpha = opacity.getNumber();
            value = color.toRGBA();
          }
        }
        return new Property(this.document, this.name, value);
      }
    };
    Property.textBaselineMapping = {
      "baseline": "alphabetic",
      "before-edge": "top",
      "text-before-edge": "top",
      "middle": "middle",
      "central": "middle",
      "after-edge": "bottom",
      "text-after-edge": "bottom",
      "ideographic": "ideographic",
      "alphabetic": "alphabetic",
      "hanging": "hanging",
      "mathematical": "alphabetic"
    };
    ViewPort = class {
      constructor() {
        this.viewPorts = [];
      }
      clear() {
        this.viewPorts = [];
      }
      setCurrent(width, height) {
        this.viewPorts.push({
          width,
          height
        });
      }
      removeCurrent() {
        this.viewPorts.pop();
      }
      getCurrent() {
        var {
          viewPorts
        } = this;
        return viewPorts[viewPorts.length - 1];
      }
      get width() {
        return this.getCurrent().width;
      }
      get height() {
        return this.getCurrent().height;
      }
      computeSize(d3) {
        if (typeof d3 === "number") {
          return d3;
        }
        if (d3 === "x") {
          return this.width;
        }
        if (d3 === "y") {
          return this.height;
        }
        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
      }
    };
    Point = class {
      constructor(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      static parse(point) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var [x2 = defaultValue, y3 = defaultValue] = toNumbers(point);
        return new Point(x2, y3);
      }
      static parseScale(scale) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var [x2 = defaultValue, y3 = x2] = toNumbers(scale);
        return new Point(x2, y3);
      }
      static parsePath(path) {
        var points = toNumbers(path);
        var len = points.length;
        var pathPoints = [];
        for (var i5 = 0; i5 < len; i5 += 2) {
          pathPoints.push(new Point(points[i5], points[i5 + 1]));
        }
        return pathPoints;
      }
      angleTo(point) {
        return Math.atan2(point.y - this.y, point.x - this.x);
      }
      applyTransform(transform) {
        var {
          x: x2,
          y: y3
        } = this;
        var xp = x2 * transform[0] + y3 * transform[2] + transform[4];
        var yp = x2 * transform[1] + y3 * transform[3] + transform[5];
        this.x = xp;
        this.y = yp;
      }
    };
    Mouse = class {
      constructor(screen) {
        this.screen = screen;
        this.working = false;
        this.events = [];
        this.eventElements = [];
        this.onClick = this.onClick.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
      }
      isWorking() {
        return this.working;
      }
      start() {
        if (this.working) {
          return;
        }
        var {
          screen,
          onClick,
          onMouseMove
        } = this;
        var canvas = screen.ctx.canvas;
        canvas.onclick = onClick;
        canvas.onmousemove = onMouseMove;
        this.working = true;
      }
      stop() {
        if (!this.working) {
          return;
        }
        var canvas = this.screen.ctx.canvas;
        this.working = false;
        canvas.onclick = null;
        canvas.onmousemove = null;
      }
      hasEvents() {
        return this.working && this.events.length > 0;
      }
      runEvents() {
        if (!this.working) {
          return;
        }
        var {
          screen: document2,
          events,
          eventElements
        } = this;
        var {
          style
        } = document2.ctx.canvas;
        if (style) {
          style.cursor = "";
        }
        events.forEach((_ref, i5) => {
          var {
            run
          } = _ref;
          var element = eventElements[i5];
          while (element) {
            run(element);
            element = element.parent;
          }
        });
        this.events = [];
        this.eventElements = [];
      }
      checkPath(element, ctx) {
        if (!this.working || !ctx) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref2, i5) => {
          var {
            x: x2,
            y: y3
          } = _ref2;
          if (!eventElements[i5] && ctx.isPointInPath && ctx.isPointInPath(x2, y3)) {
            eventElements[i5] = element;
          }
        });
      }
      checkBoundingBox(element, boundingBox) {
        if (!this.working || !boundingBox) {
          return;
        }
        var {
          events,
          eventElements
        } = this;
        events.forEach((_ref3, i5) => {
          var {
            x: x2,
            y: y3
          } = _ref3;
          if (!eventElements[i5] && boundingBox.isPointInBox(x2, y3)) {
            eventElements[i5] = element;
          }
        });
      }
      mapXY(x2, y3) {
        var {
          window: window2,
          ctx
        } = this.screen;
        var point = new Point(x2, y3);
        var element = ctx.canvas;
        while (element) {
          point.x -= element.offsetLeft;
          point.y -= element.offsetTop;
          element = element.offsetParent;
        }
        if (window2.scrollX) {
          point.x += window2.scrollX;
        }
        if (window2.scrollY) {
          point.y += window2.scrollY;
        }
        return point;
      }
      onClick(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onclick",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onClick) {
              eventTarget.onClick();
            }
          }
        });
      }
      onMouseMove(event) {
        var {
          x: x2,
          y: y3
        } = this.mapXY(event.clientX, event.clientY);
        this.events.push({
          type: "onmousemove",
          x: x2,
          y: y3,
          run(eventTarget) {
            if (eventTarget.onMouseMove) {
              eventTarget.onMouseMove();
            }
          }
        });
      }
    };
    defaultWindow = typeof window !== "undefined" ? window : null;
    defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
    Screen = class {
      constructor(ctx) {
        var {
          fetch: fetch2 = defaultFetch$1,
          window: window2 = defaultWindow
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.ctx = ctx;
        this.FRAMERATE = 30;
        this.MAX_VIRTUAL_PIXELS = 3e4;
        this.CLIENT_WIDTH = 800;
        this.CLIENT_HEIGHT = 600;
        this.viewPort = new ViewPort();
        this.mouse = new Mouse(this);
        this.animations = [];
        this.waits = [];
        this.frameDuration = 0;
        this.isReadyLock = false;
        this.isFirstRender = true;
        this.intervalId = null;
        this.window = window2;
        this.fetch = fetch2;
      }
      wait(checker) {
        this.waits.push(checker);
      }
      ready() {
        if (!this.readyPromise) {
          return Promise.resolve();
        }
        return this.readyPromise;
      }
      isReady() {
        if (this.isReadyLock) {
          return true;
        }
        var isReadyLock = this.waits.every((_4) => _4());
        if (isReadyLock) {
          this.waits = [];
          if (this.resolveReady) {
            this.resolveReady();
          }
        }
        this.isReadyLock = isReadyLock;
        return isReadyLock;
      }
      setDefaults(ctx) {
        ctx.strokeStyle = "rgba(0,0,0,0)";
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 4;
      }
      setViewBox(_ref) {
        var {
          document: document2,
          ctx,
          aspectRatio,
          width,
          desiredWidth,
          height,
          desiredHeight,
          minX = 0,
          minY = 0,
          refX,
          refY,
          clip = false,
          clipX = 0,
          clipY = 0
        } = _ref;
        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
        var align = aspectRatioAlign || "xMidYMid";
        var meetOrSlice = aspectRatioMeetOrSlice || "meet";
        var scaleX = width / desiredWidth;
        var scaleY = height / desiredHeight;
        var scaleMin = Math.min(scaleX, scaleY);
        var scaleMax = Math.max(scaleX, scaleY);
        var finalDesiredWidth = desiredWidth;
        var finalDesiredHeight = desiredHeight;
        if (meetOrSlice === "meet") {
          finalDesiredWidth *= scaleMin;
          finalDesiredHeight *= scaleMin;
        }
        if (meetOrSlice === "slice") {
          finalDesiredWidth *= scaleMax;
          finalDesiredHeight *= scaleMax;
        }
        var refXProp = new Property(document2, "refX", refX);
        var refYProp = new Property(document2, "refY", refY);
        var hasRefs = refXProp.hasValue() && refYProp.hasValue();
        if (hasRefs) {
          ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
        }
        if (clip) {
          var scaledClipX = scaleMin * clipX;
          var scaledClipY = scaleMin * clipY;
          ctx.beginPath();
          ctx.moveTo(scaledClipX, scaledClipY);
          ctx.lineTo(width, scaledClipY);
          ctx.lineTo(width, height);
          ctx.lineTo(scaledClipX, height);
          ctx.closePath();
          ctx.clip();
        }
        if (!hasRefs) {
          var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
          var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
          var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
          var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
          if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
          }
          if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height / 2 - finalDesiredHeight / 2);
          }
          if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
            ctx.translate(width - finalDesiredWidth, 0);
          }
          if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
            ctx.translate(0, height - finalDesiredHeight);
          }
        }
        switch (true) {
          case align === "none":
            ctx.scale(scaleX, scaleY);
            break;
          case meetOrSlice === "meet":
            ctx.scale(scaleMin, scaleMin);
            break;
          case meetOrSlice === "slice":
            ctx.scale(scaleMax, scaleMax);
            break;
        }
        ctx.translate(-minX, -minY);
      }
      start(element) {
        var {
          enableRedraw = false,
          ignoreMouse = false,
          ignoreAnimation = false,
          ignoreDimensions = false,
          ignoreClear = false,
          forceRedraw,
          scaleWidth,
          scaleHeight,
          offsetX,
          offsetY
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var {
          FRAMERATE,
          mouse
        } = this;
        var frameDuration = 1e3 / FRAMERATE;
        this.frameDuration = frameDuration;
        this.readyPromise = new Promise((resolve) => {
          this.resolveReady = resolve;
        });
        if (this.isReady()) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
        }
        if (!enableRedraw) {
          return;
        }
        var now2 = Date.now();
        var then = now2;
        var delta = 0;
        var tick = () => {
          now2 = Date.now();
          delta = now2 - then;
          if (delta >= frameDuration) {
            then = now2 - delta % frameDuration;
            if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
              this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
              mouse.runEvents();
            }
          }
          this.intervalId = (0, import_raf.default)(tick);
        };
        if (!ignoreMouse) {
          mouse.start();
        }
        this.intervalId = (0, import_raf.default)(tick);
      }
      stop() {
        if (this.intervalId) {
          import_raf.default.cancel(this.intervalId);
          this.intervalId = null;
        }
        this.mouse.stop();
      }
      shouldUpdate(ignoreAnimation, forceRedraw) {
        if (!ignoreAnimation) {
          var {
            frameDuration
          } = this;
          var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
          if (shouldUpdate) {
            return true;
          }
        }
        if (typeof forceRedraw === "function" && forceRedraw()) {
          return true;
        }
        if (!this.isReadyLock && this.isReady()) {
          return true;
        }
        if (this.mouse.hasEvents()) {
          return true;
        }
        return false;
      }
      render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
        var {
          CLIENT_WIDTH,
          CLIENT_HEIGHT,
          viewPort,
          ctx,
          isFirstRender
        } = this;
        var canvas = ctx.canvas;
        viewPort.clear();
        if (canvas.width && canvas.height) {
          viewPort.setCurrent(canvas.width, canvas.height);
        } else {
          viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
        }
        var widthStyle = element.getStyle("width");
        var heightStyle = element.getStyle("height");
        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
          if (widthStyle.hasValue()) {
            canvas.width = widthStyle.getPixels("x");
            if (canvas.style) {
              canvas.style.width = "".concat(canvas.width, "px");
            }
          }
          if (heightStyle.hasValue()) {
            canvas.height = heightStyle.getPixels("y");
            if (canvas.style) {
              canvas.style.height = "".concat(canvas.height, "px");
            }
          }
        }
        var cWidth = canvas.clientWidth || canvas.width;
        var cHeight = canvas.clientHeight || canvas.height;
        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
          cWidth = widthStyle.getPixels("x");
          cHeight = heightStyle.getPixels("y");
        }
        viewPort.setCurrent(cWidth, cHeight);
        if (typeof offsetX === "number") {
          element.getAttribute("x", true).setValue(offsetX);
        }
        if (typeof offsetY === "number") {
          element.getAttribute("y", true).setValue(offsetY);
        }
        if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
          var viewBox = toNumbers(element.getAttribute("viewBox").getString());
          var xRatio = 0;
          var yRatio = 0;
          if (typeof scaleWidth === "number") {
            var _widthStyle = element.getStyle("width");
            if (_widthStyle.hasValue()) {
              xRatio = _widthStyle.getPixels("x") / scaleWidth;
            } else if (!isNaN(viewBox[2])) {
              xRatio = viewBox[2] / scaleWidth;
            }
          }
          if (typeof scaleHeight === "number") {
            var _heightStyle = element.getStyle("height");
            if (_heightStyle.hasValue()) {
              yRatio = _heightStyle.getPixels("y") / scaleHeight;
            } else if (!isNaN(viewBox[3])) {
              yRatio = viewBox[3] / scaleHeight;
            }
          }
          if (!xRatio) {
            xRatio = yRatio;
          }
          if (!yRatio) {
            yRatio = xRatio;
          }
          element.getAttribute("width", true).setValue(scaleWidth);
          element.getAttribute("height", true).setValue(scaleHeight);
          var transformStyle = element.getStyle("transform", true, true);
          transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
        }
        if (!ignoreClear) {
          ctx.clearRect(0, 0, cWidth, cHeight);
        }
        element.render(ctx);
        if (isFirstRender) {
          this.isFirstRender = false;
        }
      }
    };
    Screen.defaultWindow = defaultWindow;
    Screen.defaultFetch = defaultFetch$1;
    ({
      defaultFetch
    } = Screen);
    DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
    Parser = class {
      constructor() {
        var {
          fetch: fetch2 = defaultFetch,
          DOMParser: DOMParser2 = DefaultDOMParser
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.fetch = fetch2;
        this.DOMParser = DOMParser2;
      }
      parse(resource) {
        var _this = this;
        return _asyncToGenerator(function* () {
          if (resource.startsWith("<")) {
            return _this.parseFromString(resource);
          }
          return _this.load(resource);
        })();
      }
      parseFromString(xml) {
        var parser2 = new this.DOMParser();
        try {
          return this.checkDocument(parser2.parseFromString(xml, "image/svg+xml"));
        } catch (err) {
          return this.checkDocument(parser2.parseFromString(xml, "text/xml"));
        }
      }
      checkDocument(document2) {
        var parserError = document2.getElementsByTagName("parsererror")[0];
        if (parserError) {
          throw new Error(parserError.textContent);
        }
        return document2;
      }
      load(url) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var response = yield _this2.fetch(url);
          var xml = yield response.text();
          return _this2.parseFromString(xml);
        })();
      }
    };
    Translate = class {
      constructor(_4, point) {
        this.type = "translate";
        this.point = null;
        this.point = Point.parse(point);
      }
      apply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(x2 || 0, y3 || 0);
      }
      unapply(ctx) {
        var {
          x: x2,
          y: y3
        } = this.point;
        ctx.translate(-1 * x2 || 0, -1 * y3 || 0);
      }
      applyToPoint(point) {
        var {
          x: x2,
          y: y3
        } = this.point;
        point.applyTransform([1, 0, 0, 1, x2 || 0, y3 || 0]);
      }
    };
    Rotate = class {
      constructor(document2, rotate, transformOrigin) {
        this.type = "rotate";
        this.angle = null;
        this.originX = null;
        this.originY = null;
        this.cx = 0;
        this.cy = 0;
        var numbers = toNumbers(rotate);
        this.angle = new Property(document2, "angle", numbers[0]);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
        this.cx = numbers[1] || 0;
        this.cy = numbers[2] || 0;
      }
      apply(ctx) {
        var {
          cx,
          cy,
          originX,
          originY,
          angle
        } = this;
        var tx = cx + originX.getPixels("x");
        var ty = cy + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          cx,
          cy,
          originX,
          originY,
          angle
        } = this;
        var tx = cx + originX.getPixels("x");
        var ty = cy + originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.rotate(-1 * angle.getRadians());
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        var {
          cx,
          cy,
          angle
        } = this;
        var rad = angle.getRadians();
        point.applyTransform([
          1,
          0,
          0,
          1,
          cx || 0,
          cy || 0
          // this.p.y
        ]);
        point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
        point.applyTransform([
          1,
          0,
          0,
          1,
          -cx || 0,
          -cy || 0
          // -this.p.y
        ]);
      }
    };
    Scale = class {
      constructor(_4, scale, transformOrigin) {
        this.type = "scale";
        this.scale = null;
        this.originX = null;
        this.originY = null;
        var scaleSize = Point.parseScale(scale);
        if (scaleSize.x === 0 || scaleSize.y === 0) {
          scaleSize.x = PSEUDO_ZERO;
          scaleSize.y = PSEUDO_ZERO;
        }
        this.scale = scaleSize;
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(x2, y3 || x2);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          scale: {
            x: x2,
            y: y3
          },
          originX,
          originY
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.scale(1 / x2, 1 / y3 || x2);
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        var {
          x: x2,
          y: y3
        } = this.scale;
        point.applyTransform([x2 || 0, 0, 0, y3 || 0, 0, 0]);
      }
    };
    Matrix = class {
      constructor(_4, matrix, transformOrigin) {
        this.type = "matrix";
        this.matrix = [];
        this.originX = null;
        this.originY = null;
        this.matrix = toNumbers(matrix);
        this.originX = transformOrigin[0];
        this.originY = transformOrigin[1];
      }
      apply(ctx) {
        var {
          originX,
          originY,
          matrix
        } = this;
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
        ctx.translate(-tx, -ty);
      }
      unapply(ctx) {
        var {
          originX,
          originY,
          matrix
        } = this;
        var a4 = matrix[0];
        var b2 = matrix[2];
        var c5 = matrix[4];
        var d3 = matrix[1];
        var e3 = matrix[3];
        var f5 = matrix[5];
        var g5 = 0;
        var h4 = 0;
        var i5 = 1;
        var det = 1 / (a4 * (e3 * i5 - f5 * h4) - b2 * (d3 * i5 - f5 * g5) + c5 * (d3 * h4 - e3 * g5));
        var tx = originX.getPixels("x");
        var ty = originY.getPixels("y");
        ctx.translate(tx, ty);
        ctx.transform(det * (e3 * i5 - f5 * h4), det * (f5 * g5 - d3 * i5), det * (c5 * h4 - b2 * i5), det * (a4 * i5 - c5 * g5), det * (b2 * f5 - c5 * e3), det * (c5 * d3 - a4 * f5));
        ctx.translate(-tx, -ty);
      }
      applyToPoint(point) {
        point.applyTransform(this.matrix);
      }
    };
    Skew = class extends Matrix {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skew";
        this.angle = null;
        this.angle = new Property(document2, "angle", skew);
      }
    };
    SkewX = class extends Skew {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skewX";
        this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
      }
    };
    SkewY = class extends Skew {
      constructor(document2, skew, transformOrigin) {
        super(document2, skew, transformOrigin);
        this.type = "skewY";
        this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
      }
    };
    Transform = class {
      constructor(document2, transform, transformOrigin) {
        this.document = document2;
        this.transforms = [];
        var data = parseTransforms(transform);
        data.forEach((transform2) => {
          if (transform2 === "none") {
            return;
          }
          var [type, value] = parseTransform(transform2);
          var TransformType = Transform.transformTypes[type];
          if (typeof TransformType !== "undefined") {
            this.transforms.push(new TransformType(this.document, value, transformOrigin));
          }
        });
      }
      static fromElement(document2, element) {
        var transformStyle = element.getStyle("transform", false, true);
        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
        var transformOrigin = [transformOriginXProperty, transformOriginYProperty];
        if (transformStyle.hasValue()) {
          return new Transform(document2, transformStyle.getString(), transformOrigin);
        }
        return null;
      }
      apply(ctx) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i5 = 0; i5 < len; i5++) {
          transforms[i5].apply(ctx);
        }
      }
      unapply(ctx) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i5 = len - 1; i5 >= 0; i5--) {
          transforms[i5].unapply(ctx);
        }
      }
      // TODO: applyToPoint unused ... remove?
      applyToPoint(point) {
        var {
          transforms
        } = this;
        var len = transforms.length;
        for (var i5 = 0; i5 < len; i5++) {
          transforms[i5].applyToPoint(point);
        }
      }
    };
    Transform.transformTypes = {
      translate: Translate,
      rotate: Rotate,
      scale: Scale,
      matrix: Matrix,
      skewX: SkewX,
      skewY: SkewY
    };
    Element2 = class {
      constructor(document2, node2) {
        var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.document = document2;
        this.node = node2;
        this.captureTextNodes = captureTextNodes;
        this.attributes = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.animationFrozen = false;
        this.animationFrozenValue = "";
        this.parent = null;
        this.children = [];
        if (!node2 || node2.nodeType !== 1) {
          return;
        }
        Array.from(node2.attributes).forEach((attribute) => {
          var nodeName = normalizeAttributeName(attribute.nodeName);
          this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
        });
        this.addStylesFromStyleDefinition();
        if (this.getAttribute("style").hasValue()) {
          var styles = this.getAttribute("style").getString().split(";").map((_4) => _4.trim());
          styles.forEach((style) => {
            if (!style) {
              return;
            }
            var [name, value] = style.split(":").map((_4) => _4.trim());
            this.styles[name] = new Property(document2, name, value);
          });
        }
        var {
          definitions
        } = document2;
        var id = this.getAttribute("id");
        if (id.hasValue()) {
          if (!definitions[id.getString()]) {
            definitions[id.getString()] = this;
          }
        }
        Array.from(node2.childNodes).forEach((childNode) => {
          if (childNode.nodeType === 1) {
            this.addChild(childNode);
          } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
            var textNode = document2.createTextNode(childNode);
            if (textNode.getText().length > 0) {
              this.addChild(textNode);
            }
          }
        });
      }
      getAttribute(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var attr = this.attributes[name];
        if (!attr && createIfNotExists) {
          var _attr = new Property(this.document, name, "");
          this.attributes[name] = _attr;
          return _attr;
        }
        return attr || Property.empty(this.document);
      }
      getHrefAttribute() {
        for (var key in this.attributes) {
          if (key === "href" || key.endsWith(":href")) {
            return this.attributes[key];
          }
        }
        return Property.empty(this.document);
      }
      getStyle(name) {
        var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var style = this.styles[name];
        if (style) {
          return style;
        }
        var attr = this.getAttribute(name);
        if (attr !== null && attr !== void 0 && attr.hasValue()) {
          this.styles[name] = attr;
          return attr;
        }
        if (!skipAncestors) {
          var {
            parent
          } = this;
          if (parent) {
            var parentStyle = parent.getStyle(name);
            if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
              return parentStyle;
            }
          }
        }
        if (createIfNotExists) {
          var _style = new Property(this.document, name, "");
          this.styles[name] = _style;
          return _style;
        }
        return style || Property.empty(this.document);
      }
      render(ctx) {
        if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
          return;
        }
        ctx.save();
        if (this.getStyle("mask").hasValue()) {
          var mask = this.getStyle("mask").getDefinition();
          if (mask) {
            this.applyEffects(ctx);
            mask.apply(ctx, this);
          }
        } else if (this.getStyle("filter").getValue("none") !== "none") {
          var filter2 = this.getStyle("filter").getDefinition();
          if (filter2) {
            this.applyEffects(ctx);
            filter2.apply(ctx, this);
          }
        } else {
          this.setContext(ctx);
          this.renderChildren(ctx);
          this.clearContext(ctx);
        }
        ctx.restore();
      }
      setContext(_4) {
      }
      applyEffects(ctx) {
        var transform = Transform.fromElement(this.document, this);
        if (transform) {
          transform.apply(ctx);
        }
        var clipPathStyleProp = this.getStyle("clip-path", false, true);
        if (clipPathStyleProp.hasValue()) {
          var clip = clipPathStyleProp.getDefinition();
          if (clip) {
            clip.apply(ctx);
          }
        }
      }
      clearContext(_4) {
      }
      renderChildren(ctx) {
        this.children.forEach((child) => {
          child.render(ctx);
        });
      }
      addChild(childNode) {
        var child = childNode instanceof Element2 ? childNode : this.document.createElement(childNode);
        child.parent = this;
        if (!Element2.ignoreChildTypes.includes(child.type)) {
          this.children.push(child);
        }
      }
      matchesSelector(selector) {
        var _node$getAttribute;
        var {
          node: node2
        } = this;
        if (typeof node2.matches === "function") {
          return node2.matches(selector);
        }
        var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
        if (!styleClasses || styleClasses === "") {
          return false;
        }
        return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
      }
      addStylesFromStyleDefinition() {
        var {
          styles,
          stylesSpecificity
        } = this.document;
        for (var selector in styles) {
          if (!selector.startsWith("@") && this.matchesSelector(selector)) {
            var style = styles[selector];
            var specificity = stylesSpecificity[selector];
            if (style) {
              for (var name in style) {
                var existingSpecificity = this.stylesSpecificity[name];
                if (typeof existingSpecificity === "undefined") {
                  existingSpecificity = "000";
                }
                if (specificity >= existingSpecificity) {
                  this.styles[name] = style[name];
                  this.stylesSpecificity[name] = specificity;
                }
              }
            }
          }
        }
      }
      removeStyles(element, ignoreStyles) {
        var toRestore = ignoreStyles.reduce((toRestore2, name) => {
          var styleProp = element.getStyle(name);
          if (!styleProp.hasValue()) {
            return toRestore2;
          }
          var value = styleProp.getString();
          styleProp.setValue("");
          return [...toRestore2, [name, value]];
        }, []);
        return toRestore;
      }
      restoreStyles(element, styles) {
        styles.forEach((_ref) => {
          var [name, value] = _ref;
          element.getStyle(name, true).setValue(value);
        });
      }
      isFirstChild() {
        var _this$parent;
        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
      }
    };
    Element2.ignoreChildTypes = ["title"];
    UnknownElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
      }
    };
    Font = class {
      constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
        var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
        this.fontFamily = fontFamily || inheritFont.fontFamily;
        this.fontSize = fontSize || inheritFont.fontSize;
        this.fontStyle = fontStyle || inheritFont.fontStyle;
        this.fontWeight = fontWeight || inheritFont.fontWeight;
        this.fontVariant = fontVariant || inheritFont.fontVariant;
      }
      static parse() {
        var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var inherit = arguments.length > 1 ? arguments[1] : void 0;
        var fontStyle = "";
        var fontVariant = "";
        var fontWeight = "";
        var fontSize = "";
        var fontFamily = "";
        var parts = compressSpaces(font).trim().split(" ");
        var set = {
          fontSize: false,
          fontStyle: false,
          fontWeight: false,
          fontVariant: false
        };
        parts.forEach((part) => {
          switch (true) {
            case (!set.fontStyle && Font.styles.includes(part)):
              if (part !== "inherit") {
                fontStyle = part;
              }
              set.fontStyle = true;
              break;
            case (!set.fontVariant && Font.variants.includes(part)):
              if (part !== "inherit") {
                fontVariant = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              break;
            case (!set.fontWeight && Font.weights.includes(part)):
              if (part !== "inherit") {
                fontWeight = part;
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              break;
            case !set.fontSize:
              if (part !== "inherit") {
                [fontSize] = part.split("/");
              }
              set.fontStyle = true;
              set.fontVariant = true;
              set.fontWeight = true;
              set.fontSize = true;
              break;
            default:
              if (part !== "inherit") {
                fontFamily += part;
              }
          }
        });
        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
      }
      toString() {
        return [
          prepareFontStyle(this.fontStyle),
          this.fontVariant,
          prepareFontWeight(this.fontWeight),
          this.fontSize,
          // Wrap fontFamily only on nodejs and only for canvas.ctx
          prepareFontFamily(this.fontFamily)
        ].join(" ").trim();
      }
    };
    Font.styles = "normal|italic|oblique|inherit";
    Font.variants = "normal|small-caps|inherit";
    Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
    BoundingBox = class {
      constructor() {
        var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
        var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
        var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
        var y22 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y22;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      get x() {
        return this.x1;
      }
      get y() {
        return this.y1;
      }
      get width() {
        return this.x2 - this.x1;
      }
      get height() {
        return this.y2 - this.y1;
      }
      addPoint(x2, y3) {
        if (typeof x2 !== "undefined") {
          if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x2;
            this.x2 = x2;
          }
          if (x2 < this.x1) {
            this.x1 = x2;
          }
          if (x2 > this.x2) {
            this.x2 = x2;
          }
        }
        if (typeof y3 !== "undefined") {
          if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y3;
            this.y2 = y3;
          }
          if (y3 < this.y1) {
            this.y1 = y3;
          }
          if (y3 > this.y2) {
            this.y2 = y3;
          }
        }
      }
      addX(x2) {
        this.addPoint(x2, null);
      }
      addY(y3) {
        this.addPoint(null, y3);
      }
      addBoundingBox(boundingBox) {
        if (!boundingBox) {
          return;
        }
        var {
          x1,
          y1,
          x2,
          y2: y22
        } = boundingBox;
        this.addPoint(x1, y1);
        this.addPoint(x2, y22);
      }
      sumCubic(t5, p0, p1, p22, p32) {
        return Math.pow(1 - t5, 3) * p0 + 3 * Math.pow(1 - t5, 2) * t5 * p1 + 3 * (1 - t5) * Math.pow(t5, 2) * p22 + Math.pow(t5, 3) * p32;
      }
      bezierCurveAdd(forX, p0, p1, p22, p32) {
        var b2 = 6 * p0 - 12 * p1 + 6 * p22;
        var a4 = -3 * p0 + 9 * p1 - 9 * p22 + 3 * p32;
        var c5 = 3 * p1 - 3 * p0;
        if (a4 === 0) {
          if (b2 === 0) {
            return;
          }
          var t5 = -c5 / b2;
          if (0 < t5 && t5 < 1) {
            if (forX) {
              this.addX(this.sumCubic(t5, p0, p1, p22, p32));
            } else {
              this.addY(this.sumCubic(t5, p0, p1, p22, p32));
            }
          }
          return;
        }
        var b2ac = Math.pow(b2, 2) - 4 * c5 * a4;
        if (b2ac < 0) {
          return;
        }
        var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a4);
        if (0 < t1 && t1 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t1, p0, p1, p22, p32));
          } else {
            this.addY(this.sumCubic(t1, p0, p1, p22, p32));
          }
        }
        var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a4);
        if (0 < t22 && t22 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t22, p0, p1, p22, p32));
          } else {
            this.addY(this.sumCubic(t22, p0, p1, p22, p32));
          }
        }
      }
      // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
      addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
        this.addPoint(p0x, p0y);
        this.addPoint(p3x, p3y);
        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
      }
      addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
        var cp1x = p0x + 2 / 3 * (p1x - p0x);
        var cp1y = p0y + 2 / 3 * (p1y - p0y);
        var cp2x = cp1x + 1 / 3 * (p2x - p0x);
        var cp2y = cp1y + 1 / 3 * (p2y - p0y);
        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
      }
      isPointInBox(x2, y3) {
        var {
          x1,
          y1,
          x2: x22,
          y2: y22
        } = this;
        return x1 <= x2 && x2 <= x22 && y1 <= y3 && y3 <= y22;
      }
    };
    PathParser = class extends _2 {
      constructor(path) {
        super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
        this.control = null;
        this.start = null;
        this.current = null;
        this.command = null;
        this.commands = this.commands;
        this.i = -1;
        this.previousCommand = null;
        this.points = [];
        this.angles = [];
      }
      reset() {
        this.i = -1;
        this.command = null;
        this.previousCommand = null;
        this.start = new Point(0, 0);
        this.control = new Point(0, 0);
        this.current = new Point(0, 0);
        this.points = [];
        this.angles = [];
      }
      isEnd() {
        var {
          i: i5,
          commands
        } = this;
        return i5 >= commands.length - 1;
      }
      next() {
        var command = this.commands[++this.i];
        this.previousCommand = this.command;
        this.command = command;
        return command;
      }
      getPoint() {
        var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
        var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
        var point = new Point(this.command[xProp], this.command[yProp]);
        return this.makeAbsolute(point);
      }
      getAsControlPoint(xProp, yProp) {
        var point = this.getPoint(xProp, yProp);
        this.control = point;
        return point;
      }
      getAsCurrentPoint(xProp, yProp) {
        var point = this.getPoint(xProp, yProp);
        this.current = point;
        return point;
      }
      getReflectedControlPoint() {
        var previousCommand = this.previousCommand.type;
        if (previousCommand !== _2.CURVE_TO && previousCommand !== _2.SMOOTH_CURVE_TO && previousCommand !== _2.QUAD_TO && previousCommand !== _2.SMOOTH_QUAD_TO) {
          return this.current;
        }
        var {
          current: {
            x: cx,
            y: cy
          },
          control: {
            x: ox,
            y: oy
          }
        } = this;
        var point = new Point(2 * cx - ox, 2 * cy - oy);
        return point;
      }
      makeAbsolute(point) {
        if (this.command.relative) {
          var {
            x: x2,
            y: y3
          } = this.current;
          point.x += x2;
          point.y += y3;
        }
        return point;
      }
      addMarker(point, from, priorTo) {
        var {
          points,
          angles
        } = this;
        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
          angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
        }
        this.addMarkerAngle(point, from ? from.angleTo(point) : null);
      }
      addMarkerAngle(point, angle) {
        this.points.push(point);
        this.angles.push(angle);
      }
      getMarkerPoints() {
        return this.points;
      }
      getMarkerAngles() {
        var {
          angles
        } = this;
        var len = angles.length;
        for (var i5 = 0; i5 < len; i5++) {
          if (!angles[i5]) {
            for (var j3 = i5 + 1; j3 < len; j3++) {
              if (angles[j3]) {
                angles[i5] = angles[j3];
                break;
              }
            }
          }
        }
        return angles;
      }
    };
    RenderedElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.modifiedEmSizeStack = false;
      }
      calculateOpacity() {
        var opacity = 1;
        var element = this;
        while (element) {
          var opacityStyle = element.getStyle("opacity", false, true);
          if (opacityStyle.hasValue(true)) {
            opacity *= opacityStyle.getNumber();
          }
          element = element.parent;
        }
        return opacity;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!fromMeasure) {
          var fillStyleProp = this.getStyle("fill");
          var fillOpacityStyleProp = this.getStyle("fill-opacity");
          var strokeStyleProp = this.getStyle("stroke");
          var strokeOpacityProp = this.getStyle("stroke-opacity");
          if (fillStyleProp.isUrlDefinition()) {
            var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
            if (fillStyle) {
              ctx.fillStyle = fillStyle;
            }
          } else if (fillStyleProp.hasValue()) {
            if (fillStyleProp.getString() === "currentColor") {
              fillStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _fillStyle = fillStyleProp.getColor();
            if (_fillStyle !== "inherit") {
              ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
            }
          }
          if (fillOpacityStyleProp.hasValue()) {
            var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
            ctx.fillStyle = _fillStyle2;
          }
          if (strokeStyleProp.isUrlDefinition()) {
            var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
            if (strokeStyle) {
              ctx.strokeStyle = strokeStyle;
            }
          } else if (strokeStyleProp.hasValue()) {
            if (strokeStyleProp.getString() === "currentColor") {
              strokeStyleProp.setValue(this.getStyle("color").getColor());
            }
            var _strokeStyle = strokeStyleProp.getString();
            if (_strokeStyle !== "inherit") {
              ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
            }
          }
          if (strokeOpacityProp.hasValue()) {
            var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
            ctx.strokeStyle = _strokeStyle2;
          }
          var strokeWidthStyleProp = this.getStyle("stroke-width");
          if (strokeWidthStyleProp.hasValue()) {
            var newLineWidth = strokeWidthStyleProp.getPixels();
            ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
          }
          var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
          var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
          var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
          var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
          var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
          if (strokeLinecapStyleProp.hasValue()) {
            ctx.lineCap = strokeLinecapStyleProp.getString();
          }
          if (strokeLinejoinStyleProp.hasValue()) {
            ctx.lineJoin = strokeLinejoinStyleProp.getString();
          }
          if (strokeMiterlimitProp.hasValue()) {
            ctx.miterLimit = strokeMiterlimitProp.getNumber();
          }
          if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
            var gaps = toNumbers(strokeDasharrayStyleProp.getString());
            if (typeof ctx.setLineDash !== "undefined") {
              ctx.setLineDash(gaps);
            } else if (typeof ctx.webkitLineDash !== "undefined") {
              ctx.webkitLineDash = gaps;
            } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
              ctx.mozDash = gaps;
            }
            var offset2 = strokeDashoffsetProp.getPixels();
            if (typeof ctx.lineDashOffset !== "undefined") {
              ctx.lineDashOffset = offset2;
            } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
              ctx.webkitLineDashOffset = offset2;
            } else if (typeof ctx.mozDashOffset !== "undefined") {
              ctx.mozDashOffset = offset2;
            }
          }
        }
        this.modifiedEmSizeStack = false;
        if (typeof ctx.font !== "undefined") {
          var fontStyleProp = this.getStyle("font");
          var fontStyleStyleProp = this.getStyle("font-style");
          var fontVariantStyleProp = this.getStyle("font-variant");
          var fontWeightStyleProp = this.getStyle("font-weight");
          var fontSizeStyleProp = this.getStyle("font-size");
          var fontFamilyStyleProp = this.getStyle("font-family");
          var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
          fontStyleStyleProp.setValue(font.fontStyle);
          fontVariantStyleProp.setValue(font.fontVariant);
          fontWeightStyleProp.setValue(font.fontWeight);
          fontSizeStyleProp.setValue(font.fontSize);
          fontFamilyStyleProp.setValue(font.fontFamily);
          ctx.font = font.toString();
          if (fontSizeStyleProp.isPixels()) {
            this.document.emSize = fontSizeStyleProp.getPixels();
            this.modifiedEmSizeStack = true;
          }
        }
        if (!fromMeasure) {
          this.applyEffects(ctx);
          ctx.globalAlpha = this.calculateOpacity();
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        if (this.modifiedEmSizeStack) {
          this.document.popEmSize();
        }
      }
    };
    PathElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "path";
        this.pathParser = null;
        this.pathParser = new PathParser(this.getAttribute("d").getString());
      }
      path(ctx) {
        var {
          pathParser
        } = this;
        var boundingBox = new BoundingBox();
        pathParser.reset();
        if (ctx) {
          ctx.beginPath();
        }
        while (!pathParser.isEnd()) {
          switch (pathParser.next().type) {
            case PathParser.MOVE_TO:
              this.pathM(ctx, boundingBox);
              break;
            case PathParser.LINE_TO:
              this.pathL(ctx, boundingBox);
              break;
            case PathParser.HORIZ_LINE_TO:
              this.pathH(ctx, boundingBox);
              break;
            case PathParser.VERT_LINE_TO:
              this.pathV(ctx, boundingBox);
              break;
            case PathParser.CURVE_TO:
              this.pathC(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              this.pathS(ctx, boundingBox);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(ctx, boundingBox);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              this.pathT(ctx, boundingBox);
              break;
            case PathParser.ARC:
              this.pathA(ctx, boundingBox);
              break;
            case PathParser.CLOSE_PATH:
              this.pathZ(ctx, boundingBox);
              break;
          }
        }
        return boundingBox;
      }
      getBoundingBox(_4) {
        return this.path();
      }
      getMarkers() {
        var {
          pathParser
        } = this;
        var points = pathParser.getMarkerPoints();
        var angles = pathParser.getMarkerAngles();
        var markers = points.map((point, i5) => [point, angles[i5]]);
        return markers;
      }
      renderChildren(ctx) {
        this.path(ctx);
        this.document.screen.mouse.checkPath(this, ctx);
        var fillRuleStyleProp = this.getStyle("fill-rule");
        if (ctx.fillStyle !== "") {
          if (fillRuleStyleProp.getString("inherit") !== "inherit") {
            ctx.fill(fillRuleStyleProp.getString());
          } else {
            ctx.fill();
          }
        }
        if (ctx.strokeStyle !== "") {
          if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.stroke();
          }
        }
        var markers = this.getMarkers();
        if (markers) {
          var markersLastIndex = markers.length - 1;
          var markerStartStyleProp = this.getStyle("marker-start");
          var markerMidStyleProp = this.getStyle("marker-mid");
          var markerEndStyleProp = this.getStyle("marker-end");
          if (markerStartStyleProp.isUrlDefinition()) {
            var marker = markerStartStyleProp.getDefinition();
            var [point, angle] = markers[0];
            marker.render(ctx, point, angle);
          }
          if (markerMidStyleProp.isUrlDefinition()) {
            var _marker = markerMidStyleProp.getDefinition();
            for (var i5 = 1; i5 < markersLastIndex; i5++) {
              var [_point, _angle] = markers[i5];
              _marker.render(ctx, _point, _angle);
            }
          }
          if (markerEndStyleProp.isUrlDefinition()) {
            var _marker2 = markerEndStyleProp.getDefinition();
            var [_point2, _angle2] = markers[markersLastIndex];
            _marker2.render(ctx, _point2, _angle2);
          }
        }
      }
      static pathM(pathParser) {
        var point = pathParser.getAsCurrentPoint();
        pathParser.start = pathParser.current;
        return {
          point
        };
      }
      pathM(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          point
        } = PathElement.pathM(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.moveTo(x2, y3);
        }
      }
      static pathL(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getAsCurrentPoint();
        return {
          current,
          point
        };
      }
      pathL(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathL(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathH(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
        pathParser.current = point;
        return {
          current,
          point
        };
      }
      pathH(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathH(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathV(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
        pathParser.current = point;
        return {
          current,
          point
        };
      }
      pathV(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point
        } = PathElement.pathV(pathParser);
        var {
          x: x2,
          y: y3
        } = point;
        pathParser.addMarker(point, current);
        boundingBox.addPoint(x2, y3);
        if (ctx) {
          ctx.lineTo(x2, y3);
        }
      }
      static pathC(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getPoint("x1", "y1");
        var controlPoint = pathParser.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          point,
          controlPoint,
          currentPoint
        };
      }
      pathC(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathS(pathParser) {
        var {
          current
        } = pathParser;
        var point = pathParser.getReflectedControlPoint();
        var controlPoint = pathParser.getAsControlPoint("x2", "y2");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          point,
          controlPoint,
          currentPoint
        };
      }
      pathS(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, point);
        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathQ(pathParser) {
        var {
          current
        } = pathParser;
        var controlPoint = pathParser.getAsControlPoint("x1", "y1");
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathQ(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathT(pathParser) {
        var {
          current
        } = pathParser;
        var controlPoint = pathParser.getReflectedControlPoint();
        pathParser.control = controlPoint;
        var currentPoint = pathParser.getAsCurrentPoint();
        return {
          current,
          controlPoint,
          currentPoint
        };
      }
      pathT(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          current,
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser);
        pathParser.addMarker(currentPoint, controlPoint, controlPoint);
        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        if (ctx) {
          ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        }
      }
      static pathA(pathParser) {
        var {
          current,
          command
        } = pathParser;
        var {
          rX,
          rY,
          xRot,
          lArcFlag,
          sweepFlag
        } = command;
        var xAxisRotation = xRot * (Math.PI / 180);
        var currentPoint = pathParser.getAsCurrentPoint();
        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
        var l4 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
        if (l4 > 1) {
          rX *= Math.sqrt(l4);
          rY *= Math.sqrt(l4);
        }
        var s5 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
        if (isNaN(s5)) {
          s5 = 0;
        }
        var cpp = new Point(s5 * rX * currp.y / rY, s5 * -rY * currp.x / rX);
        var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
        var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
        var u4 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
        var v4 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
        var ad = vectorsAngle(u4, v4);
        if (vectorsRatio(u4, v4) <= -1) {
          ad = Math.PI;
        }
        if (vectorsRatio(u4, v4) >= 1) {
          ad = 0;
        }
        return {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        };
      }
      pathA(ctx, boundingBox) {
        var {
          pathParser
        } = this;
        var {
          currentPoint,
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser);
        var dir = 1 - sweepFlag ? 1 : -1;
        var ah = a1 + dir * (ad / 2);
        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
        boundingBox.addPoint(currentPoint.x, currentPoint.y);
        if (ctx && !isNaN(a1) && !isNaN(ad)) {
          var r3 = rX > rY ? rX : rY;
          var sx = rX > rY ? 1 : rX / rY;
          var sy = rX > rY ? rY / rX : 1;
          ctx.translate(centp.x, centp.y);
          ctx.rotate(xAxisRotation);
          ctx.scale(sx, sy);
          ctx.arc(0, 0, r3, a1, a1 + ad, Boolean(1 - sweepFlag));
          ctx.scale(1 / sx, 1 / sy);
          ctx.rotate(-xAxisRotation);
          ctx.translate(-centp.x, -centp.y);
        }
      }
      static pathZ(pathParser) {
        pathParser.current = pathParser.start;
      }
      pathZ(ctx, boundingBox) {
        PathElement.pathZ(this.pathParser);
        if (ctx) {
          if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
            ctx.closePath();
          }
        }
      }
    };
    GlyphElement = class extends PathElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "glyph";
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        this.unicode = this.getAttribute("unicode").getString();
        this.arabicForm = this.getAttribute("arabic-form").getString();
      }
    };
    TextElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, new.target === TextElement ? true : captureTextNodes);
        this.type = "text";
        this.x = 0;
        this.y = 0;
        this.measureCache = -1;
      }
      setContext(ctx) {
        var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        super.setContext(ctx, fromMeasure);
        var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
        if (textBaseline) {
          ctx.textBaseline = textBaseline;
        }
      }
      initializeCoordinates() {
        this.x = 0;
        this.y = 0;
        this.leafTexts = [];
        this.textChunkStart = 0;
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
      }
      getBoundingBox(ctx) {
        if (this.type !== "text") {
          return this.getTElementBoundingBox(ctx);
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        var boundingBox = null;
        this.children.forEach((_4, i5) => {
          var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i5);
          if (!boundingBox) {
            boundingBox = childBoundingBox;
          } else {
            boundingBox.addBoundingBox(childBoundingBox);
          }
        });
        return boundingBox;
      }
      getFontSize() {
        var {
          document: document2,
          parent
        } = this;
        var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
        var fontSize = parent.getStyle("font-size").getNumber(inheritFontSize);
        return fontSize;
      }
      getTElementBoundingBox(ctx) {
        var fontSize = this.getFontSize();
        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
      }
      getGlyph(font, text, i5) {
        var char = text[i5];
        var glyph = null;
        if (font.isArabic) {
          var len = text.length;
          var prevChar = text[i5 - 1];
          var nextChar = text[i5 + 1];
          var arabicForm = "isolated";
          if ((i5 === 0 || prevChar === " ") && i5 < len - 1 && nextChar !== " ") {
            arabicForm = "terminal";
          }
          if (i5 > 0 && prevChar !== " " && i5 < len - 1 && nextChar !== " ") {
            arabicForm = "medial";
          }
          if (i5 > 0 && prevChar !== " " && (i5 === len - 1 || nextChar === " ")) {
            arabicForm = "initial";
          }
          if (typeof font.glyphs[char] !== "undefined") {
            var maybeGlyph = font.glyphs[char];
            glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
          }
        } else {
          glyph = font.glyphs[char];
        }
        if (!glyph) {
          glyph = font.missingGlyph;
        }
        return glyph;
      }
      getText() {
        return "";
      }
      getTextFromNode(node2) {
        var textNode = node2 || this.node;
        var childNodes = Array.from(textNode.parentNode.childNodes);
        var index4 = childNodes.indexOf(textNode);
        var lastIndex = childNodes.length - 1;
        var text = compressSpaces(
          // textNode.value
          // || textNode.text
          textNode.textContent || ""
        );
        if (index4 === 0) {
          text = trimLeft(text);
        }
        if (index4 === lastIndex) {
          text = trimRight(text);
        }
        return text;
      }
      renderChildren(ctx) {
        if (this.type !== "text") {
          this.renderTElementChildren(ctx);
          return;
        }
        this.initializeCoordinates();
        this.adjustChildCoordinatesRecursive(ctx);
        this.children.forEach((_4, i5) => {
          this.renderChild(ctx, this, this, i5);
        });
        var {
          mouse
        } = this.document.screen;
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
        }
      }
      renderTElementChildren(ctx) {
        var {
          document: document2,
          parent
        } = this;
        var renderText = this.getText();
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var {
            unitsPerEm
          } = customFont.fontFace;
          var ctxFont = Font.parse(document2.ctx.font);
          var fontSize = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
          var fontStyle = parent.getStyle("font-style").getString(ctxFont.fontStyle);
          var scale = fontSize / unitsPerEm;
          var text = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
          var dx = toNumbers(parent.getAttribute("dx").getString());
          var len = text.length;
          for (var i5 = 0; i5 < len; i5++) {
            var glyph = this.getGlyph(customFont, text, i5);
            ctx.translate(this.x, this.y);
            ctx.scale(scale, -scale);
            var lw = ctx.lineWidth;
            ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;
            if (fontStyle === "italic") {
              ctx.transform(1, 0, 0.4, 1, 0, 0);
            }
            glyph.render(ctx);
            if (fontStyle === "italic") {
              ctx.transform(1, 0, -0.4, 1, 0, 0);
            }
            ctx.lineWidth = lw;
            ctx.scale(1 / scale, -1 / scale);
            ctx.translate(-this.x, -this.y);
            this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
            if (typeof dx[i5] !== "undefined" && !isNaN(dx[i5])) {
              this.x += dx[i5];
            }
          }
          return;
        }
        var {
          x: x2,
          y: y3
        } = this;
        if (ctx.fillStyle) {
          ctx.fillText(renderText, x2, y3);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(renderText, x2, y3);
        }
      }
      applyAnchoring() {
        if (this.textChunkStart >= this.leafTexts.length) {
          return;
        }
        var firstElement = this.leafTexts[this.textChunkStart];
        var textAnchor = firstElement.getStyle("text-anchor").getString("start");
        var isRTL = false;
        var shift = 0;
        if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
          shift = firstElement.x - this.minX;
        } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
          shift = firstElement.x - this.maxX;
        } else {
          shift = firstElement.x - (this.minX + this.maxX) / 2;
        }
        for (var i5 = this.textChunkStart; i5 < this.leafTexts.length; i5++) {
          this.leafTexts[i5].x += shift;
        }
        this.minX = Number.POSITIVE_INFINITY;
        this.maxX = Number.NEGATIVE_INFINITY;
        this.textChunkStart = this.leafTexts.length;
      }
      adjustChildCoordinatesRecursive(ctx) {
        this.children.forEach((_4, i5) => {
          this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i5);
        });
        this.applyAnchoring();
      }
      adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i5) {
        var child = parent.children[i5];
        if (child.children.length > 0) {
          child.children.forEach((_4, i6) => {
            textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i6);
          });
        } else {
          this.adjustChildCoordinates(ctx, textParent, parent, i5);
        }
      }
      adjustChildCoordinates(ctx, textParent, parent, i5) {
        var child = parent.children[i5];
        if (typeof child.measureText !== "function") {
          return child;
        }
        ctx.save();
        child.setContext(ctx, true);
        var xAttr = child.getAttribute("x");
        var yAttr = child.getAttribute("y");
        var dxAttr = child.getAttribute("dx");
        var dyAttr = child.getAttribute("dy");
        var customFont = child.getStyle("font-family").getDefinition();
        var isRTL = Boolean(customFont) && customFont.isRTL;
        if (i5 === 0) {
          if (!xAttr.hasValue()) {
            xAttr.setValue(child.getInheritedAttribute("x"));
          }
          if (!yAttr.hasValue()) {
            yAttr.setValue(child.getInheritedAttribute("y"));
          }
          if (!dxAttr.hasValue()) {
            dxAttr.setValue(child.getInheritedAttribute("dx"));
          }
          if (!dyAttr.hasValue()) {
            dyAttr.setValue(child.getInheritedAttribute("dy"));
          }
        }
        var width = child.measureText(ctx);
        if (isRTL) {
          textParent.x -= width;
        }
        if (xAttr.hasValue()) {
          textParent.applyAnchoring();
          child.x = xAttr.getPixels("x");
          if (dxAttr.hasValue()) {
            child.x += dxAttr.getPixels("x");
          }
        } else {
          if (dxAttr.hasValue()) {
            textParent.x += dxAttr.getPixels("x");
          }
          child.x = textParent.x;
        }
        textParent.x = child.x;
        if (!isRTL) {
          textParent.x += width;
        }
        if (yAttr.hasValue()) {
          child.y = yAttr.getPixels("y");
          if (dyAttr.hasValue()) {
            child.y += dyAttr.getPixels("y");
          }
        } else {
          if (dyAttr.hasValue()) {
            textParent.y += dyAttr.getPixels("y");
          }
          child.y = textParent.y;
        }
        textParent.y = child.y;
        textParent.leafTexts.push(child);
        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
        child.clearContext(ctx);
        ctx.restore();
        return child;
      }
      getChildBoundingBox(ctx, textParent, parent, i5) {
        var child = parent.children[i5];
        if (typeof child.getBoundingBox !== "function") {
          return null;
        }
        var boundingBox = child.getBoundingBox(ctx);
        if (!boundingBox) {
          return null;
        }
        child.children.forEach((_4, i6) => {
          var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i6);
          boundingBox.addBoundingBox(childBoundingBox);
        });
        return boundingBox;
      }
      renderChild(ctx, textParent, parent, i5) {
        var child = parent.children[i5];
        child.render(ctx);
        child.children.forEach((_4, i6) => {
          textParent.renderChild(ctx, textParent, child, i6);
        });
      }
      measureText(ctx) {
        var {
          measureCache
        } = this;
        if (~measureCache) {
          return measureCache;
        }
        var renderText = this.getText();
        var measure = this.measureTargetText(ctx, renderText);
        this.measureCache = measure;
        return measure;
      }
      measureTargetText(ctx, targetText) {
        if (!targetText.length) {
          return 0;
        }
        var {
          parent
        } = this;
        var customFont = parent.getStyle("font-family").getDefinition();
        if (customFont) {
          var fontSize = this.getFontSize();
          var text = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
          var dx = toNumbers(parent.getAttribute("dx").getString());
          var len = text.length;
          var _measure = 0;
          for (var i5 = 0; i5 < len; i5++) {
            var glyph = this.getGlyph(customFont, text, i5);
            _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
            if (typeof dx[i5] !== "undefined" && !isNaN(dx[i5])) {
              _measure += dx[i5];
            }
          }
          return _measure;
        }
        if (!ctx.measureText) {
          return targetText.length * 10;
        }
        ctx.save();
        this.setContext(ctx, true);
        var {
          width: measure
        } = ctx.measureText(targetText);
        this.clearContext(ctx);
        ctx.restore();
        return measure;
      }
      /**
       * Inherits positional attributes from {@link TextElement} parent(s). Attributes
       * are only inherited from a parent to its first child.
       * @param name - The attribute name.
       * @returns The attribute value or null.
       */
      getInheritedAttribute(name) {
        var current = this;
        while (current instanceof TextElement && current.isFirstChild()) {
          var parentAttr = current.parent.getAttribute(name);
          if (parentAttr.hasValue(true)) {
            return parentAttr.getValue("0");
          }
          current = current.parent;
        }
        return null;
      }
    };
    TSpanElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
        this.type = "tspan";
        this.text = this.children.length > 0 ? "" : this.getTextFromNode();
      }
      getText() {
        return this.text;
      }
    };
    TextNode = class extends TSpanElement {
      constructor() {
        super(...arguments);
        this.type = "textNode";
      }
    };
    SVGElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.root = false;
      }
      setContext(ctx) {
        var _this$node$parentNode;
        var {
          document: document2
        } = this;
        var {
          screen,
          window: window2
        } = document2;
        var canvas = ctx.canvas;
        screen.setDefaults(ctx);
        if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
          ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
          var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
          if (fontSizeProp.hasValue()) {
            document2.rootEmSize = fontSizeProp.getPixels("y");
            document2.emSize = document2.rootEmSize;
          }
        }
        if (!this.getAttribute("x").hasValue()) {
          this.getAttribute("x", true).setValue(0);
        }
        if (!this.getAttribute("y").hasValue()) {
          this.getAttribute("y", true).setValue(0);
        }
        var {
          width,
          height
        } = screen.viewPort;
        if (!this.getStyle("width").hasValue()) {
          this.getStyle("width", true).setValue("100%");
        }
        if (!this.getStyle("height").hasValue()) {
          this.getStyle("height", true).setValue("100%");
        }
        if (!this.getStyle("color").hasValue()) {
          this.getStyle("color", true).setValue("black");
        }
        var refXAttr = this.getAttribute("refX");
        var refYAttr = this.getAttribute("refY");
        var viewBoxAttr = this.getAttribute("viewBox");
        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
        var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
        var minX = 0;
        var minY = 0;
        var clipX = 0;
        var clipY = 0;
        if (viewBox) {
          minX = viewBox[0];
          minY = viewBox[1];
        }
        if (!this.root) {
          width = this.getStyle("width").getPixels("x");
          height = this.getStyle("height").getPixels("y");
          if (this.type === "marker") {
            clipX = minX;
            clipY = minY;
            minX = 0;
            minY = 0;
          }
        }
        screen.viewPort.setCurrent(width, height);
        if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
          this.getStyle("transform-origin", true, true).setValue("50% 50%");
        }
        super.setContext(ctx);
        ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
        if (viewBox) {
          width = viewBox[2];
          height = viewBox[3];
        }
        document2.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: screen.viewPort.width,
          desiredWidth: width,
          height: screen.viewPort.height,
          desiredHeight: height,
          minX,
          minY,
          refX: refXAttr.getValue(),
          refY: refYAttr.getValue(),
          clip,
          clipX,
          clipY
        });
        if (viewBox) {
          screen.viewPort.removeCurrent();
          screen.viewPort.setCurrent(width, height);
        }
      }
      clearContext(ctx) {
        super.clearContext(ctx);
        this.document.screen.viewPort.removeCurrent();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width) {
        var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var widthAttr = this.getAttribute("width", true);
        var heightAttr = this.getAttribute("height", true);
        var viewBoxAttr = this.getAttribute("viewBox");
        var styleAttr = this.getAttribute("style");
        var originWidth = widthAttr.getNumber(0);
        var originHeight = heightAttr.getNumber(0);
        if (preserveAspectRatio) {
          if (typeof preserveAspectRatio === "string") {
            this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
          } else {
            var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
            if (preserveAspectRatioAttr.hasValue()) {
              preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
            }
          }
        }
        widthAttr.setValue(width);
        heightAttr.setValue(height);
        if (!viewBoxAttr.hasValue()) {
          viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
        }
        if (styleAttr.hasValue()) {
          var widthStyle = this.getStyle("width");
          var heightStyle = this.getStyle("height");
          if (widthStyle.hasValue()) {
            widthStyle.setValue("".concat(width, "px"));
          }
          if (heightStyle.hasValue()) {
            heightStyle.setValue("".concat(height, "px"));
          }
        }
      }
    };
    RectElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "rect";
      }
      path(ctx) {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width", false, true).getPixels("x");
        var height = this.getStyle("height", false, true).getPixels("y");
        var rxAttr = this.getAttribute("rx");
        var ryAttr = this.getAttribute("ry");
        var rx = rxAttr.getPixels("x");
        var ry = ryAttr.getPixels("y");
        if (rxAttr.hasValue() && !ryAttr.hasValue()) {
          ry = rx;
        }
        if (ryAttr.hasValue() && !rxAttr.hasValue()) {
          rx = ry;
        }
        rx = Math.min(rx, width / 2);
        ry = Math.min(ry, height / 2);
        if (ctx) {
          var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
          ctx.beginPath();
          if (height > 0 && width > 0) {
            ctx.moveTo(x2 + rx, y3);
            ctx.lineTo(x2 + width - rx, y3);
            ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y3, x2 + width, y3 + ry - KAPPA * ry, x2 + width, y3 + ry);
            ctx.lineTo(x2 + width, y3 + height - ry);
            ctx.bezierCurveTo(x2 + width, y3 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y3 + height, x2 + width - rx, y3 + height);
            ctx.lineTo(x2 + rx, y3 + height);
            ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y3 + height, x2, y3 + height - ry + KAPPA * ry, x2, y3 + height - ry);
            ctx.lineTo(x2, y3 + ry);
            ctx.bezierCurveTo(x2, y3 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y3, x2 + rx, y3);
            ctx.closePath();
          }
        }
        return new BoundingBox(x2, y3, x2 + width, y3 + height);
      }
      getMarkers() {
        return null;
      }
    };
    CircleElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "circle";
      }
      path(ctx) {
        var cx = this.getAttribute("cx").getPixels("x");
        var cy = this.getAttribute("cy").getPixels("y");
        var r3 = this.getAttribute("r").getPixels();
        if (ctx && r3 > 0) {
          ctx.beginPath();
          ctx.arc(cx, cy, r3, 0, Math.PI * 2, false);
          ctx.closePath();
        }
        return new BoundingBox(cx - r3, cy - r3, cx + r3, cy + r3);
      }
      getMarkers() {
        return null;
      }
    };
    EllipseElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "ellipse";
      }
      path(ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        var rx = this.getAttribute("rx").getPixels("x");
        var ry = this.getAttribute("ry").getPixels("y");
        var cx = this.getAttribute("cx").getPixels("x");
        var cy = this.getAttribute("cy").getPixels("y");
        if (ctx && rx > 0 && ry > 0) {
          ctx.beginPath();
          ctx.moveTo(cx + rx, cy);
          ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
          ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
          ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
          ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
          ctx.closePath();
        }
        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
      }
      getMarkers() {
        return null;
      }
    };
    LineElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "line";
      }
      getPoints() {
        return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
      }
      path(ctx) {
        var [{
          x: x0,
          y: y0
        }, {
          x: x1,
          y: y1
        }] = this.getPoints();
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
        return new BoundingBox(x0, y0, x1, y1);
      }
      getMarkers() {
        var [p0, p1] = this.getPoints();
        var a4 = p0.angleTo(p1);
        return [[p0, a4], [p1, a4]];
      }
    };
    PolylineElement = class extends PathElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "polyline";
        this.points = [];
        this.points = Point.parsePath(this.getAttribute("points").getString());
      }
      path(ctx) {
        var {
          points
        } = this;
        var [{
          x: x0,
          y: y0
        }] = points;
        var boundingBox = new BoundingBox(x0, y0);
        if (ctx) {
          ctx.beginPath();
          ctx.moveTo(x0, y0);
        }
        points.forEach((_ref) => {
          var {
            x: x2,
            y: y3
          } = _ref;
          boundingBox.addPoint(x2, y3);
          if (ctx) {
            ctx.lineTo(x2, y3);
          }
        });
        return boundingBox;
      }
      getMarkers() {
        var {
          points
        } = this;
        var lastIndex = points.length - 1;
        var markers = [];
        points.forEach((point, i5) => {
          if (i5 === lastIndex) {
            return;
          }
          markers.push([point, point.angleTo(points[i5 + 1])]);
        });
        if (markers.length > 0) {
          markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
        }
        return markers;
      }
    };
    PolygonElement = class extends PolylineElement {
      constructor() {
        super(...arguments);
        this.type = "polygon";
      }
      path(ctx) {
        var boundingBox = super.path(ctx);
        var [{
          x: x2,
          y: y3
        }] = this.points;
        if (ctx) {
          ctx.lineTo(x2, y3);
          ctx.closePath();
        }
        return boundingBox;
      }
    };
    PatternElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "pattern";
      }
      createPattern(ctx, _4, parentOpacityProp) {
        var width = this.getStyle("width").getPixels("x", true);
        var height = this.getStyle("height").getPixels("y", true);
        var patternSvg = new SVGElement(this.document, null);
        patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
        patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
        patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
        patternSvg.children = this.children;
        var patternCanvas = this.document.createCanvas(width, height);
        var patternCtx = patternCanvas.getContext("2d");
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue() && yAttr.hasValue()) {
          patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
        }
        if (parentOpacityProp.hasValue()) {
          this.styles["fill-opacity"] = parentOpacityProp;
        } else {
          Reflect.deleteProperty(this.styles, "fill-opacity");
        }
        for (var x2 = -1; x2 <= 1; x2++) {
          for (var y3 = -1; y3 <= 1; y3++) {
            patternCtx.save();
            patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
            patternSvg.attributes.y = new Property(this.document, "y", y3 * patternCanvas.height);
            patternSvg.render(patternCtx);
            patternCtx.restore();
          }
        }
        var pattern = ctx.createPattern(patternCanvas, "repeat");
        return pattern;
      }
    };
    MarkerElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "marker";
      }
      render(ctx, point, angle) {
        if (!point) {
          return;
        }
        var {
          x: x2,
          y: y3
        } = point;
        var orient = this.getAttribute("orient").getString("auto");
        var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
        ctx.translate(x2, y3);
        if (orient === "auto") {
          ctx.rotate(angle);
        }
        if (markerUnits === "strokeWidth") {
          ctx.scale(ctx.lineWidth, ctx.lineWidth);
        }
        ctx.save();
        var markerSvg = new SVGElement(this.document, null);
        markerSvg.type = this.type;
        markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
        markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
        markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
        markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
        markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
        markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
        markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
        markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
        markerSvg.children = this.children;
        markerSvg.render(ctx);
        ctx.restore();
        if (markerUnits === "strokeWidth") {
          ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
        }
        if (orient === "auto") {
          ctx.rotate(-angle);
        }
        ctx.translate(-x2, -y3);
      }
    };
    DefsElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "defs";
      }
      render() {
      }
    };
    GElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "g";
      }
      getBoundingBox(ctx) {
        var boundingBox = new BoundingBox();
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        return boundingBox;
      }
    };
    GradientElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.attributesToInherit = ["gradientUnits"];
        this.stops = [];
        var {
          stops,
          children
        } = this;
        children.forEach((child) => {
          if (child.type === "stop") {
            stops.push(child);
          }
        });
      }
      getGradientUnits() {
        return this.getAttribute("gradientUnits").getString("objectBoundingBox");
      }
      createGradient(ctx, element, parentOpacityProp) {
        var stopsContainer = this;
        if (this.getHrefAttribute().hasValue()) {
          stopsContainer = this.getHrefAttribute().getDefinition();
          this.inheritStopContainer(stopsContainer);
        }
        var {
          stops
        } = stopsContainer;
        var gradient = this.getGradient(ctx, element);
        if (!gradient) {
          return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
        }
        stops.forEach((stop) => {
          gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
        });
        if (this.getAttribute("gradientTransform").hasValue()) {
          var {
            document: document2
          } = this;
          var {
            MAX_VIRTUAL_PIXELS,
            viewPort
          } = document2.screen;
          var [rootView] = viewPort.viewPorts;
          var rect = new RectElement(document2, null);
          rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
          rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
          rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
          var group = new GElement(document2, null);
          group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
          group.children = [rect];
          var patternSvg = new SVGElement(document2, null);
          patternSvg.attributes.x = new Property(document2, "x", 0);
          patternSvg.attributes.y = new Property(document2, "y", 0);
          patternSvg.attributes.width = new Property(document2, "width", rootView.width);
          patternSvg.attributes.height = new Property(document2, "height", rootView.height);
          patternSvg.children = [group];
          var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
          var patternCtx = patternCanvas.getContext("2d");
          patternCtx.fillStyle = gradient;
          patternSvg.render(patternCtx);
          return patternCtx.createPattern(patternCanvas, "no-repeat");
        }
        return gradient;
      }
      inheritStopContainer(stopsContainer) {
        this.attributesToInherit.forEach((attributeToInherit) => {
          if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
            this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
          }
        });
      }
      addParentOpacity(parentOpacityProp, color) {
        if (parentOpacityProp.hasValue()) {
          var colorProp = new Property(this.document, "color", color);
          return colorProp.addOpacity(parentOpacityProp).getColor();
        }
        return color;
      }
    };
    LinearGradientElement = class extends GradientElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "linearGradient";
        this.attributesToInherit.push("x1", "y1", "x2", "y2");
      }
      getGradient(ctx, element) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
          this.getAttribute("x1", true).setValue(0);
          this.getAttribute("y1", true).setValue(0);
          this.getAttribute("x2", true).setValue(1);
          this.getAttribute("y2", true).setValue(0);
        }
        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
        var y22 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
        if (x1 === x2 && y1 === y22) {
          return null;
        }
        return ctx.createLinearGradient(x1, y1, x2, y22);
      }
    };
    RadialGradientElement = class extends GradientElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "radialGradient";
        this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
      }
      getGradient(ctx, element) {
        var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
        var boundingBox = element.getBoundingBox(ctx);
        if (isBoundingBoxUnits && !boundingBox) {
          return null;
        }
        if (!this.getAttribute("cx").hasValue()) {
          this.getAttribute("cx", true).setValue("50%");
        }
        if (!this.getAttribute("cy").hasValue()) {
          this.getAttribute("cy", true).setValue("50%");
        }
        if (!this.getAttribute("r").hasValue()) {
          this.getAttribute("r", true).setValue("50%");
        }
        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
        var fx = cx;
        var fy = cy;
        if (this.getAttribute("fx").hasValue()) {
          fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
        }
        if (this.getAttribute("fy").hasValue()) {
          fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
        }
        var r3 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
        var fr = this.getAttribute("fr").getPixels();
        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r3);
      }
    };
    StopElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "stop";
        var offset2 = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
        var stopOpacity = this.getStyle("stop-opacity");
        var stopColor = this.getStyle("stop-color", true);
        if (stopColor.getString() === "") {
          stopColor.setValue("#000");
        }
        if (stopOpacity.hasValue()) {
          stopColor = stopColor.addOpacity(stopOpacity);
        }
        this.offset = offset2;
        this.color = stopColor.getColor();
      }
    };
    AnimateElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "animate";
        this.duration = 0;
        this.initialValue = null;
        this.initialUnits = "";
        this.removed = false;
        this.frozen = false;
        document2.screen.animations.push(this);
        this.begin = this.getAttribute("begin").getMilliseconds();
        this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
        this.from = this.getAttribute("from");
        this.to = this.getAttribute("to");
        this.values = new Property(document2, "values", null);
        var valuesAttr = this.getAttribute("values");
        if (valuesAttr.hasValue()) {
          this.values.setValue(valuesAttr.getString().split(";"));
        }
      }
      getProperty() {
        var attributeType = this.getAttribute("attributeType").getString();
        var attributeName = this.getAttribute("attributeName").getString();
        if (attributeType === "CSS") {
          return this.parent.getStyle(attributeName, true);
        }
        return this.parent.getAttribute(attributeName, true);
      }
      calcValue() {
        var {
          initialUnits
        } = this;
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
        if (initialUnits === "%") {
          newValue *= 100;
        }
        return "".concat(newValue).concat(initialUnits);
      }
      update(delta) {
        var {
          parent
        } = this;
        var prop = this.getProperty();
        if (!this.initialValue) {
          this.initialValue = prop.getString();
          this.initialUnits = prop.getUnits();
        }
        if (this.duration > this.maxDuration) {
          var fill = this.getAttribute("fill").getString("remove");
          if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
            this.duration = 0;
          } else if (fill === "freeze" && !this.frozen) {
            this.frozen = true;
            parent.animationFrozen = true;
            parent.animationFrozenValue = prop.getString();
          } else if (fill === "remove" && !this.removed) {
            this.removed = true;
            prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
            return true;
          }
          return false;
        }
        this.duration += delta;
        var updated = false;
        if (this.begin < this.duration) {
          var newValue = this.calcValue();
          var typeAttr = this.getAttribute("type");
          if (typeAttr.hasValue()) {
            var type = typeAttr.getString();
            newValue = "".concat(type, "(").concat(newValue, ")");
          }
          prop.setValue(newValue);
          updated = true;
        }
        return updated;
      }
      getProgress() {
        var {
          document: document2,
          values
        } = this;
        var result = {
          progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
        };
        if (values.hasValue()) {
          var p7 = result.progress * (values.getValue().length - 1);
          var lb = Math.floor(p7);
          var ub = Math.ceil(p7);
          result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
          result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
          result.progress = (p7 - lb) / (ub - lb);
        } else {
          result.from = this.from;
          result.to = this.to;
        }
        return result;
      }
    };
    AnimateColorElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateColor";
      }
      calcValue() {
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var colorFrom = new import_rgbcolor.default(from.getColor());
        var colorTo = new import_rgbcolor.default(to.getColor());
        if (colorFrom.ok && colorTo.ok) {
          var r3 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
          var g5 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
          var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
          return "rgb(".concat(Math.floor(r3), ", ").concat(Math.floor(g5), ", ").concat(Math.floor(b2), ")");
        }
        return this.getAttribute("from").getColor();
      }
    };
    AnimateTransformElement = class extends AnimateElement {
      constructor() {
        super(...arguments);
        this.type = "animateTransform";
      }
      calcValue() {
        var {
          progress,
          from,
          to
        } = this.getProgress();
        var transformFrom = toNumbers(from.getString());
        var transformTo = toNumbers(to.getString());
        var newValue = transformFrom.map((from2, i5) => {
          var to2 = transformTo[i5];
          return from2 + (to2 - from2) * progress;
        }).join(" ");
        return newValue;
      }
    };
    FontElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "font";
        this.glyphs = {};
        this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
        var {
          definitions
        } = document2;
        var {
          children
        } = this;
        for (var child of children) {
          switch (child.type) {
            case "font-face": {
              this.fontFace = child;
              var fontFamilyStyle = child.getStyle("font-family");
              if (fontFamilyStyle.hasValue()) {
                definitions[fontFamilyStyle.getString()] = this;
              }
              break;
            }
            case "missing-glyph":
              this.missingGlyph = child;
              break;
            case "glyph": {
              var glyph = child;
              if (glyph.arabicForm) {
                this.isRTL = true;
                this.isArabic = true;
                if (typeof this.glyphs[glyph.unicode] === "undefined") {
                  this.glyphs[glyph.unicode] = {};
                }
                this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
              } else {
                this.glyphs[glyph.unicode] = glyph;
              }
              break;
            }
          }
        }
      }
      render() {
      }
    };
    FontFaceElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "font-face";
        this.ascent = this.getAttribute("ascent").getNumber();
        this.descent = this.getAttribute("descent").getNumber();
        this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
      }
    };
    MissingGlyphElement = class extends PathElement {
      constructor() {
        super(...arguments);
        this.type = "missing-glyph";
        this.horizAdvX = 0;
      }
    };
    TRefElement = class extends TextElement {
      constructor() {
        super(...arguments);
        this.type = "tref";
      }
      getText() {
        var element = this.getHrefAttribute().getDefinition();
        if (element) {
          var firstChild = element.children[0];
          if (firstChild) {
            return firstChild.getText();
          }
        }
        return "";
      }
    };
    AElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "a";
        var {
          childNodes
        } = node2;
        var firstChild = childNodes[0];
        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
        this.hasText = hasText;
        this.text = hasText ? this.getTextFromNode(firstChild) : "";
      }
      getText() {
        return this.text;
      }
      renderChildren(ctx) {
        if (this.hasText) {
          super.renderChildren(ctx);
          var {
            document: document2,
            x: x2,
            y: y3
          } = this;
          var {
            mouse
          } = document2.screen;
          var fontSize = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
          if (mouse.isWorking()) {
            mouse.checkBoundingBox(this, new BoundingBox(x2, y3 - fontSize.getPixels("y"), x2 + this.measureText(ctx), y3));
          }
        } else if (this.children.length > 0) {
          var g5 = new GElement(this.document, null);
          g5.children = this.children;
          g5.parent = this;
          g5.render(ctx);
        }
      }
      onClick() {
        var {
          window: window2
        } = this.document;
        if (window2) {
          window2.open(this.getHrefAttribute().getString());
        }
      }
      onMouseMove() {
        var ctx = this.document.ctx;
        ctx.canvas.style.cursor = "pointer";
      }
    };
    TextPathElement = class extends TextElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "textPath";
        this.textWidth = 0;
        this.textHeight = 0;
        this.pathLength = -1;
        this.glyphInfo = null;
        this.letterSpacingCache = [];
        this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
        var pathElement = this.getHrefAttribute().getDefinition();
        this.text = this.getTextFromNode();
        this.dataArray = this.parsePathData(pathElement);
      }
      getText() {
        return this.text;
      }
      path(ctx) {
        var {
          dataArray
        } = this;
        if (ctx) {
          ctx.beginPath();
        }
        dataArray.forEach((_ref) => {
          var {
            type,
            points
          } = _ref;
          switch (type) {
            case PathParser.LINE_TO:
              if (ctx) {
                ctx.lineTo(points[0], points[1]);
              }
              break;
            case PathParser.MOVE_TO:
              if (ctx) {
                ctx.moveTo(points[0], points[1]);
              }
              break;
            case PathParser.CURVE_TO:
              if (ctx) {
                ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
              }
              break;
            case PathParser.QUAD_TO:
              if (ctx) {
                ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
              }
              break;
            case PathParser.ARC: {
              var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
              var r3 = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              if (ctx) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r3, theta, theta + dTheta, Boolean(1 - fs));
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              }
              break;
            }
            case PathParser.CLOSE_PATH:
              if (ctx) {
                ctx.closePath();
              }
              break;
          }
        });
      }
      renderChildren(ctx) {
        this.setTextData(ctx);
        ctx.save();
        var textDecoration = this.parent.getStyle("text-decoration").getString();
        var fontSize = this.getFontSize();
        var {
          glyphInfo
        } = this;
        var fill = ctx.fillStyle;
        if (textDecoration === "underline") {
          ctx.beginPath();
        }
        glyphInfo.forEach((glyph, i5) => {
          var {
            p0,
            p1,
            rotation,
            text: partialText
          } = glyph;
          ctx.save();
          ctx.translate(p0.x, p0.y);
          ctx.rotate(rotation);
          if (ctx.fillStyle) {
            ctx.fillText(partialText, 0, 0);
          }
          if (ctx.strokeStyle) {
            ctx.strokeText(partialText, 0, 0);
          }
          ctx.restore();
          if (textDecoration === "underline") {
            if (i5 === 0) {
              ctx.moveTo(p0.x, p0.y + fontSize / 8);
            }
            ctx.lineTo(p1.x, p1.y + fontSize / 5);
          }
        });
        if (textDecoration === "underline") {
          ctx.lineWidth = fontSize / 20;
          ctx.strokeStyle = fill;
          ctx.stroke();
          ctx.closePath();
        }
        ctx.restore();
      }
      getLetterSpacingAt() {
        var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return this.letterSpacingCache[idx] || 0;
      }
      findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c5, charI) {
        var offset2 = inputOffset;
        var glyphWidth = this.measureText(ctx, c5);
        if (c5 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }
        if (charI > -1) {
          offset2 += this.getLetterSpacingAt(charI);
        }
        var splineStep = this.textHeight / 20;
        var p0 = this.getEquidistantPointOnPath(offset2, splineStep, 0);
        var p1 = this.getEquidistantPointOnPath(offset2 + glyphWidth, splineStep, 0);
        var segment = {
          p0,
          p1
        };
        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
        if (dy) {
          var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
          var dyY = Math.cos(-rotation) * dy;
          segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
            x: p0.x + dyX,
            y: p0.y + dyY
          });
          segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
            x: p1.x + dyX,
            y: p1.y + dyY
          });
        }
        offset2 += glyphWidth;
        return {
          offset: offset2,
          segment,
          rotation
        };
      }
      measureText(ctx, text) {
        var {
          measuresCache
        } = this;
        var targetText = text || this.getText();
        if (measuresCache.has(targetText)) {
          return measuresCache.get(targetText);
        }
        var measure = this.measureTargetText(ctx, targetText);
        measuresCache.set(targetText, measure);
        return measure;
      }
      // This method supposes what all custom fonts already loaded.
      // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
      // You need to call this method manually to update glyphs cache.
      setTextData(ctx) {
        if (this.glyphInfo) {
          return;
        }
        var renderText = this.getText();
        var chars = renderText.split("");
        var spacesNumber = renderText.split(" ").length - 1;
        var dx = this.parent.getAttribute("dx").split().map((_4) => _4.getPixels("x"));
        var dy = this.parent.getAttribute("dy").getPixels("y");
        var anchor = this.parent.getStyle("text-anchor").getString("start");
        var thisSpacing = this.getStyle("letter-spacing");
        var parentSpacing = this.parent.getStyle("letter-spacing");
        var letterSpacing = 0;
        if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
          letterSpacing = parentSpacing.getPixels();
        } else if (thisSpacing.hasValue()) {
          if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
            letterSpacing = thisSpacing.getPixels();
          }
        }
        var letterSpacingCache = [];
        var textLen = renderText.length;
        this.letterSpacingCache = letterSpacingCache;
        for (var i5 = 0; i5 < textLen; i5++) {
          letterSpacingCache.push(typeof dx[i5] !== "undefined" ? dx[i5] : letterSpacing);
        }
        var dxSum = letterSpacingCache.reduce((acc, cur, i6) => i6 === 0 ? 0 : acc + cur || 0, 0);
        var textWidth = this.measureText(ctx);
        var textFullWidth = Math.max(textWidth + dxSum, 0);
        this.textWidth = textWidth;
        this.textHeight = this.getFontSize();
        this.glyphInfo = [];
        var fullPathWidth = this.getPathLength();
        var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
        var offset2 = 0;
        if (anchor === "middle" || anchor === "center") {
          offset2 = -textFullWidth / 2;
        }
        if (anchor === "end" || anchor === "right") {
          offset2 = -textFullWidth;
        }
        offset2 += startOffset;
        chars.forEach((char, i6) => {
          var {
            offset: nextOffset,
            segment,
            rotation
          } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset2, dy, char, i6);
          offset2 = nextOffset;
          if (!segment.p0 || !segment.p1) {
            return;
          }
          this.glyphInfo.push({
            // transposeX: midpoint.x,
            // transposeY: midpoint.y,
            text: chars[i6],
            p0: segment.p0,
            p1: segment.p1,
            rotation
          });
        });
      }
      parsePathData(path) {
        this.pathLength = -1;
        if (!path) {
          return [];
        }
        var pathCommands = [];
        var {
          pathParser
        } = path;
        pathParser.reset();
        while (!pathParser.isEnd()) {
          var {
            current
          } = pathParser;
          var startX = current ? current.x : 0;
          var startY = current ? current.y : 0;
          var command = pathParser.next();
          var nextCommandType = command.type;
          var points = [];
          switch (command.type) {
            case PathParser.MOVE_TO:
              this.pathM(pathParser, points);
              break;
            case PathParser.LINE_TO:
              nextCommandType = this.pathL(pathParser, points);
              break;
            case PathParser.HORIZ_LINE_TO:
              nextCommandType = this.pathH(pathParser, points);
              break;
            case PathParser.VERT_LINE_TO:
              nextCommandType = this.pathV(pathParser, points);
              break;
            case PathParser.CURVE_TO:
              this.pathC(pathParser, points);
              break;
            case PathParser.SMOOTH_CURVE_TO:
              nextCommandType = this.pathS(pathParser, points);
              break;
            case PathParser.QUAD_TO:
              this.pathQ(pathParser, points);
              break;
            case PathParser.SMOOTH_QUAD_TO:
              nextCommandType = this.pathT(pathParser, points);
              break;
            case PathParser.ARC:
              points = this.pathA(pathParser);
              break;
            case PathParser.CLOSE_PATH:
              PathElement.pathZ(pathParser);
              break;
          }
          if (command.type !== PathParser.CLOSE_PATH) {
            pathCommands.push({
              type: nextCommandType,
              points,
              start: {
                x: startX,
                y: startY
              },
              pathLength: this.calcLength(startX, startY, nextCommandType, points)
            });
          } else {
            pathCommands.push({
              type: PathParser.CLOSE_PATH,
              points: [],
              pathLength: 0
            });
          }
        }
        return pathCommands;
      }
      pathM(pathParser, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathM(pathParser).point;
        points.push(x2, y3);
      }
      pathL(pathParser, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathL(pathParser).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathH(pathParser, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathH(pathParser).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathV(pathParser, points) {
        var {
          x: x2,
          y: y3
        } = PathElement.pathV(pathParser).point;
        points.push(x2, y3);
        return PathParser.LINE_TO;
      }
      pathC(pathParser, points) {
        var {
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathC(pathParser);
        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathS(pathParser, points) {
        var {
          point,
          controlPoint,
          currentPoint
        } = PathElement.pathS(pathParser);
        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.CURVE_TO;
      }
      pathQ(pathParser, points) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathQ(pathParser);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
      pathT(pathParser, points) {
        var {
          controlPoint,
          currentPoint
        } = PathElement.pathT(pathParser);
        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
        return PathParser.QUAD_TO;
      }
      pathA(pathParser) {
        var {
          rX,
          rY,
          sweepFlag,
          xAxisRotation,
          centp,
          a1,
          ad
        } = PathElement.pathA(pathParser);
        if (sweepFlag === 0 && ad > 0) {
          ad -= 2 * Math.PI;
        }
        if (sweepFlag === 1 && ad < 0) {
          ad += 2 * Math.PI;
        }
        return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
      }
      calcLength(x2, y3, commandType, points) {
        var len = 0;
        var p1 = null;
        var p22 = null;
        var t5 = 0;
        switch (commandType) {
          case PathParser.LINE_TO:
            return this.getLineLength(x2, y3, points[0], points[1]);
          case PathParser.CURVE_TO:
            len = 0;
            p1 = this.getPointOnCubicBezier(0, x2, y3, points[0], points[1], points[2], points[3], points[4], points[5]);
            for (t5 = 0.01; t5 <= 1; t5 += 0.01) {
              p22 = this.getPointOnCubicBezier(t5, x2, y3, points[0], points[1], points[2], points[3], points[4], points[5]);
              len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
              p1 = p22;
            }
            return len;
          case PathParser.QUAD_TO:
            len = 0;
            p1 = this.getPointOnQuadraticBezier(0, x2, y3, points[0], points[1], points[2], points[3]);
            for (t5 = 0.01; t5 <= 1; t5 += 0.01) {
              p22 = this.getPointOnQuadraticBezier(t5, x2, y3, points[0], points[1], points[2], points[3]);
              len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
              p1 = p22;
            }
            return len;
          case PathParser.ARC: {
            len = 0;
            var start2 = points[4];
            var dTheta = points[5];
            var end2 = points[4] + dTheta;
            var inc = Math.PI / 180;
            if (Math.abs(start2 - end2) < inc) {
              inc = Math.abs(start2 - end2);
            }
            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start2, 0);
            if (dTheta < 0) {
              for (t5 = start2 - inc; t5 > end2; t5 -= inc) {
                p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t5, 0);
                len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
                p1 = p22;
              }
            } else {
              for (t5 = start2 + inc; t5 < end2; t5 += inc) {
                p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t5, 0);
                len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
                p1 = p22;
              }
            }
            p22 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end2, 0);
            len += this.getLineLength(p1.x, p1.y, p22.x, p22.y);
            return len;
          }
        }
        return 0;
      }
      getPointOnLine(dist, p1x, p1y, p2x, p2y) {
        var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
        var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
        var m6 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
        var run = Math.sqrt(dist * dist / (1 + m6 * m6));
        if (p2x < p1x) {
          run *= -1;
        }
        var rise = m6 * run;
        var pt2 = null;
        if (p2x === p1x) {
          pt2 = {
            x: fromX,
            y: fromY + rise
          };
        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m6) {
          pt2 = {
            x: fromX + run,
            y: fromY + rise
          };
        } else {
          var ix = 0;
          var iy = 0;
          var len = this.getLineLength(p1x, p1y, p2x, p2y);
          if (len < PSEUDO_ZERO) {
            return null;
          }
          var u4 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
          u4 /= len * len;
          ix = p1x + u4 * (p2x - p1x);
          iy = p1y + u4 * (p2y - p1y);
          var pRise = this.getLineLength(fromX, fromY, ix, iy);
          var pRun = Math.sqrt(dist * dist - pRise * pRise);
          run = Math.sqrt(pRun * pRun / (1 + m6 * m6));
          if (p2x < p1x) {
            run *= -1;
          }
          rise = m6 * run;
          pt2 = {
            x: ix + run,
            y: iy + rise
          };
        }
        return pt2;
      }
      getPointOnPath(distance) {
        var fullLen = this.getPathLength();
        var cumulativePathLength = 0;
        var p7 = null;
        if (distance < -5e-5 || distance - 5e-5 > fullLen) {
          return null;
        }
        var {
          dataArray
        } = this;
        for (var command of dataArray) {
          if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance)) {
            cumulativePathLength += command.pathLength;
            continue;
          }
          var delta = distance - cumulativePathLength;
          var currentT = 0;
          switch (command.type) {
            case PathParser.LINE_TO:
              p7 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
              break;
            case PathParser.ARC: {
              var start2 = command.points[4];
              var dTheta = command.points[5];
              var end2 = command.points[4] + dTheta;
              currentT = start2 + delta / command.pathLength * dTheta;
              if (dTheta < 0 && currentT < end2 || dTheta >= 0 && currentT > end2) {
                break;
              }
              p7 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
              break;
            }
            case PathParser.CURVE_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p7 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
              break;
            case PathParser.QUAD_TO:
              currentT = delta / command.pathLength;
              if (currentT > 1) {
                currentT = 1;
              }
              p7 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
              break;
          }
          if (p7) {
            return p7;
          }
          break;
        }
        return null;
      }
      getLineLength(x1, y1, x2, y22) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y22 - y1) * (y22 - y1));
      }
      getPathLength() {
        if (this.pathLength === -1) {
          this.pathLength = this.dataArray.reduce((length2, command) => command.pathLength > 0 ? length2 + command.pathLength : length2, 0);
        }
        return this.pathLength;
      }
      getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
        var y3 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
        var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
        var y3 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
        return {
          x: x2,
          y: y3
        };
      }
      getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi);
        var sinPsi = Math.sin(psi);
        var pt2 = {
          x: rx * Math.cos(theta),
          y: ry * Math.sin(theta)
        };
        return {
          x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
          y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
        };
      }
      // TODO need some optimisations. possibly build cache only for curved segments?
      buildEquidistantCache(inputStep, inputPrecision) {
        var fullLen = this.getPathLength();
        var precision = inputPrecision || 0.25;
        var step = inputStep || fullLen / 100;
        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
          this.equidistantCache = {
            step,
            precision,
            points: []
          };
          var s5 = 0;
          for (var l4 = 0; l4 <= fullLen; l4 += precision) {
            var p0 = this.getPointOnPath(l4);
            var p1 = this.getPointOnPath(l4 + precision);
            if (!p0 || !p1) {
              continue;
            }
            s5 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
            if (s5 >= step) {
              this.equidistantCache.points.push({
                x: p0.x,
                y: p0.y,
                distance: l4
              });
              s5 -= step;
            }
          }
        }
      }
      getEquidistantPointOnPath(targetDistance, step, precision) {
        this.buildEquidistantCache(step, precision);
        if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
          return null;
        }
        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
        return this.equidistantCache.points[idx] || null;
      }
    };
    dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
    ImageElement = class extends RenderedElement {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "image";
        this.loaded = false;
        var href = this.getHrefAttribute().getString();
        if (!href) {
          return;
        }
        var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
        document2.images.push(this);
        if (!isSvg) {
          void this.loadImage(href);
        } else {
          void this.loadSvg(href);
        }
        this.isSvg = isSvg;
      }
      loadImage(href) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var image = yield _this.document.createImage(href);
            _this.image = image;
          } catch (err) {
            console.error('Error while loading image "'.concat(href, '":'), err);
          }
          _this.loaded = true;
        })();
      }
      loadSvg(href) {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          var match2 = dataUriRegex.exec(href);
          if (match2) {
            var data = match2[5];
            if (match2[4] === "base64") {
              _this2.image = atob(data);
            } else {
              _this2.image = decodeURIComponent(data);
            }
          } else {
            try {
              var response = yield _this2.document.fetch(href);
              var svg = yield response.text();
              _this2.image = svg;
            } catch (err) {
              console.error('Error while loading image "'.concat(href, '":'), err);
            }
          }
          _this2.loaded = true;
        })();
      }
      renderChildren(ctx) {
        var {
          document: document2,
          image,
          loaded
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        if (!loaded || !image || !width || !height) {
          return;
        }
        ctx.save();
        ctx.translate(x2, y3);
        if (this.isSvg) {
          var subDocument = document2.canvg.forkString(ctx, this.image, {
            ignoreMouse: true,
            ignoreAnimation: true,
            ignoreDimensions: true,
            ignoreClear: true,
            offsetX: 0,
            offsetY: 0,
            scaleWidth: width,
            scaleHeight: height
          });
          subDocument.document.documentElement.parent = this;
          void subDocument.render();
        } else {
          var _image = this.image;
          document2.setViewBox({
            ctx,
            aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
            width,
            desiredWidth: _image.width,
            height,
            desiredHeight: _image.height
          });
          if (this.loaded) {
            if (typeof _image.complete === "undefined" || _image.complete) {
              ctx.drawImage(_image, 0, 0);
            }
          }
        }
        ctx.restore();
      }
      getBoundingBox() {
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        return new BoundingBox(x2, y3, x2 + width, y3 + height);
      }
    };
    SymbolElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "symbol";
      }
      render(_4) {
      }
    };
    SVGFontLoader = class {
      constructor(document2) {
        this.document = document2;
        this.loaded = false;
        document2.fonts.push(this);
      }
      load(fontFamily, url) {
        var _this = this;
        return _asyncToGenerator(function* () {
          try {
            var {
              document: document2
            } = _this;
            var svgDocument = yield document2.canvg.parser.load(url);
            var fonts = svgDocument.getElementsByTagName("font");
            Array.from(fonts).forEach((fontNode) => {
              var font = document2.createElement(fontNode);
              document2.definitions[fontFamily] = font;
            });
          } catch (err) {
            console.error('Error while loading font "'.concat(url, '":'), err);
          }
          _this.loaded = true;
        })();
      }
    };
    StyleElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "style";
        var css = compressSpaces(
          Array.from(node2.childNodes).map((_4) => _4.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
          // remove imports
        );
        var cssDefs = css.split("}");
        cssDefs.forEach((_4) => {
          var def2 = _4.trim();
          if (!def2) {
            return;
          }
          var cssParts = def2.split("{");
          var cssClasses = cssParts[0].split(",");
          var cssProps = cssParts[1].split(";");
          cssClasses.forEach((_5) => {
            var cssClass = _5.trim();
            if (!cssClass) {
              return;
            }
            var props = document2.styles[cssClass] || {};
            cssProps.forEach((cssProp) => {
              var prop = cssProp.indexOf(":");
              var name = cssProp.substr(0, prop).trim();
              var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
              if (name && value) {
                props[name] = new Property(document2, name, value);
              }
            });
            document2.styles[cssClass] = props;
            document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
            if (cssClass === "@font-face") {
              var fontFamily = props["font-family"].getString().replace(/"|'/g, "");
              var srcs = props.src.getString().split(",");
              srcs.forEach((src) => {
                if (src.indexOf('format("svg")') > 0) {
                  var url = parseExternalUrl(src);
                  if (url) {
                    void new SVGFontLoader(document2).load(fontFamily, url);
                  }
                }
              });
            }
          });
        });
      }
    };
    StyleElement.parseExternalUrl = parseExternalUrl;
    UseElement = class extends RenderedElement {
      constructor() {
        super(...arguments);
        this.type = "use";
      }
      setContext(ctx) {
        super.setContext(ctx);
        var xAttr = this.getAttribute("x");
        var yAttr = this.getAttribute("y");
        if (xAttr.hasValue()) {
          ctx.translate(xAttr.getPixels("x"), 0);
        }
        if (yAttr.hasValue()) {
          ctx.translate(0, yAttr.getPixels("y"));
        }
      }
      path(ctx) {
        var {
          element
        } = this;
        if (element) {
          element.path(ctx);
        }
      }
      renderChildren(ctx) {
        var {
          document: document2,
          element
        } = this;
        if (element) {
          var tempSvg = element;
          if (element.type === "symbol") {
            tempSvg = new SVGElement(document2, null);
            tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
            tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
            tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
            tempSvg.children = element.children;
            element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
          }
          if (tempSvg.type === "svg") {
            var widthStyle = this.getStyle("width", false, true);
            var heightStyle = this.getStyle("height", false, true);
            if (widthStyle.hasValue()) {
              tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
            }
            if (heightStyle.hasValue()) {
              tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
            }
          }
          var oldParent = tempSvg.parent;
          tempSvg.parent = this;
          tempSvg.render(ctx);
          tempSvg.parent = oldParent;
        }
      }
      getBoundingBox(ctx) {
        var {
          element
        } = this;
        if (element) {
          return element.getBoundingBox(ctx);
        }
        return null;
      }
      elementTransform() {
        var {
          document: document2,
          element
        } = this;
        return Transform.fromElement(document2, element);
      }
      get element() {
        if (!this.cachedElement) {
          this.cachedElement = this.getHrefAttribute().getDefinition();
        }
        return this.cachedElement;
      }
    };
    FeColorMatrixElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feColorMatrix";
        var matrix = toNumbers(this.getAttribute("values").getString());
        switch (this.getAttribute("type").getString("matrix")) {
          case "saturate": {
            var s5 = matrix[0];
            matrix = [0.213 + 0.787 * s5, 0.715 - 0.715 * s5, 0.072 - 0.072 * s5, 0, 0, 0.213 - 0.213 * s5, 0.715 + 0.285 * s5, 0.072 - 0.072 * s5, 0, 0, 0.213 - 0.213 * s5, 0.715 - 0.715 * s5, 0.072 + 0.928 * s5, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "hueRotate": {
            var a4 = matrix[0] * Math.PI / 180;
            matrix = [c3(a4, 0.213, 0.787, -0.213), c3(a4, 0.715, -0.715, -0.715), c3(a4, 0.072, -0.072, 0.928), 0, 0, c3(a4, 0.213, -0.213, 0.143), c3(a4, 0.715, 0.285, 0.14), c3(a4, 0.072, -0.072, -0.283), 0, 0, c3(a4, 0.213, -0.213, -0.787), c3(a4, 0.715, -0.715, 0.715), c3(a4, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            break;
          }
          case "luminanceToAlpha":
            matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
            break;
        }
        this.matrix = matrix;
        this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
      }
      apply(ctx, _x, _y, width, height) {
        var {
          includeOpacity,
          matrix
        } = this;
        var srcData = ctx.getImageData(0, 0, width, height);
        for (var y3 = 0; y3 < height; y3++) {
          for (var x2 = 0; x2 < width; x2++) {
            var r3 = imGet(srcData.data, x2, y3, width, height, 0);
            var g5 = imGet(srcData.data, x2, y3, width, height, 1);
            var b2 = imGet(srcData.data, x2, y3, width, height, 2);
            var a4 = imGet(srcData.data, x2, y3, width, height, 3);
            var nr = m4(matrix, 0, r3) + m4(matrix, 1, g5) + m4(matrix, 2, b2) + m4(matrix, 3, a4) + m4(matrix, 4, 1);
            var ng = m4(matrix, 5, r3) + m4(matrix, 6, g5) + m4(matrix, 7, b2) + m4(matrix, 8, a4) + m4(matrix, 9, 1);
            var nb = m4(matrix, 10, r3) + m4(matrix, 11, g5) + m4(matrix, 12, b2) + m4(matrix, 13, a4) + m4(matrix, 14, 1);
            var na = m4(matrix, 15, r3) + m4(matrix, 16, g5) + m4(matrix, 17, b2) + m4(matrix, 18, a4) + m4(matrix, 19, 1);
            if (includeOpacity) {
              nr = 0;
              ng = 0;
              nb = 0;
              na *= a4 / 255;
            }
            imSet(srcData.data, x2, y3, width, height, 0, nr);
            imSet(srcData.data, x2, y3, width, height, 1, ng);
            imSet(srcData.data, x2, y3, width, height, 2, nb);
            imSet(srcData.data, x2, y3, width, height, 3, na);
          }
        }
        ctx.clearRect(0, 0, width, height);
        ctx.putImageData(srcData, 0, 0);
      }
    };
    MaskElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "mask";
      }
      apply(ctx, element) {
        var {
          document: document2
        } = this;
        var x2 = this.getAttribute("x").getPixels("x");
        var y3 = this.getAttribute("y").getPixels("y");
        var width = this.getStyle("width").getPixels("x");
        var height = this.getStyle("height").getPixels("y");
        if (!width && !height) {
          var boundingBox = new BoundingBox();
          this.children.forEach((child) => {
            boundingBox.addBoundingBox(child.getBoundingBox(ctx));
          });
          x2 = Math.floor(boundingBox.x1);
          y3 = Math.floor(boundingBox.y1);
          width = Math.floor(boundingBox.width);
          height = Math.floor(boundingBox.height);
        }
        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
        var maskCanvas = document2.createCanvas(x2 + width, y3 + height);
        var maskCtx = maskCanvas.getContext("2d");
        document2.screen.setDefaults(maskCtx);
        this.renderChildren(maskCtx);
        new FeColorMatrixElement(document2, {
          nodeType: 1,
          childNodes: [],
          attributes: [{
            nodeName: "type",
            value: "luminanceToAlpha"
          }, {
            nodeName: "includeOpacity",
            value: "true"
          }]
        }).apply(maskCtx, 0, 0, x2 + width, y3 + height);
        var tmpCanvas = document2.createCanvas(x2 + width, y3 + height);
        var tmpCtx = tmpCanvas.getContext("2d");
        document2.screen.setDefaults(tmpCtx);
        element.render(tmpCtx);
        tmpCtx.globalCompositeOperation = "destination-in";
        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
        tmpCtx.fillRect(0, 0, x2 + width, y3 + height);
        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
        ctx.fillRect(0, 0, x2 + width, y3 + height);
        this.restoreStyles(element, ignoredStyles);
      }
      render(_4) {
      }
    };
    MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
    noop2 = () => {
    };
    ClipPathElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "clipPath";
      }
      apply(ctx) {
        var {
          document: document2
        } = this;
        var contextProto = Reflect.getPrototypeOf(ctx);
        var {
          beginPath,
          closePath
        } = ctx;
        if (contextProto) {
          contextProto.beginPath = noop2;
          contextProto.closePath = noop2;
        }
        Reflect.apply(beginPath, ctx, []);
        this.children.forEach((child) => {
          if (typeof child.path === "undefined") {
            return;
          }
          var transform = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
          if (!transform) {
            transform = Transform.fromElement(document2, child);
          }
          if (transform) {
            transform.apply(ctx);
          }
          child.path(ctx);
          if (contextProto) {
            contextProto.closePath = closePath;
          }
          if (transform) {
            transform.unapply(ctx);
          }
        });
        Reflect.apply(closePath, ctx, []);
        ctx.clip();
        if (contextProto) {
          contextProto.beginPath = beginPath;
          contextProto.closePath = closePath;
        }
      }
      render(_4) {
      }
    };
    FilterElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "filter";
      }
      apply(ctx, element) {
        var {
          document: document2,
          children
        } = this;
        var boundingBox = element.getBoundingBox(ctx);
        if (!boundingBox) {
          return;
        }
        var px2 = 0;
        var py = 0;
        children.forEach((child) => {
          var efd = child.extraFilterDistance || 0;
          px2 = Math.max(px2, efd);
          py = Math.max(py, efd);
        });
        var width = Math.floor(boundingBox.width);
        var height = Math.floor(boundingBox.height);
        var tmpCanvasWidth = width + 2 * px2;
        var tmpCanvasHeight = height + 2 * py;
        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
          return;
        }
        var x2 = Math.floor(boundingBox.x);
        var y3 = Math.floor(boundingBox.y);
        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
        var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
        var tmpCtx = tmpCanvas.getContext("2d");
        document2.screen.setDefaults(tmpCtx);
        tmpCtx.translate(-x2 + px2, -y3 + py);
        element.render(tmpCtx);
        children.forEach((child) => {
          if (typeof child.apply === "function") {
            child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
          }
        });
        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px2, y3 - py, tmpCanvasWidth, tmpCanvasHeight);
        this.restoreStyles(element, ignoredStyles);
      }
      render(_4) {
      }
    };
    FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
    FeDropShadowElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feDropShadow";
        this.addStylesFromStyleDefinition();
      }
      apply(_4, _x, _y, _width, _height) {
      }
    };
    FeMorphologyElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "feMorphology";
      }
      apply(_4, _x, _y, _width, _height) {
      }
    };
    FeCompositeElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "feComposite";
      }
      apply(_4, _x, _y, _width, _height) {
      }
    };
    FeGaussianBlurElement = class extends Element2 {
      constructor(document2, node2, captureTextNodes) {
        super(document2, node2, captureTextNodes);
        this.type = "feGaussianBlur";
        this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
        this.extraFilterDistance = this.blurRadius;
      }
      apply(ctx, x2, y3, width, height) {
        var {
          document: document2,
          blurRadius
        } = this;
        var body = document2.window ? document2.window.document.body : null;
        var canvas = ctx.canvas;
        canvas.id = document2.getUniqueId();
        if (body) {
          canvas.style.display = "none";
          body.appendChild(canvas);
        }
        processCanvasRGBA(canvas, x2, y3, width, height, blurRadius);
        if (body) {
          body.removeChild(canvas);
        }
      }
    };
    TitleElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "title";
      }
    };
    DescElement = class extends Element2 {
      constructor() {
        super(...arguments);
        this.type = "desc";
      }
    };
    elements = {
      "svg": SVGElement,
      "rect": RectElement,
      "circle": CircleElement,
      "ellipse": EllipseElement,
      "line": LineElement,
      "polyline": PolylineElement,
      "polygon": PolygonElement,
      "path": PathElement,
      "pattern": PatternElement,
      "marker": MarkerElement,
      "defs": DefsElement,
      "linearGradient": LinearGradientElement,
      "radialGradient": RadialGradientElement,
      "stop": StopElement,
      "animate": AnimateElement,
      "animateColor": AnimateColorElement,
      "animateTransform": AnimateTransformElement,
      "font": FontElement,
      "font-face": FontFaceElement,
      "missing-glyph": MissingGlyphElement,
      "glyph": GlyphElement,
      "text": TextElement,
      "tspan": TSpanElement,
      "tref": TRefElement,
      "a": AElement,
      "textPath": TextPathElement,
      "image": ImageElement,
      "g": GElement,
      "symbol": SymbolElement,
      "style": StyleElement,
      "use": UseElement,
      "mask": MaskElement,
      "clipPath": ClipPathElement,
      "filter": FilterElement,
      "feDropShadow": FeDropShadowElement,
      "feMorphology": FeMorphologyElement,
      "feComposite": FeCompositeElement,
      "feColorMatrix": FeColorMatrixElement,
      "feGaussianBlur": FeGaussianBlurElement,
      "title": TitleElement,
      "desc": DescElement
    };
    Document = class {
      constructor(canvg) {
        var {
          rootEmSize = 12,
          emSize = 12,
          createCanvas: createCanvas2 = Document.createCanvas,
          createImage: createImage3 = Document.createImage,
          anonymousCrossOrigin
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.canvg = canvg;
        this.definitions = {};
        this.styles = {};
        this.stylesSpecificity = {};
        this.images = [];
        this.fonts = [];
        this.emSizeStack = [];
        this.uniqueId = 0;
        this.screen = canvg.screen;
        this.rootEmSize = rootEmSize;
        this.emSize = emSize;
        this.createCanvas = createCanvas2;
        this.createImage = this.bindCreateImage(createImage3, anonymousCrossOrigin);
        this.screen.wait(this.isImagesLoaded.bind(this));
        this.screen.wait(this.isFontsLoaded.bind(this));
      }
      bindCreateImage(createImage3, anonymousCrossOrigin) {
        if (typeof anonymousCrossOrigin === "boolean") {
          return (source, forceAnonymousCrossOrigin) => createImage3(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
        }
        return createImage3;
      }
      get window() {
        return this.screen.window;
      }
      get fetch() {
        return this.screen.fetch;
      }
      get ctx() {
        return this.screen.ctx;
      }
      get emSize() {
        var {
          emSizeStack
        } = this;
        return emSizeStack[emSizeStack.length - 1];
      }
      set emSize(value) {
        var {
          emSizeStack
        } = this;
        emSizeStack.push(value);
      }
      popEmSize() {
        var {
          emSizeStack
        } = this;
        emSizeStack.pop();
      }
      getUniqueId() {
        return "canvg".concat(++this.uniqueId);
      }
      isImagesLoaded() {
        return this.images.every((_4) => _4.loaded);
      }
      isFontsLoaded() {
        return this.fonts.every((_4) => _4.loaded);
      }
      createDocumentElement(document2) {
        var documentElement = this.createElement(document2.documentElement);
        documentElement.root = true;
        documentElement.addStylesFromStyleDefinition();
        this.documentElement = documentElement;
        return documentElement;
      }
      createElement(node2) {
        var elementType = node2.nodeName.replace(/^[^:]+:/, "");
        var ElementType = Document.elementTypes[elementType];
        if (typeof ElementType !== "undefined") {
          return new ElementType(this, node2);
        }
        return new UnknownElement(this, node2);
      }
      createTextNode(node2) {
        return new TextNode(this, node2);
      }
      setViewBox(config) {
        this.screen.setViewBox(_objectSpread$1({
          document: this
        }, config));
      }
    };
    Document.createCanvas = createCanvas;
    Document.createImage = createImage2;
    Document.elementTypes = elements;
    Canvg = class {
      /**
       * Main constructor.
       * @param ctx - Rendering context.
       * @param svg - SVG Document.
       * @param options - Rendering options.
       */
      constructor(ctx, svg) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        this.parser = new Parser(options2);
        this.screen = new Screen(ctx, options2);
        this.options = options2;
        var document2 = new Document(this, options2);
        var documentElement = document2.createDocumentElement(svg);
        this.document = document2;
        this.documentElement = documentElement;
      }
      /**
       * Create Canvg instance from SVG source string or URL.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static from(ctx, svg) {
        var _arguments = arguments;
        return _asyncToGenerator(function* () {
          var options2 = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
          var parser2 = new Parser(options2);
          var svgDocument = yield parser2.parse(svg);
          return new Canvg(ctx, svgDocument, options2);
        })();
      }
      /**
       * Create Canvg instance from SVG source string.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      static fromString(ctx, svg) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var parser2 = new Parser(options2);
        var svgDocument = parser2.parseFromString(svg);
        return new Canvg(ctx, svgDocument, options2);
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string or URL.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      fork(ctx, svg) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options2));
      }
      /**
       * Create new Canvg instance with inherited options.
       * @param ctx - Rendering context.
       * @param svg - SVG source string.
       * @param options - Rendering options.
       * @returns Canvg instance.
       */
      forkString(ctx, svg) {
        var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options2));
      }
      /**
       * Document is ready promise.
       * @returns Ready promise.
       */
      ready() {
        return this.screen.ready();
      }
      /**
       * Document is ready value.
       * @returns Is ready or not.
       */
      isReady() {
        return this.screen.isReady();
      }
      /**
       * Render only first frame, ignoring animations and mouse.
       * @param options - Rendering options.
       */
      render() {
        var _arguments2 = arguments, _this = this;
        return _asyncToGenerator(function* () {
          var options2 = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
          _this.start(_objectSpread({
            enableRedraw: true,
            ignoreAnimation: true,
            ignoreMouse: true
          }, options2));
          yield _this.ready();
          _this.stop();
        })();
      }
      /**
       * Start rendering.
       * @param options - Render options.
       */
      start() {
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var {
          documentElement,
          screen,
          options: baseOptions
        } = this;
        screen.start(documentElement, _objectSpread(_objectSpread({
          enableRedraw: true
        }, baseOptions), options2));
      }
      /**
       * Stop rendering.
       */
      stop() {
        this.screen.stop();
      }
      /**
       * Resize SVG to fit in given size.
       * @param width
       * @param height
       * @param preserveAspectRatio
       */
      resize(width) {
        var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.documentElement.resize(width, height, preserveAspectRatio);
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HistoricaPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");
var import_toml = __toESM(require_toml());

// node_modules/compromise/src/API/world.js
var methods = {
  one: {},
  two: {},
  three: {},
  four: {}
};
var model = {
  one: {},
  two: {},
  three: {}
};
var compute = {};
var hooks = [];
var world_default = { methods, model, compute, hooks };

// node_modules/compromise/src/API/methods/compute.js
var isArray = (input) => Object.prototype.toString.call(input) === "[object Array]";
var fns = {
  /** add metadata to term objects */
  compute: function(input) {
    const { world: world2 } = this;
    const compute4 = world2.compute;
    if (typeof input === "string" && compute4.hasOwnProperty(input)) {
      compute4[input](this);
    } else if (isArray(input)) {
      input.forEach((name) => {
        if (world2.compute.hasOwnProperty(name)) {
          compute4[name](this);
        } else {
          console.warn("no compute:", input);
        }
      });
    } else if (typeof input === "function") {
      input(this);
    } else {
      console.warn("no compute:", input);
    }
    return this;
  }
};
var compute_default = fns;

// node_modules/compromise/src/API/methods/loops.js
var forEach = function(cb) {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr, i5) => {
    let view = this.update([ptr]);
    cb(view, i5);
  });
  return this;
};
var map = function(cb, empty) {
  let ptrs = this.fullPointer;
  let res = ptrs.map((ptr, i5) => {
    let view = this.update([ptr]);
    let out2 = cb(view, i5);
    if (out2 === void 0) {
      return this.none();
    }
    return out2;
  });
  if (res.length === 0) {
    return empty || this.update([]);
  }
  if (res[0] !== void 0) {
    if (typeof res[0] === "string") {
      return res;
    }
    if (typeof res[0] === "object" && (res[0] === null || !res[0].isView)) {
      return res;
    }
  }
  let all4 = [];
  res.forEach((ptr) => {
    all4 = all4.concat(ptr.fullPointer);
  });
  return this.toView(all4);
};
var filter = function(cb) {
  let ptrs = this.fullPointer;
  ptrs = ptrs.filter((ptr, i5) => {
    let view = this.update([ptr]);
    return cb(view, i5);
  });
  let res = this.update(ptrs);
  return res;
};
var find = function(cb) {
  let ptrs = this.fullPointer;
  let found = ptrs.find((ptr, i5) => {
    let view = this.update([ptr]);
    return cb(view, i5);
  });
  return this.update([found]);
};
var some = function(cb) {
  let ptrs = this.fullPointer;
  return ptrs.some((ptr, i5) => {
    let view = this.update([ptr]);
    return cb(view, i5);
  });
};
var random = function(n5 = 1) {
  let ptrs = this.fullPointer;
  let r3 = Math.floor(Math.random() * ptrs.length);
  if (r3 + n5 > this.length) {
    r3 = this.length - n5;
    r3 = r3 < 0 ? 0 : r3;
  }
  ptrs = ptrs.slice(r3, r3 + n5);
  return this.update(ptrs);
};
var loops_default = { forEach, map, filter, find, some, random };

// node_modules/compromise/src/API/methods/utils.js
var utils = {
  /** */
  termList: function() {
    return this.methods.one.termList(this.docs);
  },
  /** return individual terms*/
  terms: function(n5) {
    let m6 = this.match(".");
    return typeof n5 === "number" ? m6.eq(n5) : m6;
  },
  /** */
  groups: function(group) {
    if (group || group === 0) {
      return this.update(this._groups[group] || []);
    }
    let res = {};
    Object.keys(this._groups).forEach((k3) => {
      res[k3] = this.update(this._groups[k3]);
    });
    return res;
  },
  /** */
  eq: function(n5) {
    let ptr = this.pointer;
    if (!ptr) {
      ptr = this.docs.map((_doc, i5) => [i5]);
    }
    if (ptr[n5]) {
      return this.update([ptr[n5]]);
    }
    return this.none();
  },
  /** */
  first: function() {
    return this.eq(0);
  },
  /** */
  last: function() {
    let n5 = this.fullPointer.length - 1;
    return this.eq(n5);
  },
  /** grab term[0] for every match */
  firstTerms: function() {
    return this.match("^.");
  },
  /** grab the last term for every match  */
  lastTerms: function() {
    return this.match(".$");
  },
  /** */
  slice: function(min2, max4) {
    let pntrs = this.pointer || this.docs.map((_o, n5) => [n5]);
    pntrs = pntrs.slice(min2, max4);
    return this.update(pntrs);
  },
  /** return a view of the entire document */
  all: function() {
    return this.update().toView();
  },
  /**  */
  fullSentences: function() {
    let ptrs = this.fullPointer.map((a4) => [a4[0]]);
    return this.update(ptrs).toView();
  },
  /** return a view of no parts of the document */
  none: function() {
    return this.update([]);
  },
  /** are these two views looking at the same words? */
  isDoc: function(b2) {
    if (!b2 || !b2.isView) {
      return false;
    }
    let aPtr = this.fullPointer;
    let bPtr = b2.fullPointer;
    if (!aPtr.length === bPtr.length) {
      return false;
    }
    return aPtr.every((ptr, i5) => {
      if (!bPtr[i5]) {
        return false;
      }
      return ptr[0] === bPtr[i5][0] && ptr[1] === bPtr[i5][1] && ptr[2] === bPtr[i5][2];
    });
  },
  /** how many seperate terms does the document have? */
  wordCount: function() {
    return this.docs.reduce((count, terms) => {
      count += terms.filter((t5) => t5.text !== "").length;
      return count;
    }, 0);
  },
  // is the pointer the full sentence?
  isFull: function() {
    let ptrs = this.pointer;
    if (!ptrs) {
      return true;
    }
    if (ptrs.length === 0 || ptrs[0][0] !== 0) {
      return false;
    }
    let wantTerms = 0;
    let haveTerms = 0;
    this.document.forEach((terms) => wantTerms += terms.length);
    this.docs.forEach((terms) => haveTerms += terms.length);
    return wantTerms === haveTerms;
  },
  // return the nth elem of a doc
  getNth: function(n5) {
    if (typeof n5 === "number") {
      return this.eq(n5);
    } else if (typeof n5 === "string") {
      return this.if(n5);
    }
    return this;
  }
};
utils.group = utils.groups;
utils.fullSentence = utils.fullSentences;
utils.sentence = utils.fullSentences;
utils.lastTerm = utils.lastTerms;
utils.firstTerm = utils.firstTerms;
var utils_default = utils;

// node_modules/compromise/src/API/methods/index.js
var methods2 = Object.assign({}, utils_default, compute_default, loops_default);
methods2.get = methods2.eq;
var methods_default = methods2;

// node_modules/compromise/src/API/View.js
var View = class {
  constructor(document2, pointer, groups = {}) {
    [
      ["document", document2],
      ["world", world_default],
      ["_groups", groups],
      ["_cache", null],
      ["viewType", "View"]
    ].forEach((a4) => {
      Object.defineProperty(this, a4[0], {
        value: a4[1],
        writable: true
      });
    });
    this.ptrs = pointer;
  }
  /* getters:  */
  get docs() {
    let docs = this.document;
    if (this.ptrs) {
      docs = world_default.methods.one.getDoc(this.ptrs, this.document);
    }
    return docs;
  }
  get pointer() {
    return this.ptrs;
  }
  get methods() {
    return this.world.methods;
  }
  get model() {
    return this.world.model;
  }
  get hooks() {
    return this.world.hooks;
  }
  get isView() {
    return true;
  }
  // is the view not-empty?
  get found() {
    return this.docs.length > 0;
  }
  // how many matches we have
  get length() {
    return this.docs.length;
  }
  // return a more-hackable pointer
  get fullPointer() {
    let { docs, ptrs, document: document2 } = this;
    let pointers = ptrs || docs.map((_d, n5) => [n5]);
    return pointers.map((a4) => {
      let [n5, start2, end2, id, endId] = a4;
      start2 = start2 || 0;
      end2 = end2 || (document2[n5] || []).length;
      if (document2[n5] && document2[n5][start2]) {
        id = id || document2[n5][start2].id;
        if (document2[n5][end2 - 1]) {
          endId = endId || document2[n5][end2 - 1].id;
        }
      }
      return [n5, start2, end2, id, endId];
    });
  }
  // create a new View, from this one
  update(pointer) {
    let m6 = new View(this.document, pointer);
    if (this._cache && pointer && pointer.length > 0) {
      let cache3 = [];
      pointer.forEach((ptr, i5) => {
        let [n5, start2, end2] = ptr;
        if (ptr.length === 1) {
          cache3[i5] = this._cache[n5];
        } else if (start2 === 0 && this.document[n5].length === end2) {
          cache3[i5] = this._cache[n5];
        }
      });
      if (cache3.length > 0) {
        m6._cache = cache3;
      }
    }
    m6.world = this.world;
    return m6;
  }
  // create a new View, from this one
  toView(pointer) {
    return new View(this.document, pointer || this.pointer);
  }
  fromText(input) {
    const { methods: methods17 } = this;
    let document2 = methods17.one.tokenize.fromString(input, this.world);
    let doc = new View(document2);
    doc.world = this.world;
    doc.compute(["normal", "lexicon"]);
    if (this.world.compute.preTagger) {
      doc.compute("preTagger");
    }
    return doc;
  }
  clone() {
    let document2 = this.document.slice(0);
    document2 = document2.map((terms) => {
      return terms.map((term) => {
        term = Object.assign({}, term);
        term.tags = new Set(term.tags);
        return term;
      });
    });
    let m6 = this.update(this.pointer);
    m6.document = document2;
    m6._cache = this._cache;
    return m6;
  }
};
Object.assign(View.prototype, methods_default);
var View_default = View;

// node_modules/compromise/src/_version.js
var version_default = "14.12.0";

// node_modules/compromise/src/API/extend.js
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
function mergeDeep(model5, plugin5) {
  if (isObject(plugin5)) {
    for (const key in plugin5) {
      if (isObject(plugin5[key])) {
        if (!model5[key])
          Object.assign(model5, { [key]: {} });
        mergeDeep(model5[key], plugin5[key]);
      } else {
        Object.assign(model5, { [key]: plugin5[key] });
      }
    }
  }
  return model5;
}
function mergeQuick(model5, plugin5) {
  for (const key in plugin5) {
    model5[key] = model5[key] || {};
    Object.assign(model5[key], plugin5[key]);
  }
  return model5;
}
var addIrregulars = function(model5, conj) {
  let m6 = model5.two.models || {};
  Object.keys(conj).forEach((k3) => {
    if (conj[k3].pastTense) {
      if (m6.toPast) {
        m6.toPast.ex[k3] = conj[k3].pastTense;
      }
      if (m6.fromPast) {
        m6.fromPast.ex[conj[k3].pastTense] = k3;
      }
    }
    if (conj[k3].presentTense) {
      if (m6.toPresent) {
        m6.toPresent.ex[k3] = conj[k3].presentTense;
      }
      if (m6.fromPresent) {
        m6.fromPresent.ex[conj[k3].presentTense] = k3;
      }
    }
    if (conj[k3].gerund) {
      if (m6.toGerund) {
        m6.toGerund.ex[k3] = conj[k3].gerund;
      }
      if (m6.fromGerund) {
        m6.fromGerund.ex[conj[k3].gerund] = k3;
      }
    }
    if (conj[k3].comparative) {
      if (m6.toComparative) {
        m6.toComparative.ex[k3] = conj[k3].comparative;
      }
      if (m6.fromComparative) {
        m6.fromComparative.ex[conj[k3].comparative] = k3;
      }
    }
    if (conj[k3].superlative) {
      if (m6.toSuperlative) {
        m6.toSuperlative.ex[k3] = conj[k3].superlative;
      }
      if (m6.fromSuperlative) {
        m6.fromSuperlative.ex[conj[k3].superlative] = k3;
      }
    }
  });
};
var extend = function(plugin5, world2, View2, nlp2) {
  const { methods: methods17, model: model5, compute: compute4, hooks: hooks2 } = world2;
  if (plugin5.methods) {
    mergeQuick(methods17, plugin5.methods);
  }
  if (plugin5.model) {
    mergeDeep(model5, plugin5.model);
  }
  if (plugin5.irregulars) {
    addIrregulars(model5, plugin5.irregulars);
  }
  if (plugin5.compute) {
    Object.assign(compute4, plugin5.compute);
  }
  if (hooks2) {
    world2.hooks = hooks2.concat(plugin5.hooks || []);
  }
  if (plugin5.api) {
    plugin5.api(View2);
  }
  if (plugin5.lib) {
    Object.keys(plugin5.lib).forEach((k3) => nlp2[k3] = plugin5.lib[k3]);
  }
  if (plugin5.tags) {
    nlp2.addTags(plugin5.tags);
  }
  if (plugin5.words) {
    nlp2.addWords(plugin5.words);
  }
  if (plugin5.frozen) {
    nlp2.addWords(plugin5.frozen, true);
  }
  if (plugin5.mutate) {
    plugin5.mutate(world2);
  }
};
var extend_default = extend;

// node_modules/compromise/src/API/_lib.js
var verbose = function(set) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  env2.DEBUG_TAGS = set === "tagger" || set === true ? true : "";
  env2.DEBUG_MATCH = set === "match" || set === true ? true : "";
  env2.DEBUG_CHUNKS = set === "chunker" || set === true ? true : "";
  return this;
};

// node_modules/compromise/src/API/inputs.js
var isObject2 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isArray2 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fromJson = function(json) {
  return json.map((o4) => {
    return o4.terms.map((term) => {
      if (isArray2(term.tags)) {
        term.tags = new Set(term.tags);
      }
      return term;
    });
  });
};
var preTokenized = function(arr) {
  return arr.map((a4) => {
    return a4.map((str) => {
      return {
        text: str,
        normal: str,
        //cleanup
        pre: "",
        post: " ",
        tags: /* @__PURE__ */ new Set()
      };
    });
  });
};
var inputs = function(input, View2, world2) {
  const { methods: methods17 } = world2;
  let doc = new View2([]);
  doc.world = world2;
  if (typeof input === "number") {
    input = String(input);
  }
  if (!input) {
    return doc;
  }
  if (typeof input === "string") {
    let document2 = methods17.one.tokenize.fromString(input, world2);
    return new View2(document2);
  }
  if (isObject2(input) && input.isView) {
    return new View2(input.document, input.ptrs);
  }
  if (isArray2(input)) {
    if (isArray2(input[0])) {
      let document3 = preTokenized(input);
      return new View2(document3);
    }
    let document2 = fromJson(input);
    return new View2(document2);
  }
  return doc;
};
var inputs_default = inputs;

// node_modules/compromise/src/nlp.js
var world = Object.assign({}, world_default);
var nlp = function(input, lex) {
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (input) {
    doc.compute(world.hooks);
  }
  return doc;
};
Object.defineProperty(nlp, "_world", {
  value: world,
  writable: true
});
nlp.tokenize = function(input, lex) {
  const { compute: compute4 } = this._world;
  if (lex) {
    nlp.addWords(lex);
  }
  let doc = inputs_default(input, View_default, world);
  if (compute4.contractions) {
    doc.compute(["alias", "normal", "machine", "contractions"]);
  }
  return doc;
};
nlp.plugin = function(plugin5) {
  extend_default(plugin5, this._world, View_default, this);
  return this;
};
nlp.extend = nlp.plugin;
nlp.world = function() {
  return this._world;
};
nlp.model = function() {
  return this._world.model;
};
nlp.methods = function() {
  return this._world.methods;
};
nlp.hooks = function() {
  return this._world.hooks;
};
nlp.verbose = verbose;
nlp.version = version_default;
var nlp_default = nlp;

// node_modules/compromise/src/1-one/cache/methods/cacheDoc.js
var createCache = function(document2) {
  let cache3 = document2.map((terms) => {
    let stuff = /* @__PURE__ */ new Set();
    terms.forEach((term) => {
      if (term.normal !== "") {
        stuff.add(term.normal);
      }
      if (term.switch) {
        stuff.add(`%${term.switch}%`);
      }
      if (term.implicit) {
        stuff.add(term.implicit);
      }
      if (term.machine) {
        stuff.add(term.machine);
      }
      if (term.root) {
        stuff.add(term.root);
      }
      if (term.alias) {
        term.alias.forEach((str) => stuff.add(str));
      }
      let tags = Array.from(term.tags);
      for (let t5 = 0; t5 < tags.length; t5 += 1) {
        stuff.add("#" + tags[t5]);
      }
    });
    return stuff;
  });
  return cache3;
};
var cacheDoc_default = createCache;

// node_modules/compromise/src/1-one/cache/methods/index.js
var methods_default2 = {
  one: {
    cacheDoc: cacheDoc_default
  }
};

// node_modules/compromise/src/1-one/cache/api.js
var methods3 = {
  /** */
  cache: function() {
    this._cache = this.methods.one.cacheDoc(this.document);
    return this;
  },
  /** */
  uncache: function() {
    this._cache = null;
    return this;
  }
};
var addAPI = function(View2) {
  Object.assign(View2.prototype, methods3);
};
var api_default = addAPI;

// node_modules/compromise/src/1-one/cache/compute.js
var compute_default2 = {
  cache: function(view) {
    view._cache = view.methods.one.cacheDoc(view.document);
  }
};

// node_modules/compromise/src/1-one/cache/plugin.js
var plugin_default = {
  api: api_default,
  compute: compute_default2,
  methods: methods_default2
};

// node_modules/compromise/src/1-one/change/api/case.js
var case_default = {
  /** */
  toLowerCase: function() {
    this.termList().forEach((t5) => {
      t5.text = t5.text.toLowerCase();
    });
    return this;
  },
  /** */
  toUpperCase: function() {
    this.termList().forEach((t5) => {
      t5.text = t5.text.toUpperCase();
    });
    return this;
  },
  /** */
  toTitleCase: function() {
    this.termList().forEach((t5) => {
      t5.text = t5.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x2) => x2.toUpperCase());
    });
    return this;
  },
  /** */
  toCamelCase: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t5, i5) => {
        if (i5 !== 0) {
          t5.text = t5.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x2) => x2.toUpperCase());
        }
        if (i5 !== terms.length - 1) {
          t5.post = "";
        }
      });
    });
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/lib/insert.js
var isTitleCase = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str) || /^\p{Lu}$/u.test(str);
var toTitleCase = (str) => str.replace(/^\p{Ll}/u, (x2) => x2.toUpperCase());
var toLowerCase = (str) => str.replace(/^\p{Lu}/u, (x2) => x2.toLowerCase());
var spliceArr = (parent, index4, child) => {
  child.forEach((term) => term.dirty = true);
  if (parent) {
    let args = [index4, 0].concat(child);
    Array.prototype.splice.apply(parent, args);
  }
  return parent;
};
var endSpace = function(terms) {
  const hasSpace2 = / $/;
  const hasDash4 = /[-–—]/;
  let lastTerm = terms[terms.length - 1];
  if (lastTerm && !hasSpace2.test(lastTerm.post) && !hasDash4.test(lastTerm.post)) {
    lastTerm.post += " ";
  }
};
var movePunct = (source, end2, needle) => {
  const juicy = /[-.?!,;:)–—'"]/g;
  let wasLast = source[end2 - 1];
  if (!wasLast) {
    return;
  }
  let post = wasLast.post;
  if (juicy.test(post)) {
    let punct = post.match(juicy).join("");
    let last = needle[needle.length - 1];
    last.post = punct + last.post;
    wasLast.post = wasLast.post.replace(juicy, "");
  }
};
var moveTitleCase = function(home, start2, needle) {
  let from = home[start2];
  if (start2 !== 0 || !isTitleCase(from.text)) {
    return;
  }
  needle[0].text = toTitleCase(needle[0].text);
  let old = home[start2];
  if (old.tags.has("ProperNoun") || old.tags.has("Acronym")) {
    return;
  }
  if (isTitleCase(old.text) && old.text.length > 1) {
    old.text = toLowerCase(old.text);
  }
};
var cleanPrepend = function(home, ptr, needle, document2) {
  let [n5, start2, end2] = ptr;
  if (start2 === 0) {
    endSpace(needle);
  } else if (end2 === document2[n5].length) {
    endSpace(needle);
  } else {
    endSpace(needle);
    endSpace([home[ptr[1]]]);
  }
  moveTitleCase(home, start2, needle);
  spliceArr(home, start2, needle);
};
var cleanAppend = function(home, ptr, needle, document2) {
  let [n5, , end2] = ptr;
  let total = (document2[n5] || []).length;
  if (end2 < total) {
    movePunct(home, end2, needle);
    endSpace(needle);
  } else if (total === end2) {
    endSpace(home);
    movePunct(home, end2, needle);
    if (document2[n5 + 1]) {
      needle[needle.length - 1].post += " ";
    }
  }
  spliceArr(home, ptr[2], needle);
  ptr[4] = needle[needle.length - 1].id;
};

// node_modules/compromise/src/1-one/change/compute/uuid.js
var index = 0;
var pad3 = (str) => {
  str = str.length < 3 ? "0" + str : str;
  return str.length < 3 ? "0" + str : str;
};
var toId = function(term) {
  let [n5, i5] = term.index || [0, 0];
  index += 1;
  index = index > 46655 ? 0 : index;
  n5 = n5 > 46655 ? 0 : n5;
  i5 = i5 > 1294 ? 0 : i5;
  let id = pad3(index.toString(36));
  id += pad3(n5.toString(36));
  let tx = i5.toString(36);
  tx = tx.length < 2 ? "0" + tx : tx;
  id += tx;
  let r3 = parseInt(Math.random() * 36, 10);
  id += r3.toString(36);
  return term.normal + "|" + id.toUpperCase();
};
var uuid_default = toId;

// node_modules/compromise/src/1-one/change/api/insert.js
var expand = function(m6) {
  if (m6.has("@hasContraction") && typeof m6.contractions === "function") {
    let more = m6.grow("@hasContraction");
    more.contractions().expand();
  }
};
var isArray3 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var addIds = function(terms) {
  terms = terms.map((term) => {
    term.id = uuid_default(term);
    return term;
  });
  return terms;
};
var getTerms = function(input, world2) {
  const { methods: methods17 } = world2;
  if (typeof input === "string") {
    return methods17.one.tokenize.fromString(input, world2)[0];
  }
  if (typeof input === "object" && input.isView) {
    return input.clone().docs[0] || [];
  }
  if (isArray3(input)) {
    return isArray3(input[0]) ? input[0] : input;
  }
  return [];
};
var insert = function(input, view, prepend) {
  const { document: document2, world: world2 } = view;
  view.uncache();
  let ptrs = view.fullPointer;
  let selfPtrs = view.fullPointer;
  view.forEach((m6, i5) => {
    let ptr = m6.fullPointer[0];
    let [n5] = ptr;
    let home = document2[n5];
    let terms = getTerms(input, world2);
    if (terms.length === 0) {
      return;
    }
    terms = addIds(terms);
    if (prepend) {
      expand(view.update([ptr]).firstTerm());
      cleanPrepend(home, ptr, terms, document2);
    } else {
      expand(view.update([ptr]).lastTerm());
      cleanAppend(home, ptr, terms, document2);
    }
    if (document2[n5] && document2[n5][ptr[1]]) {
      ptr[3] = document2[n5][ptr[1]].id;
    }
    selfPtrs[i5] = ptr;
    ptr[2] += terms.length;
    ptrs[i5] = ptr;
  });
  let doc = view.toView(ptrs);
  view.ptrs = selfPtrs;
  doc.compute(["id", "index", "lexicon"]);
  if (doc.world.compute.preTagger) {
    doc.compute("preTagger");
  }
  return doc;
};
var fns2 = {
  insertAfter: function(input) {
    return insert(input, this, false);
  },
  insertBefore: function(input) {
    return insert(input, this, true);
  }
};
fns2.append = fns2.insertAfter;
fns2.prepend = fns2.insertBefore;
fns2.insert = fns2.insertAfter;
var insert_default = fns2;

// node_modules/compromise/src/1-one/change/api/replace.js
var dollarStub = /\$[0-9a-z]+/g;
var fns3 = {};
var titleCase = function(str) {
  return str.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());
};
var replaceByFn = function(main, fn) {
  main.forEach((m6) => {
    let out2 = fn(m6);
    m6.replaceWith(out2);
  });
  return main;
};
var subDollarSign = function(input, main) {
  if (typeof input !== "string") {
    return input;
  }
  let groups = main.groups();
  input = input.replace(dollarStub, (a4) => {
    let num = a4.replace(/\$/, "");
    if (groups.hasOwnProperty(num)) {
      return groups[num].text();
    }
    return a4;
  });
  return input;
};
fns3.replaceWith = function(input, keep9 = {}) {
  let ptrs = this.fullPointer;
  let main = this;
  this.uncache();
  if (typeof input === "function") {
    return replaceByFn(main, input);
  }
  let terms = main.docs[0];
  let isPossessive3 = keep9.possessives && terms[terms.length - 1].tags.has("Possessive");
  input = subDollarSign(input, main);
  let original = this.update(ptrs);
  ptrs = ptrs.map((ptr) => ptr.slice(0, 3));
  let oldTags = (original.docs[0] || []).map((term) => Array.from(term.tags));
  if (typeof input === "string") {
    input = this.fromText(input).compute("id");
  }
  main.insertAfter(input);
  if (original.has("@hasContraction") && main.contractions) {
    let more = main.grow("@hasContraction+");
    more.contractions().expand();
  }
  main.delete(original);
  if (isPossessive3) {
    let tmp = main.docs[0];
    let term = tmp[tmp.length - 1];
    if (!term.tags.has("Possessive")) {
      term.text += "'s";
      term.normal += "'s";
      term.tags.add("Possessive");
    }
  }
  let m6 = main.toView(ptrs).compute(["index", "lexicon"]);
  if (m6.world.compute.preTagger) {
    m6.compute("preTagger");
  }
  if (keep9.tags) {
    m6.terms().forEach((term, i5) => {
      term.tagSafe(oldTags[i5]);
    });
  }
  if (keep9.case && m6.docs[0] && m6.docs[0][0] && m6.docs[0][0].index[1] === 0) {
    m6.docs[0][0].text = titleCase(m6.docs[0][0].text);
  }
  return m6;
};
fns3.replace = function(match2, input, keep9) {
  if (match2 && !input) {
    return this.replaceWith(match2, keep9);
  }
  let m6 = this.match(match2);
  if (!m6.found) {
    return this;
  }
  this.soften();
  return m6.replaceWith(input, keep9);
};
var replace_default = fns3;

// node_modules/compromise/src/1-one/change/api/lib/remove.js
var repairPunct = function(terms, len) {
  let last = terms.length - 1;
  let from = terms[last];
  let to = terms[last - len];
  if (to && from) {
    to.post += from.post;
    to.post = to.post.replace(/ +([.?!,;:])/, "$1");
    to.post = to.post.replace(/[,;:]+([.?!])/, "$1");
  }
};
var pluckOut = function(document2, nots) {
  nots.forEach((ptr) => {
    let [n5, start2, end2] = ptr;
    let len = end2 - start2;
    if (!document2[n5]) {
      return;
    }
    if (end2 === document2[n5].length && end2 > 1) {
      repairPunct(document2[n5], len);
    }
    document2[n5].splice(start2, len);
  });
  for (let i5 = document2.length - 1; i5 >= 0; i5 -= 1) {
    if (document2[i5].length === 0) {
      document2.splice(i5, 1);
      if (i5 === document2.length && document2[i5 - 1]) {
        let terms = document2[i5 - 1];
        let lastTerm = terms[terms.length - 1];
        if (lastTerm) {
          lastTerm.post = lastTerm.post.trimEnd();
        }
      }
    }
  }
  return document2;
};
var remove_default = pluckOut;

// node_modules/compromise/src/1-one/change/api/remove.js
var fixPointers = function(ptrs, gonePtrs) {
  ptrs = ptrs.map((ptr) => {
    let [n5] = ptr;
    if (!gonePtrs[n5]) {
      return ptr;
    }
    gonePtrs[n5].forEach((no) => {
      let len = no[2] - no[1];
      if (ptr[1] <= no[1] && ptr[2] >= no[2]) {
        ptr[2] -= len;
      }
    });
    return ptr;
  });
  ptrs.forEach((ptr, i5) => {
    if (ptr[1] === 0 && ptr[2] == 0) {
      for (let n5 = i5 + 1; n5 < ptrs.length; n5 += 1) {
        ptrs[n5][0] -= 1;
        if (ptrs[n5][0] < 0) {
          ptrs[n5][0] = 0;
        }
      }
    }
  });
  ptrs = ptrs.filter((ptr) => ptr[2] - ptr[1] > 0);
  ptrs = ptrs.map((ptr) => {
    ptr[3] = null;
    ptr[4] = null;
    return ptr;
  });
  return ptrs;
};
var methods4 = {
  /** */
  remove: function(reg) {
    const { indexN: indexN2 } = this.methods.one.pointer;
    this.uncache();
    let self2 = this.all();
    let not = this;
    if (reg) {
      self2 = this;
      not = this.match(reg);
    }
    let isFull = !self2.ptrs;
    if (not.has("@hasContraction") && not.contractions) {
      let more = not.grow("@hasContraction");
      more.contractions().expand();
    }
    let ptrs = self2.fullPointer;
    let nots = not.fullPointer.reverse();
    let document2 = remove_default(this.document, nots);
    let gonePtrs = indexN2(nots);
    ptrs = fixPointers(ptrs, gonePtrs);
    self2.ptrs = ptrs;
    self2.document = document2;
    self2.compute("index");
    if (isFull) {
      self2.ptrs = void 0;
    }
    if (!reg) {
      this.ptrs = [];
      return self2.none();
    }
    let res = self2.toView(ptrs);
    return res;
  }
};
methods4.delete = methods4.remove;
var remove_default2 = methods4;

// node_modules/compromise/src/1-one/change/api/whitespace.js
var methods5 = {
  /** add this punctuation or whitespace before each match: */
  pre: function(str, concat) {
    if (str === void 0 && this.found) {
      return this.docs[0][0].pre;
    }
    this.docs.forEach((terms) => {
      let term = terms[0];
      if (concat === true) {
        term.pre += str;
      } else {
        term.pre = str;
      }
    });
    return this;
  },
  /** add this punctuation or whitespace after each match: */
  post: function(str, concat) {
    if (str === void 0) {
      let last = this.docs[this.docs.length - 1];
      return last[last.length - 1].post;
    }
    this.docs.forEach((terms) => {
      let term = terms[terms.length - 1];
      if (concat === true) {
        term.post += str;
      } else {
        term.post = str;
      }
    });
    return this;
  },
  /** remove whitespace from start/end */
  trim: function() {
    if (!this.found) {
      return this;
    }
    let docs = this.docs;
    let start2 = docs[0][0];
    start2.pre = start2.pre.trimStart();
    let last = docs[docs.length - 1];
    let end2 = last[last.length - 1];
    end2.post = end2.post.trimEnd();
    return this;
  },
  /** connect words with hyphen, and remove whitespace */
  hyphenate: function() {
    this.docs.forEach((terms) => {
      terms.forEach((t5, i5) => {
        if (i5 !== 0) {
          t5.pre = "";
        }
        if (terms[i5 + 1]) {
          t5.post = "-";
        }
      });
    });
    return this;
  },
  /** remove hyphens between words, and set whitespace */
  dehyphenate: function() {
    const hasHyphen3 = /[-–—]/;
    this.docs.forEach((terms) => {
      terms.forEach((t5) => {
        if (hasHyphen3.test(t5.post)) {
          t5.post = " ";
        }
      });
    });
    return this;
  },
  /** add quotations around these matches */
  toQuotations: function(start2, end2) {
    start2 = start2 || `"`;
    end2 = end2 || `"`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  },
  /** add brackets around these matches */
  toParentheses: function(start2, end2) {
    start2 = start2 || `(`;
    end2 = end2 || `)`;
    this.docs.forEach((terms) => {
      terms[0].pre = start2 + terms[0].pre;
      let last = terms[terms.length - 1];
      last.post = end2 + last.post;
    });
    return this;
  }
};
methods5.deHyphenate = methods5.dehyphenate;
methods5.toQuotation = methods5.toQuotations;
var whitespace_default = methods5;

// node_modules/compromise/src/1-one/change/api/lib/_sort.js
var alpha = (a4, b2) => {
  if (a4.normal < b2.normal) {
    return -1;
  }
  if (a4.normal > b2.normal) {
    return 1;
  }
  return 0;
};
var length = (a4, b2) => {
  let left = a4.normal.trim().length;
  let right = b2.normal.trim().length;
  if (left < right) {
    return 1;
  }
  if (left > right) {
    return -1;
  }
  return 0;
};
var wordCount = (a4, b2) => {
  if (a4.words < b2.words) {
    return 1;
  }
  if (a4.words > b2.words) {
    return -1;
  }
  return 0;
};
var sequential = (a4, b2) => {
  if (a4[0] < b2[0]) {
    return 1;
  }
  if (a4[0] > b2[0]) {
    return -1;
  }
  return a4[1] > b2[1] ? 1 : -1;
};
var byFreq = function(arr) {
  let counts = {};
  arr.forEach((o4) => {
    counts[o4.normal] = counts[o4.normal] || 0;
    counts[o4.normal] += 1;
  });
  arr.sort((a4, b2) => {
    let left = counts[a4.normal];
    let right = counts[b2.normal];
    if (left < right) {
      return 1;
    }
    if (left > right) {
      return -1;
    }
    return 0;
  });
  return arr;
};
var sort_default = { alpha, length, wordCount, sequential, byFreq };

// node_modules/compromise/src/1-one/change/api/sort.js
var seqNames = /* @__PURE__ */ new Set(["index", "sequence", "seq", "sequential", "chron", "chronological"]);
var freqNames = /* @__PURE__ */ new Set(["freq", "frequency", "topk", "repeats"]);
var alphaNames = /* @__PURE__ */ new Set(["alpha", "alphabetical"]);
var customSort = function(view, fn) {
  let ptrs = view.fullPointer;
  ptrs = ptrs.sort((a4, b2) => {
    a4 = view.update([a4]);
    b2 = view.update([b2]);
    return fn(a4, b2);
  });
  view.ptrs = ptrs;
  return view;
};
var sort = function(input) {
  let { docs, pointer } = this;
  this.uncache();
  if (typeof input === "function") {
    return customSort(this, input);
  }
  input = input || "alpha";
  let ptrs = pointer || docs.map((_d, n5) => [n5]);
  let arr = docs.map((terms, n5) => {
    return {
      index: n5,
      words: terms.length,
      normal: terms.map((t5) => t5.machine || t5.normal || "").join(" "),
      pointer: ptrs[n5]
    };
  });
  if (seqNames.has(input)) {
    input = "sequential";
  }
  if (alphaNames.has(input)) {
    input = "alpha";
  }
  if (freqNames.has(input)) {
    arr = sort_default.byFreq(arr);
    return this.update(arr.map((o4) => o4.pointer));
  }
  if (typeof sort_default[input] === "function") {
    arr = arr.sort(sort_default[input]);
    return this.update(arr.map((o4) => o4.pointer));
  }
  return this;
};
var reverse = function() {
  let ptrs = this.pointer || this.docs.map((_d, n5) => [n5]);
  ptrs = [].concat(ptrs);
  ptrs = ptrs.reverse();
  if (this._cache) {
    this._cache = this._cache.reverse();
  }
  return this.update(ptrs);
};
var unique = function() {
  let already = /* @__PURE__ */ new Set();
  let res = this.filter((m6) => {
    let txt = m6.text("machine");
    if (already.has(txt)) {
      return false;
    }
    already.add(txt);
    return true;
  });
  return res;
};
var sort_default2 = { unique, reverse, sort };

// node_modules/compromise/src/1-one/change/api/concat.js
var isArray4 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var combineDocs = function(homeDocs, inputDocs) {
  if (homeDocs.length > 0) {
    let end2 = homeDocs[homeDocs.length - 1];
    let last = end2[end2.length - 1];
    if (/ /.test(last.post) === false) {
      last.post += " ";
    }
  }
  homeDocs = homeDocs.concat(inputDocs);
  return homeDocs;
};
var combineViews = function(home, input) {
  if (home.document === input.document) {
    let ptrs2 = home.fullPointer.concat(input.fullPointer);
    return home.toView(ptrs2).compute("index");
  }
  let ptrs = input.fullPointer;
  ptrs.forEach((a4) => {
    a4[0] += home.document.length;
  });
  home.document = combineDocs(home.document, input.docs);
  return home.all();
};
var concat_default = {
  // add string as new match/sentence
  concat: function(input) {
    if (typeof input === "string") {
      let more = this.fromText(input);
      if (!this.found || !this.ptrs) {
        this.document = this.document.concat(more.document);
      } else {
        let ptrs = this.fullPointer;
        let at2 = ptrs[ptrs.length - 1][0];
        this.document.splice(at2, 0, ...more.document);
      }
      return this.all().compute("index");
    }
    if (typeof input === "object" && input.isView) {
      return combineViews(this, input);
    }
    if (isArray4(input)) {
      let docs = combineDocs(this.document, input);
      this.document = docs;
      return this.all();
    }
    return this;
  }
};

// node_modules/compromise/src/1-one/change/api/harden.js
var harden = function() {
  this.ptrs = this.fullPointer;
  return this;
};
var soften = function() {
  let ptr = this.ptrs;
  if (!ptr || ptr.length < 1) {
    return this;
  }
  ptr = ptr.map((a4) => a4.slice(0, 3));
  this.ptrs = ptr;
  return this;
};
var harden_default = { harden, soften };

// node_modules/compromise/src/1-one/change/api/index.js
var methods6 = Object.assign({}, case_default, insert_default, replace_default, remove_default2, whitespace_default, sort_default2, concat_default, harden_default);
var addAPI2 = function(View2) {
  Object.assign(View2.prototype, methods6);
};
var api_default2 = addAPI2;

// node_modules/compromise/src/1-one/change/compute/index.js
var compute2 = {
  id: function(view) {
    let docs = view.docs;
    for (let n5 = 0; n5 < docs.length; n5 += 1) {
      for (let i5 = 0; i5 < docs[n5].length; i5 += 1) {
        let term = docs[n5][i5];
        term.id = term.id || uuid_default(term);
      }
    }
  }
};
var compute_default3 = compute2;

// node_modules/compromise/src/1-one/change/plugin.js
var plugin_default2 = {
  api: api_default2,
  compute: compute_default3
};

// node_modules/compromise/src/1-one/contraction-one/model/contractions.js
var contractions_default = [
  // simple mappings
  { word: "@", out: ["at"] },
  { word: "arent", out: ["are", "not"] },
  { word: "alot", out: ["a", "lot"] },
  { word: "brb", out: ["be", "right", "back"] },
  { word: "cannot", out: ["can", "not"] },
  { word: "dun", out: ["do", "not"] },
  { word: "can't", out: ["can", "not"] },
  { word: "shan't", out: ["should", "not"] },
  { word: "won't", out: ["will", "not"] },
  { word: "that's", out: ["that", "is"] },
  { word: "what's", out: ["what", "is"] },
  { word: "let's", out: ["let", "us"] },
  // { word: "there's", out: ['there', 'is'] },
  { word: "dunno", out: ["do", "not", "know"] },
  { word: "gonna", out: ["going", "to"] },
  { word: "gotta", out: ["have", "got", "to"] },
  //hmm
  { word: "gimme", out: ["give", "me"] },
  { word: "outta", out: ["out", "of"] },
  { word: "tryna", out: ["trying", "to"] },
  { word: "gtg", out: ["got", "to", "go"] },
  { word: "im", out: ["i", "am"] },
  { word: "imma", out: ["I", "will"] },
  { word: "imo", out: ["in", "my", "opinion"] },
  { word: "irl", out: ["in", "real", "life"] },
  { word: "ive", out: ["i", "have"] },
  { word: "rn", out: ["right", "now"] },
  { word: "tbh", out: ["to", "be", "honest"] },
  { word: "wanna", out: ["want", "to"] },
  { word: `c'mere`, out: ["come", "here"] },
  { word: `c'mon`, out: ["come", "on"] },
  // shoulda, coulda
  { word: "shoulda", out: ["should", "have"] },
  { word: "coulda", out: ["coulda", "have"] },
  { word: "woulda", out: ["woulda", "have"] },
  { word: "musta", out: ["must", "have"] },
  { word: "tis", out: ["it", "is"] },
  { word: "twas", out: ["it", "was"] },
  { word: `y'know`, out: ["you", "know"] },
  { word: "ne'er", out: ["never"] },
  { word: "o'er", out: ["over"] },
  // contraction-part mappings
  { after: "ll", out: ["will"] },
  { after: "ve", out: ["have"] },
  { after: "re", out: ["are"] },
  { after: "m", out: ["am"] },
  // french contractions
  { before: "c", out: ["ce"] },
  { before: "m", out: ["me"] },
  { before: "n", out: ["ne"] },
  { before: "qu", out: ["que"] },
  { before: "s", out: ["se"] },
  { before: "t", out: ["tu"] },
  // t'aime
  // missing apostrophes
  { word: "shouldnt", out: ["should", "not"] },
  { word: "couldnt", out: ["could", "not"] },
  { word: "wouldnt", out: ["would", "not"] },
  { word: "hasnt", out: ["has", "not"] },
  { word: "wasnt", out: ["was", "not"] },
  { word: "isnt", out: ["is", "not"] },
  { word: "cant", out: ["can", "not"] },
  { word: "dont", out: ["do", "not"] },
  { word: "wont", out: ["will", "not"] },
  // apostrophe d
  { word: "howd", out: ["how", "did"] },
  { word: "whatd", out: ["what", "did"] },
  { word: "whend", out: ["when", "did"] },
  { word: "whered", out: ["where", "did"] }
];

// node_modules/compromise/src/1-one/contraction-one/model/number-suffix.js
var t = true;
var number_suffix_default = {
  "st": t,
  "nd": t,
  "rd": t,
  "th": t,
  "am": t,
  "pm": t,
  "max": t,
  "\xB0": t,
  "s": t,
  // 1990s
  "e": t,
  // 18e - french/spanish ordinal
  "er": t,
  //french 1er
  "\xE8re": t,
  //''
  "\xE8me": t
  //french 2ème
};

// node_modules/compromise/src/1-one/contraction-one/model/index.js
var model_default = {
  one: {
    contractions: contractions_default,
    numberSuffixes: number_suffix_default
  }
};

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/_splice.js
var insertContraction = function(document2, point, words) {
  let [n5, w2] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i5) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n5, w2 + i5];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n5][w2].pre;
    words[words.length - 1].post = document2[n5][w2].post;
    words[0].text = document2[n5][w2].text;
    words[0].normal = document2[n5][w2].normal;
  }
  document2[n5].splice(w2, 1, ...words);
};
var splice_default = insertContraction;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-d.js
var hasContraction = /'/;
var alwaysDid = /* @__PURE__ */ new Set([
  "what",
  "how",
  "when",
  "where",
  "why"
]);
var useWould = /* @__PURE__ */ new Set([
  "be",
  "go",
  "start",
  "think",
  "need"
]);
var useHad = /* @__PURE__ */ new Set([
  "been",
  "gone"
]);
var _apostropheD = function(terms, i5) {
  let before2 = terms[i5].normal.split(hasContraction)[0];
  if (alwaysDid.has(before2)) {
    return [before2, "did"];
  }
  if (terms[i5 + 1]) {
    if (useHad.has(terms[i5 + 1].normal)) {
      return [before2, "had"];
    }
    if (useWould.has(terms[i5 + 1].normal)) {
      return [before2, "would"];
    }
  }
  return null;
};
var apostrophe_d_default = _apostropheD;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/apostrophe-t.js
var apostropheT = function(terms, i5) {
  if (terms[i5].normal === "ain't" || terms[i5].normal === "aint") {
    return null;
  }
  let before2 = terms[i5].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default = apostropheT;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/french.js
var hasContraction2 = /'/;
var isFeminine = /(e|é|aison|sion|tion)$/;
var isMasculine = /(age|isme|acle|ege|oire)$/;
var preL = (terms, i5) => {
  let after2 = terms[i5].normal.split(hasContraction2)[1];
  if (after2 && after2.endsWith("e")) {
    return ["la", after2];
  }
  return ["le", after2];
};
var preD = (terms, i5) => {
  let after2 = terms[i5].normal.split(hasContraction2)[1];
  if (after2 && isFeminine.test(after2) && !isMasculine.test(after2)) {
    return ["du", after2];
  } else if (after2 && after2.endsWith("s")) {
    return ["des", after2];
  }
  return ["de", after2];
};
var preJ = (terms, i5) => {
  let after2 = terms[i5].normal.split(hasContraction2)[1];
  return ["je", after2];
};
var french_default = {
  preJ,
  preL,
  preD
};

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-range.js
var isRange = /^([0-9.]{1,4}[a-z]{0,2}) ?[-–—] ?([0-9]{1,4}[a-z]{0,2})$/i;
var timeRange = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-–—] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i;
var phoneNum = /^[0-9]{3}-[0-9]{4}$/;
var numberRange = function(terms, i5) {
  let term = terms[i5];
  let parts = term.text.match(isRange);
  if (parts !== null) {
    if (term.tags.has("PhoneNumber") === true || phoneNum.test(term.text)) {
      return null;
    }
    return [parts[1], "to", parts[2]];
  } else {
    parts = term.text.match(timeRange);
    if (parts !== null) {
      return [parts[1], "to", parts[4]];
    }
  }
  return null;
};
var number_range_default = numberRange;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/number-unit.js
var numUnit = /^([+-]?[0-9][.,0-9]*)([a-z°²³µ/]+)$/;
var numberUnit = function(terms, i5, world2) {
  const notUnit = world2.model.one.numberSuffixes || {};
  let term = terms[i5];
  let parts = term.text.match(numUnit);
  if (parts !== null) {
    let unit = parts[2].toLowerCase().trim();
    if (notUnit.hasOwnProperty(unit)) {
      return null;
    }
    return [parts[1], unit];
  }
  return null;
};
var number_unit_default = numberUnit;

// node_modules/compromise/src/1-one/contraction-one/compute/contractions/index.js
var byApostrophe = /'/;
var numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/;
var reTag = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
};
var byEnd = {
  // ain't
  t: (terms, i5) => apostrophe_t_default(terms, i5),
  // how'd
  d: (terms, i5) => apostrophe_d_default(terms, i5)
};
var byStart = {
  // j'aime
  j: (terms, i5) => french_default.preJ(terms, i5),
  // l'amour
  l: (terms, i5) => french_default.preL(terms, i5),
  // d'amerique
  d: (terms, i5) => french_default.preD(terms, i5)
};
var knownOnes = function(list5, term, before2, after2) {
  for (let i5 = 0; i5 < list5.length; i5 += 1) {
    let o4 = list5[i5];
    if (o4.word === term.normal) {
      return o4.out;
    } else if (after2 !== null && after2 === o4.after) {
      return [before2].concat(o4.out);
    } else if (before2 !== null && before2 === o4.before && after2 && after2.length > 2) {
      return o4.out.concat(after2);
    }
  }
  return null;
};
var toDocs = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute(["id", "alias"]);
  return doc.docs[0];
};
var thereHas = function(terms, i5) {
  for (let k3 = i5 + 1; k3 < 5; k3 += 1) {
    if (!terms[k3]) {
      break;
    }
    if (terms[k3].normal === "been") {
      return ["there", "has"];
    }
  }
  return ["there", "is"];
};
var contractions = (view) => {
  let { world: world2, document: document2 } = view;
  const { model: model5, methods: methods17 } = world2;
  let list5 = model5.one.contractions || [];
  document2.forEach((terms, n5) => {
    for (let i5 = terms.length - 1; i5 >= 0; i5 -= 1) {
      let before2 = null;
      let after2 = null;
      if (byApostrophe.test(terms[i5].normal) === true) {
        let res = terms[i5].normal.split(byApostrophe);
        before2 = res[0];
        after2 = res[1];
      }
      let words = knownOnes(list5, terms[i5], before2, after2);
      if (!words && byEnd.hasOwnProperty(after2)) {
        words = byEnd[after2](terms, i5, world2);
      }
      if (!words && byStart.hasOwnProperty(before2)) {
        words = byStart[before2](terms, i5);
      }
      if (before2 === "there" && after2 === "s") {
        words = thereHas(terms, i5);
      }
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n5, i5], words);
        reTag(document2[n5], view, i5, words.length);
        continue;
      }
      if (numDash.test(terms[i5].normal)) {
        words = number_range_default(terms, i5);
        if (words) {
          words = toDocs(words, view);
          splice_default(document2, [n5, i5], words);
          methods17.one.setTag(words, "NumberRange", world2);
          if (words[2] && words[2].tags.has("Time")) {
            methods17.one.setTag([words[0]], "Time", world2, null, "time-range");
          }
          reTag(document2[n5], view, i5, words.length);
        }
        continue;
      }
      words = number_unit_default(terms, i5, world2);
      if (words) {
        words = toDocs(words, view);
        splice_default(document2, [n5, i5], words);
        methods17.one.setTag([words[1]], "Unit", world2, null, "contraction-unit");
      }
    }
  });
};
var contractions_default2 = contractions;

// node_modules/compromise/src/1-one/contraction-one/compute/index.js
var compute_default4 = { contractions: contractions_default2 };

// node_modules/compromise/src/1-one/contraction-one/plugin.js
var plugin = {
  model: model_default,
  compute: compute_default4,
  hooks: ["contractions"]
};
var plugin_default3 = plugin;

// node_modules/compromise/src/1-one/freeze/plugin.js
var plugin_default4 = {
  // lib: {
  //   freeze: function (obj) {
  //     this.world().model.two.freeze = obj
  //   },
  // },
  mutate: (world2) => {
    world2.methods.one.termMethods.isFrozen = (term) => term.frozen === true;
  },
  api: function(View2) {
    View2.prototype.freeze = function() {
      this.docs.forEach((ts) => {
        ts.forEach((term) => {
          term.frozen = true;
        });
      });
      return this;
    };
    View2.prototype.unfreeze = function() {
      this.docs.forEach((ts) => {
        ts.forEach((term) => {
          delete term.frozen;
        });
      });
      return this;
    };
    View2.prototype.isFrozen = function() {
      return this.match("@isFrozen+");
    };
  }
};

// node_modules/compromise/src/1-one/lexicon/compute/multi-word.js
var multiWord = function(terms, start_i, world2) {
  const { model: model5, methods: methods17 } = world2;
  const setTag2 = methods17.one.setTag;
  const multi = model5.one._multiCache || {};
  const { lexicon: lexicon4, frozenLex } = model5.one || {};
  let t5 = terms[start_i];
  let word = t5.machine || t5.normal;
  if (multi[word] !== void 0 && terms[start_i + 1]) {
    let end2 = start_i + multi[word] - 1;
    for (let i5 = end2; i5 > start_i; i5 -= 1) {
      let words = terms.slice(start_i, i5 + 1);
      if (words.length <= 1) {
        return false;
      }
      let str = words.map((term) => term.machine || term.normal).join(" ");
      if (frozenLex.hasOwnProperty(str) === true) {
        setTag2(words, frozenLex[str], world2, false, "1-frozen-multi-lexicon");
        words.forEach((term) => term.frozen = true);
        return true;
      }
      if (lexicon4.hasOwnProperty(str) === true) {
        let tag2 = lexicon4[str];
        setTag2(words, tag2, world2, false, "1-multi-lexicon");
        if (tag2 && tag2.length === 2 && (tag2[0] === "PhrasalVerb" || tag2[1] === "PhrasalVerb")) {
          setTag2([words[1]], "Particle", world2, false, "1-phrasal-particle");
        }
        return true;
      }
    }
    return false;
  }
  return null;
};
var multi_word_default = multiWord;

// node_modules/compromise/src/1-one/lexicon/compute/single-word.js
var prefix = /^(under|over|mis|re|un|dis|semi|pre|post)-?/;
var allowPrefix = /* @__PURE__ */ new Set(["Verb", "Infinitive", "PastTense", "Gerund", "PresentTense", "Adjective", "Participle"]);
var checkLexicon = function(terms, i5, world2) {
  const { model: model5, methods: methods17 } = world2;
  const setTag2 = methods17.one.setTag;
  const { lexicon: lexicon4, frozenLex } = model5.one;
  let t5 = terms[i5];
  let word = t5.machine || t5.normal;
  if (frozenLex[word] !== void 0 && frozenLex.hasOwnProperty(word)) {
    setTag2([t5], frozenLex[word], world2, false, "1-freeze-lexicon");
    t5.frozen = true;
    return true;
  }
  if (lexicon4[word] !== void 0 && lexicon4.hasOwnProperty(word)) {
    setTag2([t5], lexicon4[word], world2, false, "1-lexicon");
    return true;
  }
  if (t5.alias) {
    let found = t5.alias.find((str) => lexicon4.hasOwnProperty(str));
    if (found) {
      setTag2([t5], lexicon4[found], world2, false, "1-lexicon-alias");
      return true;
    }
  }
  if (prefix.test(word) === true) {
    let stem = word.replace(prefix, "");
    if (lexicon4.hasOwnProperty(stem) && stem.length > 3) {
      if (allowPrefix.has(lexicon4[stem])) {
        setTag2([t5], lexicon4[stem], world2, false, "1-lexicon-prefix");
        return true;
      }
    }
  }
  return null;
};
var single_word_default = checkLexicon;

// node_modules/compromise/src/1-one/lexicon/compute/index.js
var lexicon = function(view) {
  const world2 = view.world;
  view.docs.forEach((terms) => {
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      if (terms[i5].tags.size === 0) {
        let found = null;
        found = found || multi_word_default(terms, i5, world2);
        found = found || single_word_default(terms, i5, world2);
      }
    }
  });
};
var compute_default5 = {
  lexicon
};

// node_modules/compromise/src/1-one/lexicon/methods/expand.js
var expand2 = function(words) {
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag2 = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      if (_multi[split3[0]] === void 0 || split3.length > _multi[split3[0]]) {
        _multi[split3[0]] = split3.length;
      }
    }
    lex[word] = lex[word] || tag2;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default = expand2;

// node_modules/compromise/src/1-one/lexicon/methods/index.js
var methods_default3 = {
  one: {
    expandLexicon: expand_default
  }
};

// node_modules/compromise/src/1-one/lexicon/lib.js
var addWords = function(words, isFrozen = false) {
  const world2 = this.world();
  const { methods: methods17, model: model5 } = world2;
  if (!words) {
    return;
  }
  Object.keys(words).forEach((k3) => {
    if (typeof words[k3] === "string" && words[k3].startsWith("#")) {
      words[k3] = words[k3].replace(/^#/, "");
    }
  });
  if (isFrozen === true) {
    let { lex: lex2, _multi: _multi2 } = methods17.one.expandLexicon(words, world2);
    Object.assign(model5.one._multiCache, _multi2);
    Object.assign(model5.one.frozenLex, lex2);
    return;
  }
  if (methods17.two.expandLexicon) {
    let { lex: lex2, _multi: _multi2 } = methods17.two.expandLexicon(words, world2);
    Object.assign(model5.one.lexicon, lex2);
    Object.assign(model5.one._multiCache, _multi2);
  }
  let { lex, _multi } = methods17.one.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
};
var lib_default = { addWords };

// node_modules/compromise/src/1-one/lexicon/plugin.js
var model2 = {
  one: {
    lexicon: {},
    //setup blank lexicon
    _multiCache: {},
    frozenLex: {}
    //2nd lexicon
  }
};
var plugin_default5 = {
  model: model2,
  methods: methods_default3,
  compute: compute_default5,
  lib: lib_default,
  hooks: ["lexicon"]
};

// node_modules/compromise/src/1-one/lookup/api/buildTrie/index.js
var tokenize = function(phrase, world2) {
  const { methods: methods17, model: model5 } = world2;
  let terms = methods17.one.tokenize.splitTerms(phrase, model5).map((t5) => methods17.one.tokenize.splitWhitespace(t5, model5));
  return terms.map((term) => term.text.toLowerCase());
};
var buildTrie = function(phrases, world2) {
  let goNext = [{}];
  let endAs = [null];
  let failTo = [0];
  let xs = [];
  let n5 = 0;
  phrases.forEach(function(phrase) {
    let curr = 0;
    let words = tokenize(phrase, world2);
    for (let i5 = 0; i5 < words.length; i5++) {
      let word = words[i5];
      if (goNext[curr] && goNext[curr].hasOwnProperty(word)) {
        curr = goNext[curr][word];
      } else {
        n5++;
        goNext[curr][word] = n5;
        goNext[n5] = {};
        curr = n5;
        endAs[n5] = null;
      }
    }
    endAs[curr] = [words.length];
  });
  for (let word in goNext[0]) {
    n5 = goNext[0][word];
    failTo[n5] = 0;
    xs.push(n5);
  }
  while (xs.length) {
    let r3 = xs.shift();
    let keys = Object.keys(goNext[r3]);
    for (let i5 = 0; i5 < keys.length; i5 += 1) {
      let word = keys[i5];
      let s5 = goNext[r3][word];
      xs.push(s5);
      n5 = failTo[r3];
      while (n5 > 0 && !goNext[n5].hasOwnProperty(word)) {
        n5 = failTo[n5];
      }
      if (goNext.hasOwnProperty(n5)) {
        let fs = goNext[n5][word];
        failTo[s5] = fs;
        if (endAs[fs]) {
          endAs[s5] = endAs[s5] || [];
          endAs[s5] = endAs[s5].concat(endAs[fs]);
        }
      } else {
        failTo[s5] = 0;
      }
    }
  }
  return { goNext, endAs, failTo };
};
var buildTrie_default = buildTrie;

// node_modules/compromise/src/1-one/lookup/api/scan.js
var scanWords = function(terms, trie, opts2) {
  let n5 = 0;
  let results = [];
  for (let i5 = 0; i5 < terms.length; i5++) {
    let word = terms[i5][opts2.form] || terms[i5].normal;
    while (n5 > 0 && (trie.goNext[n5] === void 0 || !trie.goNext[n5].hasOwnProperty(word))) {
      n5 = trie.failTo[n5] || 0;
    }
    if (!trie.goNext[n5].hasOwnProperty(word)) {
      continue;
    }
    n5 = trie.goNext[n5][word];
    if (trie.endAs[n5]) {
      let arr = trie.endAs[n5];
      for (let o4 = 0; o4 < arr.length; o4++) {
        let len = arr[o4];
        let term = terms[i5 - len + 1];
        let [no, start2] = term.index;
        results.push([no, start2, start2 + len, term.id]);
      }
    }
  }
  return results;
};
var cacheMiss = function(words, cache3) {
  for (let i5 = 0; i5 < words.length; i5 += 1) {
    if (cache3.has(words[i5]) === true) {
      return false;
    }
  }
  return true;
};
var scan = function(view, trie, opts2) {
  let results = [];
  opts2.form = opts2.form || "normal";
  let docs = view.docs;
  if (!trie.goNext || !trie.goNext[0]) {
    console.error("Compromise invalid lookup trie");
    return view.none();
  }
  let firstWords = Object.keys(trie.goNext[0]);
  for (let i5 = 0; i5 < docs.length; i5++) {
    if (view._cache && view._cache[i5] && cacheMiss(firstWords, view._cache[i5]) === true) {
      continue;
    }
    let terms = docs[i5];
    let found = scanWords(terms, trie, opts2);
    if (found.length > 0) {
      results = results.concat(found);
    }
  }
  return view.update(results);
};
var scan_default = scan;

// node_modules/compromise/src/1-one/lookup/api/index.js
var isObject3 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
function api_default3(View2) {
  View2.prototype.lookup = function(input, opts2 = {}) {
    if (!input) {
      return this.none();
    }
    if (typeof input === "string") {
      input = [input];
    }
    let trie = isObject3(input) ? input : buildTrie_default(input, this.world);
    let res = scan_default(this, trie, opts2);
    res = res.settle();
    return res;
  };
}

// node_modules/compromise/src/1-one/lookup/api/buildTrie/compress.js
var truncate = (list5, val) => {
  for (let i5 = list5.length - 1; i5 >= 0; i5 -= 1) {
    if (list5[i5] !== val) {
      list5 = list5.slice(0, i5 + 1);
      return list5;
    }
  }
  return list5;
};
var compress = function(trie) {
  trie.goNext = trie.goNext.map((o4) => {
    if (Object.keys(o4).length === 0) {
      return void 0;
    }
    return o4;
  });
  trie.goNext = truncate(trie.goNext, void 0);
  trie.failTo = truncate(trie.failTo, 0);
  trie.endAs = truncate(trie.endAs, null);
  return trie;
};
var compress_default = compress;

// node_modules/compromise/src/1-one/lookup/plugin.js
var lib = {
  /** turn an array or object into a compressed trie*/
  buildTrie: function(input) {
    const trie = buildTrie_default(input, this.world());
    return compress_default(trie);
  }
};
lib.compile = lib.buildTrie;
var plugin_default6 = {
  api: api_default3,
  lib
};

// node_modules/compromise/src/1-one/match/api/_lib.js
var relPointer = function(ptrs, parent) {
  if (!parent) {
    return ptrs;
  }
  ptrs.forEach((ptr) => {
    let n5 = ptr[0];
    if (parent[n5]) {
      ptr[0] = parent[n5][0];
      ptr[1] += parent[n5][1];
      ptr[2] += parent[n5][1];
    }
  });
  return ptrs;
};
var fixPointers2 = function(res, parent) {
  let { ptrs, byGroup } = res;
  ptrs = relPointer(ptrs, parent);
  Object.keys(byGroup).forEach((k3) => {
    byGroup[k3] = relPointer(byGroup[k3], parent);
  });
  return { ptrs, byGroup };
};
var parseRegs = function(regs, opts2, world2) {
  const one = world2.methods.one;
  if (typeof regs === "number") {
    regs = String(regs);
  }
  if (typeof regs === "string") {
    regs = one.killUnicode(regs, world2);
    regs = one.parseMatch(regs, opts2, world2);
  }
  return regs;
};
var isObject4 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var isView = (val) => val && isObject4(val) && val.isView === true;
var isNet = (val) => val && isObject4(val) && val.isNet === true;

// node_modules/compromise/src/1-one/match/api/match.js
var match = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.settle();
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var matchOne = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.intersection(regs).eq(0);
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false, matchOne: true }).view;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let res = one.match(this.docs, todo, this._cache);
  let { ptrs, byGroup } = fixPointers2(res, this.fullPointer);
  let view = this.toView(ptrs);
  view._groups = byGroup;
  return view;
};
var has = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    let ptrs2 = this.intersection(regs).fullPointer;
    return ptrs2.length > 0;
  }
  if (isNet(regs)) {
    return this.sweep(regs, { tagger: false }).view.found;
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = one.match(this.docs, todo, this._cache).ptrs;
  return ptrs.length > 0;
};
var ifFn = function(regs, group, opts2) {
  const one = this.methods.one;
  if (isView(regs)) {
    return this.filter((m6) => m6.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m6 = this.sweep(regs, { tagger: false }).view.settle();
    return this.if(m6);
  }
  regs = parseRegs(regs, opts2, this.world);
  let todo = { regs, group, justOne: true };
  let ptrs = this.fullPointer;
  let cache3 = this._cache || [];
  ptrs = ptrs.filter((ptr, i5) => {
    let m6 = this.update([ptr]);
    let res = one.match(m6.docs, todo, cache3[i5]).ptrs;
    return res.length > 0;
  });
  let view = this.update(ptrs);
  if (this._cache) {
    view._cache = ptrs.map((ptr) => cache3[ptr[0]]);
  }
  return view;
};
var ifNo = function(regs, group, opts2) {
  const { methods: methods17 } = this;
  const one = methods17.one;
  if (isView(regs)) {
    return this.filter((m6) => !m6.intersection(regs).found);
  }
  if (isNet(regs)) {
    let m6 = this.sweep(regs, { tagger: false }).view.settle();
    return this.ifNo(m6);
  }
  regs = parseRegs(regs, opts2, this.world);
  let cache3 = this._cache || [];
  let view = this.filter((m6, i5) => {
    let todo = { regs, group, justOne: true };
    let ptrs = one.match(m6.docs, todo, cache3[i5]).ptrs;
    return ptrs.length === 0;
  });
  if (this._cache) {
    view._cache = view.ptrs.map((ptr) => cache3[ptr[0]]);
  }
  return view;
};
var match_default = { matchOne, match, has, if: ifFn, ifNo };

// node_modules/compromise/src/1-one/match/api/lookaround.js
var before = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let pre = [];
  let byN = indexN2(this.fullPointer);
  Object.keys(byN).forEach((k3) => {
    let first = byN[k3].sort((a4, b2) => a4[1] > b2[1] ? 1 : -1)[0];
    if (first[1] > 0) {
      pre.push([first[0], 0, first[1]]);
    }
  });
  let preWords = this.toView(pre);
  if (!regs) {
    return preWords;
  }
  return preWords.match(regs, group, opts2);
};
var after = function(regs, group, opts2) {
  const { indexN: indexN2 } = this.methods.one.pointer;
  let post = [];
  let byN = indexN2(this.fullPointer);
  let document2 = this.document;
  Object.keys(byN).forEach((k3) => {
    let last = byN[k3].sort((a4, b2) => a4[1] > b2[1] ? -1 : 1)[0];
    let [n5, , end2] = last;
    if (end2 < document2[n5].length) {
      post.push([n5, end2, document2[n5].length]);
    }
  });
  let postWords = this.toView(post);
  if (!regs) {
    return postWords;
  }
  return postWords.match(regs, group, opts2);
};
var growLeft = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[regs.length - 1].end = true;
  let ptrs = this.fullPointer;
  this.forEach((m6, n5) => {
    let more = m6.before(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n5][1] -= terms.length;
      ptrs[n5][3] = terms.docs[0][0].id;
    }
  });
  return this.update(ptrs);
};
var growRight = function(regs, group, opts2) {
  if (typeof regs === "string") {
    regs = this.world.methods.one.parseMatch(regs, opts2, this.world);
  }
  regs[0].start = true;
  let ptrs = this.fullPointer;
  this.forEach((m6, n5) => {
    let more = m6.after(regs, group);
    if (more.found) {
      let terms = more.terms();
      ptrs[n5][2] += terms.length;
      ptrs[n5][4] = null;
    }
  });
  return this.update(ptrs);
};
var grow = function(regs, group, opts2) {
  return this.growRight(regs, group, opts2).growLeft(regs, group, opts2);
};
var lookaround_default = { before, after, growLeft, growRight, grow };

// node_modules/compromise/src/1-one/match/api/split.js
var combine = function(left, right) {
  return [left[0], left[1], right[2]];
};
var isArray5 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc = (reg, view, group) => {
  if (typeof reg === "string" || isArray5(reg)) {
    return view.match(reg, group);
  }
  if (!reg) {
    return view.none();
  }
  return reg;
};
var addIds2 = function(ptr, view) {
  let [n5, start2, end2] = ptr;
  if (view.document[n5] && view.document[n5][start2]) {
    ptr[3] = ptr[3] || view.document[n5][start2].id;
    if (view.document[n5][end2 - 1]) {
      ptr[4] = ptr[4] || view.document[n5][end2 - 1].id;
    }
  }
  return ptr;
};
var methods7 = {};
methods7.splitOn = function(m6, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m6, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o4) => {
    res.push(o4.passthrough);
    res.push(o4.before);
    res.push(o4.match);
    res.push(o4.after);
  });
  res = res.filter((p7) => p7);
  res = res.map((p7) => addIds2(p7, this));
  return this.update(res);
};
methods7.splitBefore = function(m6, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m6, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  for (let i5 = 0; i5 < all4.length; i5 += 1) {
    if (!all4[i5].after && all4[i5 + 1] && all4[i5 + 1].before) {
      if (all4[i5].match && all4[i5].match[0] === all4[i5 + 1].before[0]) {
        all4[i5].after = all4[i5 + 1].before;
        delete all4[i5 + 1].before;
      }
    }
  }
  let res = [];
  all4.forEach((o4) => {
    res.push(o4.passthrough);
    res.push(o4.before);
    if (o4.match && o4.after) {
      res.push(combine(o4.match, o4.after));
    } else {
      res.push(o4.match);
    }
  });
  res = res.filter((p7) => p7);
  res = res.map((p7) => addIds2(p7, this));
  return this.update(res);
};
methods7.splitAfter = function(m6, group) {
  const { splitAll: splitAll2 } = this.methods.one.pointer;
  let splits = getDoc(m6, this, group).fullPointer;
  let all4 = splitAll2(this.fullPointer, splits);
  let res = [];
  all4.forEach((o4) => {
    res.push(o4.passthrough);
    if (o4.before && o4.match) {
      res.push(combine(o4.before, o4.match));
    } else {
      res.push(o4.before);
      res.push(o4.match);
    }
    res.push(o4.after);
  });
  res = res.filter((p7) => p7);
  res = res.map((p7) => addIds2(p7, this));
  return this.update(res);
};
methods7.split = methods7.splitAfter;
var split_default = methods7;

// node_modules/compromise/src/1-one/match/api/join.js
var isNeighbour = function(ptrL, ptrR) {
  if (!ptrL || !ptrR) {
    return false;
  }
  if (ptrL[0] !== ptrR[0]) {
    return false;
  }
  return ptrL[2] === ptrR[1];
};
var mergeIf = function(doc, lMatch, rMatch) {
  const world2 = doc.world;
  const parseMatch = world2.methods.one.parseMatch;
  lMatch = lMatch || ".$";
  rMatch = rMatch || "^.";
  let leftMatch = parseMatch(lMatch, {}, world2);
  let rightMatch = parseMatch(rMatch, {}, world2);
  leftMatch[leftMatch.length - 1].end = true;
  rightMatch[0].start = true;
  let ptrs = doc.fullPointer;
  let res = [ptrs[0]];
  for (let i5 = 1; i5 < ptrs.length; i5 += 1) {
    let ptrL = res[res.length - 1];
    let ptrR = ptrs[i5];
    let left = doc.update([ptrL]);
    let right = doc.update([ptrR]);
    if (isNeighbour(ptrL, ptrR) && left.has(leftMatch) && right.has(rightMatch)) {
      res[res.length - 1] = [ptrL[0], ptrL[1], ptrR[2], ptrL[3], ptrR[4]];
    } else {
      res.push(ptrR);
    }
  }
  return doc.update(res);
};
var methods8 = {
  //  merge only if conditions are met
  joinIf: function(lMatch, rMatch) {
    return mergeIf(this, lMatch, rMatch);
  },
  // merge all neighbouring matches
  join: function() {
    return mergeIf(this);
  }
};
var join_default = methods8;

// node_modules/compromise/src/1-one/match/api/index.js
var methods9 = Object.assign({}, match_default, lookaround_default, split_default, join_default);
methods9.lookBehind = methods9.before;
methods9.lookBefore = methods9.before;
methods9.lookAhead = methods9.after;
methods9.lookAfter = methods9.after;
methods9.notIf = methods9.ifNo;
var matchAPI = function(View2) {
  Object.assign(View2.prototype, methods9);
};
var api_default4 = matchAPI;

// node_modules/compromise/src/1-one/match/methods/parseMatch/01-parseBlocks.js
var bySlashes = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/;
var byParentheses = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/;
var byWord = / /g;
var isBlock = (str) => {
  return /^[![^]*(<[^<]*>)?\(/.test(str) && /\)[?\]+*$~]*$/.test(str);
};
var isReg = (str) => {
  return /^[![^]*(<[^<]*>)?\//.test(str) && /\/[?\]+*$~]*$/.test(str);
};
var cleanUp = function(arr) {
  arr = arr.map((str) => str.trim());
  arr = arr.filter((str) => str);
  return arr;
};
var parseBlocks = function(txt) {
  let arr = txt.split(bySlashes);
  let res = [];
  arr.forEach((str) => {
    if (isReg(str)) {
      res.push(str);
      return;
    }
    res = res.concat(str.split(byParentheses));
  });
  res = cleanUp(res);
  let final = [];
  res.forEach((str) => {
    if (isBlock(str)) {
      final.push(str);
    } else if (isReg(str)) {
      final.push(str);
    } else {
      final = final.concat(str.split(byWord));
    }
  });
  final = cleanUp(final);
  return final;
};
var parseBlocks_default = parseBlocks;

// node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js
var hasMinMax = /\{([0-9]+)?(, *[0-9]*)?\}/;
var andSign = /&&/;
var captureName = new RegExp(/^<\s*(\S+)\s*>/);
var titleCase2 = (str) => str.charAt(0).toUpperCase() + str.substring(1);
var end = (str) => str.charAt(str.length - 1);
var start = (str) => str.charAt(0);
var stripStart = (str) => str.substring(1);
var stripEnd = (str) => str.substring(0, str.length - 1);
var stripBoth = function(str) {
  str = stripStart(str);
  str = stripEnd(str);
  return str;
};
var parseToken = function(w2, opts2) {
  let obj = {};
  for (let i5 = 0; i5 < 2; i5 += 1) {
    if (end(w2) === "$") {
      obj.end = true;
      w2 = stripEnd(w2);
    }
    if (start(w2) === "^") {
      obj.start = true;
      w2 = stripStart(w2);
    }
    if (end(w2) === "?") {
      obj.optional = true;
      w2 = stripEnd(w2);
    }
    if (start(w2) === "[" || end(w2) === "]") {
      obj.group = null;
      if (start(w2) === "[") {
        obj.groupStart = true;
      }
      if (end(w2) === "]") {
        obj.groupEnd = true;
      }
      w2 = w2.replace(/^\[/, "");
      w2 = w2.replace(/\]$/, "");
      if (start(w2) === "<") {
        const res = captureName.exec(w2);
        if (res.length >= 2) {
          obj.group = res[1];
          w2 = w2.replace(res[0], "");
        }
      }
    }
    if (end(w2) === "+") {
      obj.greedy = true;
      w2 = stripEnd(w2);
    }
    if (w2 !== "*" && end(w2) === "*" && w2 !== "\\*") {
      obj.greedy = true;
      w2 = stripEnd(w2);
    }
    if (start(w2) === "!") {
      obj.negative = true;
      w2 = stripStart(w2);
    }
    if (start(w2) === "~" && end(w2) === "~" && w2.length > 2) {
      w2 = stripBoth(w2);
      obj.fuzzy = true;
      obj.min = opts2.fuzzy || 0.85;
      if (/\(/.test(w2) === false) {
        obj.word = w2;
        return obj;
      }
    }
    if (start(w2) === "/" && end(w2) === "/") {
      w2 = stripBoth(w2);
      if (opts2.caseSensitive) {
        obj.use = "text";
      }
      obj.regex = new RegExp(w2);
      return obj;
    }
    if (hasMinMax.test(w2) === true) {
      w2 = w2.replace(hasMinMax, (_a2, b2, c5) => {
        if (c5 === void 0) {
          obj.min = Number(b2);
          obj.max = Number(b2);
        } else {
          c5 = c5.replace(/, */, "");
          if (b2 === void 0) {
            obj.min = 0;
            obj.max = Number(c5);
          } else {
            obj.min = Number(b2);
            obj.max = Number(c5 || 999);
          }
        }
        obj.greedy = true;
        if (!obj.min) {
          obj.optional = true;
        }
        return "";
      });
    }
    if (start(w2) === "(" && end(w2) === ")") {
      if (andSign.test(w2)) {
        obj.choices = w2.split(andSign);
        obj.operator = "and";
      } else {
        obj.choices = w2.split("|");
        obj.operator = "or";
      }
      obj.choices[0] = stripStart(obj.choices[0]);
      let last = obj.choices.length - 1;
      obj.choices[last] = stripEnd(obj.choices[last]);
      obj.choices = obj.choices.map((s5) => s5.trim());
      obj.choices = obj.choices.filter((s5) => s5);
      obj.choices = obj.choices.map((str) => {
        return str.split(/ /g).map((s5) => parseToken(s5, opts2));
      });
      w2 = "";
    }
    if (start(w2) === "{" && end(w2) === "}") {
      w2 = stripBoth(w2);
      obj.root = w2;
      if (/\//.test(w2)) {
        let split3 = obj.root.split(/\//);
        obj.root = split3[0];
        obj.pos = split3[1];
        if (obj.pos === "adj") {
          obj.pos = "Adjective";
        }
        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();
        if (split3[2] !== void 0) {
          obj.sense = split3[2];
        }
      }
      return obj;
    }
    if (start(w2) === "<" && end(w2) === ">") {
      w2 = stripBoth(w2);
      obj.chunk = titleCase2(w2);
      obj.greedy = true;
      return obj;
    }
    if (start(w2) === "%" && end(w2) === "%") {
      w2 = stripBoth(w2);
      obj.switch = w2;
      return obj;
    }
  }
  if (start(w2) === "#") {
    obj.tag = stripStart(w2);
    obj.tag = titleCase2(obj.tag);
    return obj;
  }
  if (start(w2) === "@") {
    obj.method = stripStart(w2);
    return obj;
  }
  if (w2 === ".") {
    obj.anything = true;
    return obj;
  }
  if (w2 === "*") {
    obj.anything = true;
    obj.greedy = true;
    obj.optional = true;
    return obj;
  }
  if (w2) {
    w2 = w2.replace("\\*", "*");
    w2 = w2.replace("\\.", ".");
    if (opts2.caseSensitive) {
      obj.use = "text";
    } else {
      w2 = w2.toLowerCase();
    }
    obj.word = w2;
  }
  return obj;
};
var parseToken_default = parseToken;

// node_modules/compromise/src/1-one/match/methods/parseMatch/03-splitHyphens.js
var hasDash = /[a-z0-9][-–—][a-z]/i;
var splitHyphens = function(regs, world2) {
  let prefixes2 = world2.model.one.prefixes;
  for (let i5 = regs.length - 1; i5 >= 0; i5 -= 1) {
    let reg = regs[i5];
    if (reg.word && hasDash.test(reg.word)) {
      let words = reg.word.split(/[-–—]/g);
      if (prefixes2.hasOwnProperty(words[0])) {
        continue;
      }
      words = words.filter((w2) => w2).reverse();
      regs.splice(i5, 1);
      words.forEach((w2) => {
        let obj = Object.assign({}, reg);
        obj.word = w2;
        regs.splice(i5, 0, obj);
      });
    }
  }
  return regs;
};
var splitHyphens_default = splitHyphens;

// node_modules/compromise/src/1-one/match/methods/parseMatch/04-inflect-root.js
var addVerbs = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.verb || {};
  let str = token.root;
  if (!all4) {
    return [];
  }
  return all4(str, world2.model);
};
var addNoun = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.noun || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var addAdjective = function(token, world2) {
  let { all: all4 } = world2.methods.two.transform.adjective || {};
  if (!all4) {
    return [token.root];
  }
  return all4(token.root, world2.model);
};
var inflectRoot = function(regs, world2) {
  regs = regs.map((token) => {
    if (token.root) {
      if (world2.methods.two && world2.methods.two.transform) {
        let choices = [];
        if (token.pos) {
          if (token.pos === "Verb") {
            choices = choices.concat(addVerbs(token, world2));
          } else if (token.pos === "Noun") {
            choices = choices.concat(addNoun(token, world2));
          } else if (token.pos === "Adjective") {
            choices = choices.concat(addAdjective(token, world2));
          }
        } else {
          choices = choices.concat(addVerbs(token, world2));
          choices = choices.concat(addNoun(token, world2));
          choices = choices.concat(addAdjective(token, world2));
        }
        choices = choices.filter((str) => str);
        if (choices.length > 0) {
          token.operator = "or";
          token.fastOr = new Set(choices);
        }
      } else {
        token.machine = token.root;
        delete token.id;
        delete token.root;
      }
    }
    return token;
  });
  return regs;
};
var inflect_root_default = inflectRoot;

// node_modules/compromise/src/1-one/match/methods/parseMatch/05-postProcess.js
var nameGroups = function(regs) {
  let index4 = 0;
  let inGroup = null;
  for (let i5 = 0; i5 < regs.length; i5++) {
    const token = regs[i5];
    if (token.groupStart === true) {
      inGroup = token.group;
      if (inGroup === null) {
        inGroup = String(index4);
        index4 += 1;
      }
    }
    if (inGroup !== null) {
      token.group = inGroup;
    }
    if (token.groupEnd === true) {
      inGroup = null;
    }
  }
  return regs;
};
var doFastOrMode = function(tokens) {
  return tokens.map((token) => {
    if (token.choices !== void 0) {
      if (token.operator !== "or") {
        return token;
      }
      if (token.fuzzy === true) {
        return token;
      }
      let shouldPack = token.choices.every((block2) => {
        if (block2.length !== 1) {
          return false;
        }
        let reg = block2[0];
        if (reg.fuzzy === true) {
          return false;
        }
        if (reg.start || reg.end) {
          return false;
        }
        if (reg.word !== void 0 && reg.negative !== true && reg.optional !== true && reg.method !== true) {
          return true;
        }
        return false;
      });
      if (shouldPack === true) {
        token.fastOr = /* @__PURE__ */ new Set();
        token.choices.forEach((block2) => {
          token.fastOr.add(block2[0].word);
        });
        delete token.choices;
      }
    }
    return token;
  });
};
var fuzzyOr = function(regs) {
  return regs.map((reg) => {
    if (reg.fuzzy && reg.choices) {
      reg.choices.forEach((r3) => {
        if (r3.length === 1 && r3[0].word) {
          r3[0].fuzzy = true;
          r3[0].min = reg.min;
        }
      });
    }
    return reg;
  });
};
var postProcess = function(regs) {
  regs = nameGroups(regs);
  regs = doFastOrMode(regs);
  regs = fuzzyOr(regs);
  return regs;
};
var postProcess_default = postProcess;

// node_modules/compromise/src/1-one/match/methods/parseMatch/index.js
var syntax = function(input, opts2, world2) {
  if (input === null || input === void 0 || input === "") {
    return [];
  }
  opts2 = opts2 || {};
  if (typeof input === "number") {
    input = String(input);
  }
  let tokens = parseBlocks_default(input);
  tokens = tokens.map((str) => parseToken_default(str, opts2));
  tokens = splitHyphens_default(tokens, world2);
  tokens = inflect_root_default(tokens, world2);
  tokens = postProcess_default(tokens, opts2);
  return tokens;
};
var parseMatch_default = syntax;

// node_modules/compromise/src/1-one/match/methods/match/01-failFast.js
var anyIntersection = function(setA, setB) {
  for (let elem of setB) {
    if (setA.has(elem)) {
      return true;
    }
  }
  return false;
};
var failFast = function(regs, cache3) {
  for (let i5 = 0; i5 < regs.length; i5 += 1) {
    let reg = regs[i5];
    if (reg.optional === true || reg.negative === true || reg.fuzzy === true) {
      continue;
    }
    if (reg.word !== void 0 && cache3.has(reg.word) === false) {
      return true;
    }
    if (reg.tag !== void 0 && cache3.has("#" + reg.tag) === false) {
      return true;
    }
    if (reg.fastOr && anyIntersection(reg.fastOr, cache3) === false) {
      return false;
    }
  }
  return false;
};
var failFast_default = failFast;

// node_modules/compromise/src/1-one/match/methods/match/term/_fuzzy.js
var editDistance = function(strA, strB) {
  let aLength = strA.length, bLength = strB.length;
  if (aLength === 0) {
    return bLength;
  }
  if (bLength === 0) {
    return aLength;
  }
  let limit = (bLength > aLength ? bLength : aLength) + 1;
  if (Math.abs(aLength - bLength) > (limit || 100)) {
    return limit || 100;
  }
  let matrix = [];
  for (let i5 = 0; i5 < limit; i5++) {
    matrix[i5] = [i5];
    matrix[i5].length = limit;
  }
  for (let i5 = 0; i5 < limit; i5++) {
    matrix[0][i5] = i5;
  }
  let j3, a_index, b_index, cost, min2, t5;
  for (let i5 = 1; i5 <= aLength; ++i5) {
    a_index = strA[i5 - 1];
    for (j3 = 1; j3 <= bLength; ++j3) {
      if (i5 === j3 && matrix[i5][j3] > 4) {
        return aLength;
      }
      b_index = strB[j3 - 1];
      cost = a_index === b_index ? 0 : 1;
      min2 = matrix[i5 - 1][j3] + 1;
      if ((t5 = matrix[i5][j3 - 1] + 1) < min2)
        min2 = t5;
      if ((t5 = matrix[i5 - 1][j3 - 1] + cost) < min2)
        min2 = t5;
      let shouldUpdate = i5 > 1 && j3 > 1 && a_index === strB[j3 - 2] && strA[i5 - 2] === b_index && (t5 = matrix[i5 - 2][j3 - 2] + cost) < min2;
      if (shouldUpdate) {
        matrix[i5][j3] = t5;
      } else {
        matrix[i5][j3] = min2;
      }
    }
  }
  return matrix[aLength][bLength];
};
var fuzzyMatch = function(strA, strB, minLength = 3) {
  if (strA === strB) {
    return 1;
  }
  if (strA.length < minLength || strB.length < minLength) {
    return 0;
  }
  const steps = editDistance(strA, strB);
  let length2 = Math.max(strA.length, strB.length);
  let relative2 = length2 === 0 ? 0 : steps / length2;
  let similarity = 1 - relative2;
  return similarity;
};
var fuzzy_default = fuzzyMatch;

// node_modules/compromise/src/1-one/match/methods/termMethods.js
var startQuote = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/;
var endQuote = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/;
var hasHyphen = /^[-–—]$/;
var hasDash2 = / [-–—]{1,3} /;
var hasPost = (term, punct) => term.post.indexOf(punct) !== -1;
var methods10 = {
  /** does it have a quotation symbol?  */
  hasQuote: (term) => startQuote.test(term.pre) || endQuote.test(term.post),
  /** does it have a comma?  */
  hasComma: (term) => hasPost(term, ","),
  /** does it end in a period? */
  hasPeriod: (term) => hasPost(term, ".") === true && hasPost(term, "...") === false,
  /** does it end in an exclamation */
  hasExclamation: (term) => hasPost(term, "!"),
  /** does it end with a question mark? */
  hasQuestionMark: (term) => hasPost(term, "?") || hasPost(term, "\xBF"),
  /** is there a ... at the end? */
  hasEllipses: (term) => hasPost(term, "..") || hasPost(term, "\u2026"),
  /** is there a semicolon after term word? */
  hasSemicolon: (term) => hasPost(term, ";"),
  /** is there a colon after term word? */
  hasColon: (term) => hasPost(term, ":"),
  /** is there a slash '/' in term word? */
  hasSlash: (term) => /\//.test(term.text),
  /** a hyphen connects two words like-term */
  hasHyphen: (term) => hasHyphen.test(term.post) || hasHyphen.test(term.pre),
  /** a dash separates words - like that */
  hasDash: (term) => hasDash2.test(term.post) || hasDash2.test(term.pre),
  /** is it multiple words combinded */
  hasContraction: (term) => Boolean(term.implicit),
  /** is it an acronym */
  isAcronym: (term) => term.tags.has("Acronym"),
  /** does it have any tags */
  isKnown: (term) => term.tags.size > 0,
  /** uppercase first letter, then a lowercase */
  isTitleCase: (term) => /^\p{Lu}[a-z'\u00C0-\u00FF]/u.test(term.text),
  /** uppercase all letters */
  isUpperCase: (term) => /^\p{Lu}+$/u.test(term.text)
};
methods10.hasQuotation = methods10.hasQuote;
var termMethods_default = methods10;

// node_modules/compromise/src/1-one/match/methods/match/term/doesMatch.js
var wrapMatch = function() {
};
var doesMatch = function(term, reg, index4, length2) {
  if (reg.anything === true) {
    return true;
  }
  if (reg.start === true && index4 !== 0) {
    return false;
  }
  if (reg.end === true && index4 !== length2 - 1) {
    return false;
  }
  if (reg.id !== void 0 && reg.id === term.id) {
    return true;
  }
  if (reg.word !== void 0) {
    if (reg.use) {
      return reg.word === term[reg.use];
    }
    if (term.machine !== null && term.machine === reg.word) {
      return true;
    }
    if (term.alias !== void 0 && term.alias.hasOwnProperty(reg.word)) {
      return true;
    }
    if (reg.fuzzy === true) {
      if (reg.word === term.root) {
        return true;
      }
      let score = fuzzy_default(reg.word, term.normal);
      if (score >= reg.min) {
        return true;
      }
    }
    if (term.alias && term.alias.some((str) => str === reg.word)) {
      return true;
    }
    return reg.word === term.text || reg.word === term.normal;
  }
  if (reg.tag !== void 0) {
    return term.tags.has(reg.tag) === true;
  }
  if (reg.method !== void 0) {
    if (typeof termMethods_default[reg.method] === "function" && termMethods_default[reg.method](term) === true) {
      return true;
    }
    return false;
  }
  if (reg.pre !== void 0) {
    return term.pre && term.pre.includes(reg.pre);
  }
  if (reg.post !== void 0) {
    return term.post && term.post.includes(reg.post);
  }
  if (reg.regex !== void 0) {
    let str = term.normal;
    if (reg.use) {
      str = term[reg.use];
    }
    return reg.regex.test(str);
  }
  if (reg.chunk !== void 0) {
    return term.chunk === reg.chunk;
  }
  if (reg.switch !== void 0) {
    return term.switch === reg.switch;
  }
  if (reg.machine !== void 0) {
    return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;
  }
  if (reg.sense !== void 0) {
    return term.sense === reg.sense;
  }
  if (reg.fastOr !== void 0) {
    if (reg.pos && !term.tags.has(reg.pos)) {
      return null;
    }
    let str = term.root || term.implicit || term.machine || term.normal;
    return reg.fastOr.has(str) || reg.fastOr.has(term.text);
  }
  if (reg.choices !== void 0) {
    if (reg.operator === "and") {
      return reg.choices.every((r3) => wrapMatch(term, r3, index4, length2));
    }
    return reg.choices.some((r3) => wrapMatch(term, r3, index4, length2));
  }
  return false;
};
wrapMatch = function(t5, reg, index4, length2) {
  let result = doesMatch(t5, reg, index4, length2);
  if (reg.negative === true) {
    return !result;
  }
  return result;
};
var doesMatch_default = wrapMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/greedy.js
var getGreedy = function(state, endReg) {
  let reg = Object.assign({}, state.regs[state.r], { start: false, end: false });
  let start2 = state.t;
  for (; state.t < state.terms.length; state.t += 1) {
    if (endReg && doesMatch_default(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) {
      return state.t;
    }
    let count = state.t - start2 + 1;
    if (reg.max !== void 0 && count === reg.max) {
      return state.t;
    }
    if (doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {
      if (reg.min !== void 0 && count < reg.min) {
        return null;
      }
      return state.t;
    }
  }
  return state.t;
};
var greedyTo = function(state, nextReg) {
  let t5 = state.t;
  if (!nextReg) {
    return state.terms.length;
  }
  for (; t5 < state.terms.length; t5 += 1) {
    if (doesMatch_default(state.terms[t5], nextReg, state.start_i + t5, state.phrase_length) === true) {
      return t5;
    }
  }
  return null;
};
var isEndGreedy = function(reg, state) {
  if (reg.end === true && reg.greedy === true) {
    if (state.start_i + state.t < state.phrase_length - 1) {
      let tmpReg = Object.assign({}, reg, { end: false });
      if (doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/_lib.js
var getGroup = function(state, term_index) {
  if (state.groups[state.inGroup]) {
    return state.groups[state.inGroup];
  }
  state.groups[state.inGroup] = {
    start: term_index,
    length: 0
  };
  return state.groups[state.inGroup];
};

// node_modules/compromise/src/1-one/match/methods/match/steps/astrix.js
var doAstrix = function(state) {
  let { regs } = state;
  let reg = regs[state.r];
  let skipto = greedyTo(state, regs[state.r + 1]);
  if (skipto === null || skipto === 0) {
    return null;
  }
  if (reg.min !== void 0 && skipto - state.t < reg.min) {
    return null;
  }
  if (reg.max !== void 0 && skipto - state.t > reg.max) {
    state.t = state.t + reg.max;
    return true;
  }
  if (state.hasGroup === true) {
    const g5 = getGroup(state, state.t);
    g5.length = skipto - state.t;
  }
  state.t = skipto;
  return true;
};
var astrix_default = doAstrix;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/and-or.js
var isArray6 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var doOrBlock = function(state, skipN = 0) {
  let block2 = state.regs[state.r];
  let wasFound = false;
  for (let c5 = 0; c5 < block2.choices.length; c5 += 1) {
    let regs = block2.choices[c5];
    if (!isArray6(regs)) {
      return false;
    }
    wasFound = regs.every((cr, w_index) => {
      let extra = 0;
      let t5 = state.t + w_index + skipN + extra;
      if (state.terms[t5] === void 0) {
        return false;
      }
      let foundBlock = doesMatch_default(state.terms[t5], cr, t5 + state.start_i, state.phrase_length);
      if (foundBlock === true && cr.greedy === true) {
        for (let i5 = 1; i5 < state.terms.length; i5 += 1) {
          let term = state.terms[t5 + i5];
          if (term) {
            let keepGoing = doesMatch_default(term, cr, state.start_i + i5, state.phrase_length);
            if (keepGoing === true) {
              extra += 1;
            } else {
              break;
            }
          }
        }
      }
      skipN += extra;
      return foundBlock;
    });
    if (wasFound) {
      skipN += regs.length;
      break;
    }
  }
  if (wasFound && block2.greedy === true) {
    return doOrBlock(state, skipN);
  }
  return skipN;
};
var doAndBlock = function(state) {
  let longest = 0;
  let reg = state.regs[state.r];
  let allDidMatch = reg.choices.every((block2) => {
    let allWords = block2.every((cr, w_index) => {
      let tryTerm = state.t + w_index;
      if (state.terms[tryTerm] === void 0) {
        return false;
      }
      return doesMatch_default(state.terms[tryTerm], cr, tryTerm, state.phrase_length);
    });
    if (allWords === true && block2.length > longest) {
      longest = block2.length;
    }
    return allWords;
  });
  if (allDidMatch === true) {
    return longest;
  }
  return false;
};

// node_modules/compromise/src/1-one/match/methods/match/steps/or-block.js
var orBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doOrBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g5 = getGroup(state, state.t);
      g5.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length;
      if (state.t + state.start_i + skipNum !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var or_block_default = orBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/and-block.js
var andBlock = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let skipNum = doAndBlock(state);
  if (skipNum) {
    if (reg.negative === true) {
      return null;
    }
    if (state.hasGroup === true) {
      const g5 = getGroup(state, state.t);
      g5.length += skipNum;
    }
    if (reg.end === true) {
      let end2 = state.phrase_length - 1;
      if (state.t + state.start_i !== end2) {
        return null;
      }
    }
    state.t += skipNum;
    return true;
  } else if (!reg.optional) {
    return null;
  }
  return true;
};
var and_block_default = andBlock;

// node_modules/compromise/src/1-one/match/methods/match/steps/logic/negative-greedy.js
var negGreedy = function(state, reg, nextReg) {
  let skip = 0;
  for (let t5 = state.t; t5 < state.terms.length; t5 += 1) {
    let found = doesMatch_default(state.terms[t5], reg, state.start_i + state.t, state.phrase_length);
    if (found) {
      break;
    }
    if (nextReg) {
      found = doesMatch_default(state.terms[t5], nextReg, state.start_i + state.t, state.phrase_length);
      if (found) {
        break;
      }
    }
    skip += 1;
    if (reg.max !== void 0 && skip === reg.max) {
      break;
    }
  }
  if (skip === 0) {
    return false;
  }
  if (reg.min && reg.min > skip) {
    return false;
  }
  state.t += skip;
  return true;
};
var negative_greedy_default = negGreedy;

// node_modules/compromise/src/1-one/match/methods/match/steps/negative.js
var doNegative = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let tmpReg = Object.assign({}, reg);
  tmpReg.negative = false;
  let found = doesMatch_default(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length);
  if (found) {
    return false;
  }
  if (reg.optional) {
    let nextReg = regs[state.r + 1];
    if (nextReg) {
      let fNext = doesMatch_default(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length);
      if (fNext) {
        state.r += 1;
      } else if (nextReg.optional && regs[state.r + 2]) {
        let fNext2 = doesMatch_default(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length);
        if (fNext2) {
          state.r += 2;
        }
      }
    }
  }
  if (reg.greedy) {
    return negative_greedy_default(state, tmpReg, regs[state.r + 1]);
  }
  state.t += 1;
  return true;
};
var negative_default = doNegative;

// node_modules/compromise/src/1-one/match/methods/match/steps/optional-match.js
var foundOptional = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let nextRegMatched = doesMatch_default(term, regs[state.r + 1], state.start_i + state.t, state.phrase_length);
  if (reg.negative || nextRegMatched) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm || !doesMatch_default(nextTerm, regs[state.r + 1], state.start_i + state.t, state.phrase_length)) {
      state.r += 1;
    }
  }
};
var optional_match_default = foundOptional;

// node_modules/compromise/src/1-one/match/methods/match/steps/greedy-match.js
var greedyMatch = function(state) {
  const { regs, phrase_length } = state;
  let reg = regs[state.r];
  state.t = getGreedy(state, regs[state.r + 1]);
  if (state.t === null) {
    return null;
  }
  if (reg.min && reg.min > state.t) {
    return null;
  }
  if (reg.end === true && state.start_i + state.t !== phrase_length) {
    return null;
  }
  return true;
};
var greedy_match_default = greedyMatch;

// node_modules/compromise/src/1-one/match/methods/match/steps/contraction-skip.js
var contractionSkip = function(state) {
  let term = state.terms[state.t];
  let reg = state.regs[state.r];
  if (term.implicit && state.terms[state.t + 1]) {
    let nextTerm = state.terms[state.t + 1];
    if (!nextTerm.implicit) {
      return;
    }
    if (reg.word === term.normal) {
      state.t += 1;
    }
    if (reg.method === "hasContraction") {
      state.t += 1;
    }
  }
};
var contraction_skip_default = contractionSkip;

// node_modules/compromise/src/1-one/match/methods/match/steps/simple-match.js
var setGroup = function(state, startAt) {
  let reg = state.regs[state.r];
  const g5 = getGroup(state, startAt);
  if (state.t > 1 && reg.greedy) {
    g5.length += state.t - startAt;
  } else {
    g5.length++;
  }
};
var simpleMatch = function(state) {
  const { regs } = state;
  let reg = regs[state.r];
  let term = state.terms[state.t];
  let startAt = state.t;
  if (reg.optional && regs[state.r + 1] && reg.negative) {
    return true;
  }
  if (reg.optional && regs[state.r + 1]) {
    optional_match_default(state);
  }
  if (term.implicit && state.terms[state.t + 1]) {
    contraction_skip_default(state);
  }
  state.t += 1;
  if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) {
    return null;
  }
  if (reg.greedy === true) {
    let alive = greedy_match_default(state);
    if (!alive) {
      return null;
    }
  }
  if (state.hasGroup === true) {
    setGroup(state, startAt);
  }
  return true;
};
var simple_match_default = simpleMatch;

// node_modules/compromise/src/1-one/match/methods/match/02-from-here.js
var tryHere = function(terms, regs, start_i, phrase_length) {
  if (terms.length === 0 || regs.length === 0) {
    return null;
  }
  let state = {
    t: 0,
    terms,
    r: 0,
    regs,
    groups: {},
    start_i,
    phrase_length,
    inGroup: null
  };
  for (; state.r < regs.length; state.r += 1) {
    let reg = regs[state.r];
    state.hasGroup = Boolean(reg.group);
    if (state.hasGroup === true) {
      state.inGroup = reg.group;
    } else {
      state.inGroup = null;
    }
    if (!state.terms[state.t]) {
      const alive = regs.slice(state.r).some((remain) => !remain.optional);
      if (alive === false) {
        break;
      }
      return null;
    }
    if (reg.anything === true && reg.greedy === true) {
      let alive = astrix_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "or") {
      let alive = or_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.choices !== void 0 && reg.operator === "and") {
      let alive = and_block_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.anything === true) {
      if (reg.negative && reg.anything) {
        return null;
      }
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (isEndGreedy(reg, state) === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.negative) {
      let alive = negative_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    let hasMatch = doesMatch_default(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);
    if (hasMatch === true) {
      let alive = simple_match_default(state);
      if (!alive) {
        return null;
      }
      continue;
    }
    if (reg.optional === true) {
      continue;
    }
    return null;
  }
  let pntr = [null, start_i, state.t + start_i];
  if (pntr[1] === pntr[2]) {
    return null;
  }
  let groups = {};
  Object.keys(state.groups).forEach((k3) => {
    let o4 = state.groups[k3];
    let start2 = start_i + o4.start;
    groups[k3] = [null, start2, start2 + o4.length];
  });
  return { pointer: pntr, groups };
};
var from_here_default = tryHere;

// node_modules/compromise/src/1-one/match/methods/match/03-getGroup.js
var getGroup2 = function(res, group) {
  let ptrs = [];
  let byGroup = {};
  if (res.length === 0) {
    return { ptrs, byGroup };
  }
  if (typeof group === "number") {
    group = String(group);
  }
  if (group) {
    res.forEach((r3) => {
      if (r3.groups[group]) {
        ptrs.push(r3.groups[group]);
      }
    });
  } else {
    res.forEach((r3) => {
      ptrs.push(r3.pointer);
      Object.keys(r3.groups).forEach((k3) => {
        byGroup[k3] = byGroup[k3] || [];
        byGroup[k3].push(r3.groups[k3]);
      });
    });
  }
  return { ptrs, byGroup };
};
var getGroup_default = getGroup2;

// node_modules/compromise/src/1-one/match/methods/match/03-notIf.js
var notIf = function(results, not, docs) {
  results = results.filter((res) => {
    let [n5, start2, end2] = res.pointer;
    let terms = docs[n5].slice(start2, end2);
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let slice = terms.slice(i5);
      let found = from_here_default(slice, not, i5, terms.length);
      if (found !== null) {
        return false;
      }
    }
    return true;
  });
  return results;
};
var notIf_default = notIf;

// node_modules/compromise/src/1-one/match/methods/match/index.js
var addSentence = function(res, n5) {
  res.pointer[0] = n5;
  Object.keys(res.groups).forEach((k3) => {
    res.groups[k3][0] = n5;
  });
  return res;
};
var handleStart = function(terms, regs, n5) {
  let res = from_here_default(terms, regs, 0, terms.length);
  if (res) {
    res = addSentence(res, n5);
    return res;
  }
  return null;
};
var runMatch = function(docs, todo, cache3) {
  cache3 = cache3 || [];
  let { regs, group, justOne } = todo;
  let results = [];
  if (!regs || regs.length === 0) {
    return { ptrs: [], byGroup: {} };
  }
  const minLength = regs.filter((r3) => r3.optional !== true && r3.negative !== true).length;
  docs:
    for (let n5 = 0; n5 < docs.length; n5 += 1) {
      let terms = docs[n5];
      if (cache3[n5] && failFast_default(regs, cache3[n5])) {
        continue;
      }
      if (regs[0].start === true) {
        let foundStart = handleStart(terms, regs, n5, group);
        if (foundStart) {
          results.push(foundStart);
        }
        continue;
      }
      for (let i5 = 0; i5 < terms.length; i5 += 1) {
        let slice = terms.slice(i5);
        if (slice.length < minLength) {
          break;
        }
        let res = from_here_default(slice, regs, i5, terms.length);
        if (res) {
          res = addSentence(res, n5);
          results.push(res);
          if (justOne === true) {
            break docs;
          }
          let end2 = res.pointer[2];
          if (Math.abs(end2 - 1) > i5) {
            i5 = Math.abs(end2 - 1);
          }
        }
      }
    }
  if (regs[regs.length - 1].end === true) {
    results = results.filter((res) => {
      let n5 = res.pointer[0];
      return docs[n5].length === res.pointer[2];
    });
  }
  if (todo.notIf) {
    results = notIf_default(results, todo.notIf, docs);
  }
  results = getGroup_default(results, group);
  results.ptrs.forEach((ptr) => {
    let [n5, start2, end2] = ptr;
    ptr[3] = docs[n5][start2].id;
    ptr[4] = docs[n5][end2 - 1].id;
  });
  return results;
};
var match_default2 = runMatch;

// node_modules/compromise/src/1-one/match/methods/index.js
var methods11 = {
  one: {
    termMethods: termMethods_default,
    parseMatch: parseMatch_default,
    match: match_default2
  }
};
var methods_default4 = methods11;

// node_modules/compromise/src/1-one/match/lib.js
var lib_default2 = {
  /** pre-parse any match statements */
  parseMatch: function(str, opts2) {
    const world2 = this.world();
    let killUnicode2 = world2.methods.one.killUnicode;
    if (killUnicode2) {
      str = killUnicode2(str, world2);
    }
    return world2.methods.one.parseMatch(str, opts2, world2);
  }
};

// node_modules/compromise/src/1-one/match/plugin.js
var plugin_default7 = {
  api: api_default4,
  methods: methods_default4,
  lib: lib_default2
};

// node_modules/compromise/src/1-one/output/api/html.js
var isClass = /^\../;
var isId = /^#./;
var escapeXml = (str) => {
  str = str.replace(/&/g, "&amp;");
  str = str.replace(/</g, "&lt;");
  str = str.replace(/>/g, "&gt;");
  str = str.replace(/"/g, "&quot;");
  str = str.replace(/'/g, "&apos;");
  return str;
};
var toTag = function(k3) {
  let start2 = "";
  let end2 = "</span>";
  k3 = escapeXml(k3);
  if (isClass.test(k3)) {
    start2 = `<span class="${k3.replace(/^\./, "")}"`;
  } else if (isId.test(k3)) {
    start2 = `<span id="${k3.replace(/^#/, "")}"`;
  } else {
    start2 = `<${k3}`;
    end2 = `</${k3}>`;
  }
  start2 += ">";
  return { start: start2, end: end2 };
};
var getIndex = function(doc, obj) {
  let starts = {};
  let ends = {};
  Object.keys(obj).forEach((k3) => {
    let res = obj[k3];
    let tag2 = toTag(k3);
    if (typeof res === "string") {
      res = doc.match(res);
    }
    res.docs.forEach((terms) => {
      if (terms.every((t5) => t5.implicit)) {
        return;
      }
      let a4 = terms[0].id;
      starts[a4] = starts[a4] || [];
      starts[a4].push(tag2.start);
      let b2 = terms[terms.length - 1].id;
      ends[b2] = ends[b2] || [];
      ends[b2].push(tag2.end);
    });
  });
  return { starts, ends };
};
var html = function(obj) {
  let { starts, ends } = getIndex(this, obj);
  let out2 = "";
  this.docs.forEach((terms) => {
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let t5 = terms[i5];
      if (starts.hasOwnProperty(t5.id)) {
        out2 += starts[t5.id].join("");
      }
      out2 += t5.pre || "";
      out2 += t5.text || "";
      if (ends.hasOwnProperty(t5.id)) {
        out2 += ends[t5.id].join("");
      }
      out2 += t5.post || "";
    }
  });
  return out2;
};
var html_default = { html };

// node_modules/compromise/src/1-one/output/api/_text.js
var trimEnd = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4—-]+$/;
var trimStart = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/;
var punctToKill = /[,:;)('"\u201D\]]/;
var isHyphen = /^[-–—]$/;
var hasSpace = / /;
var textFromTerms = function(terms, opts2, keepSpace = true) {
  let txt = "";
  terms.forEach((t5) => {
    let pre = t5.pre || "";
    let post = t5.post || "";
    if (opts2.punctuation === "some") {
      pre = pre.replace(trimStart, "");
      if (isHyphen.test(post)) {
        post = " ";
      }
      post = post.replace(punctToKill, "");
      post = post.replace(/\?!+/, "?");
      post = post.replace(/!+/, "!");
      post = post.replace(/\?+/, "?");
      post = post.replace(/\.{2,}/, "");
      if (t5.tags.has("Abbreviation")) {
        post = post.replace(/\./, "");
      }
    }
    if (opts2.whitespace === "some") {
      pre = pre.replace(/\s/, "");
      post = post.replace(/\s+/, " ");
    }
    if (!opts2.keepPunct) {
      pre = pre.replace(trimStart, "");
      if (post === "-") {
        post = " ";
      } else {
        post = post.replace(trimEnd, "");
      }
    }
    let word = t5[opts2.form || "text"] || t5.normal || "";
    if (opts2.form === "implicit") {
      word = t5.implicit || t5.text;
    }
    if (opts2.form === "root" && t5.implicit) {
      word = t5.root || t5.implicit || t5.normal;
    }
    if ((opts2.form === "machine" || opts2.form === "implicit" || opts2.form === "root") && t5.implicit) {
      if (!post || !hasSpace.test(post)) {
        post += " ";
      }
    }
    txt += pre + word + post;
  });
  if (keepSpace === false) {
    txt = txt.trim();
  }
  if (opts2.lowerCase === true) {
    txt = txt.toLowerCase();
  }
  return txt;
};
var textFromDoc = function(docs, opts2) {
  let text = "";
  if (!docs || !docs[0] || !docs[0][0]) {
    return text;
  }
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    text += textFromTerms(docs[i5], opts2, true);
  }
  if (!opts2.keepSpace) {
    text = text.trim();
  }
  if (opts2.keepEndPunct === false) {
    if (!docs[0][0].tags.has("Emoticon")) {
      text = text.replace(trimStart, "");
    }
    let last = docs[docs.length - 1];
    if (!last[last.length - 1].tags.has("Emoticon")) {
      text = text.replace(trimEnd, "");
    }
    if (text.endsWith(`'`) && !text.endsWith(`s'`)) {
      text = text.replace(/'/, "");
    }
  }
  if (opts2.cleanWhitespace === true) {
    text = text.trim();
  }
  return text;
};

// node_modules/compromise/src/1-one/output/api/_fmts.js
var fmts = {
  text: {
    form: "text"
  },
  normal: {
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "normal"
  },
  machine: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "none",
    unicode: "some",
    form: "machine"
  },
  root: {
    keepSpace: false,
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "root"
  },
  implicit: {
    form: "implicit"
  }
};
fmts.clean = fmts.normal;
fmts.reduced = fmts.root;
var fmts_default = fmts;

// node_modules/compromise/src/1-one/output/methods/hash.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
var md5 = function(s5) {
  let b2, c5, d3, h4 = [b2 = 1732584193, c5 = 4023233417, ~b2, ~c5], words = [], j3 = decodeURI(encodeURI(s5)) + "\x80", a4 = j3.length;
  s5 = --a4 / 4 + 2 | 15;
  words[--s5] = a4 * 8;
  for (; ~a4; ) {
    words[a4 >> 2] |= j3.charCodeAt(a4) << 8 * a4--;
  }
  for (i = j3 = 0; i < s5; i += 16) {
    a4 = h4;
    for (; j3 < 64; a4 = [
      d3 = a4[3],
      b2 + ((d3 = a4[0] + [b2 & c5 | ~b2 & d3, d3 & b2 | ~d3 & c5, b2 ^ c5 ^ d3, c5 ^ (b2 | ~d3)][a4 = j3 >> 4] + k[j3] + ~~words[i | [j3, 5 * j3 + 1, 3 * j3 + 5, 7 * j3][a4] & 15]) << (a4 = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a4 + j3++ % 4]) | d3 >>> -a4),
      b2,
      c5
    ]) {
      b2 = a4[1] | 0;
      c5 = a4[2];
    }
    for (j3 = 4; j3; )
      h4[--j3] += a4[j3];
  }
  for (s5 = ""; j3 < 32; ) {
    s5 += (h4[j3 >> 3] >> (1 ^ j3++) * 4 & 15).toString(16);
  }
  return s5;
};
var hash_default = md5;

// node_modules/compromise/src/1-one/output/api/json.js
var defaults = {
  text: true,
  terms: true
};
var opts = { case: "none", unicode: "some", form: "machine", punctuation: "some" };
var merge = function(a4, b2) {
  return Object.assign({}, a4, b2);
};
var fns4 = {
  text: (terms) => textFromTerms(terms, { keepPunct: true }, false),
  normal: (terms) => textFromTerms(terms, merge(fmts_default.normal, { keepPunct: true }), false),
  implicit: (terms) => textFromTerms(terms, merge(fmts_default.implicit, { keepPunct: true }), false),
  machine: (terms) => textFromTerms(terms, opts, false),
  root: (terms) => textFromTerms(terms, merge(opts, { form: "root" }), false),
  hash: (terms) => hash_default(textFromTerms(terms, { keepPunct: true }, false)),
  offset: (terms) => {
    let len = fns4.text(terms).length;
    return {
      index: terms[0].offset.index,
      start: terms[0].offset.start,
      length: len
    };
  },
  terms: (terms) => {
    return terms.map((t5) => {
      let term = Object.assign({}, t5);
      term.tags = Array.from(t5.tags);
      return term;
    });
  },
  confidence: (_terms, view, i5) => view.eq(i5).confidence(),
  syllables: (_terms, view, i5) => view.eq(i5).syllables(),
  sentence: (_terms, view, i5) => view.eq(i5).fullSentence().text(),
  dirty: (terms) => terms.some((t5) => t5.dirty === true)
};
fns4.sentences = fns4.sentence;
fns4.clean = fns4.normal;
fns4.reduced = fns4.root;
var toJSON = function(view, option) {
  option = option || {};
  if (typeof option === "string") {
    option = {};
  }
  option = Object.assign({}, defaults, option);
  if (option.offset) {
    view.compute("offset");
  }
  return view.docs.map((terms, i5) => {
    let res = {};
    Object.keys(option).forEach((k3) => {
      if (option[k3] && fns4[k3]) {
        res[k3] = fns4[k3](terms, view, i5);
      }
    });
    return res;
  });
};
var methods12 = {
  /** return data */
  json: function(n5) {
    let res = toJSON(this, n5);
    if (typeof n5 === "number") {
      return res[n5];
    }
    return res;
  }
};
methods12.data = methods12.json;
var json_default = methods12;

// node_modules/compromise/src/1-one/output/api/debug.js
var isClientSide = () => typeof window !== "undefined" && window.document;
var debug = function(fmt2) {
  let debugMethods = this.methods.one.debug || {};
  if (fmt2 && debugMethods.hasOwnProperty(fmt2)) {
    debugMethods[fmt2](this);
    return this;
  }
  if (isClientSide()) {
    debugMethods.clientSide(this);
    return this;
  }
  debugMethods.tags(this);
  return this;
};
var debug_default = debug;

// node_modules/compromise/src/1-one/output/api/wrap.js
var toText = function(term) {
  let pre = term.pre || "";
  let post = term.post || "";
  return pre + term.text + post;
};
var findStarts = function(doc, obj) {
  let starts = {};
  Object.keys(obj).forEach((reg) => {
    let m6 = doc.match(reg);
    m6.fullPointer.forEach((a4) => {
      starts[a4[3]] = { fn: obj[reg], end: a4[2] };
    });
  });
  return starts;
};
var wrap = function(doc, obj) {
  let starts = findStarts(doc, obj);
  let text = "";
  doc.docs.forEach((terms, n5) => {
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let t5 = terms[i5];
      if (starts.hasOwnProperty(t5.id)) {
        let { fn, end: end2 } = starts[t5.id];
        let m6 = doc.update([[n5, i5, end2]]);
        text += terms[i5].pre || "";
        text += fn(m6);
        i5 = end2 - 1;
        text += terms[i5].post || "";
      } else {
        text += toText(t5);
      }
    }
  });
  return text;
};
var wrap_default = wrap;

// node_modules/compromise/src/1-one/output/api/out.js
var isObject5 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var topk = function(arr) {
  let obj = {};
  arr.forEach((a4) => {
    obj[a4] = obj[a4] || 0;
    obj[a4] += 1;
  });
  let res = Object.keys(obj).map((k3) => {
    return { normal: k3, count: obj[k3] };
  });
  return res.sort((a4, b2) => a4.count > b2.count ? -1 : 0);
};
var out = function(method) {
  if (isObject5(method)) {
    return wrap_default(this, method);
  }
  if (method === "text") {
    return this.text();
  }
  if (method === "normal") {
    return this.text("normal");
  }
  if (method === "root") {
    return this.text("root");
  }
  if (method === "machine" || method === "reduced") {
    return this.text("machine");
  }
  if (method === "hash" || method === "md5") {
    return hash_default(this.text());
  }
  if (method === "json") {
    return this.json();
  }
  if (method === "offset" || method === "offsets") {
    this.compute("offset");
    return this.json({ offset: true });
  }
  if (method === "array") {
    let arr = this.docs.map((terms) => {
      return terms.reduce((str, t5) => {
        return str + t5.pre + t5.text + t5.post;
      }, "").trim();
    });
    return arr.filter((str) => str);
  }
  if (method === "freq" || method === "frequency" || method === "topk") {
    return topk(this.json({ normal: true }).map((o4) => o4.normal));
  }
  if (method === "terms") {
    let list5 = [];
    this.docs.forEach((terms) => {
      let words = terms.map((t5) => t5.text);
      words = words.filter((t5) => t5);
      list5 = list5.concat(words);
    });
    return list5;
  }
  if (method === "tags") {
    return this.docs.map((terms) => {
      return terms.reduce((h4, t5) => {
        h4[t5.implicit || t5.normal] = Array.from(t5.tags);
        return h4;
      }, {});
    });
  }
  if (method === "debug") {
    return this.debug();
  }
  return this.text();
};
var methods13 = {
  /** */
  debug: debug_default,
  /** */
  out,
  /** */
  wrap: function(obj) {
    return wrap_default(this, obj);
  }
};
var out_default = methods13;

// node_modules/compromise/src/1-one/output/api/text.js
var isObject6 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var text_default = {
  /** */
  text: function(fmt2) {
    let opts2 = {};
    if (fmt2 && typeof fmt2 === "string" && fmts_default.hasOwnProperty(fmt2)) {
      opts2 = Object.assign({}, fmts_default[fmt2]);
    } else if (fmt2 && isObject6(fmt2)) {
      opts2 = Object.assign({}, fmt2);
    }
    if (opts2.keepSpace === void 0 && !this.isFull()) {
      opts2.keepSpace = false;
    }
    if (opts2.keepEndPunct === void 0 && this.pointer) {
      let ptr = this.pointer[0];
      if (ptr && ptr[1]) {
        opts2.keepEndPunct = false;
      } else {
        opts2.keepEndPunct = true;
      }
    }
    if (opts2.keepPunct === void 0) {
      opts2.keepPunct = true;
    }
    if (opts2.keepSpace === void 0) {
      opts2.keepSpace = true;
    }
    return textFromDoc(this.docs, opts2);
  }
};

// node_modules/compromise/src/1-one/output/api/index.js
var methods14 = Object.assign({}, out_default, text_default, json_default, html_default);
var addAPI3 = function(View2) {
  Object.assign(View2.prototype, methods14);
};
var api_default5 = addAPI3;

// node_modules/compromise/src/1-one/output/methods/debug/client-side.js
var logClientSide = function(view) {
  console.log("%c -=-=- ", "background-color:#6699cc;");
  view.forEach((m6) => {
    console.groupCollapsed(m6.text());
    let terms = m6.docs[0];
    let out2 = terms.map((t5) => {
      let text = t5.text || "-";
      if (t5.implicit) {
        text = "[" + t5.implicit + "]";
      }
      let tags = "[" + Array.from(t5.tags).join(", ") + "]";
      return { text, tags };
    });
    console.table(out2, ["text", "tags"]);
    console.groupEnd();
  });
};
var client_side_default = logClientSide;

// node_modules/compromise/src/1-one/output/methods/debug/_color.js
var reset = "\x1B[0m";
var cli = {
  green: (str) => "\x1B[32m" + str + reset,
  red: (str) => "\x1B[31m" + str + reset,
  blue: (str) => "\x1B[34m" + str + reset,
  magenta: (str) => "\x1B[35m" + str + reset,
  cyan: (str) => "\x1B[36m" + str + reset,
  yellow: (str) => "\x1B[33m" + str + reset,
  black: (str) => "\x1B[30m" + str + reset,
  dim: (str) => "\x1B[2m" + str + reset,
  i: (str) => "\x1B[3m" + str + reset
};
var color_default = cli;

// node_modules/compromise/src/1-one/output/methods/debug/tags.js
var tagString = function(tags, model5) {
  if (model5.one.tagSet) {
    tags = tags.map((tag2) => {
      if (!model5.one.tagSet.hasOwnProperty(tag2)) {
        return tag2;
      }
      const c5 = model5.one.tagSet[tag2].color || "blue";
      return color_default[c5](tag2);
    });
  }
  return tags.join(", ");
};
var showTags = function(view) {
  let { docs, model: model5 } = view;
  if (docs.length === 0) {
    console.log(color_default.blue("\n     \u2500\u2500\u2500\u2500\u2500\u2500"));
  }
  docs.forEach((terms) => {
    console.log(color_default.blue("\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
    terms.forEach((t5) => {
      let tags = [...t5.tags || []];
      let text = t5.text || "-";
      if (t5.sense) {
        text = `{${t5.normal}/${t5.sense}}`;
      }
      if (t5.implicit) {
        text = "[" + t5.implicit + "]";
      }
      text = color_default.yellow(text);
      let word = "'" + text + "'";
      if (t5.reference) {
        let str2 = view.update([t5.reference]).text("normal");
        word += ` - ${color_default.dim(color_default.i("[" + str2 + "]"))}`;
      }
      word = word.padEnd(18);
      let str = color_default.blue("  \u2502 ") + color_default.i(word) + "  - " + tagString(tags, model5);
      console.log(str);
    });
  });
  console.log("\n");
};
var tags_default = showTags;

// node_modules/compromise/src/1-one/output/methods/debug/chunks.js
var showChunks = function(view) {
  let { docs } = view;
  console.log("");
  docs.forEach((terms) => {
    let out2 = [];
    terms.forEach((term) => {
      if (term.chunk === "Noun") {
        out2.push(color_default.blue(term.implicit || term.normal));
      } else if (term.chunk === "Verb") {
        out2.push(color_default.green(term.implicit || term.normal));
      } else if (term.chunk === "Adjective") {
        out2.push(color_default.yellow(term.implicit || term.normal));
      } else if (term.chunk === "Pivot") {
        out2.push(color_default.red(term.implicit || term.normal));
      } else {
        out2.push(term.implicit || term.normal);
      }
    });
    console.log(out2.join(" "), "\n");
  });
  console.log("\n");
};
var chunks_default = showChunks;

// node_modules/compromise/src/1-one/output/methods/debug/highlight.js
var split = (txt, offset2, index4) => {
  let buff = index4 * 9;
  let start2 = offset2.start + buff;
  let end2 = start2 + offset2.length;
  let pre = txt.substring(0, start2);
  let mid = txt.substring(start2, end2);
  let post = txt.substring(end2, txt.length);
  return [pre, mid, post];
};
var spliceIn = function(txt, offset2, index4) {
  let parts = split(txt, offset2, index4);
  return `${parts[0]}${color_default.blue(parts[1])}${parts[2]}`;
};
var showHighlight = function(doc) {
  if (!doc.found) {
    return;
  }
  let bySentence = {};
  doc.fullPointer.forEach((ptr) => {
    bySentence[ptr[0]] = bySentence[ptr[0]] || [];
    bySentence[ptr[0]].push(ptr);
  });
  Object.keys(bySentence).forEach((k3) => {
    let full = doc.update([[Number(k3)]]);
    let txt = full.text();
    let matches3 = doc.update(bySentence[k3]);
    let json = matches3.json({ offset: true });
    json.forEach((obj, i5) => {
      txt = spliceIn(txt, obj.offset, i5);
    });
    console.log(txt);
  });
  console.log("\n");
};
var highlight_default = showHighlight;

// node_modules/compromise/src/1-one/output/methods/debug/index.js
var debug2 = {
  tags: tags_default,
  clientSide: client_side_default,
  chunks: chunks_default,
  highlight: highlight_default
};
var debug_default2 = debug2;

// node_modules/compromise/src/1-one/output/plugin.js
var plugin_default8 = {
  api: api_default5,
  methods: {
    one: {
      hash: hash_default,
      debug: debug_default2
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/_lib.js
var doesOverlap = function(a4, b2) {
  if (a4[0] !== b2[0]) {
    return false;
  }
  let [, startA, endA] = a4;
  let [, startB, endB] = b2;
  if (startA <= startB && endA > startB) {
    return true;
  }
  if (startB <= startA && endB > startA) {
    return true;
  }
  return false;
};
var getExtent = function(ptrs) {
  let min2 = ptrs[0][1];
  let max4 = ptrs[0][2];
  ptrs.forEach((ptr) => {
    if (ptr[1] < min2) {
      min2 = ptr[1];
    }
    if (ptr[2] > max4) {
      max4 = ptr[2];
    }
  });
  return [ptrs[0][0], min2, max4];
};
var indexN = function(ptrs) {
  let byN = {};
  ptrs.forEach((ref) => {
    byN[ref[0]] = byN[ref[0]] || [];
    byN[ref[0]].push(ref);
  });
  return byN;
};
var uniquePtrs = function(arr) {
  let obj = {};
  for (let i5 = 0; i5 < arr.length; i5 += 1) {
    obj[arr[i5].join(",")] = arr[i5];
  }
  return Object.values(obj);
};

// node_modules/compromise/src/1-one/pointers/api/lib/split.js
var pivotBy = function(full, m6) {
  let [n5, start2] = full;
  let mStart = m6[1];
  let mEnd = m6[2];
  let res = {};
  if (start2 < mStart) {
    let end2 = mStart < full[2] ? mStart : full[2];
    res.before = [n5, start2, end2];
  }
  res.match = m6;
  if (full[2] > mEnd) {
    res.after = [n5, mEnd, full[2]];
  }
  return res;
};
var doesMatch2 = function(full, m6) {
  return full[1] <= m6[1] && m6[2] <= full[2];
};
var splitAll = function(full, m6) {
  let byN = indexN(m6);
  let res = [];
  full.forEach((ptr) => {
    let [n5] = ptr;
    let matches3 = byN[n5] || [];
    matches3 = matches3.filter((p7) => doesMatch2(ptr, p7));
    if (matches3.length === 0) {
      res.push({ passthrough: ptr });
      return;
    }
    matches3 = matches3.sort((a4, b2) => a4[1] - b2[1]);
    let carry = ptr;
    matches3.forEach((p7, i5) => {
      let found = pivotBy(carry, p7);
      if (!matches3[i5 + 1]) {
        res.push(found);
      } else {
        res.push({ before: found.before, match: found.match });
        if (found.after) {
          carry = found.after;
        }
      }
    });
  });
  return res;
};
var split_default2 = splitAll;

// node_modules/compromise/src/1-one/pointers/methods/getDoc.js
var max = 20;
var blindSweep = function(id, doc, n5) {
  for (let i5 = 0; i5 < max; i5 += 1) {
    if (doc[n5 - i5]) {
      let index4 = doc[n5 - i5].findIndex((term) => term.id === id);
      if (index4 !== -1) {
        return [n5 - i5, index4];
      }
    }
    if (doc[n5 + i5]) {
      let index4 = doc[n5 + i5].findIndex((term) => term.id === id);
      if (index4 !== -1) {
        return [n5 + i5, index4];
      }
    }
  }
  return null;
};
var repairEnding = function(ptr, document2) {
  let [n5, start2, , , endId] = ptr;
  let terms = document2[n5];
  let newEnd = terms.findIndex((t5) => t5.id === endId);
  if (newEnd === -1) {
    ptr[2] = document2[n5].length;
    ptr[4] = terms.length ? terms[terms.length - 1].id : null;
  } else {
    ptr[2] = newEnd;
  }
  return document2[n5].slice(start2, ptr[2] + 1);
};
var getDoc2 = function(ptrs, document2) {
  let doc = [];
  ptrs.forEach((ptr, i5) => {
    if (!ptr) {
      return;
    }
    let [n5, start2, end2, id, endId] = ptr;
    let terms = document2[n5] || [];
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = terms.length;
    }
    if (id && (!terms[start2] || terms[start2].id !== id)) {
      let wild = blindSweep(id, document2, n5);
      if (wild !== null) {
        let len = end2 - start2;
        terms = document2[wild[0]].slice(wild[1], wild[1] + len);
        let startId = terms[0] ? terms[0].id : null;
        ptrs[i5] = [wild[0], wild[1], wild[1] + len, startId];
      }
    } else {
      terms = terms.slice(start2, end2);
    }
    if (terms.length === 0) {
      return;
    }
    if (start2 === end2) {
      return;
    }
    if (endId && terms[terms.length - 1].id !== endId) {
      terms = repairEnding(ptr, document2);
    }
    doc.push(terms);
  });
  doc = doc.filter((a4) => a4.length > 0);
  return doc;
};
var getDoc_default = getDoc2;

// node_modules/compromise/src/1-one/pointers/methods/index.js
var termList = function(docs) {
  let arr = [];
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      arr.push(docs[i5][t5]);
    }
  }
  return arr;
};
var methods_default5 = {
  one: {
    termList,
    getDoc: getDoc_default,
    pointer: {
      indexN,
      splitAll: split_default2
    }
  }
};

// node_modules/compromise/src/1-one/pointers/api/lib/union.js
var getUnion = function(a4, b2) {
  let both = a4.concat(b2);
  let byN = indexN(both);
  let res = [];
  both.forEach((ptr) => {
    let [n5] = ptr;
    if (byN[n5].length === 1) {
      res.push(ptr);
      return;
    }
    let hmm = byN[n5].filter((m6) => doesOverlap(ptr, m6));
    hmm.push(ptr);
    let range = getExtent(hmm);
    res.push(range);
  });
  res = uniquePtrs(res);
  return res;
};
var union_default = getUnion;

// node_modules/compromise/src/1-one/pointers/api/lib/difference.js
var subtract = function(refs, not) {
  let res = [];
  let found = split_default2(refs, not);
  found.forEach((o4) => {
    if (o4.passthrough) {
      res.push(o4.passthrough);
    }
    if (o4.before) {
      res.push(o4.before);
    }
    if (o4.after) {
      res.push(o4.after);
    }
  });
  return res;
};
var difference_default = subtract;

// node_modules/compromise/src/1-one/pointers/api/lib/intersection.js
var intersection = function(a4, b2) {
  let start2 = a4[1] < b2[1] ? b2[1] : a4[1];
  let end2 = a4[2] > b2[2] ? b2[2] : a4[2];
  if (start2 < end2) {
    return [a4[0], start2, end2];
  }
  return null;
};
var getIntersection = function(a4, b2) {
  let byN = indexN(b2);
  let res = [];
  a4.forEach((ptr) => {
    let hmm = byN[ptr[0]] || [];
    hmm = hmm.filter((p7) => doesOverlap(ptr, p7));
    if (hmm.length === 0) {
      return;
    }
    hmm.forEach((h4) => {
      let overlap = intersection(ptr, h4);
      if (overlap) {
        res.push(overlap);
      }
    });
  });
  return res;
};
var intersection_default = getIntersection;

// node_modules/compromise/src/1-one/pointers/api/index.js
var isArray7 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var getDoc3 = (m6, view) => {
  if (typeof m6 === "string" || isArray7(m6)) {
    return view.match(m6);
  }
  if (!m6) {
    return view.none();
  }
  return m6;
};
var addIds3 = function(ptrs, docs) {
  return ptrs.map((ptr) => {
    let [n5, start2] = ptr;
    if (docs[n5] && docs[n5][start2]) {
      ptr[3] = docs[n5][start2].id;
    }
    return ptr;
  });
};
var methods15 = {};
methods15.union = function(m6) {
  m6 = getDoc3(m6, this);
  let ptrs = union_default(this.fullPointer, m6.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.and = methods15.union;
methods15.intersection = function(m6) {
  m6 = getDoc3(m6, this);
  let ptrs = intersection_default(this.fullPointer, m6.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.not = function(m6) {
  m6 = getDoc3(m6, this);
  let ptrs = difference_default(this.fullPointer, m6.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.difference = methods15.not;
methods15.complement = function() {
  let doc = this.all();
  let ptrs = difference_default(doc.fullPointer, this.fullPointer);
  ptrs = addIds3(ptrs, this.document);
  return this.toView(ptrs);
};
methods15.settle = function() {
  let ptrs = this.fullPointer;
  ptrs.forEach((ptr) => {
    ptrs = union_default(ptrs, [ptr]);
  });
  ptrs = addIds3(ptrs, this.document);
  return this.update(ptrs);
};
var addAPI4 = function(View2) {
  Object.assign(View2.prototype, methods15);
};
var api_default6 = addAPI4;

// node_modules/compromise/src/1-one/pointers/plugin.js
var plugin_default9 = {
  methods: methods_default5,
  api: api_default6
};

// node_modules/compromise/src/1-one/sweep/lib.js
var lib_default3 = {
  // compile a list of matches into a match-net
  buildNet: function(matches3) {
    const methods17 = this.methods();
    let net3 = methods17.one.buildNet(matches3, this.world());
    net3.isNet = true;
    return net3;
  }
};

// node_modules/compromise/src/1-one/sweep/api.js
var api = function(View2) {
  View2.prototype.sweep = function(net3, opts2 = {}) {
    const { world: world2, docs } = this;
    const { methods: methods17 } = world2;
    let found = methods17.one.bulkMatch(docs, net3, this.methods, opts2);
    if (opts2.tagger !== false) {
      methods17.one.bulkTagger(found, docs, this.world);
    }
    found = found.map((o4) => {
      let ptr = o4.pointer;
      let term = docs[ptr[0]][ptr[1]];
      let len = ptr[2] - ptr[1];
      if (term.index) {
        o4.pointer = [
          term.index[0],
          term.index[1],
          ptr[1] + len
        ];
      }
      return o4;
    });
    let ptrs = found.map((o4) => o4.pointer);
    found = found.map((obj) => {
      obj.view = this.update([obj.pointer]);
      delete obj.regs;
      delete obj.needs;
      delete obj.pointer;
      delete obj._expanded;
      return obj;
    });
    return {
      view: this.update(ptrs),
      found
    };
  };
};
var api_default7 = api;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/01-parse.js
var getTokenNeeds = function(reg) {
  if (reg.optional === true || reg.negative === true) {
    return null;
  }
  if (reg.tag) {
    return "#" + reg.tag;
  }
  if (reg.word) {
    return reg.word;
  }
  if (reg.switch) {
    return `%${reg.switch}%`;
  }
  return null;
};
var getNeeds = function(regs) {
  let needs = [];
  regs.forEach((reg) => {
    needs.push(getTokenNeeds(reg));
    if (reg.operator === "and" && reg.choices) {
      reg.choices.forEach((oneSide) => {
        oneSide.forEach((r3) => {
          needs.push(getTokenNeeds(r3));
        });
      });
    }
  });
  return needs.filter((str) => str);
};
var getWants = function(regs) {
  let wants = [];
  let count = 0;
  regs.forEach((reg) => {
    if (reg.operator === "or" && !reg.optional && !reg.negative) {
      if (reg.fastOr) {
        Array.from(reg.fastOr).forEach((w2) => {
          wants.push(w2);
        });
      }
      if (reg.choices) {
        reg.choices.forEach((rs) => {
          rs.forEach((r3) => {
            let n5 = getTokenNeeds(r3);
            if (n5) {
              wants.push(n5);
            }
          });
        });
      }
      count += 1;
    }
  });
  return { wants, count };
};
var parse = function(matches3, world2) {
  const parseMatch = world2.methods.one.parseMatch;
  matches3.forEach((obj) => {
    obj.regs = parseMatch(obj.match, {}, world2);
    if (typeof obj.ifNo === "string") {
      obj.ifNo = [obj.ifNo];
    }
    if (obj.notIf) {
      obj.notIf = parseMatch(obj.notIf, {}, world2);
    }
    obj.needs = getNeeds(obj.regs);
    let { wants, count } = getWants(obj.regs);
    obj.wants = wants;
    obj.minWant = count;
    obj.minWords = obj.regs.filter((o4) => !o4.optional).length;
  });
  return matches3;
};
var parse_default = parse;

// node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js
var buildNet = function(matches3, world2) {
  matches3 = parse_default(matches3, world2);
  let hooks2 = {};
  matches3.forEach((obj) => {
    obj.needs.forEach((str) => {
      hooks2[str] = Array.isArray(hooks2[str]) ? hooks2[str] : [];
      hooks2[str].push(obj);
    });
    obj.wants.forEach((str) => {
      hooks2[str] = Array.isArray(hooks2[str]) ? hooks2[str] : [];
      hooks2[str].push(obj);
    });
  });
  Object.keys(hooks2).forEach((k3) => {
    let already = {};
    hooks2[k3] = hooks2[k3].filter((obj) => {
      if (typeof already[obj.match] === "boolean") {
        return false;
      }
      already[obj.match] = true;
      return true;
    });
  });
  let always = matches3.filter((o4) => o4.needs.length === 0 && o4.wants.length === 0);
  return {
    hooks: hooks2,
    always
  };
};
var buildNet_default = buildNet;

// node_modules/compromise/src/1-one/sweep/methods/sweep/01-getHooks.js
var getHooks = function(docCaches, hooks2) {
  return docCaches.map((set, i5) => {
    let maybe = [];
    Object.keys(hooks2).forEach((k3) => {
      if (docCaches[i5].has(k3)) {
        maybe = maybe.concat(hooks2[k3]);
      }
    });
    let already = {};
    maybe = maybe.filter((m6) => {
      if (typeof already[m6.match] === "boolean") {
        return false;
      }
      already[m6.match] = true;
      return true;
    });
    return maybe;
  });
};
var getHooks_default = getHooks;

// node_modules/compromise/src/1-one/sweep/methods/sweep/02-trim-down.js
var localTrim = function(maybeList, docCache) {
  return maybeList.map((list5, n5) => {
    let haves = docCache[n5];
    list5 = list5.filter((obj) => {
      return obj.needs.every((need) => haves.has(need));
    });
    list5 = list5.filter((obj) => {
      if (obj.ifNo !== void 0 && obj.ifNo.some((no) => haves.has(no)) === true) {
        return false;
      }
      return true;
    });
    list5 = list5.filter((obj) => {
      if (obj.wants.length === 0) {
        return true;
      }
      let found = obj.wants.filter((str) => haves.has(str)).length;
      return found >= obj.minWant;
    });
    return list5;
  });
};
var trim_down_default = localTrim;

// node_modules/compromise/src/1-one/sweep/methods/sweep/04-runMatch.js
var runMatch2 = function(maybeList, document2, docCache, methods17, opts2) {
  let results = [];
  for (let n5 = 0; n5 < maybeList.length; n5 += 1) {
    for (let i5 = 0; i5 < maybeList[n5].length; i5 += 1) {
      let m6 = maybeList[n5][i5];
      let res = methods17.one.match([document2[n5]], m6);
      if (res.ptrs.length > 0) {
        res.ptrs.forEach((ptr) => {
          ptr[0] = n5;
          let todo = Object.assign({}, m6, { pointer: ptr });
          if (m6.unTag !== void 0) {
            todo.unTag = m6.unTag;
          }
          results.push(todo);
        });
        if (opts2.matchOne === true) {
          return [results[0]];
        }
      }
    }
  }
  return results;
};
var runMatch_default = runMatch2;

// node_modules/compromise/src/1-one/sweep/methods/sweep/index.js
var tooSmall = function(maybeList, document2) {
  return maybeList.map((arr, i5) => {
    let termCount = document2[i5].length;
    arr = arr.filter((o4) => {
      return termCount >= o4.minWords;
    });
    return arr;
  });
};
var sweep = function(document2, net3, methods17, opts2 = {}) {
  let docCache = methods17.one.cacheDoc(document2);
  let maybeList = getHooks_default(docCache, net3.hooks);
  maybeList = trim_down_default(maybeList, docCache, document2);
  if (net3.always.length > 0) {
    maybeList = maybeList.map((arr) => arr.concat(net3.always));
  }
  maybeList = tooSmall(maybeList, document2);
  let results = runMatch_default(maybeList, document2, docCache, methods17, opts2);
  return results;
};
var sweep_default = sweep;

// node_modules/compromise/src/1-one/sweep/methods/tagger/canBe.js
var canBe = function(terms, tag2, model5) {
  let tagSet = model5.one.tagSet;
  if (!tagSet.hasOwnProperty(tag2)) {
    return true;
  }
  let not = tagSet[tag2].not || [];
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    let term = terms[i5];
    for (let k3 = 0; k3 < not.length; k3 += 1) {
      if (term.tags.has(not[k3]) === true) {
        return false;
      }
    }
  }
  return true;
};
var canBe_default = canBe;

// node_modules/compromise/src/1-one/sweep/methods/tagger/index.js
var tagger = function(list5, document2, world2) {
  const { model: model5, methods: methods17 } = world2;
  const { getDoc: getDoc4, setTag: setTag2, unTag: unTag2 } = methods17.one;
  const looksPlural2 = methods17.two.looksPlural;
  if (list5.length === 0) {
    return list5;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_TAGS) {
    console.log(`

  \x1B[32m\u2192 ${list5.length} post-tagger:\x1B[0m`);
  }
  return list5.map((todo) => {
    if (!todo.tag && !todo.chunk && !todo.unTag) {
      return;
    }
    let reason = todo.reason || todo.match;
    let terms = getDoc4([todo.pointer], document2)[0];
    if (todo.safe === true) {
      if (canBe_default(terms, todo.tag, model5) === false) {
        return;
      }
      if (terms[terms.length - 1].post === "-") {
        return;
      }
    }
    if (todo.tag !== void 0) {
      setTag2(terms, todo.tag, world2, todo.safe, `[post] '${reason}'`);
      if (todo.tag === "Noun" && looksPlural2) {
        let term = terms[terms.length - 1];
        if (looksPlural2(term.text)) {
          setTag2([term], "Plural", world2, todo.safe, "quick-plural");
        } else {
          setTag2([term], "Singular", world2, todo.safe, "quick-singular");
        }
      }
      if (todo.freeze === true) {
        terms.forEach((term) => term.frozen = true);
      }
    }
    if (todo.unTag !== void 0) {
      unTag2(terms, todo.unTag, world2, todo.safe, reason);
    }
    if (todo.chunk) {
      terms.forEach((t5) => t5.chunk = todo.chunk);
    }
  });
};
var tagger_default = tagger;

// node_modules/compromise/src/1-one/sweep/methods/index.js
var methods_default6 = {
  buildNet: buildNet_default,
  bulkMatch: sweep_default,
  bulkTagger: tagger_default
};

// node_modules/compromise/src/1-one/sweep/plugin.js
var plugin_default10 = {
  lib: lib_default3,
  api: api_default7,
  methods: {
    one: methods_default6
  }
};

// node_modules/compromise/src/1-one/tag/methods/setTag.js
var isMulti = / /;
var addChunk = function(term, tag2) {
  if (tag2 === "Noun") {
    term.chunk = tag2;
  }
  if (tag2 === "Verb") {
    term.chunk = tag2;
  }
};
var tagTerm = function(term, tag2, tagSet, isSafe) {
  if (term.tags.has(tag2) === true) {
    return null;
  }
  if (tag2 === ".") {
    return null;
  }
  if (term.frozen === true) {
    isSafe = true;
  }
  let known = tagSet[tag2];
  if (known) {
    if (known.not && known.not.length > 0) {
      for (let o4 = 0; o4 < known.not.length; o4 += 1) {
        if (isSafe === true && term.tags.has(known.not[o4])) {
          return null;
        }
        term.tags.delete(known.not[o4]);
      }
    }
    if (known.parents && known.parents.length > 0) {
      for (let o4 = 0; o4 < known.parents.length; o4 += 1) {
        term.tags.add(known.parents[o4]);
        addChunk(term, known.parents[o4]);
      }
    }
  }
  term.tags.add(tag2);
  term.dirty = true;
  addChunk(term, tag2);
  return true;
};
var multiTag = function(terms, tagString2, tagSet, isSafe) {
  let tags = tagString2.split(isMulti);
  terms.forEach((term, i5) => {
    let tag2 = tags[i5];
    if (tag2) {
      tag2 = tag2.replace(/^#/, "");
      tagTerm(term, tag2, tagSet, isSafe);
    }
  });
};
var isArray8 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var log = (terms, tag2, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i5 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = terms.map((t5) => {
    return t5.text || "[" + t5.implicit + "]";
  }).join(" ");
  if (typeof tag2 !== "string" && tag2.length > 2) {
    tag2 = tag2.slice(0, 2).join(", #") + " +";
  }
  tag2 = typeof tag2 !== "string" ? tag2.join(", #") : tag2;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag2.padEnd(22)}  ${i5(reason)}`);
};
var setTag = function(terms, tag2, world2 = {}, isSafe, reason) {
  const tagSet = world2.model.one.tagSet || {};
  if (!tag2) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log(terms, tag2, reason);
  }
  if (isArray8(tag2) === true) {
    tag2.forEach((tg) => setTag(terms, tg, world2, isSafe));
    return;
  }
  if (typeof tag2 !== "string") {
    console.warn(`compromise: Invalid tag '${tag2}'`);
    return;
  }
  tag2 = tag2.trim();
  if (isMulti.test(tag2)) {
    multiTag(terms, tag2, tagSet, isSafe);
    return;
  }
  tag2 = tag2.replace(/^#/, "");
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    tagTerm(terms[i5], tag2, tagSet, isSafe);
  }
};
var setTag_default = setTag;

// node_modules/compromise/src/1-one/tag/methods/unTag.js
var unTag = function(terms, tag2, tagSet) {
  tag2 = tag2.trim().replace(/^#/, "");
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    let term = terms[i5];
    if (term.frozen === true) {
      continue;
    }
    if (tag2 === "*") {
      term.tags.clear();
      continue;
    }
    let known = tagSet[tag2];
    if (known && known.children.length > 0) {
      for (let o4 = 0; o4 < known.children.length; o4 += 1) {
        term.tags.delete(known.children[o4]);
      }
    }
    term.tags.delete(tag2);
  }
};
var unTag_default = unTag;

// node_modules/compromise/src/1-one/tag/methods/canBe.js
var canBe2 = function(term, tag2, tagSet) {
  if (!tagSet.hasOwnProperty(tag2)) {
    return true;
  }
  let not = tagSet[tag2].not || [];
  for (let i5 = 0; i5 < not.length; i5 += 1) {
    if (term.tags.has(not[i5])) {
      return false;
    }
  }
  return true;
};
var canBe_default2 = canBe2;

// node_modules/grad-school/builds/grad-school.mjs
var e = function(e3) {
  return e3.children = e3.children || [], e3._cache = e3._cache || {}, e3.props = e3.props || {}, e3._cache.parents = e3._cache.parents || [], e3._cache.children = e3._cache.children || [], e3;
};
var t2 = /^ *(#|\/\/)/;
var n = function(t5) {
  let n5 = t5.trim().split(/->/), r3 = [];
  n5.forEach((t6) => {
    r3 = r3.concat(function(t7) {
      if (!(t7 = t7.trim()))
        return null;
      if (/^\[/.test(t7) && /\]$/.test(t7)) {
        let n6 = (t7 = (t7 = t7.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
        return n6 = n6.map((e3) => e3.trim()).filter((e3) => e3), n6 = n6.map((t8) => e({ id: t8 })), n6;
      }
      return [e({ id: t7 })];
    }(t6));
  }), r3 = r3.filter((e3) => e3);
  let i5 = r3[0];
  for (let e3 = 1; e3 < r3.length; e3 += 1)
    i5.children.push(r3[e3]), i5 = r3[e3];
  return r3[0];
};
var r = (e3, t5) => {
  let n5 = [], r3 = [e3];
  for (; r3.length > 0; ) {
    let e4 = r3.pop();
    n5.push(e4), e4.children && e4.children.forEach((n6) => {
      t5 && t5(e4, n6), r3.push(n6);
    });
  }
  return n5;
};
var i2 = (e3) => "[object Array]" === Object.prototype.toString.call(e3);
var c = (e3) => (e3 = e3 || "").trim();
var s = function(c5 = []) {
  return "string" == typeof c5 ? function(r3) {
    let i5 = r3.split(/\r?\n/), c6 = [];
    i5.forEach((e3) => {
      if (!e3.trim() || t2.test(e3))
        return;
      let r4 = ((e4) => {
        const t5 = /^( {2}|\t)/;
        let n5 = 0;
        for (; t5.test(e4); )
          e4 = e4.replace(t5, ""), n5 += 1;
        return n5;
      })(e3);
      c6.push({ indent: r4, node: n(e3) });
    });
    let s6 = function(e3) {
      let t5 = { children: [] };
      return e3.forEach((n5, r4) => {
        0 === n5.indent ? t5.children = t5.children.concat(n5.node) : e3[r4 - 1] && function(e4, t6) {
          let n6 = e4[t6].indent;
          for (; t6 >= 0; t6 -= 1)
            if (e4[t6].indent < n6)
              return e4[t6];
          return e4[0];
        }(e3, r4).node.children.push(n5.node);
      }), t5;
    }(c6);
    return s6 = e(s6), s6;
  }(c5) : i2(c5) ? function(t5) {
    let n5 = {};
    t5.forEach((e3) => {
      n5[e3.id] = e3;
    });
    let r3 = e({});
    return t5.forEach((t6) => {
      if ((t6 = e(t6)).parent)
        if (n5.hasOwnProperty(t6.parent)) {
          let e3 = n5[t6.parent];
          delete t6.parent, e3.children.push(t6);
        } else
          console.warn(`[Grad] - missing node '${t6.parent}'`);
      else
        r3.children.push(t6);
    }), r3;
  }(c5) : (r(s5 = c5).forEach(e), s5);
  var s5;
};
var h = (e3) => "\x1B[31m" + e3 + "\x1B[0m";
var o = (e3) => "\x1B[2m" + e3 + "\x1B[0m";
var l = function(e3, t5) {
  let n5 = "-> ";
  t5 && (n5 = o("\u2192 "));
  let i5 = "";
  return r(e3).forEach((e4, r3) => {
    let c5 = e4.id || "";
    if (t5 && (c5 = h(c5)), 0 === r3 && !e4.id)
      return;
    let s5 = e4._cache.parents.length;
    i5 += "    ".repeat(s5) + n5 + c5 + "\n";
  }), i5;
};
var a = function(e3) {
  let t5 = r(e3);
  t5.forEach((e4) => {
    delete (e4 = Object.assign({}, e4)).children;
  });
  let n5 = t5[0];
  return n5 && !n5.id && 0 === Object.keys(n5.props).length && t5.shift(), t5;
};
var p = { text: l, txt: l, array: a, flat: a };
var d = function(e3, t5) {
  return "nested" === t5 || "json" === t5 ? e3 : "debug" === t5 ? (console.log(l(e3, true)), null) : p.hasOwnProperty(t5) ? p[t5](e3) : e3;
};
var u = (e3) => {
  r(e3, (e4, t5) => {
    e4.id && (e4._cache.parents = e4._cache.parents || [], t5._cache.parents = e4._cache.parents.concat([e4.id]));
  });
};
var f = (e3, t5) => (Object.keys(t5).forEach((n5) => {
  if (t5[n5] instanceof Set) {
    let r3 = e3[n5] || /* @__PURE__ */ new Set();
    e3[n5] = /* @__PURE__ */ new Set([...r3, ...t5[n5]]);
  } else {
    if (((e4) => e4 && "object" == typeof e4 && !Array.isArray(e4))(t5[n5])) {
      let r3 = e3[n5] || {};
      e3[n5] = Object.assign({}, t5[n5], r3);
    } else
      i2(t5[n5]) ? e3[n5] = t5[n5].concat(e3[n5] || []) : void 0 === e3[n5] && (e3[n5] = t5[n5]);
  }
}), e3);
var j = /\//;
var g = class {
  constructor(e3 = {}) {
    Object.defineProperty(this, "json", { enumerable: false, value: e3, writable: true });
  }
  get children() {
    return this.json.children;
  }
  get id() {
    return this.json.id;
  }
  get found() {
    return this.json.id || this.json.children.length > 0;
  }
  props(e3 = {}) {
    let t5 = this.json.props || {};
    return "string" == typeof e3 && (t5[e3] = true), this.json.props = Object.assign(t5, e3), this;
  }
  get(t5) {
    if (t5 = c(t5), !j.test(t5)) {
      let e3 = this.json.children.find((e4) => e4.id === t5);
      return new g(e3);
    }
    let n5 = ((e3, t6) => {
      let n6 = ((e4) => "string" != typeof e4 ? e4 : (e4 = e4.replace(/^\//, "")).split(/\//))(t6 = t6 || "");
      for (let t7 = 0; t7 < n6.length; t7 += 1) {
        let r3 = e3.children.find((e4) => e4.id === n6[t7]);
        if (!r3)
          return null;
        e3 = r3;
      }
      return e3;
    })(this.json, t5) || e({});
    return new g(n5);
  }
  add(t5, n5 = {}) {
    if (i2(t5))
      return t5.forEach((e3) => this.add(c(e3), n5)), this;
    t5 = c(t5);
    let r3 = e({ id: t5, props: n5 });
    return this.json.children.push(r3), new g(r3);
  }
  remove(e3) {
    return e3 = c(e3), this.json.children = this.json.children.filter((t5) => t5.id !== e3), this;
  }
  nodes() {
    return r(this.json).map((e3) => (delete (e3 = Object.assign({}, e3)).children, e3));
  }
  cache() {
    return ((e3) => {
      let t5 = r(e3, (e4, t6) => {
        e4.id && (e4._cache.parents = e4._cache.parents || [], e4._cache.children = e4._cache.children || [], t6._cache.parents = e4._cache.parents.concat([e4.id]));
      }), n5 = {};
      t5.forEach((e4) => {
        e4.id && (n5[e4.id] = e4);
      }), t5.forEach((e4) => {
        e4._cache.parents.forEach((t6) => {
          n5.hasOwnProperty(t6) && n5[t6]._cache.children.push(e4.id);
        });
      }), e3._cache.children = Object.keys(n5);
    })(this.json), this;
  }
  list() {
    return r(this.json);
  }
  fillDown() {
    var e3;
    return e3 = this.json, r(e3, (e4, t5) => {
      t5.props = f(t5.props, e4.props);
    }), this;
  }
  depth() {
    u(this.json);
    let e3 = r(this.json), t5 = e3.length > 1 ? 1 : 0;
    return e3.forEach((e4) => {
      if (0 === e4._cache.parents.length)
        return;
      let n5 = e4._cache.parents.length + 1;
      n5 > t5 && (t5 = n5);
    }), t5;
  }
  out(e3) {
    return u(this.json), d(this.json, e3);
  }
  debug() {
    return u(this.json), d(this.json, "debug"), this;
  }
};
var _ = function(e3) {
  let t5 = s(e3);
  return new g(t5);
};
_.prototype.plugin = function(e3) {
  e3(this);
};

// node_modules/compromise/src/1-one/tag/methods/addTags/_colors.js
var colors = {
  Noun: "blue",
  Verb: "green",
  Negative: "green",
  Date: "red",
  Value: "red",
  Adjective: "magenta",
  Preposition: "cyan",
  Conjunction: "cyan",
  Determiner: "cyan",
  Hyphenated: "cyan",
  Adverb: "cyan"
};
var colors_default = colors;

// node_modules/compromise/src/1-one/tag/methods/addTags/02-fmt.js
var getColor = function(node2) {
  if (colors_default.hasOwnProperty(node2.id)) {
    return colors_default[node2.id];
  }
  if (colors_default.hasOwnProperty(node2.is)) {
    return colors_default[node2.is];
  }
  let found = node2._cache.parents.find((c5) => colors_default[c5]);
  return colors_default[found];
};
var fmt = function(nodes) {
  const res = {};
  nodes.forEach((node2) => {
    let { not, also, is, novel } = node2.props;
    let parents = node2._cache.parents;
    if (also) {
      parents = parents.concat(also);
    }
    res[node2.id] = {
      is,
      not,
      novel,
      also,
      parents,
      children: node2._cache.children,
      color: getColor(node2)
    };
  });
  Object.keys(res).forEach((k3) => {
    let nots = new Set(res[k3].not);
    res[k3].not.forEach((not) => {
      if (res[not]) {
        res[not].children.forEach((tag2) => nots.add(tag2));
      }
    });
    res[k3].not = Array.from(nots);
  });
  return res;
};
var fmt_default = fmt;

// node_modules/compromise/src/1-one/tag/methods/addTags/01-validate.js
var toArr = function(input) {
  if (!input) {
    return [];
  }
  if (typeof input === "string") {
    return [input];
  }
  return input;
};
var addImplied = function(tags, already) {
  Object.keys(tags).forEach((k3) => {
    if (tags[k3].isA) {
      tags[k3].is = tags[k3].isA;
    }
    if (tags[k3].notA) {
      tags[k3].not = tags[k3].notA;
    }
    if (tags[k3].is && typeof tags[k3].is === "string") {
      if (!already.hasOwnProperty(tags[k3].is) && !tags.hasOwnProperty(tags[k3].is)) {
        tags[tags[k3].is] = {};
      }
    }
    if (tags[k3].not && typeof tags[k3].not === "string" && !tags.hasOwnProperty(tags[k3].not)) {
      if (!already.hasOwnProperty(tags[k3].not) && !tags.hasOwnProperty(tags[k3].not)) {
        tags[tags[k3].not] = {};
      }
    }
  });
  return tags;
};
var validate = function(tags, already) {
  tags = addImplied(tags, already);
  Object.keys(tags).forEach((k3) => {
    tags[k3].children = toArr(tags[k3].children);
    tags[k3].not = toArr(tags[k3].not);
  });
  Object.keys(tags).forEach((k3) => {
    let nots = tags[k3].not || [];
    nots.forEach((no) => {
      if (tags[no] && tags[no].not) {
        tags[no].not.push(k3);
      }
    });
  });
  return tags;
};
var validate_default = validate;

// node_modules/compromise/src/1-one/tag/methods/addTags/index.js
var compute3 = function(allTags2) {
  const flatList = Object.keys(allTags2).map((k3) => {
    let o4 = allTags2[k3];
    const props = { not: new Set(o4.not), also: o4.also, is: o4.is, novel: o4.novel };
    return { id: k3, parent: o4.is, props, children: [] };
  });
  const graph = _(flatList).cache().fillDown();
  return graph.out("array");
};
var fromUser = function(tags) {
  Object.keys(tags).forEach((k3) => {
    tags[k3] = Object.assign({}, tags[k3]);
    tags[k3].novel = true;
  });
  return tags;
};
var addTags = function(tags, already) {
  if (Object.keys(already).length > 0) {
    tags = fromUser(tags);
  }
  tags = validate_default(tags, already);
  let allTags2 = Object.assign({}, already, tags);
  const nodes = compute3(allTags2);
  const res = fmt_default(nodes);
  return res;
};
var addTags_default = addTags;

// node_modules/compromise/src/1-one/tag/methods/index.js
var methods_default7 = {
  one: {
    setTag: setTag_default,
    unTag: unTag_default,
    addTags: addTags_default,
    canBe: canBe_default2
  }
};

// node_modules/compromise/src/1-one/tag/api/tag.js
var isArray9 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var fns5 = {
  /** add a given tag, to all these terms */
  tag: function(input, reason = "", isSafe) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods17, verbose: verbose2, world: world2 } = this;
    if (verbose2 === true) {
      console.log(" +  ", input, reason || "");
    }
    if (isArray9(input)) {
      input.forEach((tag2) => methods17.one.setTag(terms, tag2, world2, isSafe, reason));
    } else {
      methods17.one.setTag(terms, input, world2, isSafe, reason);
    }
    this.uncache();
    return this;
  },
  /** add a given tag, only if it is consistent */
  tagSafe: function(input, reason = "") {
    return this.tag(input, reason, true);
  },
  /** remove a given tag from all these terms */
  unTag: function(input, reason) {
    if (!this.found || !input) {
      return this;
    }
    let terms = this.termList();
    if (terms.length === 0) {
      return this;
    }
    const { methods: methods17, verbose: verbose2, model: model5 } = this;
    if (verbose2 === true) {
      console.log(" -  ", input, reason || "");
    }
    let tagSet = model5.one.tagSet;
    if (isArray9(input)) {
      input.forEach((tag2) => methods17.one.unTag(terms, tag2, tagSet));
    } else {
      methods17.one.unTag(terms, input, tagSet);
    }
    this.uncache();
    return this;
  },
  /** return only the terms that can be this tag  */
  canBe: function(tag2) {
    tag2 = tag2.replace(/^#/, "");
    let tagSet = this.model.one.tagSet;
    let canBe3 = this.methods.one.canBe;
    let nope2 = [];
    this.document.forEach((terms, n5) => {
      terms.forEach((term, i5) => {
        if (!canBe3(term, tag2, tagSet)) {
          nope2.push([n5, i5, i5 + 1]);
        }
      });
    });
    let noDoc = this.update(nope2);
    return this.difference(noDoc);
  }
};
var tag_default = fns5;

// node_modules/compromise/src/1-one/tag/api/index.js
var tagAPI = function(View2) {
  Object.assign(View2.prototype, tag_default);
};
var api_default8 = tagAPI;

// node_modules/compromise/src/1-one/tag/lib.js
var addTags2 = function(tags) {
  const { model: model5, methods: methods17 } = this.world();
  const tagSet = model5.one.tagSet;
  const fn = methods17.one.addTags;
  let res = fn(tags, tagSet);
  model5.one.tagSet = res;
  return this;
};
var lib_default4 = { addTags: addTags2 };

// node_modules/compromise/src/1-one/tag/compute/tagRank.js
var boringTags = /* @__PURE__ */ new Set(["Auxiliary", "Possessive"]);
var sortByKids = function(tags, tagSet) {
  tags = tags.sort((a4, b2) => {
    if (boringTags.has(a4) || !tagSet.hasOwnProperty(b2)) {
      return 1;
    }
    if (boringTags.has(b2) || !tagSet.hasOwnProperty(a4)) {
      return -1;
    }
    let kids = tagSet[a4].children || [];
    let aKids = kids.length;
    kids = tagSet[b2].children || [];
    let bKids = kids.length;
    return aKids - bKids;
  });
  return tags;
};
var tagRank = function(view) {
  const { document: document2, world: world2 } = view;
  const tagSet = world2.model.one.tagSet;
  document2.forEach((terms) => {
    terms.forEach((term) => {
      let tags = Array.from(term.tags);
      term.tagRank = sortByKids(tags, tagSet);
    });
  });
};
var tagRank_default = tagRank;

// node_modules/compromise/src/1-one/tag/plugin.js
var plugin_default11 = {
  model: {
    one: { tagSet: {} }
  },
  compute: {
    tagRank: tagRank_default
  },
  methods: methods_default7,
  api: api_default8,
  lib: lib_default4
};

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/01-simple-split.js
var initSplit = /([.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s)/g;
var splitsOnly = /^[.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s$/;
var newLine = /((?:\r?\n|\r)+)/;
var basicSplit = function(text) {
  let all4 = [];
  let lines = text.split(newLine);
  for (let i5 = 0; i5 < lines.length; i5++) {
    let arr = lines[i5].split(initSplit);
    for (let o4 = 0; o4 < arr.length; o4++) {
      if (arr[o4 + 1] && splitsOnly.test(arr[o4 + 1]) === true) {
        arr[o4] += arr[o4 + 1];
        arr[o4 + 1] = "";
      }
      if (arr[o4] !== "") {
        all4.push(arr[o4]);
      }
    }
  }
  return all4;
};
var simple_split_default = basicSplit;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/02-simple-merge.js
var hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i;
var hasSomething = /\S/;
var notEmpty = function(splits) {
  let chunks2 = [];
  for (let i5 = 0; i5 < splits.length; i5++) {
    let s5 = splits[i5];
    if (s5 === void 0 || s5 === "") {
      continue;
    }
    if (hasSomething.test(s5) === false || hasLetter.test(s5) === false) {
      if (chunks2[chunks2.length - 1]) {
        chunks2[chunks2.length - 1] += s5;
        continue;
      } else if (splits[i5 + 1]) {
        splits[i5 + 1] = s5 + splits[i5 + 1];
        continue;
      }
    }
    chunks2.push(s5);
  }
  return chunks2;
};
var simple_merge_default = notEmpty;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/03-smart-merge.js
var smartMerge = function(chunks2, world2) {
  const isSentence2 = world2.methods.one.tokenize.isSentence;
  const abbrevs = world2.model.one.abbreviations || /* @__PURE__ */ new Set();
  let sentences = [];
  for (let i5 = 0; i5 < chunks2.length; i5++) {
    let c5 = chunks2[i5];
    if (chunks2[i5 + 1] && isSentence2(c5, abbrevs) === false) {
      chunks2[i5 + 1] = c5 + (chunks2[i5 + 1] || "");
    } else if (c5 && c5.length > 0) {
      sentences.push(c5);
      chunks2[i5] = "";
    }
  }
  return sentences;
};
var smart_merge_default = smartMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/04-quote-merge.js
var MAX_QUOTE = 280;
var pairs = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "\uFF02": "\uFF02",
  // 'StraightDoubleQuotesWide'
  // '\u0027': '\u0027', // 'StraightSingleQuotes'
  "\u201C": "\u201D",
  // 'CommaDoubleQuotes'
  // '\u2018': '\u2019', // 'CommaSingleQuotes'
  "\u201F": "\u201D",
  // 'CurlyDoubleQuotesReversed'
  // '\u201B': '\u2019', // 'CurlySingleQuotesReversed'
  "\u201E": "\u201D",
  // 'LowCurlyDoubleQuotes'
  "\u2E42": "\u201D",
  // 'LowCurlyDoubleQuotesReversed'
  "\u201A": "\u2019",
  // 'LowCurlySingleQuotes'
  "\xAB": "\xBB",
  // 'AngleDoubleQuotes'
  "\u2039": "\u203A",
  // 'AngleSingleQuotes'
  "\u2035": "\u2032",
  // 'PrimeSingleQuotes'
  "\u2036": "\u2033",
  // 'PrimeDoubleQuotes'
  "\u2037": "\u2034",
  // 'PrimeTripleQuotes'
  "\u301D": "\u301E",
  // 'PrimeDoubleQuotes'
  // '\u0060': '\u00B4', // 'PrimeSingleQuotes'
  "\u301F": "\u301E"
  // 'LowPrimeDoubleQuotesReversed'
};
var openQuote = RegExp("[" + Object.keys(pairs).join("") + "]", "g");
var closeQuote = RegExp("[" + Object.values(pairs).join("") + "]", "g");
var closesQuote = function(str) {
  if (!str) {
    return false;
  }
  let m6 = str.match(closeQuote);
  if (m6 !== null && m6.length === 1) {
    return true;
  }
  return false;
};
var quoteMerge = function(splits) {
  let arr = [];
  for (let i5 = 0; i5 < splits.length; i5 += 1) {
    let split3 = splits[i5];
    let m6 = split3.match(openQuote);
    if (m6 !== null && m6.length === 1) {
      if (closesQuote(splits[i5 + 1]) && splits[i5 + 1].length < MAX_QUOTE) {
        splits[i5] += splits[i5 + 1];
        arr.push(splits[i5]);
        splits[i5 + 1] = "";
        i5 += 1;
        continue;
      }
      if (closesQuote(splits[i5 + 2])) {
        let toAdd = splits[i5 + 1] + splits[i5 + 2];
        if (toAdd.length < MAX_QUOTE) {
          splits[i5] += toAdd;
          arr.push(splits[i5]);
          splits[i5 + 1] = "";
          splits[i5 + 2] = "";
          i5 += 2;
          continue;
        }
      }
    }
    arr.push(splits[i5]);
  }
  return arr;
};
var quote_merge_default = quoteMerge;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/05-parens-merge.js
var MAX_LEN = 250;
var hasOpen = /\(/g;
var hasClosed = /\)/g;
var mergeParens = function(splits) {
  let arr = [];
  for (let i5 = 0; i5 < splits.length; i5 += 1) {
    let split3 = splits[i5];
    let m6 = split3.match(hasOpen);
    if (m6 !== null && m6.length === 1) {
      if (splits[i5 + 1] && splits[i5 + 1].length < MAX_LEN) {
        let m22 = splits[i5 + 1].match(hasClosed);
        if (m22 !== null && m6.length === 1 && !hasOpen.test(splits[i5 + 1])) {
          splits[i5] += splits[i5 + 1];
          arr.push(splits[i5]);
          splits[i5 + 1] = "";
          i5 += 1;
          continue;
        }
      }
    }
    arr.push(splits[i5]);
  }
  return arr;
};
var parens_merge_default = mergeParens;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/index.js
var hasSomething2 = /\S/;
var startWhitespace = /^\s+/;
var splitSentences = function(text, world2) {
  text = text || "";
  text = String(text);
  if (!text || typeof text !== "string" || hasSomething2.test(text) === false) {
    return [];
  }
  text = text.replace("\xA0", " ");
  let splits = simple_split_default(text);
  let sentences = simple_merge_default(splits);
  sentences = smart_merge_default(sentences, world2);
  sentences = quote_merge_default(sentences);
  sentences = parens_merge_default(sentences);
  if (sentences.length === 0) {
    return [text];
  }
  for (let i5 = 1; i5 < sentences.length; i5 += 1) {
    let ws = sentences[i5].match(startWhitespace);
    if (ws !== null) {
      sentences[i5 - 1] += ws[0];
      sentences[i5] = sentences[i5].replace(startWhitespace, "");
    }
  }
  return sentences;
};
var sentences_default = splitSentences;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/01-hyphens.js
var hasHyphen2 = function(str, model5) {
  let parts = str.split(/[-–—]/);
  if (parts.length <= 1) {
    return false;
  }
  const { prefixes: prefixes2, suffixes: suffixes5 } = model5.one;
  if (parts[0].length === 1 && /[a-z]/i.test(parts[0])) {
    return false;
  }
  if (prefixes2.hasOwnProperty(parts[0])) {
    return false;
  }
  parts[1] = parts[1].trim().replace(/[.?!]$/, "");
  if (suffixes5.hasOwnProperty(parts[1])) {
    return false;
  }
  let reg = /^([a-z\u00C0-\u00FF`"'/]+)[-–—]([a-z0-9\u00C0-\u00FF].*)/i;
  if (reg.test(str) === true) {
    return true;
  }
  let reg2 = /^[('"]?([0-9]{1,4})[-–—]([a-z\u00C0-\u00FF`"'/-]+[)'"]?$)/i;
  if (reg2.test(str) === true) {
    return true;
  }
  return false;
};
var splitHyphens2 = function(word) {
  let arr = [];
  const hyphens = word.split(/[-–—]/);
  let whichDash = "-";
  let found = word.match(/[-–—]/);
  if (found && found[0]) {
    whichDash = found;
  }
  for (let o4 = 0; o4 < hyphens.length; o4++) {
    if (o4 === hyphens.length - 1) {
      arr.push(hyphens[o4]);
    } else {
      arr.push(hyphens[o4] + whichDash);
    }
  }
  return arr;
};

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/03-ranges.js
var combineRanges = function(arr) {
  const startRange = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-–—] ?$/;
  const endRange = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
  for (let i5 = 0; i5 < arr.length - 1; i5 += 1) {
    if (arr[i5 + 1] && startRange.test(arr[i5]) && endRange.test(arr[i5 + 1])) {
      arr[i5] = arr[i5] + arr[i5 + 1];
      arr[i5 + 1] = null;
    }
  }
  return arr;
};
var ranges_default = combineRanges;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/02-slashes.js
var isSlash = /\p{L} ?\/ ?\p{L}+$/u;
var combineSlashes = function(arr) {
  for (let i5 = 1; i5 < arr.length - 1; i5++) {
    if (isSlash.test(arr[i5])) {
      arr[i5 - 1] += arr[i5] + arr[i5 + 1];
      arr[i5] = null;
      arr[i5 + 1] = null;
    }
  }
  return arr;
};
var slashes_default = combineSlashes;

// node_modules/compromise/src/1-one/tokenize/methods/02-terms/index.js
var wordlike = /\S/;
var isBoundary = /^[!?.]+$/;
var naiiveSplit = /(\S+)/;
var notWord = [
  ".",
  "?",
  "!",
  ":",
  ";",
  "-",
  "\u2013",
  "\u2014",
  "--",
  "...",
  "(",
  ")",
  "[",
  "]",
  '"',
  "'",
  "`",
  "\xAB",
  "\xBB",
  "*",
  "\u2022"
];
notWord = notWord.reduce((h4, c5) => {
  h4[c5] = true;
  return h4;
}, {});
var isArray10 = function(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
};
var splitWords = function(str, model5) {
  let result = [];
  let arr = [];
  str = str || "";
  if (typeof str === "number") {
    str = String(str);
  }
  if (isArray10(str)) {
    return str;
  }
  const words = str.split(naiiveSplit);
  for (let i5 = 0; i5 < words.length; i5++) {
    if (hasHyphen2(words[i5], model5) === true) {
      arr = arr.concat(splitHyphens2(words[i5]));
      continue;
    }
    arr.push(words[i5]);
  }
  let carry = "";
  for (let i5 = 0; i5 < arr.length; i5++) {
    let word = arr[i5];
    if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
      if (result.length > 0) {
        result[result.length - 1] += carry;
        result.push(word);
      } else {
        result.push(carry + word);
      }
      carry = "";
    } else {
      carry += word;
    }
  }
  if (carry) {
    if (result.length === 0) {
      result[0] = "";
    }
    result[result.length - 1] += carry;
  }
  result = slashes_default(result);
  result = ranges_default(result);
  result = result.filter((s5) => s5);
  return result;
};
var terms_default = splitWords;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/tokenize.js
var isLetter = /\p{Letter}/u;
var isNumber = /[\p{Number}\p{Currency_Symbol}]/u;
var hasAcronym = /^[a-z]\.([a-z]\.)+/i;
var chillin = /[sn]['’]$/;
var normalizePunctuation = function(str, model5) {
  let { prePunctuation: prePunctuation2, postPunctuation: postPunctuation2, emoticons: emoticons2 } = model5.one;
  let original = str;
  let pre = "";
  let post = "";
  let chars = Array.from(str);
  if (emoticons2.hasOwnProperty(str.trim())) {
    return { str: str.trim(), pre, post: " " };
  }
  let len = chars.length;
  for (let i5 = 0; i5 < len; i5 += 1) {
    let c5 = chars[0];
    if (prePunctuation2[c5] === true) {
      continue;
    }
    if ((c5 === "+" || c5 === "-") && isNumber.test(chars[1])) {
      break;
    }
    if (c5 === "'" && c5.length === 3 && isNumber.test(chars[1])) {
      break;
    }
    if (isLetter.test(c5) || isNumber.test(c5)) {
      break;
    }
    pre += chars.shift();
  }
  len = chars.length;
  for (let i5 = 0; i5 < len; i5 += 1) {
    let c5 = chars[chars.length - 1];
    if (postPunctuation2[c5] === true) {
      continue;
    }
    if (isLetter.test(c5) || isNumber.test(c5)) {
      break;
    }
    if (c5 === "." && hasAcronym.test(original) === true) {
      continue;
    }
    if (c5 === "'" && chillin.test(original) === true) {
      continue;
    }
    post = chars.pop() + post;
  }
  str = chars.join("");
  if (str === "") {
    original = original.replace(/ *$/, (after2) => {
      post = after2 || "";
      return "";
    });
    str = original;
    pre = "";
  }
  return { str, pre, post };
};
var tokenize_default = normalizePunctuation;

// node_modules/compromise/src/1-one/tokenize/methods/03-whitespace/index.js
var parseTerm = (txt, model5) => {
  let { str, pre, post } = tokenize_default(txt, model5);
  const parsed = {
    text: str,
    pre,
    post,
    tags: /* @__PURE__ */ new Set()
  };
  return parsed;
};
var whitespace_default2 = parseTerm;

// node_modules/compromise/src/1-one/tokenize/methods/unicode.js
var killUnicode = function(str, world2) {
  const unicode2 = world2.model.one.unicode || {};
  str = str || "";
  let chars = str.split("");
  chars.forEach((s5, i5) => {
    if (unicode2[s5]) {
      chars[i5] = unicode2[s5];
    }
  });
  return chars.join("");
};
var unicode_default = killUnicode;

// node_modules/compromise/src/1-one/tokenize/compute/normal/01-cleanup.js
var clean = function(str) {
  str = str || "";
  str = str.toLowerCase();
  str = str.trim();
  let original = str;
  str = str.replace(/[,;.!?]+$/, "");
  str = str.replace(/\u2026/g, "...");
  str = str.replace(/\u2013/g, "-");
  if (/^[:;]/.test(str) === false) {
    str = str.replace(/\.{3,}$/g, "");
    str = str.replace(/[",.!:;?)]+$/g, "");
    str = str.replace(/^['"(]+/g, "");
  }
  str = str.replace(/[\u200B-\u200D\uFEFF]/g, "");
  str = str.trim();
  if (str === "") {
    str = original;
  }
  str = str.replace(/([0-9]),([0-9])/g, "$1$2");
  return str;
};
var cleanup_default = clean;

// node_modules/compromise/src/1-one/tokenize/compute/normal/02-acronyms.js
var periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
var oneLetterAcronym = /^[A-Z]\.,?$/;
var noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
var isAcronym = function(str) {
  if (periodAcronym.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym.test(str) === true) {
    return true;
  }
  return false;
};
var doAcronym = function(str) {
  if (isAcronym(str)) {
    str = str.replace(/\./g, "");
  }
  return str;
};
var acronyms_default = doAcronym;

// node_modules/compromise/src/1-one/tokenize/compute/normal/index.js
var normalize = function(term, world2) {
  const killUnicode2 = world2.methods.one.killUnicode;
  let str = term.text || "";
  str = cleanup_default(str);
  str = killUnicode2(str, world2);
  str = acronyms_default(str);
  term.normal = str;
};
var normal_default = normalize;

// node_modules/compromise/src/1-one/tokenize/methods/parse.js
var parse2 = function(input, world2) {
  const { methods: methods17, model: model5 } = world2;
  const { splitSentences: splitSentences2, splitTerms, splitWhitespace } = methods17.one.tokenize;
  input = input || "";
  let sentences = splitSentences2(input, world2);
  input = sentences.map((txt) => {
    let terms = splitTerms(txt, model5);
    terms = terms.map((t5) => splitWhitespace(t5, model5));
    terms.forEach((t5) => {
      normal_default(t5, world2);
    });
    return terms;
  });
  return input;
};
var parse_default2 = parse2;

// node_modules/compromise/src/1-one/tokenize/methods/01-sentences/is-sentence.js
var isAcronym2 = /[ .][A-Z]\.? *$/i;
var hasEllipse = /(?:\u2026|\.{2,}) *$/;
var hasLetter2 = /\p{L}/u;
var hasPeriod = /\. *$/;
var leadInit = /^[A-Z]\. $/;
var isSentence = function(str, abbrevs) {
  if (hasLetter2.test(str) === false) {
    return false;
  }
  if (isAcronym2.test(str) === true) {
    return false;
  }
  if (str.length === 3 && leadInit.test(str)) {
    return false;
  }
  if (hasEllipse.test(str) === true) {
    return false;
  }
  let txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "");
  let words = txt.split(" ");
  let lastWord = words[words.length - 1].toLowerCase();
  if (abbrevs.hasOwnProperty(lastWord) === true && hasPeriod.test(str) === true) {
    return false;
  }
  return true;
};
var is_sentence_default = isSentence;

// node_modules/compromise/src/1-one/tokenize/methods/index.js
var methods_default8 = {
  one: {
    killUnicode: unicode_default,
    tokenize: {
      splitSentences: sentences_default,
      isSentence: is_sentence_default,
      splitTerms: terms_default,
      splitWhitespace: whitespace_default2,
      fromString: parse_default2
    }
  }
};

// node_modules/compromise/src/1-one/tokenize/model/aliases.js
var aliases = {
  "&": "and",
  "@": "at",
  "%": "percent",
  "plz": "please",
  "bein": "being"
};
var aliases_default = aliases;

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/misc.js
var misc_default = [
  "approx",
  "apt",
  "bc",
  "cyn",
  "eg",
  "esp",
  "est",
  "etc",
  "ex",
  "exp",
  "prob",
  //probably
  "pron",
  // Pronunciation
  "gal",
  //gallon
  "min",
  "pseud",
  "fig",
  //figure
  "jd",
  "lat",
  //latitude
  "lng",
  //longitude
  "vol",
  //volume
  "fm",
  //not am
  "def",
  //definition
  "misc",
  "plz",
  //please
  "ea",
  //each
  "ps",
  "sec",
  //second
  "pt",
  "pref",
  //preface
  "pl",
  //plural
  "pp",
  //pages
  "qt",
  //quarter
  "fr",
  //french
  "sq",
  "nee",
  //given name at birth
  "ss",
  //ship, or sections
  "tel",
  "temp",
  "vet",
  "ver",
  //version
  "fem",
  //feminine
  "masc",
  //masculine
  "eng",
  //engineering/english
  "adj",
  //adjective
  "vb",
  //verb
  "rb",
  //adverb
  "inf",
  //infinitive
  "situ",
  // in situ
  "vivo",
  "vitro",
  "wr"
  //world record
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/honorifics.js
var honorifics_default = [
  "adj",
  "adm",
  "adv",
  "asst",
  "atty",
  "bldg",
  "brig",
  "capt",
  "cmdr",
  "comdr",
  "cpl",
  "det",
  "dr",
  "esq",
  "gen",
  "gov",
  "hon",
  "jr",
  "llb",
  "lt",
  "maj",
  "messrs",
  "mlle",
  "mme",
  "mr",
  "mrs",
  "ms",
  "mstr",
  "phd",
  "prof",
  "pvt",
  "rep",
  "reps",
  "res",
  "rev",
  "sen",
  "sens",
  "sfc",
  "sgt",
  "sir",
  "sr",
  "supt",
  "surg"
  //miss
  //misses
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/months.js
var months_default = ["jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "sept", "oct", "nov", "dec"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/nouns.js
var nouns_default = [
  "ad",
  "al",
  "arc",
  "ba",
  "bl",
  "ca",
  "cca",
  "col",
  "corp",
  "ft",
  "fy",
  "ie",
  "lit",
  "ma",
  "md",
  "pd",
  "tce"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/organizations.js
var organizations_default = ["dept", "univ", "assn", "bros", "inc", "ltd", "co"];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/places.js
var places_default = [
  "rd",
  "st",
  "dist",
  "mt",
  "ave",
  "blvd",
  "cl",
  // 'ct',
  "cres",
  "hwy",
  //states
  "ariz",
  "cal",
  "calif",
  "colo",
  "conn",
  "fla",
  "fl",
  "ga",
  "ida",
  "ia",
  "kan",
  "kans",
  "minn",
  "neb",
  "nebr",
  "okla",
  "penna",
  "penn",
  "pa",
  "dak",
  "tenn",
  "tex",
  "ut",
  "vt",
  "va",
  "wis",
  "wisc",
  "wy",
  "wyo",
  "usafa",
  "alta",
  "ont",
  "que",
  "sask"
];

// node_modules/compromise/src/1-one/tokenize/model/abbreviations/units.js
var units_default = [
  "dl",
  "ml",
  "gal",
  // 'ft', //ambiguous
  "qt",
  "pt",
  "tbl",
  "tsp",
  "tbsp",
  "km",
  "dm",
  //decimeter
  "cm",
  "mm",
  "mi",
  "td",
  "hr",
  //hour
  "hrs",
  //hour
  "kg",
  "hg",
  "dg",
  //decigram
  "cg",
  //centigram
  "mg",
  //milligram
  "\xB5g",
  //microgram
  "lb",
  //pound
  "oz",
  //ounce
  "sq ft",
  "hz",
  //hertz
  "mps",
  //meters per second
  "mph",
  "kmph",
  //kilometers per hour
  "kb",
  //kilobyte
  "mb",
  //megabyte
  // 'gb', //ambig
  "tb",
  //terabyte
  "lx",
  //lux
  "lm",
  //lumen
  // 'pa', //ambig
  "fl oz",
  //
  "yb"
];

// node_modules/compromise/src/1-one/tokenize/model/lexicon.js
var list = [
  [misc_default],
  [units_default, "Unit"],
  [nouns_default, "Noun"],
  [honorifics_default, "Honorific"],
  [months_default, "Month"],
  [organizations_default, "Organization"],
  [places_default, "Place"]
];
var abbreviations = {};
var lexicon2 = {};
list.forEach((a4) => {
  a4[0].forEach((w2) => {
    abbreviations[w2] = true;
    lexicon2[w2] = "Abbreviation";
    if (a4[1] !== void 0) {
      lexicon2[w2] = [lexicon2[w2], a4[1]];
    }
  });
});

// node_modules/compromise/src/1-one/tokenize/model/prefixes.js
var prefixes_default = [
  "anti",
  "bi",
  "co",
  "contra",
  "de",
  "extra",
  "infra",
  "inter",
  "intra",
  "macro",
  "micro",
  "mis",
  "mono",
  "multi",
  "peri",
  "pre",
  "pro",
  "proto",
  "pseudo",
  "re",
  "sub",
  "supra",
  "trans",
  "tri",
  "un",
  "out",
  //out-lived
  "ex"
  //ex-wife
  // 'counter',
  // 'mid',
  // 'out',
  // 'non',
  // 'over',
  // 'post',
  // 'semi',
  // 'super', //'super-cool'
  // 'ultra', //'ulta-cool'
  // 'under',
  // 'whole',
].reduce((h4, str) => {
  h4[str] = true;
  return h4;
}, {});

// node_modules/compromise/src/1-one/tokenize/model/suffixes.js
var suffixes_default = {
  "like": true,
  "ish": true,
  "less": true,
  "able": true,
  "elect": true,
  "type": true,
  "designate": true
  // 'fold':true,
};

// node_modules/compromise/src/1-one/tokenize/model/unicode.js
var compact = {
  "!": "\xA1",
  "?": "\xBF\u0241",
  '"': '\u201C\u201D"\u275D\u275E',
  "'": "\u2018\u201B\u275B\u275C\u2019",
  "-": "\u2014\u2013",
  a: "\xAA\xC0\xC1\xC2\xC3\xC4\xC5\xE0\xE1\xE2\xE3\xE4\xE5\u0100\u0101\u0102\u0103\u0104\u0105\u01CD\u01CE\u01DE\u01DF\u01E0\u01E1\u01FA\u01FB\u0200\u0201\u0202\u0203\u0226\u0227\u023A\u0386\u0391\u0394\u039B\u03AC\u03B1\u03BB\u0410\u0430\u0466\u0467\u04D0\u04D1\u04D2\u04D3\u019B\xE6",
  b: "\xDF\xFE\u0180\u0181\u0182\u0183\u0184\u0185\u0243\u0392\u03B2\u03D0\u03E6\u0411\u0412\u042A\u042C\u0432\u044A\u044C\u0462\u0463\u048C\u048D",
  c: "\xA2\xA9\xC7\xE7\u0106\u0107\u0108\u0109\u010A\u010B\u010C\u010D\u0186\u0187\u0188\u023B\u023C\u037B\u037C\u03F2\u03F9\u03FD\u03FE\u0421\u0441\u0454\u0480\u0481\u04AA\u04AB",
  d: "\xD0\u010E\u010F\u0110\u0111\u0189\u018A\u0221\u018B\u018C",
  e: "\xC8\xC9\xCA\xCB\xE8\xE9\xEA\xEB\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011A\u011B\u0190\u0204\u0205\u0206\u0207\u0228\u0229\u0246\u0247\u0388\u0395\u039E\u03A3\u03AD\u03B5\u03BE\u03F5\u0400\u0401\u0415\u0435\u0450\u0451\u04BC\u04BD\u04BE\u04BF\u04D6\u04D7\u1EC5",
  f: "\u0191\u0192\u03DC\u03DD\u04FA\u04FB\u0492\u0493\u017F",
  g: "\u011C\u011D\u011E\u011F\u0120\u0121\u0122\u0123\u0193\u01E4\u01E5\u01E6\u01E7\u01F4\u01F5",
  h: "\u0124\u0125\u0126\u0127\u0195\u01F6\u021E\u021F\u0389\u0397\u0402\u040A\u040B\u041D\u043D\u0452\u045B\u04A2\u04A3\u04A4\u04A5\u04BA\u04BB\u04C9\u04CA",
  I: "\xCC\xCD\xCE\xCF",
  i: "\xEC\xED\xEE\xEF\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\u0131\u0196\u0197\u0208\u0209\u020A\u020B\u038A\u0390\u03AA\u03AF\u03B9\u03CA\u0406\u0407\u0456\u0457i\u0307",
  j: "\u0134\u0135\u01F0\u0237\u0248\u0249\u03F3\u0408\u0458",
  k: "\u0136\u0137\u0138\u0198\u0199\u01E8\u01E9\u039A\u03BA\u040C\u0416\u041A\u0436\u043A\u045C\u049A\u049B\u049C\u049D\u049E\u049F\u04A0\u04A1",
  l: "\u0139\u013A\u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u019A\u01AA\u01C0\u01CF\u01D0\u0234\u023D\u0399\u04C0\u04CF",
  m: "\u039C\u03FA\u03FB\u041C\u043C\u04CD\u04CE",
  n: "\xD1\xF1\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014A\u014B\u019D\u019E\u01F8\u01F9\u0220\u0235\u039D\u03A0\u03AE\u03B7\u03DE\u040D\u0418\u0419\u041B\u041F\u0438\u0439\u043B\u043F\u045D\u048A\u048B\u04C5\u04C6\u04E2\u04E3\u04E4\u04E5\u03C0",
  o: "\xD2\xD3\xD4\xD5\xD6\xD8\xF0\xF2\xF3\xF4\xF5\xF6\xF8\u014C\u014D\u014E\u014F\u0150\u0151\u019F\u01A0\u01A1\u01D1\u01D2\u01EA\u01EB\u01EC\u01ED\u01FE\u01FF\u020C\u020D\u020E\u020F\u022A\u022B\u022C\u022D\u022E\u022F\u0230\u0231\u038C\u0398\u039F\u03B8\u03BF\u03C3\u03CC\u03D5\u03D8\u03D9\u03EC\u03F4\u041E\u0424\u043E\u0472\u0473\u04E6\u04E7\u04E8\u04E9\u04EA\u04EB",
  p: "\u01A4\u03A1\u03C1\u03F7\u03F8\u03FC\u0420\u0440\u048E\u048F\xDE",
  q: "\u024A\u024B",
  r: "\u0154\u0155\u0156\u0157\u0158\u0159\u01A6\u0210\u0211\u0212\u0213\u024C\u024D\u0403\u0413\u042F\u0433\u044F\u0453\u0490\u0491",
  s: "\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u01A7\u01A8\u0218\u0219\u023F\u0405\u0455",
  t: "\u0162\u0163\u0164\u0165\u0166\u0167\u01AB\u01AC\u01AD\u01AE\u021A\u021B\u0236\u023E\u0393\u03A4\u03C4\u03EE\u0422\u0442",
  u: "\xD9\xDA\xDB\xDC\xF9\xFA\xFB\xFC\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\u0173\u01AF\u01B0\u01B1\u01B2\u01D3\u01D4\u01D5\u01D6\u01D7\u01D8\u01D9\u01DA\u01DB\u01DC\u0214\u0215\u0216\u0217\u0244\u03B0\u03C5\u03CB\u03CD",
  v: "\u03BD\u0474\u0475\u0476\u0477",
  w: "\u0174\u0175\u019C\u03C9\u03CE\u03D6\u03E2\u03E3\u0428\u0429\u0448\u0449\u0461\u047F",
  x: "\xD7\u03A7\u03C7\u03D7\u03F0\u0425\u0445\u04B2\u04B3\u04FC\u04FD\u04FE\u04FF",
  y: "\xDD\xFD\xFF\u0176\u0177\u0178\u01B3\u01B4\u0232\u0233\u024E\u024F\u038E\u03A5\u03AB\u03B3\u03C8\u03D2\u03D3\u03D4\u040E\u0423\u0443\u0447\u045E\u0470\u0471\u04AE\u04AF\u04B0\u04B1\u04EE\u04EF\u04F0\u04F1\u04F2\u04F3",
  z: "\u0179\u017A\u017B\u017C\u017D\u017E\u01B5\u01B6\u0224\u0225\u0240\u0396"
};
var unicode = {};
Object.keys(compact).forEach(function(k3) {
  compact[k3].split("").forEach(function(s5) {
    unicode[s5] = k3;
  });
});
var unicode_default2 = unicode;

// node_modules/compromise/src/1-one/tokenize/model/punctuation.js
var prePunctuation = {
  "#": true,
  //#hastag
  "@": true,
  //@atmention
  "_": true,
  //underscore
  "\xB0": true,
  // '+': true,//+4
  // '\\-',//-4  (escape)
  // '.',//.4
  // zero-width chars
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var postPunctuation = {
  "%": true,
  //88%
  "_": true,
  //underscore
  "\xB0": true,
  //degrees, italian ordinal
  // '\'',// sometimes
  // zero-width chars
  "\u200B": true,
  "\u200C": true,
  "\u200D": true,
  "\uFEFF": true
};
var emoticons = {
  "<3": true,
  "</3": true,
  "<\\3": true,
  ":^P": true,
  ":^p": true,
  ":^O": true,
  ":^3": true
};

// node_modules/compromise/src/1-one/tokenize/model/index.js
var model_default2 = {
  one: {
    aliases: aliases_default,
    abbreviations,
    prefixes: prefixes_default,
    suffixes: suffixes_default,
    prePunctuation,
    postPunctuation,
    lexicon: lexicon2,
    //give this one forward
    unicode: unicode_default2,
    emoticons
  }
};

// node_modules/compromise/src/1-one/tokenize/compute/alias.js
var hasSlash = /\//;
var hasDomain = /[a-z]\.[a-z]/i;
var isMath = /[0-9]/;
var addAliases = function(term, world2) {
  let str = term.normal || term.text || term.machine;
  const aliases3 = world2.model.one.aliases;
  if (aliases3.hasOwnProperty(str)) {
    term.alias = term.alias || [];
    term.alias.push(aliases3[str]);
  }
  if (hasSlash.test(str) && !hasDomain.test(str) && !isMath.test(str)) {
    let arr = str.split(hasSlash);
    if (arr.length <= 2) {
      arr.forEach((word) => {
        word = word.trim();
        if (word !== "") {
          term.alias = term.alias || [];
          term.alias.push(word);
        }
      });
    }
  }
  return term;
};
var alias_default = addAliases;

// node_modules/compromise/src/1-one/tokenize/compute/machine.js
var hasDash3 = /^\p{Letter}+-\p{Letter}+$/u;
var doMachine = function(term) {
  let str = term.implicit || term.normal || term.text;
  str = str.replace(/['’]s$/, "");
  str = str.replace(/s['’]$/, "s");
  str = str.replace(/([aeiou][ktrp])in'$/, "$1ing");
  if (hasDash3.test(str)) {
    str = str.replace(/-/g, "");
  }
  str = str.replace(/^[#@]/, "");
  if (str !== term.normal) {
    term.machine = str;
  }
};
var machine_default = doMachine;

// node_modules/compromise/src/1-one/tokenize/compute/freq.js
var freq = function(view) {
  let docs = view.docs;
  let counts = {};
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      let term = docs[i5][t5];
      let word = term.machine || term.normal;
      counts[word] = counts[word] || 0;
      counts[word] += 1;
    }
  }
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      let term = docs[i5][t5];
      let word = term.machine || term.normal;
      term.freq = counts[word];
    }
  }
};
var freq_default = freq;

// node_modules/compromise/src/1-one/tokenize/compute/offset.js
var offset = function(view) {
  let elapsed = 0;
  let index4 = 0;
  let docs = view.document;
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      let term = docs[i5][t5];
      term.offset = {
        index: index4,
        start: elapsed + term.pre.length,
        length: term.text.length
      };
      elapsed += term.pre.length + term.text.length + term.post.length;
      index4 += 1;
    }
  }
};
var offset_default = offset;

// node_modules/compromise/src/1-one/tokenize/compute/reindex.js
var index2 = function(view) {
  let document2 = view.document;
  for (let n5 = 0; n5 < document2.length; n5 += 1) {
    for (let i5 = 0; i5 < document2[n5].length; i5 += 1) {
      document2[n5][i5].index = [n5, i5];
    }
  }
};
var reindex_default = index2;

// node_modules/compromise/src/1-one/tokenize/compute/wordCount.js
var wordCount2 = function(view) {
  let n5 = 0;
  let docs = view.docs;
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      if (docs[i5][t5].normal === "") {
        continue;
      }
      n5 += 1;
      docs[i5][t5].wordCount = n5;
    }
  }
};
var wordCount_default = wordCount2;

// node_modules/compromise/src/1-one/tokenize/compute/index.js
var termLoop = function(view, fn) {
  let docs = view.docs;
  for (let i5 = 0; i5 < docs.length; i5 += 1) {
    for (let t5 = 0; t5 < docs[i5].length; t5 += 1) {
      fn(docs[i5][t5], view.world);
    }
  }
};
var methods16 = {
  alias: (view) => termLoop(view, alias_default),
  machine: (view) => termLoop(view, machine_default),
  normal: (view) => termLoop(view, normal_default),
  freq: freq_default,
  offset: offset_default,
  index: reindex_default,
  wordCount: wordCount_default
};
var compute_default6 = methods16;

// node_modules/compromise/src/1-one/tokenize/plugin.js
var plugin_default12 = {
  compute: compute_default6,
  methods: methods_default8,
  model: model_default2,
  hooks: ["alias", "machine", "index", "id"]
};

// node_modules/compromise/src/1-one/typeahead/compute.js
var typeahead = function(view) {
  const prefixes2 = view.model.one.typeahead;
  const docs = view.docs;
  if (docs.length === 0 || Object.keys(prefixes2).length === 0) {
    return;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let lastTerm = lastPhrase[lastPhrase.length - 1];
  if (lastTerm.post) {
    return;
  }
  if (prefixes2.hasOwnProperty(lastTerm.normal)) {
    let found = prefixes2[lastTerm.normal];
    lastTerm.implicit = found;
    lastTerm.machine = found;
    lastTerm.typeahead = true;
    if (view.compute.preTagger) {
      view.last().unTag("*").compute(["lexicon", "preTagger"]);
    }
  }
};
var compute_default7 = { typeahead };

// node_modules/compromise/src/1-one/typeahead/api.js
var autoFill = function() {
  const docs = this.docs;
  if (docs.length === 0) {
    return this;
  }
  let lastPhrase = docs[docs.length - 1] || [];
  let term = lastPhrase[lastPhrase.length - 1];
  if (term.typeahead === true && term.machine) {
    term.text = term.machine;
    term.normal = term.machine;
  }
  return this;
};
var api2 = function(View2) {
  View2.prototype.autoFill = autoFill;
};
var api_default9 = api2;

// node_modules/compromise/src/1-one/typeahead/lib/allPrefixes.js
var getPrefixes = function(arr, opts2, world2) {
  let index4 = {};
  let collisions = [];
  let existing = world2.prefixes || {};
  arr.forEach((str) => {
    str = str.toLowerCase().trim();
    let max4 = str.length;
    if (opts2.max && max4 > opts2.max) {
      max4 = opts2.max;
    }
    for (let size = opts2.min; size < max4; size += 1) {
      let prefix5 = str.substring(0, size);
      if (opts2.safe && world2.model.one.lexicon.hasOwnProperty(prefix5)) {
        continue;
      }
      if (existing.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      if (index4.hasOwnProperty(prefix5) === true) {
        collisions.push(prefix5);
        continue;
      }
      index4[prefix5] = str;
    }
  });
  index4 = Object.assign({}, existing, index4);
  collisions.forEach((str) => {
    delete index4[str];
  });
  return index4;
};
var allPrefixes_default = getPrefixes;

// node_modules/compromise/src/1-one/typeahead/lib/index.js
var isObject7 = (val) => {
  return Object.prototype.toString.call(val) === "[object Object]";
};
var defaults2 = {
  safe: true,
  min: 3
};
var prepare = function(words = [], opts2 = {}) {
  let model5 = this.model();
  opts2 = Object.assign({}, defaults2, opts2);
  if (isObject7(words)) {
    Object.assign(model5.one.lexicon, words);
    words = Object.keys(words);
  }
  let prefixes2 = allPrefixes_default(words, opts2, this.world());
  Object.keys(prefixes2).forEach((str) => {
    if (model5.one.typeahead.hasOwnProperty(str)) {
      delete model5.one.typeahead[str];
      return;
    }
    model5.one.typeahead[str] = prefixes2[str];
  });
  return this;
};
var lib_default5 = {
  typeahead: prepare
};

// node_modules/compromise/src/1-one/typeahead/plugin.js
var model3 = {
  one: {
    typeahead: {}
    //set a blank key-val
  }
};
var plugin_default13 = {
  model: model3,
  api: api_default9,
  lib: lib_default5,
  compute: compute_default7,
  hooks: ["typeahead"]
};

// node_modules/compromise/src/one.js
nlp_default.extend(plugin_default2);
nlp_default.extend(plugin_default8);
nlp_default.extend(plugin_default7);
nlp_default.extend(plugin_default9);
nlp_default.extend(plugin_default11);
nlp_default.plugin(plugin_default3);
nlp_default.extend(plugin_default4);
nlp_default.extend(plugin_default12);
nlp_default.plugin(plugin_default);
nlp_default.extend(plugin_default6);
nlp_default.extend(plugin_default13);
nlp_default.extend(plugin_default5);
nlp_default.extend(plugin_default10);
var one_default = nlp_default;

// node_modules/compromise/src/2-two/preTagger/model/irregulars/plurals.js
var plurals_default = {
  // -a
  addendum: "addenda",
  corpus: "corpora",
  criterion: "criteria",
  curriculum: "curricula",
  genus: "genera",
  memorandum: "memoranda",
  opus: "opera",
  ovum: "ova",
  phenomenon: "phenomena",
  referendum: "referenda",
  // -ae
  alga: "algae",
  alumna: "alumnae",
  antenna: "antennae",
  formula: "formulae",
  larva: "larvae",
  nebula: "nebulae",
  vertebra: "vertebrae",
  // -is
  analysis: "analyses",
  axis: "axes",
  diagnosis: "diagnoses",
  parenthesis: "parentheses",
  prognosis: "prognoses",
  synopsis: "synopses",
  thesis: "theses",
  neurosis: "neuroses",
  // -x
  appendix: "appendices",
  index: "indices",
  matrix: "matrices",
  ox: "oxen",
  sex: "sexes",
  // -i
  alumnus: "alumni",
  bacillus: "bacilli",
  cactus: "cacti",
  fungus: "fungi",
  hippopotamus: "hippopotami",
  libretto: "libretti",
  modulus: "moduli",
  nucleus: "nuclei",
  octopus: "octopi",
  radius: "radii",
  stimulus: "stimuli",
  syllabus: "syllabi",
  // -ie
  cookie: "cookies",
  calorie: "calories",
  auntie: "aunties",
  movie: "movies",
  pie: "pies",
  rookie: "rookies",
  tie: "ties",
  zombie: "zombies",
  // -f
  leaf: "leaves",
  loaf: "loaves",
  thief: "thieves",
  // ee-
  foot: "feet",
  goose: "geese",
  tooth: "teeth",
  // -eaux
  beau: "beaux",
  chateau: "chateaux",
  tableau: "tableaux",
  // -ses
  bus: "buses",
  gas: "gases",
  circus: "circuses",
  crisis: "crises",
  virus: "viruses",
  database: "databases",
  excuse: "excuses",
  abuse: "abuses",
  avocado: "avocados",
  barracks: "barracks",
  child: "children",
  clothes: "clothes",
  echo: "echoes",
  embargo: "embargoes",
  epoch: "epochs",
  deer: "deer",
  halo: "halos",
  man: "men",
  woman: "women",
  mosquito: "mosquitoes",
  mouse: "mice",
  person: "people",
  quiz: "quizzes",
  rodeo: "rodeos",
  shoe: "shoes",
  sombrero: "sombreros",
  stomach: "stomachs",
  tornado: "tornados",
  tuxedo: "tuxedos",
  volcano: "volcanoes"
};

// node_modules/compromise/src/2-two/preTagger/model/lexicon/_data.js
var data_default = {
  "Comparative": "true\xA6bett1f0;arth0ew0in0;er",
  "Superlative": "true\xA6earlier",
  "PresentTense": "true\xA6bests,sounds",
  "Condition": "true\xA6lest,unless",
  "PastTense": "true\xA6began,came,d4had,kneel3l2m0sa4we1;ea0sg2;nt;eap0i0;ed;id",
  "Participle": "true\xA60:09;a06b01cZdXeat0fSgQhPoJprov0rHs7t6u4w1;ak0ithdra02o2r1;i02uY;k0v0;nd1pr04;ergoJoJ;ak0hHo3;e9h7lain,o6p5t4un3w1;o1um;rn;g,k;ol0reS;iQok0;ught,wn;ak0o1runk;ne,wn;en,wn;ewriNi1uJ;dd0s0;ut3ver1;do4se0t1;ak0h2;do2g1;roG;ne;ast0i7;iv0o1;ne,tt0;all0loBor1;bi3g2s1;ak0e0;iv0o9;dd0;ove,r1;a5eamt,iv0;hos0lu1;ng;e4i3lo2ui1;lt;wn;tt0;at0en,gun;r2w1;ak0ok0;is0;en",
  "Gerund": "true\xA6accord0be0doin,go0result0stain0;ing",
  "Expression": "true\xA6a0Yb0Uc0Sd0Oe0Mfarew0Lg0FhZjeez,lWmVnToOpLsJtIuFvEw7y0;a5e3i1u0;ck,p;k04p0;ee,pee;a0p,s;!h;!a,h,y;a5h2o1t0;af,f;rd up,w;atsoever,e1o0;a,ops;e,w;hoo,t;ery w06oi0L;gh,h0;! 0h,m;huh,oh;here nPsk,ut tut;h0ic;eesh,hh,it,oo;ff,h1l0ow,sst;ease,s,z;ew,ooey;h1i,mg,o0uch,w,y;h,o,ps;! 0h;hTmy go0wT;d,sh;a7evertheless,o0;!pe;eh,mm;ah,eh,m1ol0;!s;ao,fao;aCeBi9o2u0;h,mph,rra0zzC;h,y;l1o0;r6y9;la,y0;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;ell;e0h,t cetera,ureka,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0tw,ye;avo,r;!ya;h,m; 1h0ka,las,men,rgh,ye;!a,em,h,oy;la",
  "Negative": "true\xA6n0;ever,o0;n,t",
  "QuestionWord": "true\xA6how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
  "Reflexive": "true\xA6h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
  "Plural": "true\xA6dick0gre0ones,records;ens",
  "Unit|Noun": "true\xA6cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,t,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
  "Value": "true\xA6a few",
  "Imperative": "true\xA6bewa0come he0;re",
  "Plural|Verb": "true\xA6leaves",
  "Demonym": "true\xA60:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
  "Organization": "true\xA60:4Q;a3Tb3Bc2Od2He2Df27g1Zh1Ti1Pj1Nk1Ll1Gm12n0Po0Mp0Cqu0Br02sTtHuCv9w3xiaomi,y1;amaha,m1Bou1w1B;gov,tu3C;a4e2iki1orld trade organizati33;leaRped0O;lls fargo,st1;fie2Hinghou2R;l1rner br3U;gree3Jl street journ2Im1E;an halOeriz2Xisa,o1;dafo2Yl1;kswagMvo;b4kip,n2ps,s1;a tod3Aps;es3Mi1;lev3Fted natio3C;er,s; mobi32aco beRd bOe9gi frida3Lh3im horto3Amz,o1witt3D;shi49y1;ota,s r 05;e 1in lizzy;b3carpen3Jdaily ma3Dguess w2holli0s1w2;mashing pumpki35uprem0;ho;ea1lack eyed pe3Xyr0Q;ch bo3Dtl0;l2n3Qs1xas instrumen1U;co,la m1F;efoni0Kus;a8cientology,e5ieme2Ymirnoff,np,o3pice gir6quare0Ata1ubaru;rbuc1to34;ks;ny,undgard1;en;a2x pisto1;ls;g1Wrs;few2Minsbur31lesfor03msu2E;adiohead,b8e4o1yana3C;man empi1Xyal 1;b1dutch she4;ank;a3d 1max,vl20;bu1c2Ahot chili peppe2Ylobst2N;ll;ders dige1Ll madrid;c,s;ant3Aizn2Q;a8bs,e5fiz2Ihilip4i3r1;emier 1udenti1D;leagTo2K;nk floyd,zza hut; morrBs;psi2tro1uge0E;br33chi0Tn33;!co;lant2Un1yp16; 2ason27da2P;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0QvZ;l,s;c,st1Otflix,w1; 1sweek;kids on the block,york0D;a,c;nd22s2t1;ional aca2Po,we0U;a,c02d0S;aDcdonalCe9i6lb,o3tv,y1;spa1;ce;b1Tnsanto,ody blu0t1;ley cr1or0T;ue;c2t1;as,subisO;helin,rosoft;dica2rcedes benz,talli1;ca;id,re;ds;cs milk,tt19z24;a3e1g,ittle caesa1P; ore09novo,x1;is,mark,us; 1bour party;pres0Dz boy;atv,fc,kk,lm,m1od1O;art;iffy lu0Roy divisi0Jpmorgan1sa;! cha09;bm,hop,k3n1tv;g,te1;l,rpol;ea;a5ewlett pack1Vi3o1sbc,yundai;me dep1n1P;ot;tac1zbollah;hi;lliburt08sbro;eneral 6hq,ithub,l5mb,o2reen d0Ou1;cci,ns n ros0;ldman sachs,o1;dye1g0H;ar;axo smith kli04encoW;electr0Nm1;oto0Z;a5bi,c barcelo4da,edex,i2leetwood m03o1rito l0G;rd,xcY;at,fa,nancial1restoZ; tim0;na;cebook,nnie mae;b0Asa,u3xxon1; m1m1;ob0J;!rosceptics;aiml0De5isney,o4u1;nkin donu2po0Zran dur1;an;ts;j,w jon0;a,f lepp12ll,peche mode,r spieg02stiny's chi1;ld;aJbc,hFiDloudflaCnn,o3r1;aigsli5eedence clearwater reviv1ossra09;al;c7inba6l4m1o0Est09;ca2p1;aq;st;dplSg1;ate;se;a c1o chanQ;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil a,na daily;r1y;on;d2pital o1rls jr;ne;bury,ill1;ac;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;cardi,idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser busDol,ppleAr6s4u3v2y1;er;is,on;di,todesk;hland o1sociated E;il;b3g2m1;co;os;ys; compu1be0;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;! lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
  "Possessive": "true\xA6its,my,our0thy;!s",
  "Noun|Verb": "true\xA60:9W;1:AA;2:96;3:A3;4:9R;5:A2;6:9K;7:8N;8:7L;9:A8;A:93;B:8D;C:8X;a9Ob8Qc7Id6Re6Gf5Sg5Hh55i4Xj4Uk4Rl4Em40n3Vo3Sp2Squ2Rr21s0Jt02u00vVwGyFzD;ip,oD;ne,om;awn,e6Fie68;aOeMhJiHoErD;ap,e9Oink2;nd0rDuC;kDry,sh5Hth;!shop;ck,nDpe,re,sh;!d,g;e86iD;p,sD;k,p0t2;aDed,lco8W;r,th0;it,lk,rEsDt4ve,x;h,te;!ehou1ra9;aGen5FiFoD;iDmAte,w;ce,d;be,ew,sA;cuum,l4B;pDr7;da5gra6Elo6A;aReQhrPiOoMrGuEwiDy5Z;n,st;nDrn;e,n7O;aGeFiEoDu6;t,ub2;bu5ck4Jgg0m,p;at,k,nd;ck,de,in,nsDp,v7J;f0i8R;ll,ne,p,r4Yss,t94uD;ch,r;ck,de,e,le,me,p,re;e5Wow,u6;ar,e,ll,mp0st,xt;g,lDng2rg7Ps5x;k,ly;a0Sc0Ne0Kh0Fi0Dk0Cl0Am08n06o05pXquaBtKuFwD;ea88iD;ng,pe,t4;bGit,m,ppErD;fa3ge,pri1v2U;lDo6S;e6Py;!je8;aMeLiKoHrEuDy2;dy,ff,mb2;a85eEiDo5Pugg2;ke,ng;am,ss,t4;ckEop,p,rD;e,m;ing,pi2;ck,nk,t4;er,m,p;ck,ff,ge,in,ke,lEmp,nd,p2rDte,y;!e,t;k,l;aJeIiHlGoFrDur,y;ay,e56inDu3;g,k2;ns8Bt;a5Qit;ll,n,r87te;ed,ll;m,n,rk;b,uC;aDee1Tow;ke,p;a5Je4FiDo53;le,rk;eep,iDou4;ce,p,t;ateboa7Ii;de,gnDl2Vnk,p,ze;!al;aGeFiEoDuff2;ck,p,re,w;ft,p,v0;d,i3Ylt0;ck,de,pe,re,ve;aEed,nDrv1It;se,t2N;l,r4t;aGhedu2oBrD;aEeDibb2o3Z;en,w;pe,t4;le,n,r2M;cDfegua72il,mp2;k,rifi3;aZeHhy6LiGoEuD;b,in,le,n,s5X;a6ck,ll,oDpe,u5;f,t;de,ng,ot,p,s1W;aTcSdo,el,fQgPje8lOmMnLo17pJque6sFturn,vDwa6V;eDi27;al,r1;er74oFpe8tEuD;lt,me;!a55;l71rt;air,eaDly,o53;l,t;dezvo2Zt;aDedy;ke,rk;ea1i4G;a6Iist0r5N;act6Yer1Vo71uD;nd,se;a38o6F;ch,s6G;c1Dge,iEke,lly,nDp1Wt1W;ge,k,t;n,se;es6Biv0;a04e00hYiXlToNrEsy4uD;mp,n4rcha1sh;aKeIiHoDu4O;be,ceFdu3fi2grDje8mi1p,te6;amDe6W;!me;ed,ss;ce,de,nt;sDy;er6Cs;cti3i1;iHlFoEp,re,sDuCw0;e,i5Yt;l,p;iDl;ce,sh;nt,s5V;aEce,e32uD;g,mp,n7;ce,nDy;!t;ck,le,n17pe,tNvot;a1oD;ne,tograph;ak,eFnErDt;fu55mA;!c32;!l,r;ckJiInHrFsEtDu1y;ch,e9;s,te;k,tD;!y;!ic;nt,r,se;!a7;bje8ff0il,oErDutli3Qver4B;bAd0ie9;ze;a4ReFoDur1;d,tD;e,i3;ed,gle8tD;!work;aMeKiIoEuD;rd0;ck,d3Rld,nEp,uDve;nt,th;it5EkD;ey;lk,n4Brr5CsDx;s,ta2B;asuBn4UrDss;ge,it;il,nFp,rk3WsEtD;ch,t0;h,k,t0;da5n0oeuvB;aLeJiHoEuD;mp,st;aEbby,ck,g,oDve;k,t;d,n;cDe,ft,mAnIst;en1k;aDc0Pe4vK;ch,d,k,p,se;bFcEnd,p,t4uD;gh,n4;e,k;el,o2U;eEiDno4E;ck,d,ll,ss;el,y;aEo1OuD;i3mp;m,zz;mpJnEr46ssD;ue;c1Rdex,fluGha2k,se2HteDvoi3;nt,rD;e6fa3viD;ew;en3;a8le2A;aJeHiGoEuD;g,nt;l3Ano2Dok,pDr1u1;!e;ghli1Fke,nt,re,t;aDd7lp;d,t;ck,mGndFrEsh,tDu9;ch,e;bo3Xm,ne4Eve6;!le;!m0;aMear,ift,lKossJrFuD;arDe4Alp,n;antee,d;aFiEoDumb2;uCwth;ll,nd,p;de,sp;ip;aBoDue;ss,w;g,in,me,ng,s,te,ze;aZeWiRlNoJrFuD;ck,el,nDss,zz;c38d;aEoDy;st,wn;cDgme,me,nchi1;tuB;cFg,il,ld,rD;ce,e29mDwa31;!at;us;aFe0Vip,oDy;at,ck,od,wD;!er;g,ke,me,re,sh,vo1E;eGgFlEnDre,sh,t,x;an3i0Q;e,m,t0;ht,uB;ld;aEeDn3;d,l;r,tuB;ce,il,ll,rm,vo2W;cho,d7ffe8nMsKxFyeD;!baD;ll;cGerci1hFpDtra8;eriDo0W;en3me9;au6ibA;el,han7u1;caDtima5;pe;count0d,vy;a01eSiMoJrEuDye;b,el,mp,pli2X;aGeFiEoD;ne,p;ft,ll,nk,p,ve;am,ss;ft,g,in;cEd7ubt,wnloD;ad;k,u0E;ge6p,sFt4vD;e,iDor3;de;char7gui1h,liEpD;at4lay,u5;ke;al,bKcJfeIlGmaCposAsEtaD;il;e07iD;gn,re;ay,ega5iD;ght;at,ct;li04rea1;a5ut;b,ma7n3rDte;e,t;a0Eent0Dh06irc2l03oKrFuD;be,e,rDt;b,e,l,ve;aGeFoEuDy;sh;p,ss,wd;dAep;ck,ft,sh;at,de,in,lTmMnFordina5py,re,st,uDv0;gh,nDp2rt;s01t;ceHdu8fli8glomeIsFtDveN;a8rD;a6ol;e9tru8;ct;ntDrn;ra5;bHfoGmFpD;leDouCromi1;me9;aCe9it,u5;rt;at,iD;ne;lap1oD;r,ur;aEiDoud,ub;ck,p;im,w;aEeDip;at,ck,er;iGllen7nErD;ge,m,t;ge,nD;el;n,r;er,re;ke,ll,mp,noe,pGrXsFtEuDve;se,ti0I;alog,ch;h,t;!tuB;re;a03eZiXlToPrHuEyD;pa11;bb2ck2dgEff0mp,rDst,zz;den,n;et;anJeHiFoadEuD;i1sh;ca6;be,d7;ge;aDed;ch,k;ch,d;aFg,mb,nEoDrd0tt2x,ycott;k,st,t;d,e;rd,st;aFeCiDoYur;nk,tz;nd;me;as,d,ke,nd,opsy,tD;!ch,e;aFef,lt,nDt;d,efA;it;r,t;ck,il,lan3nIrFsEtt2;le;e,h;!gDk;aDe;in;!d,g,k;bu1c05dZge,iYlVnTppQrLsIttGucEwaD;rd;tiD;on;aDempt;ck;k,sD;i6ocia5;st;chFmD;!oD;ur;!iD;ve;eEroa4;ch;al;chDg0sw0;or;aEt0;er;rm;d,m,r;dreHvD;an3oD;ca5;te;ce;ss;cDe,he,t;eFoD;rd,u9;nt;nt,ss;se",
  "Actor": "true\xA60:7B;1:7G;2:6A;3:7F;4:7O;5:7K;a6Nb62c4Ud4Be41f3Sg3Bh30i2Uj2Qkin2Pl2Km26n1Zo1Sp0Vqu0Tr0JsQtJuHvEw8yo6;gi,ut6;h,ub0;aAe9i8o7r6;estl0it0;m2rk0;fe,nn0t2Bza2H;atherm2ld0;ge earn0it0nder0rri1;eter7i6oyF;ll5Qp,s3Z;an,ina2U;n6s0;c6Uder03;aoisea23e9herapi5iktok0o8r6ut1yco6S;a6endseLo43;d0mp,nscri0Bvel0;ddl0u1G;a0Qchn7en6na4st0;ag0;i3Oo0D;aiXcUeRhPiMki0mu26oJpGquaFtBu7wee6;p0theart;lt2per7r6;f0ge6Iviv1;h6inten0Ist5Ivis1;ero,um2;a8ep7r6;ang0eam0;bro2Nc2Ofa2Nmo2Nsi20;ff0tesm2;tt0;ec7ir2Do6;kesp59u0M;ia5Jt3;l7me6An,rcere6ul;r,ss;di0oi5;n7s6;sy,t0;g0n0;am2ephe1Iow6;girl,m2r2Q;cretInior cit3Fr6;gea4v6;a4it1;hol4Xi7reen6ulpt1;wr2C;e01on;l1nt;aEe9o8u6;l0nn6;er up,ingE;g40le mod3Zof0;a4Zc8fug2Ppo32searQv6;ere4Uolution6;ary;e6luYru22;ptio3T;bbi,dic5Vpp0;arter6e2Z;back;aYeWhSiRlOoKr8sycho7u6;nk,p31;logi5;aGeDiBo6;d9fess1g7ph47s6;pe2Ktitu51;en6ramm0;it1y;igy,uc0;est4Nme mini0Unce6s3E;!ss;a7si6;de4;ch0;ctiti39nk0P;dca0Oet,li6pula50rnst42;c2Itic6;al scie6i2;nti5;a6umb0;nn0y6;er,ma4Lwright;lgrim,one0;a8iloso7otogra7ra6ysi1V;se;ph0;ntom,rmaci5;r6ssi1T;form0s4O;i3El,nel3Yr8st1tr6wn;i6on;arWot;ent4Wi42tn0;ccupa4ffBp8r7ut6;ca5l0B;ac4Iganiz0ig2Fph2;er3t6;i1Jomet6;ri5;ic0spring;aBe9ie4Xo7u6;n,rser3J;b6mad,vi4V;le2Vo4D;i6mesis,phew;ce,ghb1;nny,rr3t1X;aEeDiAo7u6yst1Y;m8si16;der3gul,m7n6th0;arDk;!my;ni7s6;f02s0Jt0;on,st0;chan1Qnt1rcha4;gi9k0n8rtyr,t6y1;e,riar6;ch;ag0iac;ci2stra3I;a7e2Aieutena4o6;rd,s0v0;bor0d7ndlo6ss,urea3Fwy0ym2;rd;!y;!s28;e8o7u6;ggl0;gg0urna2U;st0;c3Hdol,llu3Ummigra4n6; l9c1Qfa4habi42nov3s7ve6;nt1stig3;pe0Nt6;a1Fig3ru0M;aw;airFeBistoAo8u6ygie1K;man6sba2H;!ita8;bo,st6usekN;age,e3P;ri2;ir,r6;m7o6;!ine;it;dress0sty2C;aLeIhostGirl26ladi3oCrand7u6;e5ru;c9daug0Jfa8m7pa6s2Y;!re4;a,o6;th0;hi1B;al7d6lf0;!de3A;ie,k6te26;eep0;!wr6;it0;isha,n6;i6tl04;us;mbl0rden0;aDella,iAo7r6;eela2Nie1P;e,re6ster pare4;be1Hm2r6st0;unn0;an2ZgZlmm17nanci0r6tt0;e6st la2H; marsh2OfigXm2;rm0th0;conoEdDlectriCm8n7x6;amin0cellency,i2A;emy,trepreneur,vironmenta1J;c8p6;er1loye6;e,r;ee;ci2;it1;mi5;aKeBi8ork,ri7u6we02;de,tche2H;ft0v0;ct3eti7plom2Hre6va;ct1;ci2ti2;aDcor3fencCi0InAput9s7tectLvel6;op0;ce1Ge6ign0;rt0;ee,y;iz6;en;em2;c1Ml0;d8nc0redev7ug6;ht0;il;!dy;a06e04fo,hXitizenWlToBr9u6;r3stomer6;! representat6;ive;e3it6;ic;lJmGnAord9rpor1Nu7w6;boy,ork0;n6ri0;ciTte1Q;in3;fidantAgressSs9t6;e0Kr6;ibut1o6;ll0;tab13ul1O;!e;edi2m6pos0rade;a0EeQissi6;on0;leag8on7um6;ni5;el;ue;e6own;an0r6;ic,k;!s;a9e7i6um;ld;erle6f;ad0;ir7nce6plFract0;ll1;m2wI;lebri6o;ty;dBptAr6shi0;e7pe6;nt0;r,t6;ak0;ain;et;aMeLiJlogg0oErBu6;dd0Fild0rgl9siness6;m2p7w6;om2;ers05;ar;i7o6;!k0th0;cklay0de,gadi0;hemi2oge8y6;!frie6;nd;ym2;an;cyc6sR;li5;atbox0ings;by,nk0r6;b0on7te6;nd0;!e07;c04dWge4nQpLrHsFtAu7yatull6;ah;nt7t6;h1oG;!ie;h8t6;e6orney;nda4;ie5le6;te;sis00tron6;aut,om0;chbis8isto7tis6;an,t;crU;hop;ost9p6;ari6rentiS;ti6;on;le;a9cest1im3nou8y6;bo6;dy;nc0;ly5rc6;hi5;mi8v6;entur0is1;er;ni7r6;al;str3;at1;or;counBquaintanArob9t6;ivi5or,re6;ss;st;at;ce;ta4;nt",
  "Adj|Noun": "true\xA60:16;a1Db17c0Ud0Re0Mf0Dg0Ah08i06ju05l02mWnUoSpNrIsBt7u4v1watershed;a1ision0Z;gabo4nilla,ria1;b0Vnt;ndergr1pstairs;adua14ou1;nd;a3e1oken,ri0;en,r1;min0rori13;boo,n;age,e5ilv0Flack,o3quat,ta2u1well;bordina0Xper5;b0Lndard;ciali0Yl1vereign;e,ve16;cret,n1ri0;ior;a4e2ou1ubbiL;nd,tiY;ar,bBl0Wnt0p1side11;resent0Vublican;ci0Qsh;a4eriodic0last0Zotenti0r1;emi2incip0o1;!fession0;er,um;rall4st,tie0U;ff1pposi0Hv0;ens0Oi0C;agg01ov1uts;el;a5e3iniatJo1;bi01der07r1;al,t0;di1tr0N;an,um;le,riG;attOi2u1;sh;ber0ght,qC;stice,veniT;de0mpressioYn1;cumbe0Edividu0no0Dsta0Eterim;alf,o1umdrum;bby,melF;en2old,ra1;ph0Bve;er0ious;a7e5i4l3u1;git03t1;ure;uid;ne;llow,m1;aFiL;ir,t,vo1;riOuriO;l3p00x1;c1ecutUpeV;ess;d1iK;er;ar2e1;mographUrivO;k,l2;hiGlassSo2rude,unn1;ing;m5n1operK;creCstitueOte2vertab1;le;mpor1nt;ary;ic,m2p1;anion,lex;er2u1;ni8;ci0;al;e5lank,o4r1;i2u1;te;ef;ttom,urgeois;st;cadem9d6l2ntarct9r1;ab,ct8;e3tern1;at1;ive;rt;oles1ult;ce1;nt;ic",
  "Adj|Past": "true\xA60:4Q;1:4C;2:4H;3:4E;a44b3Tc36d2Je29f20g1Wh1Si1Jj1Gkno1Fl1Am15n12o0Xp0Mqu0Kr08sLtEuAv9w4yellow0;a7ea6o4rinkl0;r4u3Y;n,ri0;k31th3;rp0sh0tZ;ari0e1O;n5p4s0;d1li1Rset;cov3derstood,i4;fi0t0;a8e3Rhr7i6ouTr4urn0wi4C;a4imm0ou2G;ck0in0pp0;ed,r0;eat2Qi37;m0nn0r4;get0ni2T;aOcKeIhGimFm0Hoak0pDt7u4;bsid3Ogge44s4;pe4ta2Y;ct0nd0;a8e7i2Eok0r5u4;ff0mp0nn0;ength2Hip4;ed,p0;am0reotyp0;in0t0;eci4ik0oH;al3Efi0;pRul1;a4ock0ut;d0r0;a4c1Jle2t31;l0s3Ut0;a6or5r4;at4e25;ch0;r0tt3;t4ut0;is2Mur1;aEe5o4;tt0;cAdJf2Bg9je2l8m0Knew0p7qu6s4;eTpe2t4;or0ri2;e3Dir0;e1lac0;at0e2Q;i0Rul1;eiv0o4ycl0;mme2Lrd0v3;in0lli0ti2A;a4ot0;li28;aCer30iBlAo9r5u4;mp0zzl0;e6i2Oo4;ce2Fd4lo1Anou30pos0te2v0;uc0;fe1CocCp0Iss0;i2Kli1L;ann0e2CuS;ck0erc0ss0;ck0i2Hr4st0;allLk0;bse7c6pp13rgan2Dver4;lo4whelm0;ok0;cupi0;rv0;aJe5o4;t0uri1A;ed0gle2;a6e5ix0o4ut0ys1N;di1Nt15u26;as0Clt0;n4rk0;ag0ufact0A;e6i5o4;ad0ck0st,v0;cens0m04st0;ft,v4;el0;tt0wn;a5o15u4;dg0s1B;gg0;llumSmpAn4sol1;br0cre1Ldebt0f8jZspir0t5v4;it0olv0;e4ox0Y;gr1n4re23;d0si15;e2l1o1Wuri1;li0o01r4;ov0;a6e1o4um03;ok0r4;ri0Z;mm3rm0;i6r5u4;a1Bid0;a0Ui0Rown;ft0;aAe9i8l6oc0Ir4;a4i0oz0Y;ctHg19m0;avo0Ju4;st3;ni08tt0x0;ar0;d0il0sc4;in1;dCl1mBn9quipp0s8x4;agger1c6p4te0T;a0Se4os0;ct0rie1D;it0;cap0tabliZ;cha0XgFha1As4;ur0;a0Zbarra0N;i0Buc1;aMeDi5r4;a01i0;gni08miniSre2s4;a9c6grun0Ft4;o4re0Hu17;rt0;iplWou4;nt0r4;ag0;bl0;cBdRf9l8p7ra6t5v4;elop0ot0;ail0ermQ;ng0;re07;ay0ight0;e4in0o0M;rr0;ay0enTor1;m5t0z4;ed,zl0;ag0p4;en0;aPeLhIlHo9r6u4;lt4r0stom03;iv1;a5owd0u4;sh0;ck0mp0;d0loAm7n4ok0v3;centr1f5s4troC;id3olid1;us0;b5pl4;ic1;in0;r0ur0;assi9os0utt3;ar5i4;ll0;g0m0;lebr1n6r4;ti4;fi0;tralJ;g0lcul1;aDewild3iCl9o7r5urn4;ed,t;ok4uis0;en;il0r0t4und;tl0;e5i4;nd0;ss0;as0;ffl0k0laMs0tt3;bPcNdKfIg0lFmaz0nDppBrm0ss9u5wa4;rd0;g5thor4;iz0;me4;nt0;o6u4;m0r0;li0re4;ci1;im1ticip1;at0;a5leg0t3;er0;rm0;fe2;ct0;ju5o7va4;nc0;st0;ce4knowledg0;pt0;and5so4;rb0;on0;ed",
  "Singular": "true\xA60:5I;1:5G;2:4V;3:4R;4:51;5:56;6:5K;a4Zb4Ic3Ld33e2Vf2Mg2Hh26in22j21k20l1Sm1Jn1Fo19p0Pqu0Or0DsXtKuFvAw7x r55yo yo;a7ha3No3O;f3i4Ot0Ey7;! arou37;arAe8ideo ga2Oo7;cabu4Gl59;gMr7t;di4Wt1W;iety,ni4M;n9p2Yr8s 7;do41s5B;bani1in0;coordinat38der7;estima1to22we3Z; rex,aIeHhFiDoCr9u8v7;! show;m2Mn2rntJto1B;agedy,ib7o4B;e,u7;n0ta43;ni1p2rq3J;c,er,m7;etD;ing7ree24;!y;am,mp3D;ct2le6x return;aLcKeIhor4NiHkFoEpin off,tBu9y7;ll7ner4Jst4Q;ab2V;b7i1n26per bowl,rro1V;st3Jtot0;at8ipe2Eo1Jrate4Fudent7;! lo0G;i37u1;ft ser4Imeo1G;elet5i7;ll,r3S;b36gn2Rte;ab2Hc7min39;t,urity gua2L;e6ho2W;bbatic0la3Gndwi0Opi5;av5eBhetor2i8o7;de6om,w;t8v7;erb2A;e,u0;bBc9f7publ2r0Yspi1;er7orm3;e6r0;i7ord label;p2Ft0;a1u43;estion mark,ot2D;aNeKhoJiGlEoCr8u7yram1D;ddi3EpCrpo1Hs3G;e9o7;bl3Ws7;pe3Gta1;dic1Pmi1Dp1Oroga3Sss relea1D;p7rt0;py;a7ebisci1;q2Bte;cn2e8g7;!gy;!r;ne call,tocoI;anut,d8r7t0yo1;cen3Gsp3H;al,est0;nop4r8t7;e,hog5;adi0Zi2S;atme0bj3Cc9pia1rde0thers,utspok5ve7wn3;n,r7;ti0Nview;cu8e7;an;pi3;ar9it8ot7umb3;a2Chi2O;e,ra1;cot2ra34;aDeAi8o7ur0;nopo4p16rni2Ksq1Pti33uld;c,li0Zn08s7tt5;chief,si31;d8nu,t7;al,i3;al,ic;gna1mm0nd13rsupi0te7yf4;ri0;aBegAi9u7;ddi1n7;ch;me,p07; 9e0K;bor12y7; 7er;up;eyno1itt5;el4ourn0;c9dices,itia2Kni22s8tel0Jvert7;eb1H;e25titu1;en2Hi2Q;aGeCighBo8u7;man right,s1Z;me7rmoDsp1Dtb0I;! r7;un; scho0WriW;a7i1K;d7v5; start,pho7;ne;ndful,sh brown,v5ze;a9elat0Glaci3r7ul4yp1P;an7enadi3id;a19d slam,ny;df4r7;l2ni1F;aEeti1EiDlu1oAr8un7;er0;ee market,i7onti3;ga1;l4ur7;so7;me;eNref4;br2mi4;conoDffi1Mgg,lecto0Pmbas1BnApidem2s1Wth2ven9x8yel7;id;ampXempl0Lte6;i16t;er1Iterp7;ri7;se;my;eJiCo9r7ump tru0R;agonf4i7;er,ve thru;c8g1Bi4or,ssi3wn7;side;to0CumenC;aCgniBnn3s8vide7;nd;conte6incen1Bp7tri0Y;osi7;tion;ta0E;le0U;ath9c8f7ni0terre6;ault 03err0;al,im0;!b7;ed;aUeRhKiJlHoBr7;edit ca9uc7;ib7;le;rd;efficBke,lAmmuniqJns8pi3rr0t0Uus7yo1;in;erv7uG;atoZ;ic,lO;ie6;er0Li7oth;e6n2;ty,vil wK;aBeqAick5oco9r7;istmas car7ysanthemum;ol;la1;ue;ndeli3racteri7;st2;i8llCr7;e0tifica1;liW;hi3nDpCrAt7ucus;erpi7hedr0;ll7;ar;!bohyd7ri3;ra1;it0;a7e,nib0;l,ry;aKeJiop2leHoFrBu7;nny,r7tterf4;g7i0;la7;ry;eak8i7;ck;fa7thro9;st;dy,ro7wl;ugh;mi7;sh;an,l4;nki8rri3;er;ng;cQdKlGnDppeti1rBs9tt2utop7;sy;ic;ce6pe7;ct;r7sen0;ay;ec8oma4ti8;ly;do1;i5l7;er7y;gy;en; hominBj8van7;tage;ec7;ti7;ve;em;cAe8qui7;tt0;ta1;te;i8ru0;al;de6;nt",
  "Person|Noun": "true\xA6a0Eb07c03dWeUfQgOhLjHkiGlFmCnBolive,p7r4s3trini06v1wa0;ng,rd,tts;an,enus,iol0;a,et;ky,onPumm09;ay,e1o0uby;bin,d,se;ed,x;a2e1o0;l,tt04;aLnJ;dYge,tR;at,orm;a0eloW;t0x,ya;!s;a9eo,iH;ng,tP;a2e1o0;lGy;an,w3;de,smi4y;a0erb,iOolBuntR;ll,z0;el;ail,e0iLuy;ne;a1ern,i0lo;elds,nn;ith,n0;ny;a0dEmir,ula,ve;rl;a4e3i1j,ol0;ly;ck,x0;ie;an,ja;i0wn;sy;am,h0liff,rystal;a0in,ristian;mbers,ri0;ty;a4e3i2o,r0ud;an0ook;dy;ll;nedict,rg;k0nks;er;l0rt;fredo,ma",
  "Actor|Verb": "true\xA6aCb8c5doctor,engineAfool,g3host,judge,m2nerd,p1recruit,scout,ushAvolunteAwi0;mp,tneA;arent,ilot;an,ime;eek,oof,r0uide;adu8oom;ha1o0;ach,nscript,ok;mpion,uffeur;o2u0;lly,tch0;er;ss;ddi1ffili0rchite1;ate;ct",
  "MaleName": "true\xA60:H6;1:FZ;2:DS;3:GQ;4:CZ;5:FV;6:GM;7:FP;8:GW;9:ET;A:C2;B:GD;aF8bE1cCQdBMeASfA1g8Yh88i7Uj6Sk6Bl5Mm48n3So3Ip33qu31r26s1Et0Ru0Ov0CwTxSyHzC;aCor0;cChC1karia,nAT;!hDkC;!aF6;!ar7CeF5;aJevgenBSoEuC;en,rFVsCu3FvEF;if,uf;nDs6OusC;ouf,s6N;aCg;s,tC;an,h0;hli,nCrosE1ss09;is,nC;!iBU;avi2ho5;aPeNiDoCyaEL;jcieBJlfgang,odrFutR;lFnC;f8TsC;lCt1;ow;bGey,frEhe4QlC;aE5iCy;am,e,s;ed8iC;d,ed;eAur;i,ndeD2rn2sC;!l9t1;lDyC;l1ne;lDtC;!er;aCHy;aKernDAiFladDoC;jteB0lodymyr;!iC;mFQsDB;cFha0ktBZnceDrgCOvC;a0ek;!nC;t,zo;!e4StBV;lCnC7sily;!entC;in9J;ghE2lCm70nax,ri,sm0;riCyss87;ch,k;aWeRhNiLoGrEuDyC;!l2roEDs1;n6r6E;avD0eCist0oy,um0;ntCRvBKy;bFdAWmCny;!asDmCoharu;aFFie,y;!z;iA6y;mCt4;!my,othy;adEeoDia0SomC;!as;!dor91;!de4;dFrC;enBKrC;anBJeCy;ll,nBI;!dy;dgh,ha,iCnn2req,tsu5V;cDAka;aYcotWeThPiMlobod0oKpenc2tEurDvenAEyCzym1;ed,lvest2;aj,e9V;anFeDuC;!aA;fan17phEQvCwaA;e77ie;!islaCl9;v,w;lom1rBuC;leymaDHta;dDgmu9UlCm1yabonga;as,v8B;!dhart8Yn9;aEeClo75;lCrm0;d1t1;h9Jne,qu1Jun,wn,yne;aDbastiEDk2Yl5Mpp,rgCth,ymoCU;e1Dio;m4n;!tC;!ie,y;eDPlFmEnCq67tosCMul;dCj2UtiA5;e01ro;!iATkeB6mC4u5;!ik,vato9K;aZeUheC8iRoGuDyC;an,ou;b99dDf4peAssC;!elEG;ol00y;an,bLc7MdJel,geIh0lHmGnEry,sDyC;!ce;ar7Ocoe,s;!aCnBU;ld,n;an,eo;a7Ef;l7Jr;e3Eg2n9olfo,riC;go;bBNeDH;cCl9;ar87c86h54kCo;!ey,ie,y;cFeA3gDid,ubByCza;an8Ln06;g85iC;naC6s;ep;ch8Kfa5hHin2je8HlGmFndEoHpha5sDul,wi36yC;an,mo8O;h9Im4;alDSol3O;iD0on;f,ph;ul;e9CinC;cy,t1;aOeLhilJiFrCyoG;aDeC;m,st1;ka85v2O;eDoC;tr;r8GtC;er,ro;!ipCl6H;!p6U;dCLrcy,tC;ar,e9JrC;!o7;b9Udra8So9UscAHtri62ulCv8I;!ie,o7;ctav6Ji2lImHndrBRrGsDtCum6wB;is,to;aDc6k6m0vCwaBE;al79;ma;i,vR;ar,er;aDeksandr,ivC;er,i2;f,v;aNeLguyBiFoCu3O;aDel,j4l0ma0rC;beAm0;h,m;cFels,g5i9EkDlC;es,s;!au,h96l78olaC;!i,y;hCkCol76;ol75;al,d,il,ls1vC;ilAF;hom,tC;e,hC;anCy;!a5i5;aYeViLoGuDyC;l4Nr1;hamDr84staC;fa,p6E;ed,mG;di10e,hamEis4JntDritz,sCussa;es,he;e,y;ad,ed,mC;ad,ed;cGgu5hai,kFlEnDtchC;!e8O;a9Pik;house,o7t1;ae73eC3ha8Iolaj;ah,hDkC;!ey,y;aDeC;al,l;el,l;hDlv3rC;le,ri8Ev4T;di,met;ay0c00gn4hWjd,ks2NlTmadZnSrKsXtDuric7VxC;imilBKwe8B;eHhEi69tCus,y69;!eo,hCia7;ew,i67;eDiC;as,eu,s;us,w;j,o;cHiGkFlEqu8Qsha83tCv3;iCy;!m,n;in,on;el,o7us;a6Yo7us;!elCin,o7us;!l8o;frAEi5Zny,u5;achDcoCik;lm;ai,y;amDdi,e5VmC;oud;adCm6W;ou;aulCi9P;ay;aWeOiMloyd,oJuDyC;le,nd1;cFdEiDkCth2uk;a7e;gi,s,z;ov7Cv6Hw6H;!as,iC;a6Een;g0nn52renDuCvA4we7D;!iS;!zo;am,n4oC;n5r;a9Yevi,la5KnHoFst2thaEvC;eCi;nte;bo;nCpo8V;!a82el,id;!nC;aAy;mEnd1rDsz73urenCwr6K;ce,t;ry,s;ar,beAont;aOeIhalHiFla4onr63rDu5SylC;e,s;istCzysztof;i0oph2;er0ngsl9p,rC;ilA9k,ollos;ed,id;en0iGnDrmCv4Z;it;!dDnCt1;e2Ny;ri4Z;r,th;cp2j4mEna8BrDsp6them,uC;ri;im,l;al,il;a03eXiVoFuC;an,lCst3;en,iC;an,en,o,us;aQeOhKkub4AnIrGsDzC;ef;eDhCi9Wue;!ua;!f,ph;dCge;i,on;!aCny;h,s,th6J;anDnC;!ath6Hie,n72;!nC;!es;!l,sCy;ph;o,qu3;an,mC;!i,m6V;d,ffFns,rCs4;a7JemDmai7QoCry;me,ni1H;i9Dy;!e73rC;ey,y;cKdBkImHrEsDvi2yC;dBs1;on,p2;ed,oDrCv67;e6Qod;d,s61;al,es5Wis1;a,e,oCub;b,v;ob,qu13;aTbNchiMgLke53lija,nuKonut,rIsEtCv0;ai,suC;ki;aDha0i8XmaCsac;el,il;ac,iaC;h,s;a,vinCw3;!g;k,nngu6X;nac1Xor;ka;ai,rahC;im;aReLoIuCyd6;beAgGmFsC;eyDsC;a3e3;in,n;ber5W;h,o;m2raDsse3wC;a5Pie;c49t1K;a0Qct3XiGnDrC;beAman08;dr7VrC;iCy2N;!k,q1R;n0Tt3S;bKlJmza,nIo,rEsDyC;a5KdB;an,s0;lEo67r2IuCv9;hi5Hki,tC;a,o;an,ey;k,s;!im;ib;a08e00iUlenToQrMuCyorgy;iHnFsC;!taC;f,vC;!e,o;n6tC;er,h2;do,lC;herDlC;auCerQ;me;aEegCov2;!g,orC;!io,y;dy,h7C;dfr9nza3XrDttfC;ri6C;an,d47;!n;acoGlEno,oCuseppe;rgiCvan6O;!o,s;be6Ies,lC;es;mo;oFrC;aDha4HrC;it,y;ld,rd8;ffErgC;!e7iCy;!os;!r9;bElBrCv3;eCla1Nr4Hth,y;th;e,rC;e3YielC;!i4;aXeSiQlOorrest,rCyod2E;aHedFiC;edDtC;s,z;ri18;!d42eri11riC;ck,k;nCs2;cEkC;ie,lC;in,yn;esLisC;!co,z3M;etch2oC;ri0yd;d5lConn;ip;deriFliEng,rC;dinaCg4nan0B;nd8;pe,x;co;bCdi,hd;iEriC;ce,zC;io;an,en,o;benez2dZfrYit0lTmMnJo3rFsteb0th0ugenEvCymBzra;an,eCge4D;ns,re3K;!e;gi,iDnCrol,v3w3;est8ie,st;cCk;!h,k;o0DriCzo;co,qC;ue;aHerGiDmC;aGe3A;lCrh0;!iC;a10o,s;s1y;nu5;beAd1iEliDm2t1viCwood;n,s;ot28s;!as,j5Hot,sC;ha;a3en;!dGg6mFoDua2QwC;a2Pin;arC;do;oZuZ;ie;a04eTiOmitrNoFrag0uEwDylC;an,l0;ay3Hig4D;a3Gdl9nc0st3;minFnDri0ugCvydGy2S;!lF;!a36nCov0;e1Eie,y;go,iDykC;as;cCk;!k;i,y;armuFetDll1mitri7neCon,rk;sh;er,m6riC;ch;id;andLepak,j0lbeAmetri4nIon,rGsEvDwCxt2;ay30ey;en,in;hawn,moC;nd;ek,riC;ck;is,nC;is,y;rt;re;an,le,mKnIrEvC;e,iC;!d;en,iEne0PrCyl;eCin,yl;l45n;n,o,us;!iCny;el,lo;iCon;an,en,on;a0Fe0Ch03iar0lRoJrFuDyrC;il,us;rtC;!is;aEistC;iaCob12;no;ig;dy,lInErC;ey,neliCy;s,us;nEor,rDstaC;nt3;ad;or;by,e,in,l3t1;aHeEiCyde;fCnt,ve;fo0Xt1;menDt4;us;s,t;rFuDyC;!t1;dCs;e,io;enC;ce;aHeGrisC;!toC;phCs;!eC;!r;st2t;d,rCs;b5leC;s,y;cDdrCs6;ic;il;lHmFrC;ey,lDroCy;ll;!o7t1;er1iC;lo;!eb,v3;a09eZiVjorn,laUoSrEuCyr1;ddy,rtKst2;er;aKeFiEuDyC;an,ce,on;ce,no;an,ce;nDtC;!t;dDtC;!on;an,on;dFnC;dDisC;lav;en,on;!foOl9y;bby,gd0rCyd;is;i0Lke;bElDshC;al;al,lL;ek;nIrCshoi;at,nEtC;!raC;m,nd;aDhaCie;rd;rd8;!iDjam3nCs1;ie,y;to;kaMlazs,nHrC;n9rDtC;!holomew;eCy;tt;ey;dCeD;ar,iC;le;ar1Nb1Dd16fon15gust3hm12i0Zja0Yl0Bm07nTputsiSrGsaFugustEveDyCziz;a0kh0;ry;o,us;hi;aMchiKiJjun,mHnEon,tCy0;em,hCie,ur8;ur;aDoC;!ld;ud,v;aCin;an,nd8;!el,ki;baCe;ld;ta;aq;aMdHgel8tCw6;hoFoC;iDnC;!i8y;ne;ny;er7rCy;eDzC;ej;!as,i,j,s,w;!s;s,tolC;iCy;!y;ar,iEmaCos;nu5r;el;ne,r,t;aVbSdBeJfHiGl01onFphonsEt1vC;aPin;on;e,o;so,zo;!sR;!onZrC;ed;c,jaHksFssaHxC;!andC;er,rC;e,os,u;andCei;ar,er,r;ndC;ro;en;eDrecC;ht;rt8;dd3in,n,sC;taC;ir;ni;dDm6;ar;an,en;ad,eC;d,t;in;so;aGi,olErDvC;ik;ian8;f8ph;!o;mCn;!a;dGeFraDuC;!bakr,lfazl;hCm;am;!l;allFel,oulaye,ulC;!lDrahm0;an;ah,o;ah;av,on",
  "Uncountable": "true\xA60:2E;1:2L;2:33;a2Ub2Lc29d22e1Rf1Ng1Eh16i11j0Yk0Wl0Rm0Hn0Do0Cp03rZsLt9uran2Jv7w3you gu0E;a5his17i4oo3;d,l;ldlife,ne;rm8t1;apor,ernacul29i3;neg28ol1Otae;eDhBiAo8r4un3yranny;a,gst1B;aff2Oea1Ko4ue nor3;th;o08u3;bleshoot2Ose1Tt;night,othpas1Vwn3;foEsfoE;me off,n;er3und1;e,mod2S;a,nnis;aDcCeBhAi9ki8o7p6t4u3weepstak0;g1Unshi2Hshi;ati08e3;am,el;ace2Keci0;ap,cc1meth2C;n,ttl0;lk;eep,ingl0or1C;lf,na1Gri0;ene1Kisso1C;d0Wfe2l4nd,t3;i0Iurn;m1Ut;abi0e4ic3;e,ke15;c3i01laxa11search;ogni10rea10;a9e8hys7luto,o5re3ut2;amble,mis0s3ten20;en1Zs0L;l3rk;i28l0EyH; 16i28;a24tr0F;nt3ti0M;i0s;bstetri24vercrowd1Qxyg09;a5e4owada3utella;ys;ptu1Ows;il poliZtional securi2;aAe8o5u3;m3s1H;ps;n3o1K;ey,o3;gamy;a3cha0Elancholy,rchandi1Htallurgy;sl0t;chine3g1Aj1Hrs,thema1Q; learn1Cry;aught1e6i5ogi4u3;ck,g12;c,s1M;ce,ghtn18nguis1LteratWv1;ath1isVss;ara0EindergartPn3;icke0Aowled0Y;e3upit1;a3llyfiGwel0G;ns;ce,gnor6mp5n3;forma00ter3;net,sta07;atiSort3rov;an18;a7e6isto09o3ung1;ckey,mework,ne4o3rseradi8spitali2use arrest;ky;s2y;adquarteXre;ir,libut,ppiHs3;hi3te;sh;ene8l6o5r3um,ymnas11;a3eZ;niUss;lf,re;ut3yce0F;en; 3ti0W;edit0Hpo3;ol;aNicFlour,o4urnit3;ure;od,rgive3uri1wl;ness;arCcono0LducaBlectr9n7quip8thi0Pvery6x3;ist4per3;ti0B;en0J;body,o08th07;joy3tertain3;ment;ici2o3;ni0H;tiS;nings,th;emi02i6o4raugh3ynas2;ts;pe,wnstai3;rs;abet0ce,s3;honZrepu3;te;aDelciChAivi07l8o3urrency;al,ld w6mmenta5n3ral,ttIuscoB;fusiHt 3;ed;ry;ar;assi01oth0;es;aos,e3;eMwK;us;d,rO;a8i6lood,owlHread5u3;ntGtt1;er;!th;lliarJs3;on;g3ss;ga3;ge;cKdviJeroGirFmBn6ppeal court,r4spi3thleL;rin;ithmet3sen3;ic;i6y3;o4th3;ing;ne;se;en5n3;es2;ty;ds;craft;bi8d3nau7;yna3;mi6;ce;id,ous3;ti3;cs",
  "Infinitive": "true\xA60:9G;1:9T;2:AD;3:90;4:9Z;5:84;6:AH;7:A9;8:92;9:A0;A:AG;B:AI;C:9V;D:8R;E:8O;F:97;G:6H;H:7D;a94b8Hc7Jd68e4Zf4Mg4Gh4Ai3Qj3Nk3Kl3Bm34nou48o2Vp2Equ2Dr1Es0CtZuTvRwI;aOeNiLors5rI;eJiI;ng,te;ak,st3;d5e8TthI;draw,er;a2d,ep;i2ke,nIrn;d1t;aIie;liADniAry;nJpI;ho8Llift;cov1dJear8Hfound8DlIplug,rav82tie,ve94;eaAo3X;erIo;cut,go,staAFvalA3w2G;aSeQhNoMrIu73;aIe72;ffi3Smp3nsI;aBfo7CpI;i8oD;pp3ugh5;aJiJrIwaD;eat5i2;nk;aImA0;ch,se;ck3ilor,keImp1r8L;! paD;a0Ic0He0Fh0Bi0Al08mugg3n07o05p02qu01tUuLwI;aJeeIim;p,t5;ll7Wy;bNccMffLggeCmmKppJrI;mouFpa6Zvi2;o0re6Y;ari0on;er,i4;e7Numb;li9KmJsiIveD;de,st;er9it;aMe8MiKrI;ang3eIi2;ng27w;fIng;f5le;b,gg1rI;t3ve;a4AiA;a4UeJit,l7DoI;il,of;ak,nd;lIot7Kw;icEve;atGeak,i0O;aIi6;m,y;ft,ng,t;aKi6CoJriIun;nk,v6Q;ot,rt5;ke,rp5tt1;eIll,nd,que8Gv1w;!k,m;aven9ul8W;dd5tis1Iy;a0FeKiJoI;am,t,ut;d,p5;a0Ab08c06d05f01group,hea00iZjoi4lXmWnVpTq3MsOtMup,vI;amp,eJiIo3B;sEve;l,rI;e,t;i8rI;ie2ofE;eLiKpo8PtIurfa4;o24rI;aHiBuctu8;de,gn,st;mb3nt;el,hra0lIreseF;a4e71;d1ew,o07;aHe3Fo2;a7eFiIo6Jy;e2nq41ve;mbur0nf38;r0t;inKleBocus,rJuI;el,rbiA;aBeA;an4e;aBu4;ei2k8Bla43oIyc3;gni39nci3up,v1;oot,uI;ff;ct,d,liIp;se,ze;tt3viA;aAenGit,o7;aWerUinpoiFlumm1LoTrLuI;b47ke,niArIt;poDsuI;aFe;eMoI;cKd,fe4XhibEmo7noJpo0sp1tru6vI;e,i6o5L;un4;la3Nu8;aGclu6dJf1occupy,sup0JvI;a6BeF;etermi4TiB;aGllu7rtr5Ksse4Q;cei2fo4NiAmea7plex,sIva6;eve8iCua6;mp1rItrol,ve;a6It6E;bOccuNmEpMutLverIwe;l07sJtu6Yu0wI;helm;ee,h1F;gr5Cnu2Cpa4;era7i4Ipo0;py,r;ey,seItaH;r2ss;aMe0ViJoIultiply;leCu6Pw;micJnIspla4;ce,g3us;!k;iIke,na9;m,ntaH;aPeLiIo0u3N;ke,ng1quIv5;eIi6S;fy;aKnIss5;d,gI;th5;rn,ve;ng2Gu1N;eep,idnJnI;e4Cow;ap;oHuI;gg3xtaI;po0;gno8mVnIrk;cTdRfQgeChPitia7ju8q1CsNtKun6EvI;a6eIo11;nt,rt,st;erJimi6BoxiPrI;odu4u6;aBn,pr03ru6C;iCpi8tIu8;all,il,ruB;abEibE;eCo3Eu0;iIul9;ca7;i7lu6;b5Xmer0pI;aLer4Uin9ly,oJrI;e3Ais6Bo2;rt,se,veI;riA;le,rt;aLeKiIoiCuD;de,jaInd1;ck;ar,iT;mp1ng,pp5raIve;ng5Mss;ath1et,iMle27oLrI;aJeIow;et;b,pp3ze;!ve5A;gg3ve;aTer45i5RlSorMrJuI;lf4Cndrai0r48;eJiIolic;ght5;e0Qsh5;b3XeLfeEgJsI;a3Dee;eIi2;!t;clo0go,shIwa4Z;ad3F;att1ee,i36;lt1st5;a0OdEl0Mm0FnXquip,rWsVtGvTxI;aRcPeDhOiNpJtIu6;ing0Yol;eKi8lIo0un9;aHoI;it,re;ct,di7l;st,t;a3oDu3B;e30lI;a10u6;lt,mi28;alua7oI;ke,l2;chew,pou0tab19;a0u4U;aYcVdTfSgQhan4joy,lPqOrNsuMtKvI;e0YisI;a9i50;er,i4rI;aHenGuC;e,re;iGol0F;ui8;ar9iC;a9eIra2ulf;nd1;or4;ang1oIu8;r0w;irc3lo0ou0ErJuI;mb1;oaGy4D;b3ct;bKer9pI;hasiIow1;ze;aKody,rI;a4oiI;d1l;lm,rk;ap0eBuI;ci40de;rIt;ma0Rn;a0Re04iKo,rIwind3;aw,ed9oI;wn;agno0e,ff1g,mi2Kne,sLvI;eIul9;rIst;ge,t;aWbVcQlod9mant3pNru3TsMtI;iIoDu37;lJngI;uiA;!l;ol2ua6;eJlIo0ro2;a4ea0;n0r0;a2Xe36lKoIu0S;uIv1;ra9;aIo0;im;a3Kur0;b3rm;af5b01cVduBep5fUliTmQnOpMrLsiCtaGvI;eIol2;lop;ch;a20i2;aDiBloIoD;re,y;oIy;te,un4;eJoI;liA;an;mEv1;a4i0Ao06raud,y;ei2iMla8oKrI;ee,yI;!pt;de,mIup3;missi34po0;de,ma7ph1;aJrief,uI;g,nk;rk;mp5rk5uF;a0Dea0h0Ai09l08oKrIurta1G;a2ea7ipp3uI;mb3;ales4e04habEinci6ll03m00nIrro6;cXdUfQju8no7qu1sLtKvI;eIin4;ne,r9y;aHin2Bribu7;er2iLoli2Epi8tJuI;lt,me;itu7raH;in;d1st;eKiJoIroFu0;rm;de,gu8rm;ss;eJoI;ne;mn,n0;eIlu6ur;al,i2;buCe,men4pI;eIi3ly;l,te;eBi6u6;r4xiC;ean0iT;rcumveFte;eJirp,oI;o0p;riAw;ncIre5t1ulk;el;a02eSi6lQoPrKuI;iXrIy;st,y;aLeaKiJoad5;en;ng;stfeLtX;ke;il,l11mba0WrrMth1;eIow;ed;!coQfrie1LgPhMliLqueaKstJtrIwild1;ay;ow;th;e2tt3;a2eJoI;ld;ad;!in,ui3;me;bysEckfi8ff3tI;he;b15c0Rd0Iff0Ggree,l0Cm09n03ppZrXsQttOuMvJwaE;it;eDoI;id;rt;gIto0X;meF;aIeCraB;ch,in;pi8sJtoI;niA;aKeIi04u8;mb3rt,ss;le;il;re;g0Hi0ou0rI;an9i2;eaKly,oiFrI;ai0o2;nt;r,se;aMi0GnJtI;icipa7;eJoIul;un4y;al;ly0;aJu0;se;lga08ze;iKlI;e9oIu6;t,w;gn;ix,oI;rd;a03jNmiKoJsoI;rb;pt,rn;niIt;st1;er;ouJuC;st;rn;cLhie2knowled9quiItiva7;es4re;ce;ge;eQliOoKrJusI;e,tom;ue;mIst;moJpI;any,liA;da7;ma7;te;pt;andPduBet,i6oKsI;coKol2;ve;liArt,uI;nd;sh;de;ct;on",
  "Person": "true\xA60:1Q;a29b1Zc1Md1Ee18f15g13h0Ri0Qj0Nk0Jl0Gm09n06o05p00rPsItCusain bolt,v9w4xzibit,y1;anni,oko on2uji,v1;an,es;en,o;a3ednesday adams,i2o1;lfram,o0Q;ll ferrell,z khalifa;lt disn1Qr1;hol,r0G;a2i1oltai06;n dies0Zrginia wo17;lentino rossi,n goG;a4h3i2ripp,u1yra banks;lZpac shakur;ger woods,mba07;eresa may,or;kashi,t1ylor;um,ya1B;a5carlett johanss0h4i3lobodan milosevic,no2ocr1Lpider1uperm0Fwami; m0Em0E;op dogg,w whi1H;egfried,nbad;akespeaTerlock holm1Sia labeouf;ddam hussa16nt1;a cla11ig9;aAe6i5o3u1za;mi,n dmc,paul,sh limbau1;gh;bin hood,d stew16nald1thko;in0Mo;han0Yngo starr,valdo;ese witherspo0i1mbrandt;ll2nh1;old;ey,y;chmaninoff,ffi,iJshid,y roma1H;a4e3i2la16o1uff daddy;cahont0Ie;lar,p19;le,rZ;lm17ris hilt0;leg,prah winfr0Sra;a2e1iles cra1Bostradam0J; yo,l5tt06wmQ;pole0s;a5e4i2o1ubar03;by,lie5net,rriss0N;randa ju1tt romn0M;ly;rl0GssiaB;cklemo1rkov,s0ta hari,ya angelou;re;ady gaga,e1ibera0Pu;bron jam0Xch wale1e;sa;anye west,e3i1obe bryant;d cudi,efer suther1;la0P;ats,sha;a2effers0fk,k rowling,rr tolki1;en;ck the ripp0Mwaharlal nehru,y z;liTnez,ron m7;a7e5i3u1;lk hog5mphrey1sa01;! bog05;l1tl0H;de; m1dwig,nry 4;an;ile selassFlle ber4m3rrison1;! 1;ford;id,mo09;ry;ast0iannis,o1;odwPtye;ergus0lorence nightinga08r1;an1ederic chopN;s,z;ff5m2nya,ustaXzeki1;el;eril lagasse,i1;le zatop1nem;ek;ie;a6e4i2octor w1rake;ho;ck w1ego maradoC;olf;g1mi lovaOnzel washingt0;as;l1nHrth vadR;ai lNt0;a8h5lint0o1thulhu;n1olio;an,fuci1;us;on;aucKop2ristian baMy1;na;in;millo,ptain beefhe4r1;dinal wols2son1;! palmF;ey;art;a8e5hatt,i3oHro1;ck,n1;te;ll g1ng crosby;atB;ck,nazir bhut2rtil,yon1;ce;to;nksy,rack ob1;ama;l 6r3shton kutch2vril lavig8yn ra1;nd;er;chimed2istot1;le;es;capo2paci1;no;ne",
  "Adjective": "true\xA60:AI;1:BS;2:BI;3:BA;4:A8;5:84;6:AV;7:AN;8:AF;9:7H;A:BQ;B:AY;C:BC;D:BH;E:9Y;aA2b9Ec8Fd7We79f6Ng6Eh61i4Xj4Wk4Tl4Im41n3Po36p2Oquart7Pr2Ds1Dt14uSvOwFye29;aMeKhIiHoF;man5oFrth7G;dADzy;despreB1n w97s86;acked1UoleF;!sa6;ather1PeFll o70ste1D;!k5;nt1Ist6Ate4;aHeGiFola5T;bBUce versa,gi3Lle;ng67rsa5R;ca1gBSluAV;lt0PnLpHrGsFttermoBL;ef9Ku3;b96ge1; Hb32pGsFtiAH;ca6ide d4R;er,i85;f52to da2;a0Fbeco0Hc0Bd04e02f01gu1XheaBGiXkn4OmUnTopp06pRrNsJtHus0wF;aFiel3K;nt0rra0P;app0eXoF;ld,uS;eHi37o5ApGuF;perv06spec39;e1ok9O;en,ttl0;eFu5;cogn06gul2RlGqu84sF;erv0olv0;at0en33;aFrecede0E;id,rallel0;am0otic0;aFet;rri0tF;ch0;nFq26vers3;sur0terFv7U;eFrupt0;st0;air,inish0orese98;mploy0n7Ov97xpF;ect0lain0;eHisFocume01ue;clFput0;os0;cid0rF;!a8Scov9ha8Jlyi8nea8Gprivileg0sMwF;aFei9I;t9y;hGircumcFonvin2U;is0;aFeck0;lleng0rt0;b20ppea85ssuGttend0uthorF;iz0;mi8;i4Ara;aLeIhoHip 25oGrF;anspare1encha1i2;geth9leADp notch,rpB;rny,ugh6H;ena8DmpGrFs6U;r49tia4;eCo8P;leFst4M;nt0;a0Dc09e07h06i04ki03l01mug,nobbi4XoVpRqueami4XtKuFymb94;bHccinAi generis,pFr5;erFre7N;! dup9b,vi70;du0li7Lp6IsFurb7J;eq9Atanda9X;aKeJi16o2QrGubboFy4Q;rn;aightFin5GungS; fFfF;or7V;adfa9Pri6;lwa6Ftu82;arHeGir6NlendBot Fry;on;c3Qe1S;k5se; call0lImb9phistic16rHuFviV;ndFth1B;proof;dBry;dFub6; o2A;e60ipF;pe4shod;ll0n d7R;g2HnF;ceEg6ist9;am3Se9;co1Zem5lfFn6Are7; suf4Xi43;aGholFient3A;ar5;rlFt4A;et;cr0me,tisfac7F;aOeIheumatoBiGoF;bu8Ztt7Gy3;ghtFv3; 1Sf6X;cJdu8PlInown0pro69sGtF;ard0;is47oF;lu2na1;e1Suc45;alcit8Xe1ondi2;bBci3mpa1;aSePicayu7laOoNrGuF;bl7Tnjabi;eKiIoF;b7VfGmi49pFxi2M;er,ort81;a7uD;maFor,sti7va2;!ry;ciDexis0Ima2CpaB;in55puli8G;cBid;ac2Ynt 3IrFti2;ma40tFv7W;!i3Z;i2YrFss7R;anoBtF; 5XiF;al,s5V;bSffQkPld OnMrLth9utKverF;!aIbMdHhGni75seas,t,wF;ei74rou74;a63e7A;ue;ll;do1Ger,si6A;d3Qg2Aotu5Z; bFbFe on o7g3Uli7;oa80;fashion0school;!ay; gua7XbFha5Uli7;eat;eHligGsF;ce7er0So1C;at0;diFse;a1e1;aOeNiMoGuF;anc0de; moEnHrthFt6V;!eFwe7L;a7Krn;chaGdescri7Iprof30sF;top;la1;ght5;arby,cessa4ighbor5wlyw0xt;k0usiaFv3;ti8;aQeNiLoHuF;dIltiF;facet0p6;deHlGnFot,rbBst;ochro4Xth5;dy;rn,st;ddle ag0nF;dbloZi,or;ag9diocEga,naGrFtropolit4Q;e,ry;ci8;cIgenta,inHj0Fkeshift,mmGnFri4Oscu61ver18;da5Dy;ali4Lo4U;!stream;abEho;aOeLiIoFumberi8;ngFuti1R;stan3RtF;erm,i4H;ghtGteraF;l,ry,te;heart0wei5O;ft JgFss9th3;al,eFi0M;nda4;nguBps0te5;apGind5noF;wi8;ut;ad0itte4uniW;ce co0Hgno6Mll0Cm04nHpso 2UrF;a2releF;va1; ZaYcoWdReQfOgrNhibi4Ri05nMoLsHtFvalu5M;aAeF;nDrdepe2K;a7iGolFuboI;ub6ve1;de,gF;nifica1;rdi5N;a2er;own;eriIiLluenVrF;ar0eq5H;pt,rt;eHiGoFul1O;or;e,reA;fiFpe26termi5E;ni2;mpFnsideCrreA;le2;ccuCdeq5Ene,ppr4J;fFsitu,vitro;ro1;mJpF;arHeGl15oFrop9;li2r11;n2LrfeA;ti3;aGeFi18;d4BnD;tuE;egGiF;c0YteC;al,iF;tiF;ma2;ld;aOelNiLoFuma7;a4meInHrrGsFur5;ti6;if4E;e58o3U; ma3GsF;ick;ghfalut2HspF;an49;li00pf33;i4llow0ndGrdFtM; 05coEworki8;sy,y;aLener44iga3Blob3oKrGuF;il1Nng ho;aFea1Fizzl0;cGtF;ef2Vis;ef2U;ld3Aod;iFuc2D;nf2R;aVeSiQlOoJrF;aGeFil5ug3;q43tf2O;gFnt3S;i6ra1;lk13oHrF; keeps,eFge0Vm9tu41;g0Ei2Ds3R;liF;sh;ag4Mowe4uF;e1or45;e4nF;al,i2;d Gmini7rF;ti6ve1;up;bl0lDmIr Fst pac0ux;oGreacF;hi8;ff;ed,ili0R;aXfVlTmQnOqu3rMthere3veryday,xF;aApIquisi2traHuF;be48lF;ta1;!va2L;edRlF;icF;it;eAstF;whi6; Famor0ough,tiE;rou2sui2;erGiF;ne1;ge1;dFe2Aoq34;er5;ficF;ie1;g9sF;t,ygF;oi8;er;aWeMiHoGrFue;ea4owY;ci6mina1ne,r31ti8ubQ;dact2Jfficult,m,sGverF;ge1se;creGePjoi1paCtF;a1inA;et,te; Nadp0WceMfiLgeneCliJmuEpeIreliAsGvoF;id,ut;pFtitu2ul1L;eCoF;nde1;ca2ghF;tf13;a1ni2;as0;facto;i5ngero0I;ar0Ce09h07i06l05oOrIuF;rmudgeon5stoma4teF;sy;ly;aIeHu1EystalF; cleFli7;ar;epy;fFv17z0;ty;erUgTloSmPnGrpoCunterclVveFy;rt;cLdJgr21jIsHtrF;aFi2;dic0Yry;eq1Yta1;oi1ug3;escenFuN;di8;a1QeFiD;it0;atoDmensuCpF;ass1SulF;so4;ni3ss3;e1niza1;ci1J;ockwiD;rcumspeAvil;eFintzy;e4wy;leGrtaF;in;ba2;diac,ef00;a00ePiLliJoGrFuck nak0;and new,isk,on22;gGldface,naF; fi05fi05;us;nd,tF;he;gGpartisFzarE;an;tiF;me;autifOhiNlLnHsFyoN;iWtselF;li8;eGiFt;gn;aFfi03;th;at0oF;v0w;nd;ul;ckwards,rF;e,rT; priori,b13c0Zd0Tf0Ng0Ihe0Hl09mp6nt06pZrTsQttracti0MuLvIwF;aGkF;wa1B;ke,re;ant garGeraF;ge;de;diIsteEtF;heFoimmu7;nt07;re;to4;hGlFtu2;eep;en;bitIchiv3roHtF;ifiFsy;ci3;ga1;ra4;ry;pFt;aHetizi8rF;oprF;ia2;llFre1;ed,i8;ng;iquFsy;at0e;ed;cohKiJkaHl,oGriFterX;ght;ne,of;li7;ne;ke,ve;olF;ic;ad;ain07gressiIi6rF;eeF;ab6;le;ve;fGraB;id;ectGlF;ue1;ioF;na2; JaIeGvF;erD;pt,qF;ua2;ma1;hoc,infinitum;cuCquiGtu3u2;al;esce1;ra2;erSjeAlPoNrKsGuF;nda1;e1olu2trF;aAuD;se;te;eaGuF;pt;st;aFve;rd;aFe;ze;ct;ra1;nt",
  "Pronoun": "true\xA6elle,h3i2me,she,th0us,we,you;e0ou;e,m,y;!l,t;e,im",
  "Preposition": "true\xA6aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s a vis;n1p0;!on;like,til;h1ill,oward0;!s;an,ereby,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
  "SportsTeam": "true\xA60:18;1:1E;2:1D;3:14;a1Db15c0Sd0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Am01new UoRpKqueens parkJreal salt lake,sBt6utah jazz,vancouver whitecaps,w4yW;ashington 4h10;natio1Mredski2wizar0W;ampa bay 7e6o4;ronto 4ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasD;buccanee0ra0K;a8eattle 6porting kansas0Wt4; louis 4oke0V;c1Drams;marine0s4;eah13ounH;cramento Rn 4;antonio spu0diego 4francisco gJjose earthquak1;char08paB; ran07;a9h6ittsburgh 5ortland t4;imbe0rail blaze0;pirat1steele0;il4oenix su2;adelphia 4li1;eagl1philNunE;dr1;akland 4klahoma city thunder,rlando magic;athle0Lrai4;de0;england 8orleans 7york 4;g5je3knYme3red bul0Xy4;anke1;ian3;pelica2sain3;patrio3revolut4;ion;anchEeAi4ontreal impact;ami 8lwaukee b7nnesota 4;t5vi4;kings;imberwolv1wi2;rewe0uc0J;dolphi2heat,marli2;mphis grizz4ts;li1;a6eic5os angeles 4;clippe0dodFlaB;esterV; galaxy,ke0;ansas city 4nF;chiefs,roya0D; pace0polis col3;astr05dynamo,rocke3texa2;olden state warrio0reen bay pac4;ke0;allas 8e4i04od6;nver 6troit 4;lio2pisto2ti4;ge0;broncYnugge3;cowbo5maver4;icZ;ys;arEelLhAincinnati 8leveland 6ol4;orado r4umbus crew sc;api7ocki1;brow2cavalie0guar4in4;dia2;bengaVre4;ds;arlotte horAicago 4;b5cubs,fire,wh4;iteB;ea0ulQ;diff4olina panthe0; city;altimore Alackburn rove0oston 6rooklyn 4uffalo bilN;ne3;ts;cel5red4; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 4;brav1falco2h4;awA;ns;es;on villa,r4;os;c6di4;amondbac4;ks;ardi4;na4;ls",
  "Unit": "true\xA6a07b04cXdWexVfTgRhePinYjoule0BkMlJmDnan08oCp9quart0Bsq ft,t7volts,w6y2ze3\xB01\xB50;g,s;c,f,n;dVear1o0;ttR; 0s 0;old;att,b;erNon0;!ne02;ascals,e1i0;cXnt00;rcent,tJ;hms,unceY;/s,e4i0m\xB2,\xB2,\xB3;/h,cro2l0;e0liK;!\xB2;grLsR;gCtJ;it1u0;menQx;erPreP;b5elvins,ilo1m0notO;/h,ph,\xB2;!byGgrEmCs;ct0rtzL;aJogrC;allonJb0ig3rB;ps;a0emtEl oz,t4;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;\xB2,\xB3;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
  "Noun|Gerund": "true\xA60:3O;1:3M;2:3N;3:3D;4:32;5:2V;6:3E;7:3K;8:36;9:3J;A:3B;a3Pb37c2Jd27e23f1Vg1Sh1Mi1Ij1Gk1Dl18m13n11o0Wp0Pques0Sr0EsTtNunderMvKwFyDzB;eroi0oB;ni0o3P;aw2eB;ar2l3;aEed4hispe5i5oCrB;ap8est3i1;n0ErB;ki0r31;i1r2s9tc9;isualizi0oB;lunt1Vti0;stan4ta6;aFeDhin6iCraBy8;c6di0i2vel1M;mi0p8;aBs1;c9si0;l6n2s1;aUcReQhOiMkatKl2Wmo6nowJpeItFuCwB;ea5im37;b35f0FrB;fi0vB;e2Mi2J;aAoryt1KrCuB;d2KfS;etc9ugg3;l3n4;bCi0;ebBi0;oar4;gnBnAt1;a3i0;ip8oB;p8rte2u1;a1r27t1;hCo5reBulp1;a2Qe2;edu3oo3;i3yi0;aKeEi4oCuB;li0n2;oBwi0;fi0;aFcEhear7laxi0nDpor1sB;pon4tructB;r2Iu5;de5;or4yc3;di0so2;p8ti0;aFeacek20laEoCrBublis9;a1Teten4in1oces7;iso2siB;tio2;n2yi0;ckaAin1rB;ki0t1O;fEpeDrganiCvB;erco24ula1;si0zi0;ni0ra1;fe5;avi0QeBur7;gotia1twor6;aDeCi2oB;de3nito5;a2dita1e1ssaA;int0XnBrke1;ifUufactu5;aEeaDiBodAyi0;cen7f1mi1stB;e2i0;r2si0;n4ug9;iCnB;ea4it1;c6l3;ogAuB;dAgg3stif12;ci0llust0VmDnBro2;nova1sp0NterBven1;ac1vie02;agi2plo4;aDea1iCoBun1;l4w3;ki0ri0;nd3rB;roWvB;es1;aCene0Lli4rBui4;ee1ie0N;rde2the5;aHeGiDlCorBros1un4;e0Pmat1;ir1oo4;gh1lCnBs9;anZdi0;i0li0;e3nX;r0Zscina1;a1du01nCxB;erci7plo5;chan1di0ginB;ee5;aLeHiGoub1rCum8wB;el3;aDeCiB;bb3n6vi0;a0Qs7;wi0;rTscoDvi0;ba1coZlBvelo8;eCiB;ve5;ga1;nGti0;aVelebUhSlPoDrBur3yc3;aBos7yi0;f1w3;aLdi0lJmFnBo6pi0ve5;dDsCvinB;ci0;trBul1;uc1;muniDpB;lBo7;ai2;ca1;lBo5;ec1;c9ti0;ap8eaCimToBubT;ni0t9;ni0ri0;aBee5;n1t1;ra1;m8rCs1te5;ri0;vi0;aPeNitMlLoGrDuB;dge1il4llBr8;yi0;an4eat9oadB;cas1;di0;a1mEokB;i0kB;ee8;pi0;bi0;es7oa1;c9i0;gin2lonAt1;gi0;bysit1c6ki0tt3;li0;ki0;bando2cGdverti7gi0pproac9rgDssuCtB;trac1;mi0;ui0;hi0;si0;coun1ti0;ti0;ni0;ng",
  "PhrasalVerb": "true\xA60:92;1:96;2:8H;3:8V;4:8A;5:83;6:85;7:98;8:90;9:8G;A:8X;B:8R;C:8U;D:8S;E:70;F:97;G:8Y;H:81;I:7H;J:79;a9Fb7Uc6Rd6Le6Jf5Ig50h4Biron0j47k40l3Em31n2Yo2Wp2Cquiet Hr1Xs0KtZuXvacuu6QwNyammerBzK;ero Dip LonK;e0k0;by,ov9up;aQeMhLiKor0Mrit19;mp0n3Fpe0r5s5;ackAeel Di0S;aLiKn33;gh 3Wrd0;n Dr K;do1in,oJ;it 79k5lk Lrm 69sh Kt83v60;aw3do1o7up;aw3in,oC;rgeBsK;e 2herE;a00eYhViRoQrMuKypP;ckErn K;do1in,oJup;aLiKot0y 30;ckl7Zp F;ck HdK;e 5Y;n7Wp 3Es5K;ck MdLe Kghten 6me0p o0Rre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Lrow K;aw3ba4in,up;ba4ov9up;aKe 77ll62;m 2r 5M;ckBke Llk K;ov9shit,u47;aKba4do1in,leave,o4Dup;ba4ft9pa69w3;a0Vc0Te0Mh0Ii0Fl09m08n07o06p01quar5GtQuOwK;earMiK;ngLtch K;aw3ba4o8K; by;cKi6Bm 2ss0;k 64;aReQiPoNrKud35;aigh2Det75iK;ke 7Sng K;al6Yup;p Krm2F;by,in,oG;c3Ln3Lr 2tc4O;p F;c3Jmp0nd LrKveAy 2O;e Ht 2L;ba4do1up;ar3GeNiMlLrKurB;ead0ingBuc5;a49it 6H;c5ll o3Cn 2;ak Fe1Xll0;a3Bber 2rt0und like;ap 5Vow Duggl5;ash 6Noke0;eep NiKow 6;cLp K;o6Dup;e 68;in,oK;ff,v9;de19gn 4NnKt 6Gz5;gKkE; al6Ale0;aMoKu5W;ot Kut0w 7M;aw3ba4f48oC;c2WdeEk6EveA;e Pll1Nnd Orv5tK; Ktl5J;do1foLin,o7upK;!on;ot,r5Z;aw3ba4do1in,o33up;oCto;al66out0rK;ap65ew 6J;ilAv5;aXeUiSoOuK;b 5Yle0n Kstl5;aLba4do1inKo2Ith4Nu5P;!to;c2Xr8w3;ll Mot LpeAuK;g3Ind17;a2Wf3Po7;ar8in,o7up;ng 68p oKs5;ff,p18;aKelAinEnt0;c6Hd K;o4Dup;c27t0;aZeYiWlToQrOsyc35uK;ll Mn5Kt K;aKba4do1in,oJto47up;pa4Dw3;a3Jdo1in,o21to45up;attleBess KiNop 2;ah2Fon;iLp Kr4Zu1Gwer 6N;do1in,o6Nup;nt0;aLuK;gEmp 6;ce u20y 6D;ck Kg0le 4An 6p5B;oJup;el 5NncilE;c53ir 39n0ss MtLy K;ba4oG; Hc2R;aw3ba4in,oJ;pKw4Y;e4Xt D;aLerd0oK;dAt53;il Hrrow H;aTeQiPoLuK;ddl5ll I;c1FnkeyMp 6uthAve K;aKdo1in,o4Lup;l4Nw3; wi4K;ss0x 2;asur5e3SlLss K;a21up;t 6;ke Ln 6rKs2Ax0;k 6ryA;do,fun,oCsure,up;a02eViQoLuK;ck0st I;aNc4Fg MoKse0;k Kse4D;aft9ba4do1forw37in56o0Zu46;in,oJ;d 6;e NghtMnLsKve 00;ten F;e 2k 2; 2e46;ar8do1in;aMt LvelK; oC;do1go,in,o7up;nEve K;in,oK;pKut;en;c5p 2sh LtchBughAy K;do1o59;in4Po7;eMick Lnock K;do1oCup;oCup;eLy K;in,up;l Ip K;aw3ba4do1f04in,oJto,up;aMoLuK;ic5mpE;ke3St H;c43zz 2;a01eWiToPuK;nLrrKsh 6;y 2;keLt K;ar8do1;r H;lKneErse3K;d Ke 2;ba4dKfast,o0Cup;ear,o1;de Lt K;ba4on,up;aw3o7;aKlp0;d Ml Ir Kt 2;fKof;rom;f11in,o03uW;cPm 2nLsh0ve Kz2P;at,it,to;d Lg KkerP;do1in,o2Tup;do1in,oK;ut,v9;k 2;aZeTive Rloss IoMrLunK; f0S;ab hold,in43ow 2U; Kof 2I;aMb1Mit,oLr8th1IuK;nd9;ff,n,v9;bo7ft9hQw3;aw3bKdo1in,oJrise,up,w3;a4ir2H;ar 6ek0t K;aLb1Fdo1in,oKr8up;ff,n,ut,v9;cLhKl2Fr8t,w3;ead;ross;d aKng 2;bo7;a0Ee07iYlUoQrMuK;ck Ke2N;ar8up;eLighten KownBy 2;aw3oG;eKshe27; 2z5;g 2lMol Krk I;aKwi20;bo7r8;d 6low 2;aLeKip0;sh0;g 6ke0mKrKtten H;e F;gRlPnNrLsKzzle0;h F;e Km 2;aw3ba4up;d0isK;h 2;e Kl 1T;aw3fPin,o7;ht ba4ure0;ePnLsK;s 2;cMd K;fKoG;or;e D;d04l 2;cNll Krm0t1G;aLbKdo1in,o09sho0Eth08victim;a4ehi2O;pa0C;e K;do1oGup;at Kdge0nd 12y5;in,o7up;aOi1HoNrK;aLess 6op KuN;aw3b03in,oC;gBwB; Ile0ubl1B;m 2;a0Ah05l02oOrLut K;aw3ba4do1oCup;ackBeep LoKy0;ss Dwd0;by,do1in,o0Uup;me NoLuntK; o2A;k 6l K;do1oG;aRbQforOin,oNtKu0O;hLoKrue;geth9;rough;ff,ut,v9;th,wK;ard;a4y;paKr8w3;rt;eaLose K;in,oCup;n 6r F;aNeLiK;ll0pE;ck Der Kw F;on,up;t 2;lRncel0rOsMtch LveE; in;o1Nup;h Dt K;doubt,oG;ry LvK;e 08;aw3oJ;l Km H;aLba4do1oJup;ff,n,ut;r8w3;a0Ve0MiteAl0Fo04rQuK;bblNckl05il0Dlk 6ndl05rLsKtMy FzzA;t 00;n 0HsK;t D;e I;ov9;anWeaUiLush K;oGup;ghQng K;aNba4do1forMin,oLuK;nd9p;n,ut;th;bo7lKr8w3;ong;teK;n 2;k K;do1in,o7up;ch0;arTg 6iRn5oPrNssMttlLunce Kx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aPeed0oKurt0;cMw K;aw3ba4do1o7up;ck;k K;in,oC;ck0nk0stA; oQaNef 2lt0nd K;do1ov9up;er;up;r Lt K;do1in,oCup;do1o7;ff,nK;to;ck Pil0nMrgLsK;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdQir0sk MuctionA; oG;ff;ar8o7;ouK;nd; o7;d K;do1oKup;ff,n;wn;o7up;ut",
  "ProperNoun": "true\xA6abid,barbie,c3e2f1iron maiden,kirby,m0nis,riel;cgill,ercedes,issy;lorence,ranco;lmo,uro;atalina,hristi",
  "Person|Place": "true\xA6a8d6h4jordan,k3orlando,s1vi0;ctor9rgin9;a0ydney;lvador,mara,ntia4;ent,obe;amil0ous0;ton;arw2ie0;go;lexandr1ust0;in;ia",
  "LastName": "true\xA60:BR;1:BF;2:B5;3:BH;4:AX;5:9Y;6:B6;7:BK;8:B0;9:AV;A:AL;B:8Q;C:8G;D:7K;E:BM;F:AH;aBDb9Zc8Wd88e81f7Kg6Wh64i60j5Lk4Vl4Dm39n2Wo2Op25quispe,r1Ls0Pt0Ev03wTxSyKzG;aIhGimmerm6A;aGou,u;ng,o;khar5ytsE;aKeun9BiHoGun;koya32shiBU;!lG;diGmaz;rim,z;maGng;da,g52mo83sGzaC;aChiBV;iao,u;aLeJiHoGright,u;jcA5lff,ng;lGmm0nkl0sniewsC;kiB1liams33s3;bGiss,lt0;b,er,st0;a6Vgn0lHtG;anabe,s3;k0sh,tG;e2Non;aLeKiHoGukD;gt,lk5roby5;dHllalGnogr3Kr1Css0val3S;ba,ob1W;al,ov4;lasHsel8W;lJn dIrgBEsHzG;qu7;ilyEqu7siljE;en b6Aijk,yk;enzueAIverde;aPeix1VhKi2j8ka43oJrIsui,uG;om5UrG;c2n0un1;an,emblA7ynisC;dorAMlst3Km4rrAth;atch0i8UoG;mHrG;are84laci79;ps3sG;en,on;hirDkah9Mnaka,te,varA;a06ch01eYhUiRmOoMtIuHvGzabo;en9Jobod3N;ar7bot4lliv2zuC;aIeHoG;i7Bj4AyanAB;ele,in2FpheBvens25;l8rm0;kol5lovy5re7Tsa,to,uG;ng,sa;iGy72;rn5tG;!h;l71mHnGrbu;at9cla9Egh;moBo7M;aIeGimizu;hu,vchG;en8Luk;la,r1G;gu9infe5YmGoh,pulveA7rra5P;jGyG;on5;evi6iltz,miHneid0roed0uGwarz;be3Elz;dHtG;!t,z;!t;ar4Th8ito,ka4OlJnGr4saCto,unde19v4;ch7dHtGz;a5Le,os;b53e16;as,ihDm4Po0Y;aVeSiPoJuHyG;a6oo,u;bio,iz,sG;so,u;bKc8Fdrigue67ge10j9YmJosevelt,sItHux,wG;e,li6;a9Ch;enb4Usi;a54e4L;erts15i93;bei4JcHes,vGzzo;as,e9;ci,hards12;ag2es,iHut0yG;es,nol5N;s,t0;dImHnGsmu97v6C;tan1;ir7os;ic,u;aUeOhMiJoHrGut8;asad,if6Zochazk27;lishc2GpGrti72u10we76;e3Aov51;cHe45nG;as,to;as70hl0;aGillips;k,m,n6I;a3Hde3Wete0Bna,rJtG;ersHrovGters54;!a,ic;!en,on;eGic,kiBss3;i9ra,tz,z;h86k,padopoulIrk0tHvG;ic,l4N;el,te39;os;bMconn2Ag2TlJnei6PrHsbor6XweBzG;dem7Rturk;ella4DtGwe6N;ega,iz;iGof7Hs8I;vGyn1R;ei9;aSri1;aPeNiJoGune50ym2;rHvGwak;ak4Qik5otn66;odahl,r4S;cholsZeHkolGls4Jx3;ic,ov84;ls1miG;!n1;ils3mG;co4Xec;gy,kaGray2sh,var38;jiGmu9shiG;ma;a07c04eZiWoMuHyeG;rs;lJnIrGssoli6S;atGp03r7C;i,ov4;oz,te58;d0l0;h2lOnNo0RrHsGza1A;er,s;aKeJiIoz5risHtG;e56on;!on;!n7K;au,i9no,t5J;!lA;r1Btgome59;i3El0;cracFhhail5kkeHlG;l0os64;ls1;hmeJiIj30lHn3Krci0ssiGyer2N;!er;n0Po;er,j0;dDti;cartHlG;aughl8e2;hy;dQe7Egnu68i0jer3TkPmNnMrItHyG;er,r;ei,ic,su21thews;iHkDquAroqu8tinG;ez,s;a5Xc,nG;!o;ci5Vn;a5UmG;ad5;ar5e6Kin1;rig77s1;aVeOiLoJuHyG;!nch;k4nGo;d,gu;mbarGpe3Fvr4we;di;!nGu,yana2B;coln,dG;b21holm,strom;bedEfeKhIitn0kaHn8rGw35;oy;!j;m11tG;in1on1;bvGvG;re;iGmmy,ng,rs2Qu,voie,ws3;ne,t1F;aZeYh2iWlUnez50oNrJuHvar2woG;k,n;cerGmar68znets5;a,o34;aHem0isGyeziu;h23t3O;m0sni4Fus3KvG;ch4O;bay57ch,rh0Usk16vaIwalGzl5;czGsC;yk;cIlG;!cGen4K;huk;!ev4ic,s;e8uiveG;rt;eff0kGl4mu9nnun1;ucF;ll0nnedy;hn,llKminsCne,pIrHstra3Qto,ur,yGzl5;a,s0;j0Rls22;l2oG;or;oe;aPenOha6im14oHuG;ng,r4;e32hInHrge32u6vG;anD;es,ss3;anHnsG;en,on,t3;nesGs1R;en,s1;kiBnings,s1;cJkob4EnGrv0E;kDsG;en,sG;en0Ion;ks3obs2A;brahimDglesi5Nke5Fl0Qno07oneIshikHto,vanoG;u,v54;awa;scu;aVeOiNjaltal8oIrist50uG;!aGb0ghAynh;m2ng;a6dz4fIjgaa3Hk,lHpUrGwe,x3X;ak1Gvat;mAt;er,fm3WmG;ann;ggiBtchcock;iJmingw4BnHrGss;nand7re9;deGriks1;rs3;kkiHnG;on1;la,n1;dz4g1lvoQmOns0ZqNrMsJuIwHyG;asFes;kiB;g1ng;anHhiG;mo14;i,ov0J;di6p0r10t;ue;alaG;in1;rs1;aVeorgUheorghe,iSjonRoLrJuGw3;errGnnar3Co,staf3Ctierr7zm2;a,eG;ro;ayli6ee2Lg4iffithGub0;!s;lIme0UnHodGrbachE;e,m2;calvAzale0S;dGubE;bGs0E;erg;aj,i;bs3l,mGordaO;en7;iev3U;gnMlJmaIndFo,rGsFuthi0;cGdn0za;ia;ge;eaHlG;agh0i,o;no;e,on;aVerQiLjeldsted,lKoIrHuG;chs,entAji41ll0;eem2iedm2;ntaGrt8urni0wl0;na;emi6orA;lipIsHtzgeraG;ld;ch0h0;ovG;!ic;hatDnanIrG;arGei9;a,i;deY;ov4;b0rre1D;dKinsJriksIsGvaB;cob3GpGtra3D;inoza,osiQ;en,s3;te8;er,is3warG;ds;aXePiNjurhuMoKrisco15uHvorakG;!oT;arte,boHmitru,nn,rGt3C;and,ic;is;g2he0Omingu7nErd1ItG;to;us;aGcki2Hmitr2Ossanayake,x3;s,z; JbnaIlHmirGrvisFvi,w2;!ov4;gado,ic;th;bo0groot,jo6lHsilGvriA;va;a cruz,e3uG;ca;hl,mcevsCnIt2WviG;dGes,s;ov,s3;ielsGku22;!en;ki;a0Be06hRiobQlarkPoIrGunningh1H;awfo0RivGuz;elli;h1lKntJoIrGs2Nx;byn,reG;a,ia;ke,p0;i,rer2K;em2liB;ns;!e;anu;aOeMiu,oIristGu6we;eGiaG;ns1;i,ng,p9uHwGy;!dH;dGng;huJ;!n,onGu6;!g;kJnIpm2ttHudhGv7;ry;erjee,o14;!d,g;ma,raboG;rty;bJl0Cng4rG;eghetHnG;a,y;ti;an,ota1C;cerAlder3mpbeLrIstGvadi0B;iGro;llo;doHl0Er,t0uGvalho;so;so,zo;ll;a0Fe01hYiXlUoNrKuIyG;rLtyG;qi;chan2rG;ke,ns;ank5iem,oGyant;oks,wG;ne;gdan5nIruya,su,uchaHyKziG;c,n5;rd;darGik;enG;ko;ov;aGond15;nco,zG;ev4;ancFshw16;a08oGuiy2;umGwmG;ik;ckRethov1gu,ktPnNrG;gJisInG;ascoGds1;ni;ha;er,mG;anG;!n;gtGit7nP;ss3;asF;hi;er,hG;am;b4ch,ez,hRiley,kk0ldw8nMrIshHtAu0;es;ir;bInHtlGua;ett;es,i0;ieYosa;dGik;a9yoG;padhyG;ay;ra;k,ng;ic;bb0Acos09d07g04kht05lZnPrLsl2tJyG;aHd8;in;la;chis3kiG;ns3;aImstro6sl2;an;ng;ujo,ya;dJgelHsaG;ri;ovG;!a;ersJov,reG;aGjEws;ss1;en;en,on,s3;on;eksejEiyEmeiIvG;ar7es;ez;da;ev;arwHuilG;ar;al;ams,l0;er;ta;as",
  "Ordinal": "true\xA6eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
  "Cardinal": "true\xA6bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
  "Multiple": "true\xA6b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
  "City": "true\xA60:74;1:61;2:6G;3:6J;4:5S;a68b53c4Id48e44f3Wg3Hh39i31j2Wk2Fl23m1Mn1Co19p0Wq0Ur0Os05tRuQvLwDxiBy9z5;a7h5i4Muri4O;a5e5ongsh0;ng3H;greb,nzib5G;ang2e5okoha3Sunfu;katerin3Hrev0;a5n0Q;m5Hn;arsBeAi6roclBu5;h0xi,zh5P;c7n5;d5nipeg,terth4;hoek,s1L;hi5Zkl3A;l63xford;aw;a8e6i5ladivost5Molgogr6L;en3lni6S;ni22r5;o3saill4N;lenc4Wncouv3Sr3ughn;lan bat1Crumqi,trecht;aFbilisi,eEheDiBo9r7u5;l21n63r5;in,ku;i5ondh62;es51poli;kyo,m2Zron1Pulo5;n,uS;an5jua3l2Tmisoa6Bra3;j4Tshui; hag62ssaloni2H;gucigal26hr0l av1U;briz,i6llinn,mpe56ng5rtu,shk2R;i3Esh0;an,chu1n0p2Eyu0;aEeDh8kopje,owe1Gt7u5;ra5zh4X;ba0Ht;aten is55ockholm,rasbou67uttga2V;an8e6i5;jiazhua1llo1m5Xy0;f50n5;ya1zh4H;gh3Kt4Q;att45o1Vv44;cramen16int ClBn5o paulo,ppo3Rrajevo; 7aa,t5;a 5o domin3E;a3fe,m1M;antonio,die3Cfrancisco,j5ped3Nsalvad0J;o5u0;se;em,t lake ci5Fz25;lou58peters24;a9e8i6o5;me,t59;ga,o5yadh;! de janei3F;cife,ims,nn3Jykjavik;b4Sip4lei2Inc2Pwalpindi;ingdao,u5;ez2i0Q;aFeEhDiCo9r7u6yong5;ya1;eb59ya1;a5etor3M;g52to;rt5zn0; 5la4Co;au prin0Melizabe24sa03;ls3Prae5Atts26;iladelph3Gnom pe1Aoenix;ki1r21tah tik3E;dua,lerYnaji,r4Ot5;na,r32;ak44des0Km1Mr6s5ttawa;a3Vlo;an,d06;a7ew5ing2Fovosibir1Jyc; 5cast36;del24orlea44taip14;g8iro4Wn5pl2Wshv33v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0W;aEeCi9o6u5;mb2Ani26sc3Y;gadishu,nt6s5;c13ul;evideo,pelli1Rre2Z;ami,l6n14s5;kolc,sissauga;an,waukee;cca,d5lbour2Mmph41ndo1Cssi3;an,ell2Xi3;cau,drAkass2Sl9n8r5shh4A;aca6ib5rakesh,se2L;or;i1Sy;a4EchFdal0Zi47;mo;id;aDeAi8o6u5vSy2;anMckn0Odhia3;n5s angel26;d2g bea1N;brev2Be3Lma5nz,sb2verpo28;!ss27; ma39i5;c5pzig;est16; p6g5ho2Wn0Cusan24;os;az,la33;aHharFiClaipeBo9rak0Du7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Hlka2Xpavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bHdu3llakuric0Qmpa3Fn6ohsiu1ra5un1Iwaguc0Q;c0Pj;d5o,p4;ah1Ty;a7e6i5ohannesV;l1Vn0;dd36rusalem;ip4k5;ar2H;bad0mph1OnArkutUs7taXz5;mir,tapala5;pa;fah0l6tanb5;ul;am2Zi2H;che2d5;ianap2Mo20;aAe7o5yder2W; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Oupe;ld coa1Bthen5;bu2S;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal29es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Zr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1Q;lo7n6penhag0Ar5;do1Ok;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber1Ac5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0BkFn9ot8r7s6yan n4;ur;el,r07;celo3i,ranquil09;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a05b02cc01ddis aba00gartaZhmedXizawl,lSmPnHqa00rEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaOtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 7buquerq6eppo,giers,ma5;ty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
  "Region": "true\xA60:2K;1:2Q;2:2H;3:2B;a2Ob2Bc1Xd1Ses1Rf1Pg1Kh1Gi1Bj17k12l0Zm0On06o04pYqVrSsJtEuBverAw6y4zacatec2S;akut0o0Cu4;cat2k06;a5est 4isconsin,yomi1K;bengal,virgin0;rwick3shington4;! dc;acruz,mont;dmurt0t4;ah,tar4; 2La0Y;a6e5laxca1Rripu1Xu4;scaEva;langa1nnessee,x2F;bas0Wm4smOtar25;aulip2Dil nadu;a9i7o5taf12u4ylh1F;ffZrr05s1A;me1Cno1Quth 4;cWdV;ber0c4kkim,naloa;hu2ily;n5skatchew2xo4;ny; luis potosi,ta catari1;a4hodeA;j4ngp08;asth2shahi;ingh25u4;e4intana roo;bec,en6retaro;ara8e6rince edward4unjab; i4;sl0C;i,nnsylv4rnambu0C;an0;!na;axa0Ydisha,h4klaho20ntar4reg7ss0Cx0H;io;aKeEo6u4;evo le4nav0W;on;r4tt17va scot0;f9mandy,th4; 4ampton3;c6d5yo4;rk3;ako1N;aroli1;olk;bras1Mva0Cw4; 5foundland4;! and labrador;brunswick,hamp3jers5mexiTyork4;! state;ey;galPyarit;aAeghala0Mi6o4;nta1r4;dov0elos;ch6dlanDn5ss4zor11;issippi,ouri;as geraPneso18;ig2oac2;dhy12harasht0Gine,ni5r4ssachusetts;anhao,i el,ylG;p4toba;ur;anca3e4incoln3ouisI;e4iR;ds;a6e5h4omi;aka06ul1;ntucky,ra01;bardino,lmyk0ns0Qr4;achay,el0nata0X;alis6har4iangxi;kh4;and;co;daho,llino7n4owa;d5gush4;et0;ia1;is;a6ert5i4un2;dalFm0D;ford3;mp3rya1waii;ansu,eorg0lou7oa,u4;an4izhou,jarat;ajuato,gdo4;ng;cester3;lori4uji2;da;sex;ageUe7o5uran4;go;rs4;et;lawaMrby3;aFeaEh9o4rim08umbr0;ahui7l6nnectic5rsi4ventry;ca;ut;i03orado;la;e5hattisgarh,i4uvash0;apRhuahua;chn5rke4;ss0;ya;ra;lGm4;bridge3peche;a9ihar,r8u4;ck4ryat0;ingham3;shi4;re;emen,itish columb0;h0ja cal8lk7s4v7;hkorto4que;st2;an;ar0;iforn0;ia;dygHguascalientes,lBndhr9r5ss4;am;izo1kans5un4;achal 7;as;na;a 4;pradesh;a6ber5t4;ai;ta;ba5s4;ka;ma;ea",
  "Country": "true\xA60:38;1:2L;2:3B;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om2pZqat1KrXsKtCu7v5wal4yemTz3;a25imbabwe;es,lis and futu2Y;a3enezue32ietnam;nuatu,tican city;gTk6nited 4ruXs3zbeE; 2Ca,sr;arab emirat0Kkingdom,states3;! of am2Y;!raiV;a8haCimor les0Co7rinidad 5u3;nis0rk3valu;ey,me2Zs and caic1V;and t3t3;oba1L;go,kel10nga;iw2ji3nz2T;ki2V;aDcotl1eCi9lov8o6pa2Dri lanka,u5w3yr0;az3edAitzerl1;il1;d2riname;lomon1Xmal0uth 3;afr2KkMsud2;ak0en0;erra leoFn3;gapo1Yt maart3;en;negLrb0ychellZ;int 3moa,n marino,udi arab0;hele26luc0mart21;epublic of ir0Eom2Euss0w3;an27;a4eIhilippinUitcairn1Mo3uerto riN;l1rtugF;ki2Dl4nama,pua new0Vra3;gu7;au,esti3;ne;aBe9i7or3;folk1Ith4w3;ay; k3ern mariana1D;or0O;caragua,ger3ue;!ia;p3ther1Aw zeal1;al;mib0u3;ru;a7exi6icro0Bo3yanm06;ldova,n3roc5zambA;a4gol0t3;enegro,serrat;co;cAdagasc01l7r5urit4yot3;te;an0i16;shall0Xtin3;ique;a4div3i,ta;es;wi,ys0;ao,ed02;a6e5i3uxembourg;b3echtenste12thu1G;er0ya;ban0Isotho;os,tv0;azakh1Fe4iriba04o3uwait,yrgyz1F;rXsovo;eling0Knya;a3erG;ma16p2;c7nd6r4s3taly,vory coast;le of m2rael;a3el1;n,q;ia,oJ;el1;aiTon3ungary;dur0Ng kong;aBermany,ha0QibraltAre8u3;a6ern5inea3ya0P;! biss3;au;sey;deloupe,m,tema0Q;e3na0N;ce,nl1;ar;bUmb0;a7i6r3;ance,ench 3;guia0Epoly3;nes0;ji,nl1;lklandUroeU;ast tim7cu6gypt,l salv6ngl1quatorial4ritr5st3thiop0;on0; guin3;ea;ad3;or;enmark,jibou5ominica4r con3;go;!n C;ti;aBentral african Ah8o5roat0u4yprRzech3; 9ia;ba,racao;c4lo3morQngo brazzaville,okGsta r04te de ivoiL;mb0;osE;i3ristmasG;le,na;republic;m3naUpe verde,ymanA;bod0ero3;on;aGeDhut2o9r5u3;lgar0r3;kina faso,ma,undi;azil,itish 3unei;virgin3; is3;lands;liv0nai5snia and herzegoviHtswaHuvet3; isl1;and;re;l3n8rmuG;ar3gium,ize;us;h4ngladesh,rbad3;os;am4ra3;in;as;fghaGlDmBn6r4ustr3zerbaij2;al0ia;genti3men0uba;na;dorra,g5t3;arct7igua and barbu3;da;o3uil3;la;er3;ica;b3ger0;an0;ia;ni3;st2;an",
  "Place": "true\xA6a0Gb0Bc03d02e01f00gWhUiSkQlNmLnIorHpDrCsAt5u4v3w2y0;a0yz;kutPngtze;ake isHupatki;irgin islands,ostok;laanbaatar,p02;a3eotihuac0Hh1onto,sarskoe selo,u0;lXzigoot;am09e 0;bronx,hamptons;hiti,j mahE;a0cotts bluff,eine,fo,oho,under9;int lawrence river,khalY;ed s3io grande;a1ek,h0itcairn,ompeii;l,x;cif05pahanaumokuak0rthenX;ea;ange county,d,inoco;e0ile;uschwansteQw eng0;land;a0co,ekong,idLuc;chu picchu,gad00libu,nhatt00;a1gw,hr,incoln memori0;al;s,x;azan kremlJosrae,rasnoyar0ul;sk;ax,cn,nd0st;ianSochina;arlem,kg,nd,ov0;d,enweep;a2odavari,re0;at 0enwich;britaBlakI;ngHy village;co,ra;urope,vergladF;anube,en,fw,own4xb;arrizo pla6dg,edar 5gk,h1lt,olosse0;um;a2i0uuk;chen itza,mney rock,na0ricahua;town;morro,tham;breaks,fa5;in;cn,e2kk,ro0;oklyn,wns cany0;on;l air,verly hi0;lls;driadic,frica,lhambra,m7n3rc2sia,tl1zor0;es;!ant2; de triomphe,t1;adyr,tarct0;ic0; oce0;an;ericas,s",
  "FirstName": "true\xA6aTblair,cQdOfrancoZgabMhinaLilya,jHkClBm6ni4quinn,re3s0;h0umit,yd;ay,e0iloh;a,lby;g9ne;co,ko0;!s;a1el0ina,org6;!okuhF;ds,naia,r1tt0xiB;i,y;ion,lo;ashawn,eif,uca;a3e1ir0rM;an;lsFn0rry;dall,yat5;i,sD;a0essIie,ude;i1m0;ie,mG;me;ta;rie0y;le;arcy,ev0;an,on;as1h0;arl8eyenne;ey,sidy;drien,kira,l4nd1ubr0vi;ey;i,r0;a,e0;a,y;ex2f1o0;is;ie;ei,is",
  "WeekDay": "true\xA6fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
  "Month": "true\xA6dec0february,july,nov0octo1sept0;em0;ber",
  "Date": "true\xA6ago,on4som4t1week0yesterd5; end,ends;mr1o0;d2morrow;!w;ed0;ay",
  "Duration": "true\xA6centurAd8h7m5q4se3w1y0;ear8r8;eek0k7;!end,s;ason,c5;tr,uarter;i0onth3;llisecond2nute2;our1r1;ay0ecade0;!s;ies,y",
  "FemaleName": "true\xA60:J7;1:JB;2:IJ;3:IK;4:J1;5:IO;6:JS;7:JO;8:HB;9:JK;A:H4;B:I2;C:IT;D:JH;E:IX;F:BA;G:I4;aGTbFLcDRdD0eBMfB4gADh9Ti9Gj8Dk7Cl5Wm48n3Lo3Hp33qu32r29s15t0Eu0Cv02wVxiTyOzH;aLeIineb,oHsof3;e3Sf3la,ra;h2iKlIna,ynH;ab,ep;da,ma;da,h2iHra;nab;aKeJi0FolB7uIvH;et8onDP;i0na;le0sen3;el,gm3Hn,rGLs8W;aoHme0nyi;m5XyAD;aMendDZhiDGiH;dele9lJnH;if48niHo0;e,f47;a,helmi0lHma;a,ow;ka0nB;aNeKiHusa5;ck84kIl8oleAviH;anFenJ4;ky,toriBK;da,lA8rHs0;a,nHoniH9;a,iFR;leHnesH9;nILrH;i1y;g9rHs6xHA;su5te;aYeUhRiNoLrIuHy2;i,la;acJ3iHu0J;c3na,sH;hFta;nHr0F;iFya;aJffaEOnHs6;a,gtiH;ng;!nFSra;aIeHomasi0;a,l9Oo8Ares1;l3ndolwethu;g9Fo88rIssH;!a,ie;eHi,ri7;sa,za;bOlMmKnIrHs6tia0wa0;a60yn;iHya;a,ka,s6;arFe2iHm77ra;!ka;a,iH;a,t6;at6it6;a0Ecarlett,e0AhWiSkye,neza0oQri,tNuIyH;bIGlvi1;ha,mayIJniAsIzH;an3Net8ie,y;anHi7;!a,e,nH;aCe;aIeH;fan4l5Dphan6E;cI5r5;b3fiAAm0LnHphi1;d2ia,ja,ya;er2lJmon1nIobh8QtH;a,i;dy;lETv3;aMeIirHo0risFDy5;a,lDM;ba,e0i5lJrH;iHr6Jyl;!d8Ifa;ia,lDZ;hd,iMki2nJrIu0w0yH;la,ma,na;i,le9on,ron,yn;aIda,ia,nHon;a,on;!ya;k6mH;!aa;lJrItaye82vH;da,inj;e0ife;en1i0ma;anA9bLd5Oh1SiBkKlJmInd2rHs6vannaC;aCi0;ant6i2;lDOma,ome;ee0in8Tu2;in1ri0;a05eZhXiUoHuthDM;bScRghQl8LnPsJwIxH;anB3ie,y;an,e0;aIeHie,lD;ann7ll1marDGtA;!lHnn1;iHyn;e,nH;a,dF;da,i,na;ayy8G;hel67io;bDRerAyn;a,cIkHmas,nFta,ya;ki,o;h8Xki;ea,iannGMoH;da,n1P;an0bJemFgi0iInHta,y0;a8Bee;han86na;a,eH;cHkaC;a,ca;bi0chIe,i0mo0nHquETy0;di,ia;aERelHiB;!e,le;een4ia0;aPeOhMiLoJrHute6A;iHudenCV;scil3LyamvaB;lHrt3;i0ly;a,paluk;ilome0oebe,ylH;is,lis;ggy,nelope,r5t2;ige,m0VnKo5rvaDMtIulH;a,et8in1;ricHt4T;a,e,ia;do2i07;ctav3dIfD3is6ksa0lHphD3umC5yunbileg;a,ga,iv3;eHvAF;l3t8;aWeUiMoIurHy5;!ay,ul;a,eJor,rIuH;f,r;aCeEma;ll1mi;aNcLhariBQkKlaJna,sHta,vi;anHha;ur;!y;a,iDZki;hoGk9YolH;a,e4P;!mh;hir,lHna,risDEsreE;!a,lBV;asuMdLh3i6Dl5nKomi7rgEVtH;aHhal4;lHs6;i1ya;cy,et8;e9iF0ya;nngu2X;a0Ackenz4e02iMoJrignayani,uriDJyH;a,rH;a,iOlNna,tG;bi0i2llBJnH;a,iH;ca,ka,qD9;a,cUdo4ZkaTlOmi,nMrItzi,yH;ar;aJiIlH;anET;am;!l,nB;dy,eHh,n4;nhGrva;aKdJe0iCUlH;iHy;cent,e;red;!gros;!e5;ae5hH;ae5el3Z;ag5DgNi,lKrH;edi7AiIjem,on,yH;em,l;em,sCG;an4iHliCF;nHsCJ;a,da;!an,han;b09cASd07e,g05ha,i04ja,l02n00rLsoum5YtKuIv84xBKyHz4;bell,ra,soBB;d7rH;a,eE;h8Gild1t4;a,cUgQiKjor4l7Un4s6tJwa,yH;!aHbe6Xja9lAE;m,nBL;a,ha,in1;!aJbCGeIja,lDna,sHt63;!a,ol,sa;!l1D;!h,mInH;!a,e,n1;!awit,i;arJeIie,oHr48ueri8;!t;!ry;et46i3B;el4Xi7Cy;dHon,ue5;akranAy;ak,en,iHlo3S;a,ka,nB;a,re,s4te;daHg4;!l3E;alDd4elHge,isDJon0;ei9in1yn;el,le;a0Ne0CiXoQuLyH;d3la,nH;!a,dIe2OnHsCT;!a,e2N;a,sCR;aD4cJel0Pis1lIna,pHz;e,iA;a,u,wa;iHy;a0Se,ja,l2NnB;is,l1UrItt1LuHvel4;el5is1;aKeIi7na,rH;aADi7;lHn1tA;ei;!in1;aTbb9HdSepa,lNnKsJvIzH;!a,be5Ret8z4;!ia;a,et8;!a,dH;a,sHy;ay,ey,i,y;a,iJja,lH;iHy;aA8e;!aH;!nF;ia,ya;!nH;!a,ne;aPda,e0iNjYla,nMoKsJtHx93y5;iHt4;c3t3;e2PlCO;la,nHra;a,ie,o2;a,or1;a,gh,laH;!ni;!h,nH;a,d2e,n5V;cOdon9DiNkes6mi9Gna,rMtJurIvHxmi,y5;ern1in3;a,e5Aie,yn;as6iIoH;nya,ya;fa,s6;a,isA9;a,la;ey,ie,y;a04eZhXiOlASoNrJyH;lHra;a,ee,ie;istHy6I;a,en,iIyH;!na;!e,n5F;nul,ri,urtnB8;aOerNlB7mJrHzzy;a,stH;en,in;!berlImernH;aq;eHi,y;e,y;a,stE;!na,ra;aHei2ongordzol;dij1w5;el7UiKjsi,lJnIrH;a,i,ri;d2na,za;ey,i,lBLs4y;ra,s6;biAcARdiat7MeBAiSlQmPnyakuma1DrNss6NtKviAyH;!e,lH;a,eH;e,i8T;!a6HeIhHi4TlDri0y;ar8Her8Hie,leErBAy;!lyn8Ori0;a,en,iHl5Xoli0yn;!ma,nFs95;a5il1;ei8Mi,lH;e,ie;a,tl6O;a0AeZiWoOuH;anMdLlHst88;es,iH;a8NeHs8X;!n9tH;!a,te;e5Mi3My;a,iA;!anNcelDdMelGhan7VleLni,sIva0yH;a,ce;eHie;fHlDph7Y;a,in1;en,n1;i7y;!a,e,n45;lHng;!i1DlH;!i1C;anNle0nKrJsH;i8JsH;!e,i8I;i,ri;!a,elGif2CnH;a,et8iHy;!e,f2A;a,eJiInH;a,eIiH;e,n1;!t8;cMda,mi,nIque4YsminFvie2y9zH;min7;a7eIiH;ce,e,n1s;!lHs82t0F;e,le;inIk6HlDquelH;in1yn;da,ta;da,lRmPnOo0rNsIvaHwo0zaro;!a0lu,na;aJiIlaHob89;!n9R;do2;belHdo2;!a,e,l3B;a7Ben1i0ma;di2es,gr72ji;a9elBogH;en1;a,e9iHo0se;a0na;aSeOiJoHus7Kyacin2C;da,ll4rten24snH;a,i9U;lImaH;ri;aIdHlaI;a,egard;ry;ath1BiJlInrietArmi9sH;sa,t1A;en2Uga,mi;di;bi2Fil8MlNnMrJsItHwa,yl8M;i5Tt4;n60ti;iHmo51ri53;etH;!te;aCnaC;a,ey,l4;a02eWiRlPoNrKunJwH;enHyne1R;!dolD;ay,el;acieIetHiselB;a,chE;!la;ld1CogooH;sh;adys,enHor3yn2K;a,da,na;aKgi,lIna,ov8EselHta;a,e,le;da,liH;an;!n0;mLnJorgIrH;ald5Si,m3Etrud7;et8i4X;a,eHna;s29vieve;ma;bIle,mHrnet,yG;al5Si5;iIrielH;a,l1;!ja;aTeQiPlorOoz3rH;anJeIiH;da,eB;da,ja;!cH;esIiHoi0P;n1s66;!ca;a,enc3;en,o0;lIn0rnH;anB;ec3ic3;jr,nArKtHy7;emIiHma,oumaA;ha,ma,n;eh;ah,iBrah,za0;cr4Rd0Re0Qi0Pk0Ol07mXn54rUsOtNuMvHwa;aKelIiH;!e,ta;inFyn;!a;!ngel4V;geni1ni47;h5Yien9ta;mLperanKtH;eIhHrel5;er;l31r7;za;a,eralB;iHma,ne4Lyn;cHka,n;a,ka;aPeNiKmH;aHe21ie,y;!li9nuH;elG;lHn1;e7iHy;a,e,ja;lHrald;da,y;!nue5;aWeUiNlMma,no2oKsJvH;a,iH;na,ra;a,ie;iHuiH;se;a,en,ie,y;a0c3da,e,f,nMsJzaH;!betHveA;e,h;aHe,ka;!beH;th;!a,or;anor,nH;!a,i;!in1na;ate1Rta;leEs6;vi;eIiHna,wi0;e,th;l,n;aYeMh3iLjeneKoH;lor5Vminiq4Ln3FrHtt4;a,eEis,la,othHthy;ea,y;ba;an09naCon9ya;anQbPde,eOiMlJmetr3nHsir5M;a,iH;ce,se;a,iIla,orHphi9;es,is;a,l6F;dHrdH;re;!d5Ena;!b2ForaCraC;a,d2nH;!a,e;hl3i0l0GmNnLphn1rIvi1WyH;le,na;a,by,cIia,lH;a,en1;ey,ie;a,et8iH;!ca,el1Aka,z;arHia;is;a0Re0Nh04i02lUoJristIynH;di,th3;al,i0;lPnMrIurH;tn1D;aJd2OiHn2Ori9;!nH;a,e,n1;!l4;cepci5Cn4sH;tanHuelo;ce,za;eHleE;en,t8;aJeoIotH;il54;!pat2;ir7rJudH;et8iH;a,ne;a,e,iH;ce,sZ;a2er2ndH;i,y;aReNloe,rH;isJyH;stH;al;sy,tH;a1Sen,iHy;an1e,n1;deJlseIrH;!i7yl;a,y;li9;nMrH;isKlImH;ai9;a,eHot8;n1t8;!sa;d2elGtH;al,elG;cIlH;es8i47;el3ilH;e,ia,y;itlYlXmilWndVrMsKtHy5;aIeIhHri0;er1IleErDy;ri0;a38sH;a37ie;a,iOlLmeJolIrH;ie,ol;!e,in1yn;lHn;!a,la;a,eIie,otHy;a,ta;ne,y;na,s1X;a0Ii0I;a,e,l1;isAl4;in,yn;a0Ke02iZlXoUrH;andi7eRiJoIyH;an0nn;nwDoke;an3HdgMgiLtH;n31tH;!aInH;ey,i,y;ny;d,t8;etH;!t7;an0e,nH;da,na;bbi7glarIlo07nH;iAn4;ka;ancHythe;a,he;an1Clja0nHsm3M;iAtH;ou;aWcVlinUniArPssOtJulaCvH;!erlH;ey,y;hJsy,tH;e,iHy7;e,na;!anH;ie,y;!ie;nItHyl;ha,ie;adIiH;ce;et8i9;ay,da;ca,ky;!triH;ce,z;rbJyaH;rmH;aa;a2o2ra;a2Ub2Od25g21i1Sj5l18m0Zn0Boi,r06sWtVuPvOwa,yIzH;ra,u0;aKes6gJlIn,seH;!l;in;un;!nH;a,na;a,i2K;drLguJrIsteH;ja;el3;stH;in1;a,ey,i,y;aahua,he0;hIi2Gja,miAs2DtrH;id;aMlIraqHt21;at;eIi7yH;!n;e,iHy;gh;!nH;ti;iJleIo6piA;ta;en,n1t8;aHelG;!n1J;a01dje5eZgViTjRnKohito,toHya;inet8nH;el5ia;te;!aKeIiHmJ;e,ka;!mHtt7;ar4;!belIliHmU;sa;!l1;a,eliH;ca;ka,sHta;a,sa;elHie;a,iH;a,ca,n1qH;ue;!tH;a,te;!bImHstasiMya;ar3;el;aLberKeliJiHy;e,l3naH;!ta;a,ja;!ly;hGiIl3nB;da;a,ra;le;aWba,ePiMlKthJyH;a,c3sH;a,on,sa;ea;iHys0N;e,s0M;a,cIn1sHza;a,e,ha,on,sa;e,ia,ja;c3is6jaKksaKna,sJxH;aHia;!nd2;ia,saH;nd2;ra;ia;i0nIyH;ah,na;a,is,naCoud;la;c6da,leEmNnLsH;haClH;inHyY;g,n;!h;a,o,slH;ey;ee;en;at6g4nIusH;ti0;es;ie;aWdiTelMrH;eJiH;anMenH;a,e,ne;an0;na;!aLeKiIyH;nn;a,n1;a,e;!ne;!iH;de;e,lDsH;on;yn;!lH;i9yn;ne;aKbIiHrL;!e,gaK;ey,i7y;!e;gaH;il;dKliyJradhIs6;ha;ya;ah;a,ya",
  "Honorific": "true\xA6director1field marsh2lieutenant1rear0sergeant major,vice0; admir1; gener0;al",
  "Adj|Gerund": "true\xA60:3F;1:3H;2:31;3:2X;4:35;5:33;6:3C;7:2Z;8:36;9:29;a33b2Tc2Bd1Te1If19g12h0Zi0Rl0Nm0Gnu0Fo0Ap04rYsKtEuBvAw1Ayiel3;ar6e08;nBpA;l1Rs0B;fol3n1Zsett2;aEeDhrBi4ouc7rAwis0;e0Bif2oub2us0yi1;ea1SiA;l2vi1;l2mp0rr1J;nt1Vxi1;aMcreec7enten2NhLkyrocke0lo0Vmi2oJpHtDuBweA;e0Ul2;pp2ArA;gi1pri5roun3;aBea8iAri2Hun9;mula0r4;gge4rA;t2vi1;ark2eAraw2;e3llb2F;aAot7;ki1ri1;i9oc29;dYtisf6;aEeBive0oAus7;a4l2;assu4defi9fres7ig9juve07mai9s0vAwar3;ea2italiAol1G;si1zi1;gi1ll6mb2vi1;a6eDier23lun1VrAun2C;eBoA;mi5vo1Z;ce3s5vai2;n3rpleA;xi1;ffCpWutBverAwi1;arc7lap04p0Pri3whel8;goi1l6st1J;en3sA;et0;m2Jrtu4;aEeDiCoBuAyst0L;mb2;t1Jvi1;s5tiga0;an1Rl0n3smeri26;dAtu4;de9;aCeaBiAo0U;fesa0Tvi1;di1ni1;c1Fg19s0;llumiGmFnArri0R;cDfurHsCtBviA;go23ti1;e1Oimi21oxica0rig0V;pi4ul0;orpo20r0K;po5;na0;eaBorr02umilA;ia0;li1rtwar8;lFrA;atiDipCoBuelA;i1li1;undbrea10wi1;pi1;f6ng;a4ea8;a3etc7it0lEoCrBulfA;il2;ee1FighXust1L;rAun3;ebo3thco8;aCoA;a0wA;e4i1;mi1tte4;lectrJmHnExA;aCci0hBis0pA;an3lo3;aOila1B;c0spe1A;ab2coura0CdBergi13ga0Clive9ric7s02tA;hral2i0J;ea4u4;barras5er09pA;owe4;if6;aQeIiBrA;if0;sAzz6;aEgDhearCsen0tA;rAur11;ac0es5;te9;us0;ppoin0r8;biliGcDfi9gra3ligh0mBpres5sAvasG;erE;an3ea9orA;ali0L;a6eiBli9rA;ea5;vi1;ta0;maPri1s7un0zz2;aPhMlo5oAripp2ut0;mGnArrespon3;cer9fDspi4tA;inBrA;as0ibu0ol2;ui1;lic0u5;ni1;fDmCpA;eAromi5;l2ti1;an3;or0;aAil2;llenAnAr8;gi1;l8ptAri1;iva0;aff2eGin3lFoDrBuA;d3st2;eathtaAui5;ki1;gg2i2o8ri1unA;ci1;in3;co8wiA;lAtc7;de4;bsorVcOgonMlJmHnno6ppea2rFsA;pi4su4toA;nBun3;di1;is7;hi1;res0;li1;aFu5;si1;ar8lu4;ri1;mi1;iAzi1;zi1;cAhi1;eleDomA;moBpan6;yi1;da0;ra0;ti1;bi1;ng",
  "Comparable": "true\xA60:3C;1:3Q;2:3F;a3Tb3Cc33d2Te2Mf2Ag1Wh1Li1Fj1Ek1Bl13m0Xn0So0Rp0Iqu0Gr07sHtCug0vAw4y3za0Q;el10ouN;ary,e6hi5i3ry;ck0Cde,l3n1ry,se;d,y;ny,te;a3i3R;k,ry;a3erda2ulgar;gue,in,st;a6en2Xhi5i4ouZr3;anqu2Cen1ue;dy,g36me0ny;ck,rs28;ll,me,rt,wd3I;aRcaPeOhMiLkin0BlImGoEpDt6u4w3;eet,ift;b3dd0Wperfi21rre28;sta26t21;a8e7iff,r4u3;pUr1;a4ict,o3;ng;ig2Vn0N;a1ep,rn;le,rk,te0;e1Si2Vright0;ci1Yft,l3on,re;emn,id;a3el0;ll,rt;e4i3y;g2Mm0Z;ek,nd2T;ck24l0mp1L;a3iRrill,y;dy,l01rp;ve0Jxy;n1Jr3;ce,y;d,fe,int0l1Hv0V;a8e6i5o3ude;mantic,o19sy,u3;gh;pe,t1P;a3d,mo0A;dy,l;gg4iFndom,p3re,w;id;ed;ai2i3;ck,et;hoAi1Fl9o8r5u3;ny,r3;e,p11;egna2ic4o3;fouSud;ey,k0;liXor;ain,easa2;ny;dd,i0ld,ranL;aive,e5i4o3u14;b0Sisy,rm0Ysy;bb0ce,mb0R;a3r1w;r,t;ad,e5ild,o4u3;nda12te;ist,o1;a4ek,l3;low;s0ty;a8e7i6o3ucky;f0Jn4o15u3ve0w10y0N;d,sy;e0g;ke0l,mp,tt0Eve0;e1Qwd;me,r3te;ge;e4i3;nd;en;ol0ui19;cy,ll,n3;secu6t3;e3ima4;llege2rmedia3;te;re;aAe7i6o5u3;ge,m3ng1C;bYid;me0t;gh,l0;a3fXsita2;dy,rWv3;en0y;nd13ppy,r3;d3sh;!y;aFenEhCiBlAoofy,r3;a8e6i5o3ue0Z;o3ss;vy;m,s0;at,e3y;dy,n;nd,y;ad,ib,ooD;a2d1;a3o3;st0;tDuiS;u1y;aCeebBi9l8o6r5u3;ll,n3r0N;!ny;aCesh,iend0;a3nd,rmD;my;at,ir7;erce,nan3;ci9;le;r,ul3;ty;a6erie,sse4v3xtre0B;il;nti3;al;r4s3;tern,y;ly,th0;appZe9i5ru4u3;mb;nk;r5vi4z3;zy;ne;e,ty;a3ep,n9;d3f,r;!ly;agey,h8l7o5r4u3;dd0r0te;isp,uel;ar3ld,mmon,st0ward0zy;se;evKou1;e3il0;ap,e3;sy;aHiFlCoAr5u3;ff,r0sy;ly;a6i3oad;g4llia2;nt;ht;sh,ve;ld,un3;cy;a4o3ue;nd,o1;ck,nd;g,tt3;er;d,ld,w1;dy;bsu6ng5we3;so3;me;ry;rd",
  "Adverb": "true\xA6a08b05d00eYfSheQinPjustOkinda,likewiZmMnJoEpCquite,r9s5t2u0very,well;ltima01p0; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0C;a1e0;alS;ndomRth05;ar excellenEer0oint blank; Lhaps;f3n0utright;ce0ly;! 0;ag05moX; courGten;ewJo0; longWt 0;onHwithstand9;aybe,eanwhiNore0;!ovT;! aboX;deed,steY;lla,n0;ce;or3u0;ck1l9rther0;!moK;ing; 0evK;exampCgood,suH;n mas0vI;se;e0irect2; 2fini0;te0;ly;juAtrop;ackward,y 0;far,no0; means,w; GbroFd nauseam,gEl7ny5part,s4t 2w0;ay,hi0;le;be7l0mo7wor7;arge,ea6; soon,i4;mo0way;re;l 3mo2ongsi1ready,so,togeth0ways;er;de;st;b1t0;hat;ut;ain;ad;lot,posteriori",
  "Conjunction": "true\xA6aXbTcReNhowMiEjust00noBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,by,vM;evL;h0il,o;erefOo0;!uU;lus,rovided th9;r0therwiM;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mIcaForder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,tB;er;o0uz;s,z;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
  "Currency": "true\xA6$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0\xA2,\xA3,\xA5,\u0434\u0435\u043D,\u043B\u0432,\u0440\u0443\u0431,\u0E3F,\u20A1,\u20A8,\u20AC,\u20AD,\uFDFC;lotyQ\u0142;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
  "Determiner": "true\xA6aBboth,d9e6few,le5mu8neiDplenty,s4th2various,wh0;at0ich0;evC;a0e4is,ose;!t;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
  "Adj|Present": "true\xA6a07b04cVdQeNfJhollIidRlEmCnarrIoBp9qua8r7s3t2uttFw0;aKet,ro0;ng,u08;endChin;e2hort,l1mooth,our,pa9tray,u0;re,speU;i2ow;cu6da02leSpaN;eplica01i02;ck;aHerfePr0;eseUime,omV;bscu1pen,wn;atu0e3odeH;re;a2e1ive,ow0;er;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iIke,ncy,st;l1mpty,x0;emHpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;li2pproxi0rticula1;ma0;te;ght",
  "Person|Adj": "true\xA6b3du2earnest,frank,mi2r0san1woo1;an0ich,u1;dy;sty;ella,rown",
  "Modal": "true\xA6c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
  "Verb": "true\xA6born,cannot,gonna,has,keep tabs,msg",
  "Person|Verb": "true\xA6b8ch7dr6foster,gra5ja9lan4ma2ni9ollie,p1rob,s0wade;kip,pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
  "Person|Date": "true\xA6a2j0sep;an0une;!uary;p0ugust,v0;ril"
};

// node_modules/efrt/src/encoding.js
var BASE = 36;
var seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var cache = seq.split("").reduce(function(h4, c5, i5) {
  h4[c5] = i5;
  return h4;
}, {});
var toAlphaCode = function(n5) {
  if (seq[n5] !== void 0) {
    return seq[n5];
  }
  let places2 = 1;
  let range = BASE;
  let s5 = "";
  for (; n5 >= range; n5 -= range, places2++, range *= BASE) {
  }
  while (places2--) {
    const d3 = n5 % BASE;
    s5 = String.fromCharCode((d3 < 10 ? 48 : 55) + d3) + s5;
    n5 = (n5 - d3) / BASE;
  }
  return s5;
};
var fromAlphaCode = function(s5) {
  if (cache[s5] !== void 0) {
    return cache[s5];
  }
  let n5 = 0;
  let places2 = 1;
  let range = BASE;
  let pow = 1;
  for (; places2 < s5.length; n5 += range, places2++, range *= BASE) {
  }
  for (let i5 = s5.length - 1; i5 >= 0; i5--, pow *= BASE) {
    let d3 = s5.charCodeAt(i5) - 48;
    if (d3 > 10) {
      d3 -= 7;
    }
    n5 += d3 * pow;
  }
  return n5;
};
var encoding_default = {
  toAlphaCode,
  fromAlphaCode
};

// node_modules/efrt/src/unpack/symbols.js
var symbols = function(t5) {
  const reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
  for (let i5 = 0; i5 < t5.nodes.length; i5++) {
    const m6 = reSymbol.exec(t5.nodes[i5]);
    if (!m6) {
      t5.symCount = i5;
      break;
    }
    t5.syms[encoding_default.fromAlphaCode(m6[1])] = encoding_default.fromAlphaCode(m6[2]);
  }
  t5.nodes = t5.nodes.slice(t5.symCount, t5.nodes.length);
};
var symbols_default = symbols;

// node_modules/efrt/src/unpack/traverse.js
var indexFromRef = function(trie, ref, index4) {
  const dnode = encoding_default.fromAlphaCode(ref);
  if (dnode < trie.symCount) {
    return trie.syms[dnode];
  }
  return index4 + dnode + 1 - trie.symCount;
};
var toArray = function(trie) {
  const all4 = [];
  const crawl = (index4, pref) => {
    let node2 = trie.nodes[index4];
    if (node2[0] === "!") {
      all4.push(pref);
      node2 = node2.slice(1);
    }
    const matches3 = node2.split(/([A-Z0-9,]+)/g);
    for (let i5 = 0; i5 < matches3.length; i5 += 2) {
      const str = matches3[i5];
      const ref = matches3[i5 + 1];
      if (!str) {
        continue;
      }
      const have = pref + str;
      if (ref === "," || ref === void 0) {
        all4.push(have);
        continue;
      }
      const newIndex = indexFromRef(trie, ref, index4);
      crawl(newIndex, have);
    }
  };
  crawl(0, "");
  return all4;
};
var unpack = function(str) {
  const trie = {
    nodes: str.split(";"),
    syms: [],
    symCount: 0
  };
  if (str.match(":")) {
    symbols_default(trie);
  }
  return toArray(trie);
};
var traverse_default = unpack;

// node_modules/efrt/src/unpack/index.js
var unpack2 = function(str) {
  if (!str) {
    return {};
  }
  const obj = str.split("|").reduce((h4, s5) => {
    const arr = s5.split("\xA6");
    h4[arr[0]] = arr[1];
    return h4;
  }, {});
  const all4 = {};
  Object.keys(obj).forEach(function(cat) {
    const arr = traverse_default(obj[cat]);
    if (cat === "true") {
      cat = true;
    }
    for (let i5 = 0; i5 < arr.length; i5++) {
      const k3 = arr[i5];
      if (all4.hasOwnProperty(k3) === true) {
        if (Array.isArray(all4[k3]) === false) {
          all4[k3] = [all4[k3], cat];
        } else {
          all4[k3].push(cat);
        }
      } else {
        all4[k3] = cat;
      }
    }
  });
  return all4;
};
var unpack_default = unpack2;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/misc.js
var prp = ["Possessive", "Pronoun"];
var misc = {
  // numbers
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  g8: "Organization",
  vh1: "Organization",
  "76ers": "SportsTeam",
  "49ers": "SportsTeam",
  q1: "Date",
  q2: "Date",
  q3: "Date",
  q4: "Date",
  km2: "Unit",
  m2: "Unit",
  dm2: "Unit",
  cm2: "Unit",
  mm2: "Unit",
  mile2: "Unit",
  in2: "Unit",
  yd2: "Unit",
  ft2: "Unit",
  m3: "Unit",
  dm3: "Unit",
  cm3: "Unit",
  in3: "Unit",
  ft3: "Unit",
  yd3: "Unit",
  // ampersands
  "at&t": "Organization",
  "black & decker": "Organization",
  "h & m": "Organization",
  "johnson & johnson": "Organization",
  "procter & gamble": "Organization",
  "ben & jerry's": "Organization",
  "&": "Conjunction",
  //pronouns
  i: ["Pronoun", "Singular"],
  he: ["Pronoun", "Singular"],
  she: ["Pronoun", "Singular"],
  it: ["Pronoun", "Singular"],
  they: ["Pronoun", "Plural"],
  we: ["Pronoun", "Plural"],
  was: ["Copula", "PastTense"],
  is: ["Copula", "PresentTense"],
  are: ["Copula", "PresentTense"],
  am: ["Copula", "PresentTense"],
  were: ["Copula", "PastTense"],
  // possessive pronouns
  her: prp,
  his: prp,
  hers: prp,
  their: prp,
  theirs: prp,
  themselves: prp,
  your: prp,
  our: prp,
  ours: prp,
  my: prp,
  its: prp,
  // misc
  vs: ["Conjunction", "Abbreviation"],
  if: ["Condition", "Preposition"],
  closer: "Comparative",
  closest: "Superlative",
  much: "Adverb",
  may: "Modal",
  // irregular conjugations with two forms
  babysat: "PastTense",
  blew: "PastTense",
  drank: "PastTense",
  drove: "PastTense",
  forgave: "PastTense",
  skiied: "PastTense",
  spilt: "PastTense",
  stung: "PastTense",
  swam: "PastTense",
  swung: "PastTense",
  guaranteed: "PastTense",
  shrunk: "PastTense",
  // support 'near', 'nears', 'nearing'
  nears: "PresentTense",
  nearing: "Gerund",
  neared: "PastTense",
  no: ["Negative", "Expression"]
  // '-': 'Preposition', //june - july
  // there: 'There'
};
var misc_default2 = misc;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/frozenLex.js
var frozenLex_default = {
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  "excuse me": "Expression",
  "financial times": "Organization",
  "guns n roses": "Organization",
  "la z boy": "Organization",
  "labour party": "Organization",
  "new kids on the block": "Organization",
  "new york times": "Organization",
  "the guess who": "Organization",
  "thin lizzy": "Organization",
  "prime minister": "Actor",
  "free market": "Singular",
  "lay up": "Singular",
  "living room": "Singular",
  "living rooms": "Plural",
  "spin off": "Singular",
  "appeal court": "Uncountable",
  "cold war": "Uncountable",
  "gene pool": "Uncountable",
  "machine learning": "Uncountable",
  "nail polish": "Uncountable",
  "time off": "Uncountable",
  "take part": "Infinitive",
  "bill gates": "Person",
  "doctor who": "Person",
  "he man": "Person",
  "iron man": "Person",
  "kid cudi": "Person",
  "run dmc": "Person",
  "rush limbaugh": "Person",
  "snow white": "Person",
  "tiger woods": "Person",
  "brand new": "Adjective",
  "en route": "Adjective",
  "left wing": "Adjective",
  "off guard": "Adjective",
  "on board": "Adjective",
  "part time": "Adjective",
  "right wing": "Adjective",
  "so called": "Adjective",
  "spot on": "Adjective",
  "straight forward": "Adjective",
  "super duper": "Adjective",
  "tip top": "Adjective",
  "top notch": "Adjective",
  "up to date": "Adjective",
  "win win": "Adjective",
  "brooklyn nets": "SportsTeam",
  "chicago bears": "SportsTeam",
  "houston astros": "SportsTeam",
  "houston dynamo": "SportsTeam",
  "houston rockets": "SportsTeam",
  "houston texans": "SportsTeam",
  "minnesota twins": "SportsTeam",
  "orlando magic": "SportsTeam",
  "san antonio spurs": "SportsTeam",
  "san diego chargers": "SportsTeam",
  "san diego padres": "SportsTeam",
  "iron maiden": "ProperNoun",
  "isle of man": "Country",
  "united states": "Country",
  "united states of america": "Country",
  "prince edward island": "Region",
  "cedar breaks": "Place",
  "cedar falls": "Place",
  "point blank": "Adverb",
  "tiny bit": "Adverb",
  "by the time": "Conjunction",
  "no matter": "Conjunction",
  "civil wars": "Plural",
  "credit cards": "Plural",
  "default rates": "Plural",
  "free markets": "Plural",
  "head starts": "Plural",
  "home runs": "Plural",
  "lay ups": "Plural",
  "phone calls": "Plural",
  "press releases": "Plural",
  "record labels": "Plural",
  "soft serves": "Plural",
  "student loans": "Plural",
  "tax returns": "Plural",
  "tv shows": "Plural",
  "video games": "Plural",
  "took part": "PastTense",
  "takes part": "PresentTense",
  "taking part": "Gerund",
  "taken part": "Participle",
  "light bulb": "Noun",
  "rush hour": "Noun",
  "fluid ounce": "Unit",
  "the rolling stones": "Organization"
};

// node_modules/compromise/src/2-two/preTagger/model/lexicon/emoticons.js
var emoticons_default = [
  ":(",
  ":)",
  ":P",
  ":p",
  ":O",
  ";(",
  ";)",
  ";P",
  ";p",
  ";O",
  ":3",
  ":|",
  ":/",
  ":\\",
  ":$",
  ":*",
  ":@",
  ":-(",
  ":-)",
  ":-P",
  ":-p",
  ":-O",
  ":-3",
  ":-|",
  ":-/",
  ":-\\",
  ":-$",
  ":-*",
  ":-@",
  ":^(",
  ":^)",
  ":^P",
  ":^p",
  ":^O",
  ":^3",
  ":^|",
  ":^/",
  ":^\\",
  ":^$",
  ":^*",
  ":^@",
  "):",
  "(:",
  "$:",
  "*:",
  ")-:",
  "(-:",
  "$-:",
  "*-:",
  ")^:",
  "(^:",
  "$^:",
  "*^:",
  "<3",
  "</3",
  "<\\3",
  "=("
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/_rules.js
var suffixes = {
  a: [
    [/(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae"],
    [/ia$/i, "ia"]
  ],
  e: [
    [/(kn|l|w)ife$/i, "$1ives"],
    [/(hive)$/i, "$1s"],
    [/([m|l])ouse$/i, "$1ice"],
    [/([m|l])ice$/i, "$1ice"]
  ],
  f: [
    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves"],
    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves"]
  ],
  i: [[/(octop|vir)i$/i, "$1i"]],
  m: [[/([ti])um$/i, "$1a"]],
  n: [[/^(oxen)$/i, "$1"]],
  o: [[/(al|ad|at|er|et|ed)o$/i, "$1oes"]],
  s: [
    [/(ax|test)is$/i, "$1es"],
    [/(alias|status)$/i, "$1es"],
    [/sis$/i, "ses"],
    [/(bu)s$/i, "$1ses"],
    [/(sis)$/i, "ses"],
    [/^(?!talis|.*hu)(.*)man$/i, "$1men"],
    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i"]
  ],
  x: [
    [/(matr|vert|ind|cort)(ix|ex)$/i, "$1ices"],
    [/^(ox)$/i, "$1en"]
  ],
  y: [[/([^aeiouy]|qu)y$/i, "$1ies"]],
  z: [[/(quiz)$/i, "$1zes"]]
};
var rules_default = suffixes;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toPlural/index.js
var addE = /([xsz]|ch|sh)$/;
var trySuffix = function(str) {
  let c5 = str[str.length - 1];
  if (rules_default.hasOwnProperty(c5) === true) {
    for (let i5 = 0; i5 < rules_default[c5].length; i5 += 1) {
      let reg = rules_default[c5][i5][0];
      if (reg.test(str) === true) {
        return str.replace(reg, rules_default[c5][i5][1]);
      }
    }
  }
  return null;
};
var pluralize = function(str = "", model5) {
  let { irregularPlurals, uncountable: uncountable2 } = model5.two;
  if (uncountable2.hasOwnProperty(str)) {
    return str;
  }
  if (irregularPlurals.hasOwnProperty(str)) {
    return irregularPlurals[str];
  }
  let plural2 = trySuffix(str);
  if (plural2 !== null) {
    return plural2;
  }
  if (addE.test(str)) {
    return str + "es";
  }
  return str + "s";
};
var toPlural_default = pluralize;

// node_modules/compromise/src/2-two/preTagger/model/lexicon/index.js
var hasSwitch = /\|/;
var lexicon3 = misc_default2;
var switches = {};
var tmpModel = { two: { irregularPlurals: plurals_default, uncountable: {} } };
Object.keys(data_default).forEach((tag2) => {
  let wordsObj = unpack_default(data_default[tag2]);
  if (!hasSwitch.test(tag2)) {
    Object.keys(wordsObj).forEach((w2) => {
      lexicon3[w2] = tag2;
    });
    return;
  }
  Object.keys(wordsObj).forEach((w2) => {
    switches[w2] = tag2;
    if (tag2 === "Noun|Verb") {
      let plural2 = toPlural_default(w2, tmpModel);
      switches[plural2] = "Plural|Verb";
    }
  });
});
emoticons_default.forEach((str) => lexicon3[str] = "Emoticon");
delete lexicon3[""];
delete lexicon3[null];
delete lexicon3[" "];

// node_modules/compromise/src/2-two/preTagger/model/clues/_noun.js
var n2 = "Singular";
var noun_default = {
  beforeTags: {
    Determiner: n2,
    //the date
    Possessive: n2,
    //his date
    Acronym: n2,
    //u.s. state
    // ProperNoun:n,
    Noun: n2,
    //nasa funding
    Adjective: n2,
    //whole bottles
    // Verb:true, //save storm victims
    PresentTense: n2,
    //loves hiking
    Gerund: n2,
    //uplifting victims
    PastTense: n2,
    //saved storm victims
    Infinitive: n2,
    //profess love
    Date: n2,
    //9pm show
    Ordinal: n2,
    //first date
    Demonym: n2
    //dutch map
  },
  afterTags: {
    Value: n2,
    //date nine  -?
    Modal: n2,
    //date would
    Copula: n2,
    //fear is
    PresentTense: n2,
    //babysitting sucks
    PastTense: n2,
    //babysitting sucked
    // Noun:n, //talking therapy, planning process
    Demonym: n2,
    //american touch
    Actor: n2
    //dance therapist
  },
  // ownTags: { ProperNoun: n },
  beforeWords: {
    the: n2,
    //the brands
    with: n2,
    //with cakes
    without: n2,
    //
    // was:n, //was time  -- was working
    // is:n, //
    of: n2,
    //of power
    for: n2,
    //for rats
    any: n2,
    //any rats
    all: n2,
    //all tips
    on: n2,
    //on time
    // thing-ish verbs
    cut: n2,
    //cut spending
    cuts: n2,
    //cut spending
    increase: n2,
    // increase funding
    decrease: n2,
    //
    raise: n2,
    //
    drop: n2,
    //
    // give: n,//give parents
    save: n2,
    //
    saved: n2,
    //
    saves: n2,
    //
    make: n2,
    //
    makes: n2,
    //
    made: n2,
    //
    minus: n2,
    //minus laughing
    plus: n2,
    //
    than: n2,
    //more than age
    another: n2,
    //
    versus: n2,
    //
    neither: n2,
    //
    about: n2,
    //about claims
    // strong adjectives
    favorite: n2,
    //
    best: n2,
    //
    daily: n2,
    //
    weekly: n2,
    //
    linear: n2,
    //
    binary: n2,
    //
    mobile: n2,
    //
    lexical: n2,
    //
    technical: n2,
    //
    computer: n2,
    //
    scientific: n2,
    //
    security: n2,
    //
    government: n2,
    //
    popular: n2,
    //
    formal: n2,
    no: n2,
    //no worries
    more: n2,
    //more details
    one: n2,
    //one flood
    let: n2,
    //let fear
    her: n2,
    //her boots
    his: n2,
    //
    their: n2,
    //
    our: n2,
    //
    us: n2,
    //served us drinks
    sheer: n2,
    monthly: n2,
    yearly: n2,
    current: n2,
    previous: n2,
    upcoming: n2,
    last: n2,
    next: n2,
    main: n2,
    initial: n2,
    final: n2,
    beginning: n2,
    end: n2,
    top: n2,
    bottom: n2,
    future: n2,
    past: n2,
    major: n2,
    minor: n2,
    side: n2,
    central: n2,
    peripheral: n2,
    public: n2,
    private: n2
  },
  afterWords: {
    of: n2,
    //date of birth (preposition)
    system: n2,
    aid: n2,
    method: n2,
    utility: n2,
    tool: n2,
    reform: n2,
    therapy: n2,
    philosophy: n2,
    room: n2,
    authority: n2,
    says: n2,
    said: n2,
    wants: n2,
    wanted: n2,
    is: n2,
    did: n2,
    do: n2,
    can: n2,
    //parents can
    wise: n2
    //service-wise
    // they: n,//snakes they
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_verb.js
var v = "Infinitive";
var verb_default = {
  beforeTags: {
    Modal: v,
    //would date
    Adverb: v,
    //quickly date
    Negative: v,
    //not date
    Plural: v
    //characters drink
    // ProperNoun: vb,//google thought
  },
  afterTags: {
    Determiner: v,
    //flash the
    Adverb: v,
    //date quickly
    Possessive: v,
    //date his
    Reflexive: v,
    //resolve yourself
    // Noun:true, //date spencer
    Preposition: v,
    //date around, dump onto, grumble about
    // Conjunction: v, // dip to, dip through
    Cardinal: v,
    //cut 3 squares
    Comparative: v,
    //feel greater
    Superlative: v
    //feel greatest
  },
  beforeWords: {
    i: v,
    //i date
    we: v,
    //we date
    you: v,
    //you date
    they: v,
    //they date
    to: v,
    //to date
    please: v,
    //please check
    will: v,
    //will check
    have: v,
    had: v,
    would: v,
    could: v,
    should: v,
    do: v,
    did: v,
    does: v,
    can: v,
    must: v,
    us: v,
    me: v,
    let: v,
    even: v,
    when: v,
    help: v,
    //help combat
    // them: v,
    he: v,
    she: v,
    it: v,
    being: v,
    // prefixes
    bi: v,
    co: v,
    contra: v,
    de: v,
    inter: v,
    intra: v,
    mis: v,
    pre: v,
    out: v,
    counter: v,
    nobody: v,
    somebody: v,
    anybody: v,
    everybody: v
    // un: v,
    // over: v,
    // under: v,
  },
  afterWords: {
    the: v,
    //echo the
    me: v,
    //date me
    you: v,
    //date you
    him: v,
    //loves him
    us: v,
    //cost us
    her: v,
    //
    his: v,
    //
    them: v,
    //
    they: v,
    //
    it: v,
    //hope it
    himself: v,
    herself: v,
    itself: v,
    myself: v,
    ourselves: v,
    themselves: v,
    something: v,
    anything: v,
    a: v,
    //covers a
    an: v,
    //covers an
    // from: v, //ranges from
    up: v,
    //serves up
    down: v,
    //serves up
    by: v,
    // in: v, //bob in
    out: v,
    // on: v,
    off: v,
    under: v,
    what: v,
    //look what
    // when: v,//starts when
    // for:true, //settled for
    all: v,
    //shiver all night
    // conjunctions
    to: v,
    //dip to
    because: v,
    //
    although: v,
    //
    // after: v,
    // before: v,//
    how: v,
    //
    otherwise: v,
    //
    together: v,
    //fit together
    though: v,
    //
    into: v,
    //
    yet: v,
    //
    more: v,
    //kill more
    here: v,
    // look here
    there: v,
    //
    away: v
    //float away
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/actor-verb.js
var clue = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {}),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {}),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {}),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {})
};
var actor_verb_default = clue;

// node_modules/compromise/src/2-two/preTagger/model/clues/_adj.js
var jj = "Adjective";
var adj_default = {
  beforeTags: {
    Determiner: jj,
    //the detailed
    // Copula: jj, //is detailed
    Possessive: jj,
    //spencer's detailed
    Hyphenated: jj
    //rapidly-changing
  },
  afterTags: {
    // Noun: jj, //detailed plan, overwhelming evidence
    Adjective: jj
    //intoxicated little
  },
  beforeWords: {
    seem: jj,
    //seem prepared
    seemed: jj,
    seems: jj,
    feel: jj,
    //feel prepared
    feels: jj,
    felt: jj,
    stay: jj,
    appear: jj,
    appears: jj,
    appeared: jj,
    also: jj,
    over: jj,
    //over cooked
    under: jj,
    too: jj,
    //too insulting
    it: jj,
    //find it insulting
    but: jj,
    //nothing but frustrating
    still: jj,
    //still scared
    // adverbs that are adjective-ish
    really: jj,
    //really damaged
    quite: jj,
    well: jj,
    very: jj,
    truly: jj,
    how: jj,
    //how slow
    deeply: jj,
    hella: jj,
    // always: jj,
    // never: jj,
    profoundly: jj,
    extremely: jj,
    so: jj,
    badly: jj,
    mostly: jj,
    totally: jj,
    awfully: jj,
    rather: jj,
    nothing: jj,
    //nothing secret,
    something: jj,
    //something wrong
    anything: jj,
    not: jj,
    //not swell
    me: jj,
    //called me swell
    is: jj,
    face: jj,
    //faces shocking revelations
    faces: jj,
    faced: jj,
    look: jj,
    looks: jj,
    looked: jj,
    reveal: jj,
    reveals: jj,
    revealed: jj,
    sound: jj,
    sounded: jj,
    sounds: jj,
    remains: jj,
    remained: jj,
    prove: jj,
    //would prove shocking
    proves: jj,
    proved: jj,
    becomes: jj,
    stays: jj,
    tastes: jj,
    taste: jj,
    smells: jj,
    smell: jj,
    gets: jj,
    //gets shocking snowfall
    grows: jj,
    as: jj,
    rings: jj,
    radiates: jj,
    conveys: jj,
    convey: jj,
    conveyed: jj,
    of: jj
    // 'smacks of': jj,
    // 'reeks of': jj,
  },
  afterWords: {
    too: jj,
    //insulting too
    also: jj,
    //insulting too
    or: jj,
    //insulting or
    enough: jj,
    //cool enough
    as: jj
    //as shocking as
    //about: jj, //cool about
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/_gerund.js
var g2 = "Gerund";
var gerund_default = {
  beforeTags: {
    // Verb: g, // loves shocking
    Adverb: g2,
    //quickly shocking
    Preposition: g2,
    //by insulting
    Conjunction: g2
    //to insulting
  },
  afterTags: {
    Adverb: g2,
    //shocking quickly
    Possessive: g2,
    //shocking spencer's
    Person: g2,
    //telling spencer
    Pronoun: g2,
    //shocking him
    Determiner: g2,
    //shocking the
    Copula: g2,
    //shocking is
    Preposition: g2,
    //dashing by, swimming in
    Conjunction: g2,
    //insulting to
    Comparative: g2
    //growing shorter
  },
  beforeWords: {
    been: g2,
    keep: g2,
    //keep going
    continue: g2,
    //
    stop: g2,
    //
    am: g2,
    //am watching
    be: g2,
    //be timing
    me: g2,
    //got me thinking
    // action-words
    began: g2,
    start: g2,
    starts: g2,
    started: g2,
    stops: g2,
    stopped: g2,
    help: g2,
    helps: g2,
    avoid: g2,
    avoids: g2,
    love: g2,
    //love painting
    loves: g2,
    loved: g2,
    hate: g2,
    hates: g2,
    hated: g2
    // was:g,//was working
    // is:g,
    // be:g,
  },
  afterWords: {
    you: g2,
    //telling you
    me: g2,
    //
    her: g2,
    //
    him: g2,
    //
    his: g2,
    //
    them: g2,
    //
    their: g2,
    // fighting their
    it: g2,
    //dumping it
    this: g2,
    //running this
    there: g2,
    // swimming there
    on: g2,
    // landing on
    about: g2,
    // talking about
    for: g2,
    // paying for
    up: g2,
    //speeding up
    down: g2
    //
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-gerund.js
var g3 = "Gerund";
var jj2 = "Adjective";
var clue2 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, gerund_default.beforeTags, {
    // Copula: jj,
    Imperative: g3,
    //recommend living in
    Infinitive: jj2,
    //say charming things
    // PresentTense: g,
    Plural: g3
    //kids cutting
  }),
  afterTags: Object.assign({}, adj_default.afterTags, gerund_default.afterTags, {
    Noun: jj2
    //shocking ignorance
    // Plural: jj, //shocking lies
  }),
  beforeWords: Object.assign({}, adj_default.beforeWords, gerund_default.beforeWords, {
    is: jj2,
    are: g3,
    //is overflowing: JJ, are overflowing : VB ??
    was: jj2,
    of: jj2,
    //of varying
    suggest: g3,
    suggests: g3,
    suggested: g3,
    recommend: g3,
    recommends: g3,
    recommended: g3,
    imagine: g3,
    imagines: g3,
    imagined: g3,
    consider: g3,
    considered: g3,
    considering: g3,
    resist: g3,
    resists: g3,
    resisted: g3,
    avoid: g3,
    avoided: g3,
    avoiding: g3,
    except: jj2,
    accept: jj2,
    assess: g3,
    explore: g3,
    fear: g3,
    fears: g3,
    appreciate: g3,
    question: g3,
    help: g3,
    embrace: g3,
    with: jj2
    //filled with daring
  }),
  afterWords: Object.assign({}, adj_default.afterWords, gerund_default.afterWords, {
    to: g3,
    not: g3,
    //trying not to car
    the: g3
    //sweeping the country
  })
};
var adj_gerund_default = clue2;

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-noun.js
var misc2 = {
  beforeTags: {
    Determiner: void 0,
    //the premier university
    Cardinal: "Noun",
    //1950 convertable
    PhrasalVerb: "Adjective"
    //starts out fine
  },
  afterTags: {
    // Pronoun: 'Noun'//as an adult i
  }
};
var clue3 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, noun_default.beforeTags, misc2.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, noun_default.afterTags, misc2.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, noun_default.beforeWords, {
    // are representative
    are: "Adjective",
    is: "Adjective",
    was: "Adjective",
    be: "Adjective",
    // phrasals
    off: "Adjective",
    //start off fine
    out: "Adjective"
    //comes out fine
  }),
  afterWords: Object.assign({}, adj_default.afterWords, noun_default.afterWords)
};
var adj_noun_default = clue3;

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-past.js
var past = "PastTense";
var jj3 = "Adjective";
var adjPast = {
  beforeTags: {
    Adverb: past,
    //quickly detailed
    Pronoun: past,
    //he detailed
    ProperNoun: past,
    //toronto closed
    Auxiliary: past,
    Noun: past
    //eye closed  -- i guess.
  },
  afterTags: {
    Possessive: past,
    //hooked him
    Pronoun: past,
    //hooked me
    Determiner: past,
    //hooked the
    Adverb: past,
    //cooked perfectly
    Comparative: past,
    //closed higher
    Date: past,
    // alleged thursday
    Gerund: past
    //left dancing
  },
  beforeWords: {
    be: past,
    //be hooked vs be embarrassed
    who: past,
    //who lost
    get: jj3,
    //get charged
    had: past,
    has: past,
    have: past,
    been: past,
    it: past,
    //it intoxicated him
    as: past,
    //as requested
    for: jj3,
    //for discounted items
    more: jj3,
    //more broken promises
    always: jj3
  },
  afterWords: {
    by: past,
    //damaged by
    back: past,
    //charged back
    out: past,
    //charged out
    in: past,
    //crowded in
    up: past,
    //heated up
    down: past,
    //hammered down
    before: past,
    //
    after: past,
    //
    for: past,
    //settled for
    the: past,
    //settled the
    with: past,
    //obsessed with
    as: past,
    //known as
    on: past,
    //focused on
    at: past,
    //recorded at
    between: past,
    //settled between
    to: past,
    //dedicated to
    into: past,
    //pumped into
    us: past,
    //charged us
    them: past,
    //charged us
    his: past,
    //shared his
    her: past,
    //
    their: past,
    //
    our: past,
    //
    me: past,
    //
    about: jj3
  }
};
var adj_past_default = {
  beforeTags: Object.assign({}, adj_default.beforeTags, adjPast.beforeTags),
  afterTags: Object.assign({}, adj_default.afterTags, adjPast.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, adjPast.beforeWords),
  afterWords: Object.assign({}, adj_default.afterWords, adjPast.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/adj-present.js
var misc3 = {
  afterTags: {
    Noun: "Adjective",
    //ruling party
    Conjunction: void 0
    //clean and excellent
  }
};
var clue4 = {
  beforeTags: Object.assign({}, adj_default.beforeTags, verb_default.beforeTags, {
    // always clean
    Adverb: void 0,
    Negative: void 0
  }),
  afterTags: Object.assign({}, adj_default.afterTags, verb_default.afterTags, misc3.afterTags),
  beforeWords: Object.assign({}, adj_default.beforeWords, verb_default.beforeWords, {
    // have seperate contracts
    have: void 0,
    had: void 0,
    not: void 0,
    //went wrong, got wrong
    went: "Adjective",
    goes: "Adjective",
    got: "Adjective",
    // be sure
    be: "Adjective"
  }),
  afterWords: Object.assign({}, adj_default.afterWords, verb_default.afterWords, {
    to: void 0,
    //slick to the touch
    as: "Adjective"
    //pale as
  })
};
var adj_present_default = clue4;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-gerund.js
var misc4 = {
  beforeTags: {
    Copula: "Gerund",
    PastTense: "Gerund",
    PresentTense: "Gerund",
    Infinitive: "Gerund"
  },
  afterTags: {
    Value: "Gerund"
    //maintaining 500
  },
  beforeWords: {
    are: "Gerund",
    were: "Gerund",
    be: "Gerund",
    no: "Gerund",
    without: "Gerund",
    //are you playing
    you: "Gerund",
    we: "Gerund",
    they: "Gerund",
    he: "Gerund",
    she: "Gerund",
    //stop us playing
    us: "Gerund",
    them: "Gerund"
  },
  afterWords: {
    // offering the
    the: "Gerund",
    this: "Gerund",
    that: "Gerund",
    //got me thinking
    me: "Gerund",
    us: "Gerund",
    them: "Gerund"
  }
};
var clue5 = {
  beforeTags: Object.assign({}, gerund_default.beforeTags, noun_default.beforeTags, misc4.beforeTags),
  afterTags: Object.assign({}, gerund_default.afterTags, noun_default.afterTags, misc4.afterTags),
  beforeWords: Object.assign({}, gerund_default.beforeWords, noun_default.beforeWords, misc4.beforeWords),
  afterWords: Object.assign({}, gerund_default.afterWords, noun_default.afterWords, misc4.afterWords)
};
var noun_gerund_default = clue5;

// node_modules/compromise/src/2-two/preTagger/model/clues/noun-verb.js
var nn = "Singular";
var vb = "Infinitive";
var clue6 = {
  beforeTags: Object.assign({}, verb_default.beforeTags, noun_default.beforeTags, {
    // Noun: undefined
    Adjective: nn,
    //great name
    Particle: nn
    //brought under control
  }),
  afterTags: Object.assign({}, verb_default.afterTags, noun_default.afterTags, {
    ProperNoun: vb,
    Gerund: vb,
    Adjective: vb,
    Copula: nn
  }),
  beforeWords: Object.assign({}, verb_default.beforeWords, noun_default.beforeWords, {
    // is time
    is: nn,
    was: nn,
    //balance of power
    of: nn,
    have: null
    //have cash
  }),
  afterWords: Object.assign({}, verb_default.afterWords, noun_default.afterWords, {
    // for: vb,//work for
    instead: vb,
    // that: nn,//subject that was
    // for: vb,//work for
    about: vb,
    //talk about
    his: vb,
    //shot his
    her: vb,
    //
    to: null,
    by: null,
    in: null
  })
};
var noun_verb_default = clue6;

// node_modules/compromise/src/2-two/preTagger/model/clues/_person.js
var p2 = "Person";
var person_default = {
  beforeTags: {
    Honorific: p2,
    Person: p2
    // Preposition: p, //with sue
  },
  afterTags: {
    Person: p2,
    ProperNoun: p2,
    Verb: p2
    //bob could
    // Modal:true, //bob could
    // Copula:true, //bob is
    // PresentTense:true, //bob seems
  },
  ownTags: {
    ProperNoun: p2
    //capital letter
  },
  beforeWords: {
    hi: p2,
    hey: p2,
    yo: p2,
    dear: p2,
    hello: p2
  },
  afterWords: {
    // person-usually verbs
    said: p2,
    says: p2,
    told: p2,
    tells: p2,
    feels: p2,
    felt: p2,
    seems: p2,
    thinks: p2,
    thought: p2,
    spends: p2,
    spendt: p2,
    plays: p2,
    played: p2,
    sing: p2,
    sang: p2,
    learn: p2,
    learned: p2,
    wants: p2,
    wanted: p2
    // and:true, //sue and jeff
  }
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-date.js
var m = "Month";
var p3 = "Person";
var month = {
  beforeTags: {
    Date: m,
    Value: m
  },
  afterTags: {
    Date: m,
    Value: m
  },
  beforeWords: {
    by: m,
    in: m,
    on: m,
    during: m,
    after: m,
    before: m,
    between: m,
    until: m,
    til: m,
    sometime: m,
    of: m,
    //5th of april
    this: m,
    //this april
    next: m,
    last: m,
    previous: m,
    following: m,
    with: p3
    // for: p,
  },
  afterWords: {
    sometime: m,
    in: m,
    of: m,
    until: m,
    the: m
    //june the 4th
  }
};
var person_date_default = {
  beforeTags: Object.assign({}, person_default.beforeTags, month.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, month.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, month.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, month.afterWords)
};

// node_modules/compromise/src/2-two/preTagger/model/clues/person-noun.js
var clue7 = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, { i: "Infinitive", we: "Infinitive" }),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords)
};
var person_noun_default = clue7;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-verb.js
var clues = {
  beforeTags: Object.assign({}, noun_default.beforeTags, person_default.beforeTags, verb_default.beforeTags),
  afterTags: Object.assign({}, noun_default.afterTags, person_default.afterTags, verb_default.afterTags),
  beforeWords: Object.assign({}, noun_default.beforeWords, person_default.beforeWords, verb_default.beforeWords),
  afterWords: Object.assign({}, noun_default.afterWords, person_default.afterWords, verb_default.afterWords)
};
var person_verb_default = clues;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-place.js
var p4 = "Place";
var place = {
  beforeTags: {
    Place: p4
  },
  afterTags: {
    Place: p4,
    Abbreviation: p4
  },
  beforeWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4
  },
  afterWords: {
    in: p4,
    by: p4,
    near: p4,
    from: p4,
    to: p4,
    government: p4,
    council: p4,
    region: p4,
    city: p4
  }
};
var clue8 = {
  beforeTags: Object.assign({}, place.beforeTags, person_default.beforeTags),
  afterTags: Object.assign({}, place.afterTags, person_default.afterTags),
  beforeWords: Object.assign({}, place.beforeWords, person_default.beforeWords),
  afterWords: Object.assign({}, place.afterWords, person_default.afterWords)
};
var person_place_default = clue8;

// node_modules/compromise/src/2-two/preTagger/model/clues/person-adj.js
var clues2 = {
  beforeTags: Object.assign({}, person_default.beforeTags, adj_default.beforeTags),
  afterTags: Object.assign({}, person_default.afterTags, adj_default.afterTags),
  beforeWords: Object.assign({}, person_default.beforeWords, adj_default.beforeWords),
  afterWords: Object.assign({}, person_default.afterWords, adj_default.afterWords)
};
var person_adj_default = clues2;

// node_modules/compromise/src/2-two/preTagger/model/clues/unit-noun.js
var un = "Unit";
var clues3 = {
  beforeTags: { Value: un },
  afterTags: {},
  beforeWords: {
    per: un,
    every: un,
    each: un,
    square: un,
    //square km
    cubic: un,
    sq: un,
    metric: un
    //metric ton
  },
  afterWords: {
    per: un,
    squared: un,
    cubed: un,
    long: un
    //foot long
  }
};
var unit_noun_default = clues3;

// node_modules/compromise/src/2-two/preTagger/model/clues/index.js
var clues4 = {
  "Actor|Verb": actor_verb_default,
  "Adj|Gerund": adj_gerund_default,
  "Adj|Noun": adj_noun_default,
  "Adj|Past": adj_past_default,
  "Adj|Present": adj_present_default,
  "Noun|Verb": noun_verb_default,
  "Noun|Gerund": noun_gerund_default,
  "Person|Noun": person_noun_default,
  "Person|Date": person_date_default,
  "Person|Verb": person_verb_default,
  "Person|Place": person_place_default,
  "Person|Adj": person_adj_default,
  "Unit|Noun": unit_noun_default
};
var copy = (obj, more) => {
  let res = Object.keys(obj).reduce((h4, k3) => {
    h4[k3] = obj[k3] === "Infinitive" ? "PresentTense" : "Plural";
    return h4;
  }, {});
  return Object.assign(res, more);
};
clues4["Plural|Verb"] = {
  beforeWords: copy(clues4["Noun|Verb"].beforeWords, {
    had: "Plural",
    //had tears
    have: "Plural"
  }),
  afterWords: copy(clues4["Noun|Verb"].afterWords, {
    his: "PresentTense",
    her: "PresentTense",
    its: "PresentTense",
    in: null,
    to: null,
    is: "PresentTense",
    //the way it works is
    by: "PresentTense"
    //it works by
  }),
  beforeTags: copy(clues4["Noun|Verb"].beforeTags, {
    Conjunction: "PresentTense",
    //and changes
    Noun: void 0,
    //the century demands
    ProperNoun: "PresentTense"
    //john plays
  }),
  afterTags: copy(clues4["Noun|Verb"].afterTags, {
    Gerund: "Plural",
    //ice caps disappearing
    Noun: "PresentTense",
    //changes gears
    Value: "PresentTense"
    //changes seven gears
  })
};
var clues_default = clues4;

// node_modules/compromise/src/2-two/preTagger/model/patterns/suffixes.js
var Adj = "Adjective";
var Inf = "Infinitive";
var Pres = "PresentTense";
var Sing = "Singular";
var Past = "PastTense";
var Avb = "Adverb";
var Plrl = "Plural";
var Actor = "Actor";
var Vb = "Verb";
var Noun = "Noun";
var Last = "LastName";
var Modal = "Modal";
var Place = "Place";
var Prt = "Participle";
var suffixes_default2 = [
  null,
  null,
  {
    //2-letter
    ea: Sing,
    ia: Noun,
    ic: Adj,
    ly: Avb,
    "'n": Vb,
    "'t": Vb
  },
  {
    //3-letter
    oed: Past,
    ued: Past,
    xed: Past,
    " so": Avb,
    "'ll": Modal,
    "'re": "Copula",
    azy: Adj,
    eer: Noun,
    end: Vb,
    ped: Past,
    ffy: Adj,
    ify: Inf,
    ing: "Gerund",
    ize: Inf,
    ibe: Inf,
    lar: Adj,
    mum: Adj,
    nes: Pres,
    nny: Adj,
    // oid: Adj,
    ous: Adj,
    que: Adj,
    ger: Noun,
    ber: Noun,
    rol: Sing,
    sis: Sing,
    ogy: Sing,
    oid: Sing,
    ian: Sing,
    zes: Pres,
    eld: Past,
    ken: Prt,
    //awoken
    ven: Prt,
    //woven
    ten: Prt,
    //brighten
    ect: Inf,
    ict: Inf,
    // ide: Inf,
    ign: Inf,
    oze: Inf,
    ful: Adj,
    bal: Adj,
    ton: Noun
  },
  {
    //4-letter
    amed: Past,
    aped: Past,
    ched: Past,
    lked: Past,
    rked: Past,
    reed: Past,
    nded: Past,
    mned: Adj,
    cted: Past,
    dged: Past,
    ield: Sing,
    akis: Last,
    cede: Inf,
    chuk: Last,
    czyk: Last,
    ects: Pres,
    iend: Sing,
    ends: Vb,
    enko: Last,
    ette: Sing,
    iary: Sing,
    wner: Sing,
    //owner
    fies: Pres,
    fore: Avb,
    gate: Inf,
    gone: Adj,
    ices: Plrl,
    ints: Plrl,
    ruct: Inf,
    ines: Plrl,
    ions: Plrl,
    ners: Plrl,
    pers: Plrl,
    lers: Plrl,
    less: Adj,
    llen: Adj,
    made: Adj,
    nsen: Last,
    oses: Pres,
    ould: Modal,
    some: Adj,
    sson: Last,
    ians: Plrl,
    // tage: Inf,
    tion: Sing,
    tage: Noun,
    ique: Sing,
    tive: Adj,
    tors: Noun,
    vice: Sing,
    lier: Sing,
    fier: Sing,
    wned: Past,
    gent: Sing,
    tist: Actor,
    pist: Actor,
    rist: Actor,
    mist: Actor,
    yist: Actor,
    vist: Actor,
    ists: Actor,
    lite: Sing,
    site: Sing,
    rite: Sing,
    mite: Sing,
    bite: Sing,
    mate: Sing,
    date: Sing,
    ndal: Sing,
    vent: Sing,
    uist: Actor,
    gist: Actor,
    note: Sing,
    cide: Sing,
    //homicide
    ence: Sing,
    //absence
    wide: Adj,
    //nationwide
    // side: Adj,//alongside
    vide: Inf,
    //provide
    ract: Inf,
    duce: Inf,
    pose: Inf,
    eive: Inf,
    lyze: Inf,
    lyse: Inf,
    iant: Adj,
    nary: Adj,
    ghty: Adj,
    uent: Adj,
    erer: Actor,
    //caterer
    bury: Place,
    dorf: Noun,
    esty: Noun,
    wych: Place,
    dale: Place,
    folk: Place
  },
  {
    //5-letter
    elist: Actor,
    holic: Sing,
    phite: Sing,
    tized: Past,
    urned: Past,
    eased: Past,
    ances: Plrl,
    bound: Adj,
    ettes: Plrl,
    fully: Avb,
    ishes: Pres,
    ities: Plrl,
    marek: Last,
    nssen: Last,
    ology: Noun,
    osome: Sing,
    tment: Sing,
    ports: Plrl,
    rough: Adj,
    tches: Pres,
    tieth: "Ordinal",
    tures: Plrl,
    wards: Avb,
    where: Avb,
    archy: Noun,
    pathy: Noun,
    opoly: Noun,
    embly: Noun,
    phate: Noun,
    ndent: Sing,
    scent: Sing,
    onist: Actor,
    anist: Actor,
    alist: Actor,
    olist: Actor,
    icist: Actor,
    ounce: Inf,
    iable: Adj,
    borne: Adj,
    gnant: Adj,
    inant: Adj,
    igent: Adj,
    atory: Adj,
    // ctory: Adj,
    rient: Sing,
    dient: Sing,
    maker: Actor,
    burgh: Place,
    mouth: Place,
    ceter: Place,
    ville: Place,
    worth: Noun
  },
  {
    //6-letter
    auskas: Last,
    parent: Sing,
    cedent: Sing,
    ionary: Sing,
    cklist: Sing,
    keeper: Actor,
    logist: Actor,
    teenth: "Value",
    worker: Actor,
    master: Actor,
    writer: Actor,
    brough: Place,
    cester: Place
  },
  {
    //7-letter
    logists: Actor,
    opoulos: Last,
    borough: Place,
    sdottir: Last
    //swedish female
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/prefixes.js
var Adj2 = "Adjective";
var Noun2 = "Noun";
var Verb = "Verb";
var prefixes_default2 = [
  null,
  null,
  {
    // 2-letter
  },
  {
    // 3-letter
    neo: Noun2,
    bio: Noun2,
    // pre: Noun,
    "de-": Verb,
    "re-": Verb,
    "un-": Verb,
    "ex-": Noun2
  },
  {
    // 4-letter
    anti: Noun2,
    auto: Noun2,
    faux: Adj2,
    hexa: Noun2,
    kilo: Noun2,
    mono: Noun2,
    nano: Noun2,
    octa: Noun2,
    poly: Noun2,
    semi: Adj2,
    tele: Noun2,
    "pro-": Adj2,
    "mis-": Verb,
    "dis-": Verb,
    "pre-": Adj2
    //hmm
  },
  {
    // 5-letter
    anglo: Noun2,
    centi: Noun2,
    ethno: Noun2,
    ferro: Noun2,
    grand: Noun2,
    hepta: Noun2,
    hydro: Noun2,
    intro: Noun2,
    macro: Noun2,
    micro: Noun2,
    milli: Noun2,
    nitro: Noun2,
    penta: Noun2,
    quasi: Adj2,
    radio: Noun2,
    tetra: Noun2,
    "omni-": Adj2,
    "post-": Adj2
  },
  {
    // 6-letter
    pseudo: Adj2,
    "extra-": Adj2,
    "hyper-": Adj2,
    "inter-": Adj2,
    "intra-": Adj2,
    "deca-": Adj2
    // 'trans-': Noun,
  },
  {
    // 7-letter
    electro: Noun2
  }
];

// node_modules/compromise/src/2-two/preTagger/model/patterns/endsWith.js
var Adj3 = "Adjective";
var Inf2 = "Infinitive";
var Pres2 = "PresentTense";
var Sing2 = "Singular";
var Past2 = "PastTense";
var Adverb = "Adverb";
var Exp = "Expression";
var Actor2 = "Actor";
var Verb2 = "Verb";
var Noun3 = "Noun";
var Last2 = "LastName";
var endsWith_default = {
  a: [
    [/.[aeiou]na$/, Noun3, "tuna"],
    [/.[oau][wvl]ska$/, Last2],
    [/.[^aeiou]ica$/, Sing2, "harmonica"],
    [/^([hyj]a+)+$/, Exp, "haha"]
    //hahah
  ],
  c: [[/.[^aeiou]ic$/, Adj3]],
  d: [
    //==-ed==
    //double-consonant
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, Past2, "popped"],
    //double-vowel
    [/.[aeo]{2}[bdgmnprvz]ed$/, Past2, "rammed"],
    //-hed
    [/.[aeiou][sg]hed$/, Past2, "gushed"],
    //-rd
    [/.[aeiou]red$/, Past2, "hired"],
    [/.[aeiou]r?ried$/, Past2, "hurried"],
    // ard
    [/[^aeiou]ard$/, Sing2, "steward"],
    // id
    [/[aeiou][^aeiou]id$/, Adj3, ""],
    [/.[vrl]id$/, Adj3, "livid"],
    // ===== -ed ======
    //-led
    [/..led$/, Past2, "hurled"],
    //-sed
    [/.[iao]sed$/, Past2, ""],
    [/[aeiou]n?[cs]ed$/, Past2, ""],
    //-med
    [/[aeiou][rl]?[mnf]ed$/, Past2, ""],
    //-ked
    [/[aeiou][ns]?c?ked$/, Past2, "bunked"],
    //-gned
    [/[aeiou]gned$/, Past2],
    //-ged
    [/[aeiou][nl]?ged$/, Past2],
    //-ted
    [/.[tdbwxyz]ed$/, Past2],
    [/[^aeiou][aeiou][tvx]ed$/, Past2],
    //-ied
    [/.[cdflmnprstv]ied$/, Past2, "emptied"]
  ],
  e: [
    [/.[lnr]ize$/, Inf2, "antagonize"],
    [/.[^aeiou]ise$/, Inf2, "antagonise"],
    [/.[aeiou]te$/, Inf2, "bite"],
    [/.[^aeiou][ai]ble$/, Adj3, "fixable"],
    [/.[^aeiou]eable$/, Adj3, "maleable"],
    [/.[ts]ive$/, Adj3, "festive"],
    [/[a-z]-like$/, Adj3, "woman-like"]
  ],
  h: [
    [/.[^aeiouf]ish$/, Adj3, "cornish"],
    [/.v[iy]ch$/, Last2, "..ovich"],
    [/^ug?h+$/, Exp, "ughh"],
    [/^uh[ -]?oh$/, Exp, "uhoh"],
    [/[a-z]-ish$/, Adj3, "cartoon-ish"]
  ],
  i: [[/.[oau][wvl]ski$/, Last2, "polish-male"]],
  k: [
    [/^(k){2}$/, Exp, "kkkk"]
    //kkkk
  ],
  l: [
    [/.[gl]ial$/, Adj3, "familial"],
    [/.[^aeiou]ful$/, Adj3, "fitful"],
    [/.[nrtumcd]al$/, Adj3, "natal"],
    [/.[^aeiou][ei]al$/, Adj3, "familial"]
  ],
  m: [
    [/.[^aeiou]ium$/, Sing2, "magnesium"],
    [/[^aeiou]ism$/, Sing2, "schism"],
    [/^[hu]m+$/, Exp, "hmm"],
    [/^\d+ ?[ap]m$/, "Date", "3am"]
  ],
  n: [
    [/.[lsrnpb]ian$/, Adj3, "republican"],
    [/[^aeiou]ician$/, Actor2, "musician"],
    [/[aeiou][ktrp]in'$/, "Gerund", "cookin'"]
    // 'cookin', 'hootin'
  ],
  o: [
    [/^no+$/, Exp, "noooo"],
    [/^(yo)+$/, Exp, "yoo"],
    [/^wo{2,}[pt]?$/, Exp, "woop"]
    //woo
  ],
  r: [
    [/.[bdfklmst]ler$/, "Noun"],
    [/[aeiou][pns]er$/, Sing2],
    [/[^i]fer$/, Inf2],
    [/.[^aeiou][ao]pher$/, Actor2],
    [/.[lk]er$/, "Noun"],
    [/.ier$/, "Comparative"]
  ],
  t: [
    [/.[di]est$/, "Superlative"],
    [/.[icldtgrv]ent$/, Adj3],
    [/[aeiou].*ist$/, Adj3],
    [/^[a-z]et$/, Verb2]
  ],
  s: [
    [/.[^aeiou]ises$/, Pres2],
    [/.[rln]ates$/, Pres2],
    [/.[^z]ens$/, Verb2],
    [/.[lstrn]us$/, Sing2],
    [/.[aeiou]sks$/, Pres2],
    [/.[aeiou]kes$/, Pres2],
    [/[aeiou][^aeiou]is$/, Sing2],
    [/[a-z]'s$/, Noun3],
    [/^yes+$/, Exp]
    //yessss
  ],
  v: [
    [/.[^aeiou][ai][kln]ov$/, Last2]
    //east-europe
  ],
  y: [
    [/.[cts]hy$/, Adj3],
    [/.[st]ty$/, Adj3],
    [/.[tnl]ary$/, Adj3],
    [/.[oe]ry$/, Sing2],
    [/[rdntkbhs]ly$/, Adverb],
    [/.(gg|bb|zz)ly$/, Adj3],
    [/...lly$/, Adverb],
    [/.[gk]y$/, Adj3],
    [/[bszmp]{2}y$/, Adj3],
    [/.[ai]my$/, Adj3],
    [/[ea]{2}zy$/, Adj3],
    [/.[^aeiou]ity$/, Sing2]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/patterns/neighbours.js
var vb2 = "Verb";
var nn2 = "Noun";
var neighbours_default = {
  // looking at the previous word's tags:
  leftTags: [
    ["Adjective", nn2],
    ["Possessive", nn2],
    ["Determiner", nn2],
    ["Adverb", vb2],
    ["Pronoun", vb2],
    ["Value", nn2],
    ["Ordinal", nn2],
    ["Modal", vb2],
    ["Superlative", nn2],
    ["Demonym", nn2],
    ["Honorific", "Person"]
    //dr. Smith
  ],
  // looking at the previous word:
  leftWords: [
    ["i", vb2],
    ["first", nn2],
    ["it", vb2],
    ["there", vb2],
    ["not", vb2],
    ["because", nn2],
    ["if", nn2],
    ["but", nn2],
    ["who", vb2],
    ["this", nn2],
    ["his", nn2],
    ["when", nn2],
    ["you", vb2],
    ["very", "Adjective"],
    ["old", nn2],
    ["never", vb2],
    ["before", nn2],
    ["a", nn2],
    ["the", nn2],
    ["been", vb2]
  ],
  // looking at the next word's tags:
  rightTags: [
    ["Copula", nn2],
    ["PastTense", nn2],
    ["Conjunction", nn2],
    ["Modal", nn2]
  ],
  // looking at the next word:
  rightWords: [
    ["there", vb2],
    ["me", vb2],
    ["man", "Adjective"],
    // ['only', vb],
    ["him", vb2],
    ["it", vb2],
    //relaunch it
    ["were", nn2],
    ["took", nn2],
    ["himself", vb2],
    ["went", nn2],
    ["who", nn2],
    ["jr", "Person"]
  ]
};

// node_modules/compromise/src/2-two/preTagger/model/models/_data.js
var data_default2 = {
  "Comparative": {
    "fwd": "3:ser,ier\xA61er:h,t,f,l,n\xA61r:e\xA62er:ss,or,om",
    "both": "3er:ver,ear,alm\xA63ner:hin\xA63ter:lat\xA62mer:im\xA62er:ng,rm,mb\xA62ber:ib\xA62ger:ig\xA61er:w,p,k,d\xA6ier:y",
    "rev": "1:tter,yer\xA62:uer,ver,ffer,oner,eler,ller,iler,ster,cer,uler,sher,ener,gher,aner,adder,nter,eter,rter,hter,rner,fter\xA63:oser,ooler,eafer,user,airer,bler,maler,tler,eater,uger,rger,ainer,urer,ealer,icher,pler,emner,icter,nser,iser\xA64:arser,viner,ucher,rosser,somer,ndomer,moter,oother,uarer,hiter\xA65:nuiner,esser,emier\xA6ar:urther",
    "ex": "worse:bad\xA6better:good\xA64er:fair,gray,poor\xA61urther:far\xA63ter:fat,hot,wet\xA63der:mad,sad\xA63er:shy,fun\xA64der:glad\xA6:\xA64r:cute,dire,fake,fine,free,lame,late,pale,rare,ripe,rude,safe,sore,tame,wide\xA65r:eerie,stale"
  },
  "Gerund": {
    "fwd": "1:nning,tting,rring,pping,eing,mming,gging,dding,bbing,kking\xA62:eking,oling,eling,eming\xA63:velling,siting,uiting,fiting,loting,geting,ialing,celling\xA64:graming",
    "both": "1:aing,iing,fing,xing,ying,oing,hing,wing\xA62:tzing,rping,izzing,bting,mning,sping,wling,rling,wding,rbing,uping,lming,wning,mping,oning,lting,mbing,lking,fting,hting,sking,gning,pting,cking,ening,nking,iling,eping,ering,rting,rming,cting,lping,ssing,nting,nding,lding,sting,rning,rding,rking\xA63:belling,siping,toming,yaking,uaking,oaning,auling,ooping,aiding,naping,euring,tolling,uzzing,ganing,haning,ualing,halling,iasing,auding,ieting,ceting,ouling,voring,ralling,garing,joring,oaming,oaking,roring,nelling,ooring,uelling,eaming,ooding,eaping,eeting,ooting,ooming,xiting,keting,ooking,ulling,airing,oaring,biting,outing,oiting,earing,naling,oading,eeding,ouring,eaking,aiming,illing,oining,eaning,onging,ealing,aining,eading\xA64:thoming,melling,aboring,ivoting,weating,dfilling,onoring,eriting,imiting,tialling,rgining,otoring,linging,winging,lleting,louding,spelling,mpelling,heating,feating,opelling,choring,welling,ymaking,ctoring,calling,peating,iloring,laiting,utoring,uditing,mmaking,loating,iciting,waiting,mbating,voiding,otalling,nsoring,nselling,ocusing,itoring,eloping\xA65:rselling,umpeting,atrolling,treating,tselling,rpreting,pringing,ummeting,ossoming,elmaking,eselling,rediting,totyping,onmaking,rfeiting,ntrolling\xA65e:chmaking,dkeeping,severing,erouting,ecreting,ephoning,uthoring,ravening,reathing,pediting,erfering,eotyping,fringing,entoring,ombining,ompeting\xA64e:emaking,eething,twining,rruling,chuting,xciting,rseding,scoping,edoring,pinging,lunging,agining,craping,pleting,eleting,nciting,nfining,ncoding,tponing,ecoding,writing,esaling,nvening,gnoring,evoting,mpeding,rvening,dhering,mpiling,storing,nviting,ploring\xA63e:tining,nuring,saking,miring,haling,ceding,xuding,rining,nuting,laring,caring,miling,riding,hoking,piring,lading,curing,uading,noting,taping,futing,paring,hading,loding,siring,guring,vading,voking,during,niting,laning,caping,luting,muting,ruding,ciding,juring,laming,caling,hining,uoting,liding,ciling,duling,tuting,puting,cuting,coring,uiding,tiring,turing,siding,rading,enging,haping,buting,lining,taking,anging,haring,uiring,coming,mining,moting,suring,viding,luding\xA62e:tring,zling,uging,oging,gling,iging,vring,fling,lging,obing,psing,pling,ubing,cling,dling,wsing,iking,rsing,dging,kling,ysing,tling,rging,eging,nsing,uning,osing,uming,using,ibing,bling,aging,ising,asing,ating\xA62ie:rlying\xA61e:zing,uing,cing,ving",
    "rev": "ying:ie\xA61ing:se,ke,te,we,ne,re,de,pe,me,le,c,he\xA62ing:ll,ng,dd,ee,ye,oe,rg,us\xA62ning:un\xA62ging:og,ag,ug,ig,eg\xA62ming:um\xA62bing:ub,ab,eb,ob\xA63ning:lan,can,hin,pin,win\xA63ring:cur,lur,tir,tar,pur,car\xA63ing:ait,del,eel,fin,eat,oat,eem,lel,ool,ein,uin\xA63ping:rop,rap,top,uip,wap,hip,hop,lap,rip,cap\xA63ming:tem,wim,rim,kim,lim\xA63ting:mat,cut,pot,lit,lot,hat,set,pit,put\xA63ding:hed,bed,bid\xA63king:rek\xA63ling:cil,pel\xA63bing:rib\xA64ning:egin\xA64ing:isit,ruit,ilot,nsit,dget,rkel,ival,rcel\xA64ring:efer,nfer\xA64ting:rmit,mmit,ysit,dmit,emit,bmit,tfit,gret\xA64ling:evel,xcel,ivel\xA64ding:hred\xA65ing:arget,posit,rofit\xA65ring:nsfer\xA65ting:nsmit,orget,cquit\xA65ling:ancel,istil",
    "ex": "3:adding,eating,aiming,aiding,airing,outing,gassing,setting,getting,putting,cutting,winning,sitting,betting,mapping,tapping,letting,bidding,hitting,tanning,netting,popping,fitting,capping,lapping,barring,banning,vetting,topping,rotting,tipping,potting,wetting,pitting,dipping,budding,hemming,pinning,jetting,kidding,padding,podding,sipping,wedding,bedding,donning,warring,penning,gutting,cueing,wadding,petting,ripping,napping,matting,tinning,binning,dimming,hopping,mopping,nodding,panning,rapping,ridding,sinning\xA64:selling,falling,calling,waiting,editing,telling,rolling,heating,boating,hanging,beating,coating,singing,tolling,felling,polling,discing,seating,voiding,gelling,yelling,baiting,reining,ruining,seeking,spanning,stepping,knitting,emitting,slipping,quitting,dialing,omitting,clipping,shutting,skinning,abutting,flipping,trotting,cramming,fretting,suiting\xA65:bringing,treating,spelling,stalling,trolling,expelling,rivaling,wringing,deterring,singeing,befitting,refitting\xA66:enrolling,distilling,scrolling,strolling,caucusing,travelling\xA67:installing,redefining,stencilling,recharging,overeating,benefiting,unraveling,programing\xA69:reprogramming\xA6is:being\xA62e:using,aging,owing\xA63e:making,taking,coming,noting,hiring,filing,coding,citing,doping,baking,coping,hoping,lading,caring,naming,voting,riding,mining,curing,lining,ruling,typing,boring,dining,firing,hiding,piling,taping,waning,baling,boning,faring,honing,wiping,luring,timing,wading,piping,fading,biting,zoning,daring,waking,gaming,raking,ceding,tiring,coking,wining,joking,paring,gaping,poking,pining,coring,liming,toting,roping,wiring,aching\xA64e:writing,storing,eroding,framing,smoking,tasting,wasting,phoning,shaking,abiding,braking,flaking,pasting,priming,shoring,sloping,withing,hinging\xA65e:defining,refining,renaming,swathing,fringing,reciting\xA61ie:dying,tying,lying,vying\xA67e:sunbathing"
  },
  "Participle": {
    "fwd": "1:mt\xA62:llen\xA63:iven,aken\xA6:ne\xA6y:in",
    "both": "1:wn\xA62:me,aten\xA63:seen,bidden,isen\xA64:roven,asten\xA63l:pilt\xA63d:uilt\xA62e:itten\xA61im:wum\xA61eak:poken\xA61ine:hone\xA61ose:osen\xA61in:gun\xA61ake:woken\xA6ear:orn\xA6eal:olen\xA6eeze:ozen\xA6et:otten\xA6ink:unk\xA6ing:ung",
    "rev": "2:un\xA6oken:eak\xA6ought:eek\xA6oven:eave\xA61ne:o\xA61own:ly\xA61den:de\xA61in:ay\xA62t:am\xA62n:ee\xA63en:all\xA64n:rive,sake,take\xA65n:rgive",
    "ex": "2:been\xA63:seen,run\xA64:given,taken\xA65:shaken\xA62eak:broken\xA61ive:dove\xA62y:flown\xA63e:hidden,ridden\xA61eek:sought\xA61ake:woken\xA61eave:woven"
  },
  "PastTense": {
    "fwd": "1:tted,wed,gged,nned,een,rred,pped,yed,bbed,oed,dded,rd,wn,mmed\xA62:eed,nded,et,hted,st,oled,ut,emed,eled,lded,ken,rt,nked,apt,ant,eped,eked\xA63:eared,eat,eaded,nelled,ealt,eeded,ooted,eaked,eaned,eeted,mited,bid,uit,ead,uited,ealed,geted,velled,ialed,belled\xA64:ebuted,hined,comed\xA6y:ied\xA6ome:ame\xA6ear:ore\xA6ind:ound\xA6ing:ung,ang\xA6ep:pt\xA6ink:ank,unk\xA6ig:ug\xA6all:ell\xA6ee:aw\xA6ive:ave\xA6eeze:oze\xA6old:eld\xA6ave:ft\xA6ake:ook\xA6ell:old\xA6ite:ote\xA6ide:ode\xA6ine:one\xA6in:un,on\xA6eal:ole\xA6im:am\xA6ie:ay\xA6and:ood\xA61ise:rose\xA61eak:roke\xA61ing:rought\xA61ive:rove\xA61el:elt\xA61id:bade\xA61et:got\xA61y:aid\xA61it:sat\xA63e:lid\xA63d:pent",
    "both": "1:aed,fed,xed,hed\xA62:sged,xted,wled,rped,lked,kied,lmed,lped,uped,bted,rbed,rked,wned,rled,mped,fted,mned,mbed,zzed,omed,ened,cked,gned,lted,sked,ued,zed,nted,ered,rted,rmed,ced,sted,rned,ssed,rded,pted,ved,cted\xA63:cled,eined,siped,ooned,uked,ymed,jored,ouded,ioted,oaned,lged,asped,iged,mured,oided,eiled,yped,taled,moned,yled,lit,kled,oaked,gled,naled,fled,uined,oared,valled,koned,soned,aided,obed,ibed,meted,nicked,rored,micked,keted,vred,ooped,oaded,rited,aired,auled,filled,ouled,ooded,ceted,tolled,oited,bited,aped,tled,vored,dled,eamed,nsed,rsed,sited,owded,pled,sored,rged,osed,pelled,oured,psed,oated,loned,aimed,illed,eured,tred,ioned,celled,bled,wsed,ooked,oiled,itzed,iked,iased,onged,ased,ailed,uned,umed,ained,auded,nulled,ysed,eged,ised,aged,oined,ated,used,dged,doned\xA64:ntied,efited,uaked,caded,fired,roped,halled,roked,himed,culed,tared,lared,tuted,uared,routed,pited,naked,miled,houted,helled,hared,cored,caled,tired,peated,futed,ciled,called,tined,moted,filed,sided,poned,iloted,honed,lleted,huted,ruled,cured,named,preted,vaded,sured,talled,haled,peded,gined,nited,uided,ramed,feited,laked,gured,ctored,unged,pired,cuted,voked,eloped,ralled,rined,coded,icited,vided,uaded,voted,mined,sired,noted,lined,nselled,luted,jured,fided,puted,piled,pared,olored,cided,hoked,enged,tured,geoned,cotted,lamed,uiled,waited,udited,anged,luded,mired,uired,raded\xA65:modelled,izzled,eleted,umpeted,ailored,rseded,treated,eduled,ecited,rammed,eceded,atrolled,nitored,basted,twined,itialled,ncited,gnored,ploded,xcited,nrolled,namelled,plored,efeated,redited,ntrolled,nfined,pleted,llided,lcined,eathed,ibuted,lloted,dhered,cceded\xA63ad:sled\xA62aw:drew\xA62ot:hot\xA62ke:made\xA62ow:hrew,grew\xA62ose:hose\xA62d:ilt\xA62in:egan\xA61un:ran\xA61ink:hought\xA61ick:tuck\xA61ike:ruck\xA61eak:poke,nuck\xA61it:pat\xA61o:did\xA61ow:new\xA61ake:woke\xA6go:went",
    "rev": "3:rst,hed,hut,cut,set\xA64:tbid\xA65:dcast,eread,pread,erbid\xA6ought:uy,eek\xA61ied:ny,ly,dy,ry,fy,py,vy,by,ty,cy\xA61ung:ling,ting,wing\xA61pt:eep\xA61ank:rink\xA61ore:bear,wear\xA61ave:give\xA61oze:reeze\xA61ound:rind,wind\xA61ook:take,hake\xA61aw:see\xA61old:sell\xA61ote:rite\xA61ole:teal\xA61unk:tink\xA61am:wim\xA61ay:lie\xA61ood:tand\xA61eld:hold\xA62d:he,ge,re,le,leed,ne,reed,be,ye,lee,pe,we\xA62ed:dd,oy,or,ey,gg,rr,us,ew,to\xA62ame:ecome,rcome\xA62ped:ap\xA62ged:ag,og,ug,eg\xA62bed:ub,ab,ib,ob\xA62lt:neel\xA62id:pay\xA62ang:pring\xA62ove:trive\xA62med:um\xA62ode:rride\xA62at:ysit\xA63ted:mit,hat,mat,lat,pot,rot,bat\xA63ed:low,end,tow,und,ond,eem,lay,cho,dow,xit,eld,ald,uld,law,lel,eat,oll,ray,ank,fin,oam,out,how,iek,tay,haw,ait,vet,say,cay,bow\xA63d:ste,ede,ode,ete,ree,ude,ame,oke,ote,ime,ute,ade\xA63red:lur,cur,pur,car\xA63ped:hop,rop,uip,rip,lip,tep,top\xA63ded:bed,rod,kid\xA63ade:orbid\xA63led:uel\xA63ned:lan,can,kin,pan,tun\xA63med:rim,lim\xA64ted:quit,llot\xA64ed:pear,rrow,rand,lean,mand,anel,pand,reet,link,abel,evel,imit,ceed,ruit,mind,peal,veal,hool,head,pell,well,mell,uell,band,hear,weak\xA64led:nnel,qual,ebel,ivel\xA64red:nfer,efer,sfer\xA64n:sake,trew\xA64d:ntee\xA64ded:hred\xA64ned:rpin\xA65ed:light,nceal,right,ndear,arget,hread,eight,rtial,eboot\xA65d:edite,nvite\xA65ted:egret\xA65led:ravel",
    "ex": "2:been,upped\xA63:added,aged,aided,aimed,aired,bid,died,dyed,egged,erred,eyed,fit,gassed,hit,lied,owed,pent,pied,tied,used,vied,oiled,outed,banned,barred,bet,canned,cut,dipped,donned,ended,feed,inked,jarred,let,manned,mowed,netted,padded,panned,pitted,popped,potted,put,set,sewn,sowed,tanned,tipped,topped,vowed,weed,bowed,jammed,binned,dimmed,hopped,mopped,nodded,pinned,rigged,sinned,towed,vetted\xA64:ached,baked,baled,boned,bored,called,caned,cared,ceded,cited,coded,cored,cubed,cured,dared,dined,edited,exited,faked,fared,filed,fined,fired,fuelled,gamed,gelled,hired,hoped,joked,lined,mined,named,noted,piled,poked,polled,pored,pulled,reaped,roamed,rolled,ruled,seated,shed,sided,timed,tolled,toned,voted,waited,walled,waned,winged,wiped,wired,zoned,yelled,tamed,lubed,roped,faded,mired,caked,honed,banged,culled,heated,raked,welled,banded,beat,cast,cooled,cost,dealt,feared,folded,footed,handed,headed,heard,hurt,knitted,landed,leaked,leapt,linked,meant,minded,molded,neared,needed,peaked,plodded,plotted,pooled,quit,read,rooted,sealed,seeded,seeped,shipped,shunned,skimmed,slammed,sparred,stemmed,stirred,suited,thinned,twinned,swayed,winked,dialed,abutted,blotted,fretted,healed,heeded,peeled,reeled\xA65:basted,cheated,equalled,eroded,exiled,focused,opined,pleated,primed,quoted,scouted,shored,sloped,smoked,sniped,spelled,spouted,routed,staked,stored,swelled,tasted,treated,wasted,smelled,dwelled,honored,prided,quelled,eloped,scared,coveted,sweated,breaded,cleared,debuted,deterred,freaked,modeled,pleaded,rebutted,speeded\xA66:anchored,defined,endured,impaled,invited,refined,revered,strolled,cringed,recast,thrust,unfolded\xA67:authored,combined,competed,conceded,convened,excreted,extruded,redefined,restored,secreted,rescinded,welcomed\xA68:expedited,infringed\xA69:interfered,intervened,persevered\xA610:contravened\xA6eat:ate\xA6is:was\xA6go:went\xA6are:were\xA63d:bent,lent,rent,sent\xA63e:bit,fled,hid,lost\xA63ed:bled,bred\xA62ow:blew,grew\xA61uy:bought\xA62tch:caught\xA61o:did\xA61ive:dove,gave\xA62aw:drew\xA62ed:fed\xA62y:flew,laid,paid,said\xA61ight:fought\xA61et:got\xA62ve:had\xA61ang:hung\xA62ad:led\xA62ght:lit\xA62ke:made\xA62et:met\xA61un:ran\xA61ise:rose\xA61it:sat\xA61eek:sought\xA61each:taught\xA61ake:woke,took\xA61eave:wove\xA62ise:arose\xA61ear:bore,tore,wore\xA61ind:bound,found,wound\xA62eak:broke\xA62ing:brought,wrung\xA61ome:came\xA62ive:drove\xA61ig:dug\xA61all:fell\xA62el:felt\xA64et:forgot\xA61old:held\xA62ave:left\xA61ing:rang,sang\xA61ide:rode\xA61ink:sank\xA61ee:saw\xA62ine:shone\xA64e:slid\xA61ell:sold,told\xA64d:spent\xA62in:spun\xA61in:won"
  },
  "PresentTense": {
    "fwd": "1:oes\xA61ve:as",
    "both": "1:xes\xA62:zzes,ches,shes,sses\xA63:iases\xA62y:llies,plies\xA61y:cies,bies,ties,vies,nies,pies,dies,ries,fies\xA6:s",
    "rev": "1ies:ly\xA62es:us,go,do\xA63es:cho,eto",
    "ex": "2:does,goes\xA63:gasses\xA65:focuses\xA6is:are\xA63y:relies\xA62y:flies\xA62ve:has"
  },
  "Superlative": {
    "fwd": "1st:e\xA61est:l,m,f,s\xA61iest:cey\xA62est:or,ir\xA63est:ver",
    "both": "4:east\xA65:hwest\xA65lest:erful\xA64est:weet,lgar,tter,oung\xA64most:uter\xA63est:ger,der,rey,iet,ong,ear\xA63test:lat\xA63most:ner\xA62est:pt,ft,nt,ct,rt,ht\xA62test:it\xA62gest:ig\xA61est:b,k,n,p,h,d,w\xA6iest:y",
    "rev": "1:ttest,nnest,yest\xA62:sest,stest,rmest,cest,vest,lmest,olest,ilest,ulest,ssest,imest,uest\xA63:rgest,eatest,oorest,plest,allest,urest,iefest,uelest,blest,ugest,amest,yalest,ealest,illest,tlest,itest\xA64:cerest,eriest,somest,rmalest,ndomest,motest,uarest,tiffest\xA65:leverest,rangest\xA6ar:urthest\xA63ey:riciest",
    "ex": "best:good\xA6worst:bad\xA65est:great\xA64est:fast,full,fair,dull\xA63test:hot,wet,fat\xA64nest:thin\xA61urthest:far\xA63est:gay,shy,ill\xA64test:neat\xA64st:late,wide,fine,safe,cute,fake,pale,rare,rude,sore,ripe,dire\xA66st:severe"
  },
  "AdjToNoun": {
    "fwd": "1:tistic,eable,lful,sful,ting,tty\xA62:onate,rtable,geous,ced,seful,ctful\xA63:ortive,ented\xA6arity:ear\xA6y:etic\xA6fulness:begone\xA61ity:re\xA61y:tiful,gic\xA62ity:ile,imous,ilous,ime\xA62ion:ated\xA62eness:iving\xA62y:trious\xA62ation:iring\xA62tion:vant\xA63ion:ect\xA63ce:mant,mantic\xA63tion:irable\xA63y:est,estic\xA63m:mistic,listic\xA63ess:ning\xA64n:utious\xA64on:rative,native,vative,ective\xA64ce:erant",
    "both": "1:king,wing\xA62:alous,ltuous,oyful,rdous\xA63:gorous,ectable,werful,amatic\xA64:oised,usical,agical,raceful,ocused,lined,ightful\xA65ness:stful,lding,itous,nuous,ulous,otous,nable,gious,ayful,rvous,ntous,lsive,peful,entle,ciful,osive,leful,isive,ncise,reful,mious\xA65ty:ivacious\xA65ties:ubtle\xA65ce:ilient,adiant,atient\xA65cy:icient\xA65sm:gmatic\xA65on:sessive,dictive\xA65ity:pular,sonal,eative,entic\xA65sity:uminous\xA65ism:conic\xA65nce:mperate\xA65ility:mitable\xA65ment:xcited\xA65n:bitious\xA64cy:brant,etent,curate\xA64ility:erable,acable,icable,ptable\xA64ty:nacious,aive,oyal,dacious\xA64n:icious\xA64ce:vient,erent,stent,ndent,dient,quent,ident\xA64ness:adic,ound,hing,pant,sant,oing,oist,tute\xA64icity:imple\xA64ment:fined,mused\xA64ism:otic\xA64ry:dantic\xA64ity:tund,eral\xA64edness:hand\xA64on:uitive\xA64lity:pitable\xA64sm:eroic,namic\xA64sity:nerous\xA63th:arm\xA63ility:pable,bable,dable,iable\xA63cy:hant,nant,icate\xA63ness:red,hin,nse,ict,iet,ite,oud,ind,ied,rce\xA63ion:lute\xA63ity:ual,gal,volous,ial\xA63ce:sent,fensive,lant,gant,gent,lent,dant\xA63on:asive\xA63m:fist,sistic,iastic\xA63y:terious,xurious,ronic,tastic\xA63ur:amorous\xA63e:tunate\xA63ation:mined\xA63sy:rteous\xA63ty:ain\xA63ry:ave\xA63ment:azed\xA62ness:de,on,ue,rn,ur,ft,rp,pe,om,ge,rd,od,ay,ss,er,ll,oy,ap,ht,ld,ad,rt\xA62inousness:umous\xA62ity:neous,ene,id,ane\xA62cy:bate,late\xA62ation:ized\xA62ility:oble,ible\xA62y:odic\xA62e:oving,aring\xA62s:ost\xA62itude:pt\xA62dom:ee\xA62ance:uring\xA62tion:reet\xA62ion:oted\xA62sion:ending\xA62liness:an\xA62or:rdent\xA61th:ung\xA61e:uable\xA61ness:w,h,k,f\xA61ility:mble\xA61or:vent\xA61ement:ging\xA61tiquity:ncient\xA61ment:hed\xA6verty:or\xA6ength:ong\xA6eat:ot\xA6pth:ep\xA6iness:y",
    "rev": "",
    "ex": "5:forceful,humorous\xA68:charismatic\xA613:understanding\xA65ity:active\xA611ness:adventurous,inquisitive,resourceful\xA68on:aggressive,automatic,perceptive\xA67ness:amorous,fatuous,furtive,ominous,serious\xA65ness:ample,sweet\xA612ness:apprehensive,cantankerous,contemptuous,ostentatious\xA613ness:argumentative,conscientious\xA69ness:assertive,facetious,imperious,inventive,oblivious,rapacious,receptive,seditious,whimsical\xA610ness:attractive,expressive,impressive,loquacious,salubrious,thoughtful\xA63edom:boring\xA64ness:calm,fast,keen,tame\xA68ness:cheerful,gracious,specious,spurious,timorous,unctuous\xA65sity:curious\xA69ion:deliberate\xA68ion:desperate\xA66e:expensive\xA67ce:fragrant\xA63y:furious\xA69ility:ineluctable\xA66ism:mystical\xA68ity:physical,proactive,sensitive,vertical\xA65cy:pliant\xA67ity:positive\xA69ity:practical\xA612ism:professional\xA66ce:prudent\xA63ness:red\xA66cy:vagrant\xA63dom:wise"
  }
};

// node_modules/suffix-thumb/src/convert/index.js
var checkEx = function(str, ex = {}) {
  if (ex.hasOwnProperty(str)) {
    return ex[str];
  }
  return null;
};
var checkSame = function(str, same = []) {
  for (let i5 = 0; i5 < same.length; i5 += 1) {
    if (str.endsWith(same[i5])) {
      return str;
    }
  }
  return null;
};
var checkRules = function(str, fwd, both = {}) {
  fwd = fwd || {};
  let max4 = str.length - 1;
  for (let i5 = max4; i5 >= 1; i5 -= 1) {
    let size = str.length - i5;
    let suff = str.substring(size, str.length);
    if (fwd.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + fwd[suff];
    }
    if (both.hasOwnProperty(suff) === true) {
      return str.slice(0, size) + both[suff];
    }
  }
  if (fwd.hasOwnProperty("")) {
    return str += fwd[""];
  }
  if (both.hasOwnProperty("")) {
    return str += both[""];
  }
  return null;
};
var convert = function(str = "", model5 = {}) {
  let out2 = checkEx(str, model5.ex);
  out2 = out2 || checkSame(str, model5.same);
  out2 = out2 || checkRules(str, model5.fwd, model5.both);
  out2 = out2 || str;
  return out2;
};
var convert_default = convert;

// node_modules/suffix-thumb/src/reverse/index.js
var flipObj = function(obj) {
  return Object.entries(obj).reduce((h4, a4) => {
    h4[a4[1]] = a4[0];
    return h4;
  }, {});
};
var reverse2 = function(model5 = {}) {
  return {
    reversed: true,
    // keep these two
    both: flipObj(model5.both),
    ex: flipObj(model5.ex),
    // swap this one in
    fwd: model5.rev || {}
  };
};
var reverse_default = reverse2;

// node_modules/suffix-thumb/src/compress/unpack.js
var prefix2 = /^([0-9]+)/;
var toObject = function(txt) {
  let obj = {};
  txt.split("\xA6").forEach((str) => {
    let [key, vals] = str.split(":");
    vals = (vals || "").split(",");
    vals.forEach((val) => {
      obj[val] = key;
    });
  });
  return obj;
};
var growObject = function(key = "", val = "") {
  val = String(val);
  let m6 = val.match(prefix2);
  if (m6 === null) {
    return val;
  }
  let num = Number(m6[1]) || 0;
  let pre = key.substring(0, num);
  let full = pre + val.replace(prefix2, "");
  return full;
};
var unpackOne = function(str) {
  let obj = toObject(str);
  return Object.keys(obj).reduce((h4, k3) => {
    h4[k3] = growObject(k3, obj[k3]);
    return h4;
  }, {});
};
var uncompress = function(model5 = {}) {
  if (typeof model5 === "string") {
    model5 = JSON.parse(model5);
  }
  model5.fwd = unpackOne(model5.fwd || "");
  model5.both = unpackOne(model5.both || "");
  model5.rev = unpackOne(model5.rev || "");
  model5.ex = unpackOne(model5.ex || "");
  return model5;
};
var unpack_default2 = uncompress;

// node_modules/compromise/src/2-two/preTagger/model/models/index.js
var fromPast = unpack_default2(data_default2.PastTense);
var fromPresent = unpack_default2(data_default2.PresentTense);
var fromGerund = unpack_default2(data_default2.Gerund);
var fromParticiple = unpack_default2(data_default2.Participle);
var toPast = reverse_default(fromPast);
var toPresent = reverse_default(fromPresent);
var toGerund = reverse_default(fromGerund);
var toParticiple = reverse_default(fromParticiple);
var toComparative = unpack_default2(data_default2.Comparative);
var toSuperlative = unpack_default2(data_default2.Superlative);
var fromComparative = reverse_default(toComparative);
var fromSuperlative = reverse_default(toSuperlative);
var adjToNoun = unpack_default2(data_default2.AdjToNoun);
var models_default = {
  fromPast,
  fromPresent,
  fromGerund,
  fromParticiple,
  toPast,
  toPresent,
  toGerund,
  toParticiple,
  // adjectives
  toComparative,
  toSuperlative,
  fromComparative,
  fromSuperlative,
  adjToNoun
};

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-normal.js
var regex_normal_default = [
  //web tags
  [/^[\w.]+@[\w.]+\.[a-z]{2,3}$/, "Email"],
  [/^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/, "Url", "http.."],
  [/^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/, "Url", ".com"],
  // timezones
  [/^[PMCE]ST$/, "Timezone", "EST"],
  //names
  [/^ma?c'[a-z]{3}/, "LastName", "mc'neil"],
  [/^o'[a-z]{3}/, "LastName", "o'connor"],
  [/^ma?cd[aeiou][a-z]{3}/, "LastName", "mcdonald"],
  //slang things
  [/^(lol)+[sz]$/, "Expression", "lol"],
  [/^wo{2,}a*h?$/, "Expression", "wooah"],
  [/^(hee?){2,}h?$/, "Expression", "hehe"],
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, "Verb", "un-vite"],
  // m/h
  [/^(m|k|cm|km)\/(s|h|hr)$/, "Unit", "5 k/m"],
  // μg/g
  [/^(ug|ng|mg)\/(l|m3|ft3)$/, "Unit", "ug/L"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-text.js
var regex_text_default = [
  // #coolguy
  [/^#[\p{Number}_]*\p{Letter}/u, "HashTag"],
  // can't be all numbers
  // @spencermountain
  [/^@\w{2,}$/, "AtMention"],
  // period-ones acronyms - f.b.i.
  [/^([A-Z]\.){2}[A-Z]?/i, ["Acronym", "Noun"], "F.B.I"],
  //ascii-only
  // ending-apostrophes
  [/.{3}[lkmnp]in['‘’‛‵′`´]$/, "Gerund", "chillin'"],
  [/.{4}s['‘’‛‵′`´]$/, "Possessive", "flanders'"],
  //from https://www.regextester.com/106421
  // [/^([\u00a9\u00ae\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, 'Emoji', 'emoji-range']
  // unicode character range
  [/^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u, "Emoji", "emoji-class"]
];

// node_modules/compromise/src/2-two/preTagger/model/regex/regex-numbers.js
var regex_numbers_default = [
  [/^@1?[0-9](am|pm)$/i, "Time", "3pm"],
  [/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, "Time", "3:30pm"],
  [/^'[0-9]{2}$/, "Year"],
  // times
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, "Time", "3:12:31"],
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, "Time", "1:12pm"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, "Time", "1:12:31pm"],
  //can remove?
  // iso-dates
  [/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, "Date", "iso-date"],
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, "Date", "iso-dash"],
  [/^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/, "Date", "iso-slash"],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, "Date", "iso-dot"],
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, "Date", "12-dec-2019"],
  // timezones
  [/^utc ?[+-]?[0-9]+$/, "Timezone", "utc-9"],
  [/^(gmt|utc)[+-][0-9]{1,2}$/i, "Timezone", "gmt-3"],
  //phone numbers
  [/^[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "421-0029"],
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "1-800-"],
  //money
  //like $5.30
  [/^[-+]?\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?([kmb]|bn)?\+?$/u, ["Money", "Value"], "$5.30"],
  //like 5.30$
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\p{Currency_Symbol}\+?$/u, ["Money", "Value"], "5.30\xA3"],
  //like
  [/^[-+]?[$£]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ["Money", "Value"], "$400usd"],
  //numbers
  // 50 | -50 | 3.23  | 5,999.0  | 10+
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ["Cardinal", "NumericValue"], "5,999"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ["Ordinal", "NumericValue"], "53rd"],
  // .73th
  [/^\.[0-9]+\+?$/, ["Cardinal", "NumericValue"], ".73th"],
  //percent
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ["Percent", "Cardinal", "NumericValue"], "-4%"],
  [/^\.[0-9]+%$/, ["Percent", "Cardinal", "NumericValue"], ".3%"],
  //fraction
  [/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ["Fraction", "NumericValue"], "2/3rds"],
  //range
  [/^[0-9.]{1,3}[a-z]{0,2}[-–—][0-9]{1,3}[a-z]{0,2}$/, ["Value", "NumberRange"], "3-4"],
  //time-range
  [/^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-–—] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/, ["Time", "NumberRange"], "3-4pm"],
  //number with unit
  [/^[0-9.]+([a-z°]{1,4})$/, "NumericValue", "9km"]
];

// node_modules/compromise/src/2-two/preTagger/model/orgWords.js
var orgWords_default = [
  "academy",
  "administration",
  "agence",
  "agences",
  "agencies",
  "agency",
  "airlines",
  "airways",
  "army",
  "assoc",
  "associates",
  "association",
  "assurance",
  "authority",
  "autorite",
  "aviation",
  "bank",
  "banque",
  "board",
  "boys",
  "brands",
  "brewery",
  "brotherhood",
  "brothers",
  "bureau",
  "cafe",
  "co",
  "caisse",
  "capital",
  "care",
  "cathedral",
  "center",
  "centre",
  "chemicals",
  "choir",
  "chronicle",
  "church",
  "circus",
  "clinic",
  "clinique",
  "club",
  "co",
  "coalition",
  "coffee",
  "collective",
  "college",
  "commission",
  "committee",
  "communications",
  "community",
  "company",
  "comprehensive",
  "computers",
  "confederation",
  "conference",
  "conseil",
  "consulting",
  "containers",
  "corporation",
  "corps",
  "corp",
  "council",
  "crew",
  "data",
  "departement",
  "department",
  "departments",
  "design",
  "development",
  "directorate",
  "division",
  "drilling",
  "education",
  "eglise",
  "electric",
  "electricity",
  "energy",
  "ensemble",
  "enterprise",
  "enterprises",
  "entertainment",
  "estate",
  "etat",
  "faculty",
  "faction",
  "federation",
  "financial",
  "fm",
  "foundation",
  "fund",
  "gas",
  "gazette",
  "girls",
  "government",
  "group",
  "guild",
  "herald",
  "holdings",
  "hospital",
  "hotel",
  "hotels",
  "inc",
  "industries",
  "institut",
  "institute",
  "institutes",
  "insurance",
  "international",
  "interstate",
  "investment",
  "investments",
  "investors",
  "journal",
  "laboratory",
  "labs",
  "llc",
  "ltd",
  "limited",
  "machines",
  "magazine",
  "management",
  "marine",
  "marketing",
  "markets",
  "media",
  "memorial",
  "ministere",
  "ministry",
  "military",
  "mobile",
  "motor",
  "motors",
  "musee",
  "museum",
  "news",
  "observatory",
  "office",
  "oil",
  "optical",
  "orchestra",
  "organization",
  "partners",
  "partnership",
  "petrol",
  "petroleum",
  "pharmacare",
  "pharmaceutical",
  "pharmaceuticals",
  "pizza",
  "plc",
  "police",
  "politburo",
  "polytechnic",
  "post",
  "power",
  "press",
  "productions",
  "quartet",
  "radio",
  "reserve",
  "resources",
  "restaurant",
  "restaurants",
  "savings",
  "school",
  "securities",
  "service",
  "services",
  "societe",
  "subsidiary",
  "society",
  "sons",
  // 'standard',
  "subcommittee",
  "syndicat",
  "systems",
  "telecommunications",
  "telegraph",
  "television",
  "times",
  "tribunal",
  "tv",
  "union",
  "university",
  "utilities",
  "workers"
].reduce((h4, str) => {
  h4[str] = true;
  return h4;
}, {});

// node_modules/compromise/src/2-two/preTagger/model/placeWords.js
var placeWords_default = [
  // geology
  "atoll",
  "basin",
  "bay",
  "beach",
  "bluff",
  "bog",
  "camp",
  "canyon",
  "canyons",
  "cape",
  "cave",
  "caves",
  // 'cliff',
  "cliffs",
  "coast",
  "cove",
  "coves",
  "crater",
  "creek",
  "desert",
  "dune",
  "dunes",
  "escarpment",
  "estuary",
  "falls",
  "fjord",
  "fjords",
  "forest",
  "forests",
  "glacier",
  "gorge",
  "gorges",
  "gulf",
  "gully",
  "highland",
  "hill",
  "hills",
  "inlet",
  "island",
  "islands",
  "isthmus",
  "knoll",
  "lagoon",
  "lake",
  "marsh",
  "marshes",
  "mount",
  "mountain",
  "mountains",
  "narrows",
  "peninsula",
  "plains",
  "plateau",
  "pond",
  "rapids",
  "ravine",
  "reef",
  "reefs",
  "ridge",
  // 'river delta',
  "river",
  "rivers",
  "sandhill",
  "shoal",
  "shore",
  "shoreline",
  "shores",
  "strait",
  "straits",
  "stream",
  "swamp",
  "tombolo",
  "trail",
  "trails",
  "trench",
  "valley",
  "vallies",
  "volcano",
  "waterfall",
  "watershed",
  "wetland",
  "woods",
  // districts
  "burough",
  "county",
  "district",
  "municipality",
  "prefecture",
  "province",
  "region",
  "reservation",
  "state",
  "territory",
  "borough",
  "metropolis",
  "downtown",
  "uptown",
  "midtown",
  "city",
  "town",
  "township",
  "hamlet",
  "country",
  "kingdom",
  "enclave",
  "neighbourhood",
  "neighborhood",
  "kingdom",
  "ward",
  "zone",
  // 'range',
  //building/ complex
  "airport",
  "amphitheater",
  "arch",
  "arena",
  "auditorium",
  "bar",
  "barn",
  "basilica",
  "battlefield",
  "bridge",
  "building",
  "castle",
  "centre",
  "coliseum",
  "cineplex",
  "complex",
  "dam",
  "farm",
  "field",
  "fort",
  "garden",
  "gardens",
  // 'grounds',
  "gymnasium",
  "hall",
  "house",
  "levee",
  "library",
  "memorial",
  "monument",
  "museum",
  "gallery",
  "palace",
  "pillar",
  "pits",
  // 'pit',
  // 'place',
  // 'point',
  // 'room',
  "plantation",
  "playhouse",
  "quarry",
  // 'ruins',
  "sportsfield",
  "sportsplex",
  "stadium",
  // 'statue',
  "terrace",
  "terraces",
  "theater",
  "tower",
  "park",
  "parks",
  "site",
  "raceway",
  "sportsplex",
  // 'sports centre',
  // 'sports field',
  // 'soccer complex',
  // 'soccer centre',
  // 'sports complex',
  // 'civic centre',
  // roads
  "st",
  "street",
  "rd",
  "road",
  "crescent",
  "cr",
  "way",
  "tr",
  "terrace",
  "avenue",
  "ave"
].reduce((h4, str) => {
  h4[str] = true;
  return h4;
}, {});

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/_rules.js
var rules_default2 = [
  [/([^v])ies$/i, "$1y"],
  [/(ise)s$/i, "$1"],
  //promises
  [/(kn|[^o]l|w)ives$/i, "$1ife"],
  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f"],
  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f"],
  [/(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a"],
  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us"],
  [/(buffal|tomat|tornad)(oes)$/i, "$1o"],
  [/(ause)s$/i, "$1"],
  //causes
  [/(ease)s$/i, "$1"],
  //diseases
  [/(ious)es$/i, "$1"],
  //geniouses
  [/(ouse)s$/i, "$1"],
  //houses
  [/(ose)s$/i, "$1"],
  //roses
  [/(..ase)s$/i, "$1"],
  [/(..[aeiu]s)es$/i, "$1"],
  [/(vert|ind|cort)(ices)$/i, "$1ex"],
  [/(matr|append)(ices)$/i, "$1ix"],
  [/([xo]|ch|ss|sh)es$/i, "$1"],
  [/men$/i, "man"],
  [/(n)ews$/i, "$1ews"],
  [/([ti])a$/i, "$1um"],
  [/([^aeiouy]|qu)ies$/i, "$1y"],
  [/(s)eries$/i, "$1eries"],
  [/(m)ovies$/i, "$1ovie"],
  [/(cris|ax|test)es$/i, "$1is"],
  [/(alias|status)es$/i, "$1"],
  [/(ss)$/i, "$1"],
  [/(ic)s$/i, "$1"],
  [/s$/i, ""]
];

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/toSingular/index.js
var invertObj = function(obj) {
  return Object.keys(obj).reduce((h4, k3) => {
    h4[obj[k3]] = k3;
    return h4;
  }, {});
};
var toSingular = function(str, model5) {
  const { irregularPlurals } = model5.two;
  let invert = invertObj(irregularPlurals);
  if (invert.hasOwnProperty(str)) {
    return invert[str];
  }
  for (let i5 = 0; i5 < rules_default2.length; i5++) {
    if (rules_default2[i5][0].test(str) === true) {
      str = str.replace(rules_default2[i5][0], rules_default2[i5][1]);
      return str;
    }
  }
  return str;
};
var toSingular_default = toSingular;

// node_modules/compromise/src/2-two/preTagger/methods/transform/nouns/index.js
var all = function(str, model5) {
  let arr = [str];
  let p7 = toPlural_default(str, model5);
  if (p7 !== str) {
    arr.push(p7);
  }
  let s5 = toSingular_default(str, model5);
  if (s5 !== str) {
    arr.push(s5);
  }
  return arr;
};
var nouns_default2 = { toPlural: toPlural_default, toSingular: toSingular_default, all };

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/_guess.js
var guessVerb = {
  Gerund: ["ing"],
  Actor: ["erer"],
  Infinitive: [
    "ate",
    "ize",
    "tion",
    "rify",
    "then",
    "ress",
    "ify",
    "age",
    "nce",
    "ect",
    "ise",
    "ine",
    "ish",
    "ace",
    "ash",
    "ure",
    "tch",
    "end",
    "ack",
    "and",
    "ute",
    "ade",
    "ock",
    "ite",
    "ase",
    "ose",
    "use",
    "ive",
    "int",
    "nge",
    "lay",
    "est",
    "ain",
    "ant",
    "ent",
    "eed",
    "er",
    "le",
    "unk",
    "ung",
    "upt",
    "en"
  ],
  PastTense: ["ept", "ed", "lt", "nt", "ew", "ld"],
  PresentTense: [
    "rks",
    "cks",
    "nks",
    "ngs",
    "mps",
    "tes",
    "zes",
    "ers",
    "les",
    "acks",
    "ends",
    "ands",
    "ocks",
    "lays",
    "eads",
    "lls",
    "els",
    "ils",
    "ows",
    "nds",
    "ays",
    "ams",
    "ars",
    "ops",
    "ffs",
    "als",
    "urs",
    "lds",
    "ews",
    "ips",
    "es",
    "ts",
    "ns"
  ],
  Participle: ["ken", "wn"]
};
guessVerb = Object.keys(guessVerb).reduce((h4, k3) => {
  guessVerb[k3].forEach((a4) => h4[a4] = k3);
  return h4;
}, {});
var guess_default = guessVerb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/getTense/index.js
var getTense = function(str) {
  let three = str.substring(str.length - 3);
  if (guess_default.hasOwnProperty(three) === true) {
    return guess_default[three];
  }
  let two = str.substring(str.length - 2);
  if (guess_default.hasOwnProperty(two) === true) {
    return guess_default[two];
  }
  let one = str.substring(str.length - 1);
  if (one === "s") {
    return "PresentTense";
  }
  return null;
};
var getTense_default = getTense;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/toInfinitive/index.js
var toParts = function(str, model5) {
  let prefix5 = "";
  let prefixes2 = {};
  if (model5.one && model5.one.prefixes) {
    prefixes2 = model5.one.prefixes;
  }
  let [verb, particle] = str.split(/ /);
  if (particle && prefixes2[verb] === true) {
    prefix5 = verb;
    verb = particle;
    particle = "";
  }
  return {
    prefix: prefix5,
    verb,
    particle
  };
};
var copulaMap = {
  are: "be",
  were: "be",
  been: "be",
  is: "be",
  am: "be",
  was: "be",
  be: "be",
  being: "be"
};
var toInfinitive = function(str, model5, tense) {
  const { fromPast: fromPast2, fromPresent: fromPresent2, fromGerund: fromGerund2, fromParticiple: fromParticiple2 } = model5.two.models;
  let { prefix: prefix5, verb, particle } = toParts(str, model5);
  let inf = "";
  if (!tense) {
    tense = getTense_default(str);
  }
  if (copulaMap.hasOwnProperty(str)) {
    inf = copulaMap[str];
  } else if (tense === "Participle") {
    inf = convert_default(verb, fromParticiple2);
  } else if (tense === "PastTense") {
    inf = convert_default(verb, fromPast2);
  } else if (tense === "PresentTense") {
    inf = convert_default(verb, fromPresent2);
  } else if (tense === "Gerund") {
    inf = convert_default(verb, fromGerund2);
  } else {
    return str;
  }
  if (particle) {
    inf += " " + particle;
  }
  if (prefix5) {
    inf = prefix5 + " " + inf;
  }
  return inf;
};
var toInfinitive_default = toInfinitive;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/conjugate/index.js
var parse3 = (inf) => {
  if (/ /.test(inf)) {
    return inf.split(/ /);
  }
  return [inf, ""];
};
var conjugate = function(inf, model5) {
  const { toPast: toPast5, toPresent: toPresent4, toGerund: toGerund4, toParticiple: toParticiple2 } = model5.two.models;
  if (inf === "be") {
    return {
      Infinitive: inf,
      Gerund: "being",
      PastTense: "was",
      PresentTense: "is"
    };
  }
  let [str, particle] = parse3(inf);
  let found = {
    Infinitive: str,
    PastTense: convert_default(str, toPast5),
    PresentTense: convert_default(str, toPresent4),
    Gerund: convert_default(str, toGerund4),
    FutureTense: "will " + str
  };
  let pastPrt = convert_default(str, toParticiple2);
  if (pastPrt !== inf && pastPrt !== found.PastTense) {
    let lex = model5.one.lexicon || {};
    if (lex[pastPrt] === "Participle" || lex[pastPrt] === "Adjective") {
      if (inf === "play") {
        pastPrt = "played";
      }
      found.Participle = pastPrt;
    }
  }
  if (particle) {
    Object.keys(found).forEach((k3) => {
      found[k3] += " " + particle;
    });
  }
  return found;
};
var conjugate_default = conjugate;

// node_modules/compromise/src/2-two/preTagger/methods/transform/verbs/index.js
var all2 = function(str, model5) {
  let res = conjugate_default(str, model5);
  delete res.FutureTense;
  return Object.values(res).filter((s5) => s5);
};
var verbs_default = {
  toInfinitive: toInfinitive_default,
  conjugate: conjugate_default,
  all: all2
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/inflect.js
var toSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.toSuperlative;
  return convert_default(adj, mod);
};
var toComparative2 = function(adj, model5) {
  const mod = model5.two.models.toComparative;
  return convert_default(adj, mod);
};
var fromComparative2 = function(adj, model5) {
  const mod = model5.two.models.fromComparative;
  return convert_default(adj, mod);
};
var fromSuperlative2 = function(adj, model5) {
  const mod = model5.two.models.fromSuperlative;
  return convert_default(adj, mod);
};
var toNoun = function(adj, model5) {
  const mod = model5.two.models.adjToNoun;
  return convert_default(adj, mod);
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/lib.js
var suffixLoop = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max4 = len <= 6 ? len - 1 : 6;
  for (let i5 = max4; i5 >= 1; i5 -= 1) {
    let suffix = str.substring(len - i5, str.length);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let pre = str.slice(0, len - i5);
      let post = suffixes5[suffix.length][suffix];
      return pre + post;
    }
  }
  return null;
};
var lib_default6 = suffixLoop;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/fromAdverb.js
var s2 = "ically";
var ical = /* @__PURE__ */ new Set([
  "analyt" + s2,
  //analytical
  "chem" + s2,
  // chemical
  "class" + s2,
  //classical
  "clin" + s2,
  // clinical
  "crit" + s2,
  // critical
  "ecolog" + s2,
  // ecological
  "electr" + s2,
  // electrical
  "empir" + s2,
  // empirical
  "frant" + s2,
  // frantical
  "grammat" + s2,
  // grammatical
  "ident" + s2,
  // identical
  "ideolog" + s2,
  // ideological
  "log" + s2,
  // logical
  "mag" + s2,
  //magical
  "mathemat" + s2,
  // mathematical
  "mechan" + s2,
  // mechanical
  "med" + s2,
  // medical
  "method" + s2,
  // methodical
  "method" + s2,
  // methodical
  "mus" + s2,
  // musical
  "phys" + s2,
  // physical
  "phys" + s2,
  // physical
  "polit" + s2,
  // political
  "pract" + s2,
  // practical
  "rad" + s2,
  //radical
  "satir" + s2,
  // satirical
  "statist" + s2,
  // statistical
  "techn" + s2,
  // technical
  "technolog" + s2,
  // technological
  "theoret" + s2,
  // theoretical
  "typ" + s2,
  // typical
  "vert" + s2,
  // vertical
  "whims" + s2
  // whimsical
]);
var suffixes2 = [
  null,
  {},
  { "ly": "" },
  {
    "ily": "y",
    "bly": "ble",
    "ply": "ple"
  },
  {
    "ally": "al",
    "rply": "rp"
  },
  {
    "ually": "ual",
    "ially": "ial",
    "cally": "cal",
    "eally": "eal",
    "rally": "ral",
    "nally": "nal",
    "mally": "mal",
    "eeply": "eep",
    "eaply": "eap"
  },
  {
    ically: "ic"
  }
];
var noAdj = /* @__PURE__ */ new Set([
  "early",
  "only",
  "hourly",
  "daily",
  "weekly",
  "monthly",
  "yearly",
  "mostly",
  "duly",
  "unduly",
  "especially",
  "undoubtedly",
  "conversely",
  "namely",
  "exceedingly",
  "presumably",
  "accordingly",
  "overly",
  "best",
  "latter",
  "little",
  "long",
  "low"
]);
var exceptions = {
  wholly: "whole",
  fully: "full",
  truly: "true",
  gently: "gentle",
  singly: "single",
  customarily: "customary",
  idly: "idle",
  publically: "public",
  quickly: "quick",
  superbly: "superb",
  cynically: "cynical",
  well: "good"
  // -?
};
var toAdjective = function(str) {
  if (!str.endsWith("ly")) {
    return null;
  }
  if (ical.has(str)) {
    return str.replace(/ically/, "ical");
  }
  if (noAdj.has(str)) {
    return null;
  }
  if (exceptions.hasOwnProperty(str)) {
    return exceptions[str];
  }
  return lib_default6(str, suffixes2) || str;
};
var fromAdverb_default = toAdjective;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/conjugate/toAdverb.js
var suffixes3 = [
  null,
  {
    y: "ily"
  },
  {
    ly: "ly",
    //unchanged
    ic: "ically"
  },
  {
    ial: "ially",
    ual: "ually",
    tle: "tly",
    ble: "bly",
    ple: "ply",
    ary: "arily"
  },
  {},
  {},
  {}
];
var exceptions2 = {
  cool: "cooly",
  whole: "wholly",
  full: "fully",
  good: "well",
  idle: "idly",
  public: "publicly",
  single: "singly",
  special: "especially"
};
var toAdverb = function(str) {
  if (exceptions2.hasOwnProperty(str)) {
    return exceptions2[str];
  }
  let adv = lib_default6(str, suffixes3);
  if (!adv) {
    adv = str + "ly";
  }
  return adv;
};
var toAdverb_default = toAdverb;

// node_modules/compromise/src/2-two/preTagger/methods/transform/adjectives/index.js
var all3 = function(str, model5) {
  let arr = [str];
  arr.push(toSuperlative2(str, model5));
  arr.push(toComparative2(str, model5));
  arr.push(toAdverb_default(str));
  arr = arr.filter((s5) => s5);
  arr = new Set(arr);
  return Array.from(arr);
};
var adjectives_default = {
  toSuperlative: toSuperlative2,
  toComparative: toComparative2,
  toAdverb: toAdverb_default,
  toNoun,
  fromAdverb: fromAdverb_default,
  fromSuperlative: fromSuperlative2,
  fromComparative: fromComparative2,
  all: all3
};

// node_modules/compromise/src/2-two/preTagger/methods/transform/index.js
var transform_default = {
  noun: nouns_default2,
  verb: verbs_default,
  adjective: adjectives_default
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/byTag.js
var byTag_default = {
  // add plural forms of singular nouns
  Singular: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || "Plural";
    }
  },
  // 'lawyer', 'manager' plural forms
  Actor: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    if (!already[plural2]) {
      lex[plural2] = lex[plural2] || ["Plural", "Actor"];
    }
  },
  // superlative/ comparative forms for adjectives
  Comparable: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let { toSuperlative: toSuperlative3, toComparative: toComparative3 } = methods17.two.transform.adjective;
    let sup = toSuperlative3(word, model5);
    if (!already[sup]) {
      lex[sup] = lex[sup] || "Superlative";
    }
    let comp = toComparative3(word, model5);
    if (!already[comp]) {
      lex[comp] = lex[comp] || "Comparative";
    }
    lex[word] = "Adjective";
  },
  // 'german' -> 'germans'
  Demonym: (word, lex, methods17, model5) => {
    let plural2 = methods17.two.transform.noun.toPlural(word, model5);
    lex[plural2] = lex[plural2] || ["Demonym", "Plural"];
  },
  // conjugate all forms of these verbs
  Infinitive: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    let all4 = methods17.two.transform.verb.conjugate(word, model5);
    Object.entries(all4).forEach((a4) => {
      if (!already[a4[1]] && !lex[a4[1]] && a4[0] !== "FutureTense") {
        lex[a4[1]] = a4[0];
      }
    });
  },
  // 'walk up' should conjugate, too
  PhrasalVerb: (word, lex, methods17, model5) => {
    let already = model5.one.lexicon;
    lex[word] = ["PhrasalVerb", "Infinitive"];
    let _multi = model5.one._multiCache;
    let [inf, rest] = word.split(" ");
    if (!already[inf]) {
      lex[inf] = lex[inf] || "Infinitive";
    }
    let all4 = methods17.two.transform.verb.conjugate(inf, model5);
    delete all4.FutureTense;
    Object.entries(all4).forEach((a4) => {
      if (a4[0] === "Actor" || a4[1] === "") {
        return;
      }
      if (!lex[a4[1]] && !already[a4[1]]) {
        lex[a4[1]] = a4[0];
      }
      _multi[a4[1]] = 2;
      let str = a4[1] + " " + rest;
      lex[str] = lex[str] || [a4[0], "PhrasalVerb"];
    });
  },
  // expand 'million'
  Multiple: (word, lex) => {
    lex[word] = ["Multiple", "Cardinal"];
    lex[word + "th"] = ["Multiple", "Ordinal"];
    lex[word + "ths"] = ["Multiple", "Fraction"];
  },
  // expand number-words
  Cardinal: (word, lex) => {
    lex[word] = ["TextValue", "Cardinal"];
  },
  // 'millionth'
  Ordinal: (word, lex) => {
    lex[word] = ["TextValue", "Ordinal"];
    lex[word + "s"] = ["TextValue", "Fraction"];
  },
  // 'thames'
  Place: (word, lex) => {
    lex[word] = ["Place", "ProperNoun"];
  },
  // 'ontario'
  Region: (word, lex) => {
    lex[word] = ["Region", "ProperNoun"];
  }
};

// node_modules/compromise/src/2-two/preTagger/methods/expand/index.js
var expand3 = function(words, world2) {
  const { methods: methods17, model: model5 } = world2;
  let lex = {};
  let _multi = {};
  Object.keys(words).forEach((word) => {
    let tag2 = words[word];
    word = word.toLowerCase().trim();
    word = word.replace(/'s\b/, "");
    let split3 = word.split(/ /);
    if (split3.length > 1) {
      if (_multi[split3[0]] === void 0 || split3.length > _multi[split3[0]]) {
        _multi[split3[0]] = split3.length;
      }
    }
    if (byTag_default.hasOwnProperty(tag2) === true) {
      byTag_default[tag2](word, lex, methods17, model5);
    }
    lex[word] = lex[word] || tag2;
  });
  delete lex[""];
  delete lex[null];
  delete lex[" "];
  return { lex, _multi };
};
var expand_default2 = expand3;

// node_modules/compromise/src/2-two/preTagger/methods/quickSplit.js
var splitOn = function(terms, i5) {
  const isNum = /^[0-9]+$/;
  let term = terms[i5];
  if (!term) {
    return false;
  }
  const maybeDate = /* @__PURE__ */ new Set(["may", "april", "august", "jan"]);
  if (term.normal === "like" || maybeDate.has(term.normal)) {
    return false;
  }
  if (term.tags.has("Place") || term.tags.has("Date")) {
    return false;
  }
  if (terms[i5 - 1]) {
    let lastTerm = terms[i5 - 1];
    if (lastTerm.tags.has("Date") || maybeDate.has(lastTerm.normal)) {
      return false;
    }
    if (lastTerm.tags.has("Adjective") || term.tags.has("Adjective")) {
      return false;
    }
  }
  let str = term.normal;
  if (str.length === 1 || str.length === 2 || str.length === 4) {
    if (isNum.test(str)) {
      return false;
    }
  }
  return true;
};
var quickSplit = function(document2) {
  const splitHere = /[,:;]/;
  let arr = [];
  document2.forEach((terms) => {
    let start2 = 0;
    terms.forEach((term, i5) => {
      if (splitHere.test(term.post) && splitOn(terms, i5 + 1)) {
        arr.push(terms.slice(start2, i5 + 1));
        start2 = i5 + 1;
      }
    });
    if (start2 < terms.length) {
      arr.push(terms.slice(start2, terms.length));
    }
  });
  return arr;
};
var quickSplit_default = quickSplit;

// node_modules/compromise/src/2-two/preTagger/methods/looksPlural.js
var isPlural = {
  e: ["mice", "louse", "antennae", "formulae", "nebulae", "vertebrae", "vitae"],
  i: ["tia", "octopi", "viri", "radii", "nuclei", "fungi", "cacti", "stimuli"],
  n: ["men"],
  t: ["feet"]
};
var exceptions3 = /* @__PURE__ */ new Set([
  // 'formulas',
  // 'umbrellas',
  // 'gorillas',
  // 'koalas',
  "israelis",
  "menus",
  "logos"
]);
var notPlural = [
  "bus",
  "mas",
  //christmas
  "was",
  // 'las',
  "ias",
  //alias
  "xas",
  "vas",
  "cis",
  //probocis
  "lis",
  "nis",
  //tennis
  "ois",
  "ris",
  "sis",
  //thesis
  "tis",
  //mantis, testis
  "xis",
  "aus",
  "cus",
  "eus",
  //nucleus
  "fus",
  //doofus
  "gus",
  //fungus
  "ius",
  //radius
  "lus",
  //stimulus
  "nus",
  "das",
  "ous",
  "pus",
  //octopus
  "rus",
  //virus
  "sus",
  //census
  "tus",
  //status,cactus
  "xus",
  "aos",
  //chaos
  "igos",
  "ados",
  //barbados
  "ogos",
  "'s",
  "ss"
];
var looksPlural = function(str) {
  if (!str || str.length <= 3) {
    return false;
  }
  if (exceptions3.has(str)) {
    return true;
  }
  let end2 = str[str.length - 1];
  if (isPlural.hasOwnProperty(end2)) {
    return isPlural[end2].find((suff) => str.endsWith(suff));
  }
  if (end2 !== "s") {
    return false;
  }
  if (notPlural.find((suff) => str.endsWith(suff))) {
    return false;
  }
  return true;
};
var looksPlural_default = looksPlural;

// node_modules/compromise/src/2-two/preTagger/methods/index.js
var methods_default9 = {
  two: {
    quickSplit: quickSplit_default,
    expandLexicon: expand_default2,
    transform: transform_default,
    looksPlural: looksPlural_default
  }
};

// node_modules/compromise/src/2-two/preTagger/model/_expand/irregulars.js
var expandIrregulars = function(model5) {
  const { irregularPlurals } = model5.two;
  const { lexicon: lexicon4 } = model5.one;
  Object.entries(irregularPlurals).forEach((a4) => {
    lexicon4[a4[0]] = lexicon4[a4[0]] || "Singular";
    lexicon4[a4[1]] = lexicon4[a4[1]] || "Plural";
  });
  return model5;
};
var irregulars_default = expandIrregulars;

// node_modules/compromise/src/2-two/preTagger/model/_expand/index.js
var tmpModel2 = {
  one: { lexicon: {} },
  two: { models: models_default }
};
var switchDefaults = {
  // 'pilot'
  "Actor|Verb": "Actor",
  //
  // 'amusing'
  "Adj|Gerund": "Adjective",
  //+conjugations
  // 'standard'
  "Adj|Noun": "Adjective",
  // 'boiled'
  "Adj|Past": "Adjective",
  //+conjugations
  // 'smooth'
  "Adj|Present": "Adjective",
  //+conjugations
  // 'box'
  "Noun|Verb": "Singular",
  //+conjugations (no-present)
  //'singing'
  "Noun|Gerund": "Gerund",
  //+conjugations
  // 'hope'
  "Person|Noun": "Noun",
  // 'April'
  "Person|Date": "Month",
  // 'rob'
  "Person|Verb": "FirstName",
  //+conjugations
  // 'victoria'
  "Person|Place": "Person",
  // 'rusty'
  "Person|Adj": "Comparative",
  // 'boxes'
  "Plural|Verb": "Plural",
  //(these are already derivative)
  // 'miles'
  "Unit|Noun": "Noun"
};
var expandLexicon = function(words, model5) {
  const world2 = { model: model5, methods: methods_default9 };
  let { lex, _multi } = methods_default9.two.expandLexicon(words, world2);
  Object.assign(model5.one.lexicon, lex);
  Object.assign(model5.one._multiCache, _multi);
  return model5;
};
var addUncountables = function(words, model5) {
  Object.keys(words).forEach((k3) => {
    if (words[k3] === "Uncountable") {
      model5.two.uncountable[k3] = true;
      words[k3] = "Uncountable";
    }
  });
  return model5;
};
var expandVerb = function(str, words, doPresent) {
  let obj = conjugate_default(str, tmpModel2);
  words[obj.PastTense] = words[obj.PastTense] || "PastTense";
  words[obj.Gerund] = words[obj.Gerund] || "Gerund";
  if (doPresent === true) {
    words[obj.PresentTense] = words[obj.PresentTense] || "PresentTense";
  }
};
var expandAdjective = function(str, words, model5) {
  let sup = toSuperlative2(str, model5);
  words[sup] = words[sup] || "Superlative";
  let comp = toComparative2(str, model5);
  words[comp] = words[comp] || "Comparative";
};
var expandNoun = function(str, words, model5) {
  let plur = toPlural_default(str, model5);
  words[plur] = words[plur] || "Plural";
};
var expandVariable = function(switchWords, model5) {
  let words = {};
  const lex = model5.one.lexicon;
  Object.keys(switchWords).forEach((w2) => {
    const name = switchWords[w2];
    words[w2] = switchDefaults[name];
    if (name === "Noun|Verb" || name === "Person|Verb" || name === "Actor|Verb") {
      expandVerb(w2, lex, false);
    }
    if (name === "Adj|Present") {
      expandVerb(w2, lex, true);
      expandAdjective(w2, lex, model5);
    }
    if (name === "Person|Adj") {
      expandAdjective(w2, lex, model5);
    }
    if (name === "Adj|Gerund" || name === "Noun|Gerund") {
      let inf = toInfinitive_default(w2, tmpModel2, "Gerund");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
    if (name === "Noun|Gerund" || name === "Adj|Noun" || name === "Person|Noun") {
      expandNoun(w2, lex, model5);
    }
    if (name === "Adj|Past") {
      let inf = toInfinitive_default(w2, tmpModel2, "PastTense");
      if (!lex[inf]) {
        words[inf] = "Infinitive";
      }
    }
  });
  model5 = expandLexicon(words, model5);
  return model5;
};
var expand4 = function(model5) {
  model5 = expandLexicon(model5.one.lexicon, model5);
  model5 = addUncountables(model5.one.lexicon, model5);
  model5 = expandVariable(model5.two.switches, model5);
  model5 = irregulars_default(model5);
  return model5;
};
var expand_default3 = expand4;

// node_modules/compromise/src/2-two/preTagger/model/index.js
var model4 = {
  one: {
    _multiCache: {},
    lexicon: lexicon3,
    frozenLex: frozenLex_default
  },
  two: {
    irregularPlurals: plurals_default,
    models: models_default,
    suffixPatterns: suffixes_default2,
    prefixPatterns: prefixes_default2,
    endsWith: endsWith_default,
    neighbours: neighbours_default,
    regexNormal: regex_normal_default,
    regexText: regex_text_default,
    regexNumbers: regex_numbers_default,
    switches,
    clues: clues_default,
    uncountable: {},
    orgWords: orgWords_default,
    placeWords: placeWords_default
  }
};
model4 = expand_default3(model4);
var model_default3 = model4;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/01-colons.js
var byPunctuation = function(terms, i5, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  if (i5 === 0 && terms.length >= 3) {
    const hasColon = /:/;
    let post = terms[0].post;
    if (post.match(hasColon)) {
      let nextTerm = terms[1];
      if (nextTerm.tags.has("Value") || nextTerm.tags.has("Email") || nextTerm.tags.has("PhoneNumber")) {
        return;
      }
      setTag2([terms[0]], "Expression", world2, null, `2-punct-colon''`);
    }
  }
};
var colons_default = byPunctuation;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/1st-pass/02-hyphens.js
var byHyphen = function(terms, i5, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  if (terms[i5].post === "-" && terms[i5 + 1]) {
    setTag2([terms[i5], terms[i5 + 1]], "Hyphenated", world2, null, `1-punct-hyphen''`);
  }
};
var hyphens_default = byHyphen;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/00-tagSwitch.js
var prefix3 = /^(under|over|mis|re|un|dis|semi)-?/;
var tagSwitch = function(terms, i5, model5) {
  const switches2 = model5.two.switches;
  let term = terms[i5];
  if (switches2.hasOwnProperty(term.normal)) {
    term.switch = switches2[term.normal];
    return;
  }
  if (prefix3.test(term.normal)) {
    let stem = term.normal.replace(prefix3, "");
    if (stem.length > 3 && switches2.hasOwnProperty(stem)) {
      term.switch = switches2[stem];
    }
  }
};
var tagSwitch_default = tagSwitch;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/_fastTag.js
var log2 = (term, tag2, reason = "") => {
  const yellow = (str) => "\x1B[33m\x1B[3m" + str + "\x1B[0m";
  const i5 = (str) => "\x1B[3m" + str + "\x1B[0m";
  let word = term.text || "[" + term.implicit + "]";
  if (typeof tag2 !== "string" && tag2.length > 2) {
    tag2 = tag2.slice(0, 2).join(", #") + " +";
  }
  tag2 = typeof tag2 !== "string" ? tag2.join(", #") : tag2;
  console.log(` ${yellow(word).padEnd(24)} \x1B[32m\u2192\x1B[0m #${tag2.padEnd(22)}  ${i5(reason)}`);
};
var fastTag = function(term, tag2, reason) {
  if (!tag2 || tag2.length === 0) {
    return;
  }
  if (term.frozen === true) {
    return;
  }
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2 && env2.DEBUG_TAGS) {
    log2(term, tag2, reason);
  }
  term.tags = term.tags || /* @__PURE__ */ new Set();
  if (typeof tag2 === "string") {
    term.tags.add(tag2);
  } else {
    tag2.forEach((tg) => term.tags.add(tg));
  }
};
var fastTag_default = fastTag;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_fillTags.js
var uncountable = [
  "Acronym",
  "Abbreviation",
  "ProperNoun",
  "Uncountable",
  "Possessive",
  "Pronoun",
  "Activity",
  "Honorific",
  "Month"
];
var setPluralSingular = function(term) {
  if (!term.tags.has("Noun") || term.tags.has("Plural") || term.tags.has("Singular")) {
    return;
  }
  if (uncountable.find((tag2) => term.tags.has(tag2))) {
    return;
  }
  if (looksPlural_default(term.normal)) {
    fastTag_default(term, "Plural", "3-plural-guess");
  } else {
    fastTag_default(term, "Singular", "3-singular-guess");
  }
};
var setTense = function(term) {
  let tags = term.tags;
  if (tags.has("Verb") && tags.size === 1) {
    let guess = getTense_default(term.normal);
    if (guess) {
      fastTag_default(term, guess, "3-verb-tense-guess");
    }
  }
};
var fillTags = function(terms, i5, model5) {
  let term = terms[i5];
  let tags = Array.from(term.tags);
  for (let k3 = 0; k3 < tags.length; k3 += 1) {
    if (model5.one.tagSet[tags[k3]]) {
      let toAdd = model5.one.tagSet[tags[k3]].parents;
      fastTag_default(term, toAdd, ` -inferred by #${tags[k3]}`);
    }
  }
  setPluralSingular(term);
  setTense(term, model5);
};
var fillTags_default = fillTags;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/01-case.js
var titleCase3 = /^\p{Lu}[\p{Ll}'’]/u;
var hasNumber = /[0-9]/;
var notProper = ["Date", "Month", "WeekDay", "Unit", "Expression"];
var hasIVX = /[IVX]/;
var romanNumeral = /^[IVXLCDM]{2,}$/;
var romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;
var nope = {
  li: true,
  dc: true,
  md: true,
  dm: true,
  ml: true
};
var checkCase = function(terms, i5, model5) {
  let term = terms[i5];
  term.index = term.index || [0, 0];
  let index4 = term.index[1];
  let str = term.text || "";
  if (index4 !== 0 && titleCase3.test(str) === true && hasNumber.test(str) === false) {
    if (notProper.find((tag2) => term.tags.has(tag2))) {
      return null;
    }
    if (term.pre.match(/["']$/)) {
      return null;
    }
    if (term.normal === "the") {
      return null;
    }
    fillTags_default(terms, i5, model5);
    if (!term.tags.has("Noun") && !term.frozen) {
      term.tags.clear();
    }
    fastTag_default(term, "ProperNoun", "2-titlecase");
    return true;
  }
  if (str.length >= 2 && romanNumeral.test(str) && hasIVX.test(str) && romanNumValid.test(str) && !nope[term.normal]) {
    fastTag_default(term, "RomanNumeral", "2-xvii");
    return true;
  }
  return null;
};
var case_default2 = checkCase;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/02-suffix.js
var suffixLoop2 = function(str = "", suffixes5 = []) {
  const len = str.length;
  let max4 = 7;
  if (len <= max4) {
    max4 = len - 1;
  }
  for (let i5 = max4; i5 > 1; i5 -= 1) {
    let suffix = str.substring(len - i5, len);
    if (suffixes5[suffix.length].hasOwnProperty(suffix) === true) {
      let tag2 = suffixes5[suffix.length][suffix];
      return tag2;
    }
  }
  return null;
};
var tagBySuffix = function(terms, i5, model5) {
  let term = terms[i5];
  if (term.tags.size === 0) {
    let tag2 = suffixLoop2(term.normal, model5.two.suffixPatterns);
    if (tag2 !== null) {
      fastTag_default(term, tag2, "2-suffix");
      term.confidence = 0.7;
      return true;
    }
    if (term.implicit) {
      tag2 = suffixLoop2(term.implicit, model5.two.suffixPatterns);
      if (tag2 !== null) {
        fastTag_default(term, tag2, "2-implicit-suffix");
        term.confidence = 0.7;
        return true;
      }
    }
  }
  return null;
};
var suffix_default = tagBySuffix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/03-regex.js
var hasApostrophe = /['‘’‛‵′`´]/;
var doRegs = function(str, regs) {
  for (let i5 = 0; i5 < regs.length; i5 += 1) {
    if (regs[i5][0].test(str) === true) {
      return regs[i5];
    }
  }
  return null;
};
var doEndsWith = function(str = "", byEnd3) {
  let char = str[str.length - 1];
  if (byEnd3.hasOwnProperty(char) === true) {
    let regs = byEnd3[char] || [];
    for (let r3 = 0; r3 < regs.length; r3 += 1) {
      if (regs[r3][0].test(str) === true) {
        return regs[r3];
      }
    }
  }
  return null;
};
var checkRegex = function(terms, i5, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  let { regexText, regexNormal, regexNumbers, endsWith } = model5.two;
  let term = terms[i5];
  let normal = term.machine || term.normal;
  let text = term.text;
  if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) {
    text += term.post.trim();
  }
  let arr = doRegs(text, regexText) || doRegs(normal, regexNormal);
  if (!arr && /[0-9]/.test(normal)) {
    arr = doRegs(normal, regexNumbers);
  }
  if (!arr && term.tags.size === 0) {
    arr = doEndsWith(normal, endsWith);
  }
  if (arr) {
    setTag2([term], arr[1], world2, null, `2-regex-'${arr[2] || arr[0]}'`);
    term.confidence = 0.6;
    return true;
  }
  return null;
};
var regex_default = checkRegex;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/04-prefix.js
var prefixLoop = function(str = "", prefixes2 = []) {
  const len = str.length;
  let max4 = 7;
  if (max4 > len - 3) {
    max4 = len - 3;
  }
  for (let i5 = max4; i5 > 2; i5 -= 1) {
    let prefix5 = str.substring(0, i5);
    if (prefixes2[prefix5.length].hasOwnProperty(prefix5) === true) {
      let tag2 = prefixes2[prefix5.length][prefix5];
      return tag2;
    }
  }
  return null;
};
var checkPrefix = function(terms, i5, model5) {
  let term = terms[i5];
  if (term.tags.size === 0) {
    let tag2 = prefixLoop(term.normal, model5.two.prefixPatterns);
    if (tag2 !== null) {
      fastTag_default(term, tag2, "2-prefix");
      term.confidence = 0.5;
      return true;
    }
  }
  return null;
};
var prefix_default = checkPrefix;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/2nd-pass/05-year.js
var min = 1400;
var max2 = 2100;
var dateWords = /* @__PURE__ */ new Set([
  "in",
  "on",
  "by",
  "until",
  "for",
  "to",
  "during",
  "throughout",
  "through",
  "within",
  "before",
  "after",
  "of",
  "this",
  "next",
  "last",
  "circa",
  "around",
  "post",
  "pre",
  "budget",
  "classic",
  "plan",
  "may"
]);
var seemsGood = function(term) {
  if (!term) {
    return false;
  }
  let str = term.normal || term.implicit;
  if (dateWords.has(str)) {
    return true;
  }
  if (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year")) {
    return true;
  }
  if (term.tags.has("ProperNoun")) {
    return true;
  }
  return false;
};
var seemsOkay = function(term) {
  if (!term) {
    return false;
  }
  if (term.tags.has("Ordinal")) {
    return true;
  }
  if (term.tags.has("Cardinal") && term.normal.length < 3) {
    return true;
  }
  if (term.normal === "is" || term.normal === "was") {
    return true;
  }
  return false;
};
var seemsFine = function(term) {
  return term && (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year"));
};
var tagYear = function(terms, i5) {
  const term = terms[i5];
  if (term.tags.has("NumericValue") && term.tags.has("Cardinal") && term.normal.length === 4) {
    let num = Number(term.normal);
    if (num && !isNaN(num)) {
      if (num > min && num < max2) {
        let lastTerm = terms[i5 - 1];
        let nextTerm = terms[i5 + 1];
        if (seemsGood(lastTerm) || seemsGood(nextTerm)) {
          return fastTag_default(term, "Year", "2-tagYear");
        }
        if (num >= 1920 && num < 2025) {
          if (seemsOkay(lastTerm) || seemsOkay(nextTerm)) {
            return fastTag_default(term, "Year", "2-tagYear-close");
          }
          if (seemsFine(terms[i5 - 2]) || seemsFine(terms[i5 + 2])) {
            return fastTag_default(term, "Year", "2-tagYear-far");
          }
          if (lastTerm && (lastTerm.tags.has("Determiner") || lastTerm.tags.has("Possessive"))) {
            if (nextTerm && nextTerm.tags.has("Noun") && !nextTerm.tags.has("Plural")) {
              return fastTag_default(term, "Year", "2-tagYear-noun");
            }
          }
        }
      }
    }
  }
  return null;
};
var year_default = tagYear;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/07-verb-type.js
var verbType = function(terms, i5, model5, world2) {
  const setTag2 = world2.methods.one.setTag;
  const term = terms[i5];
  const types = ["PastTense", "PresentTense", "Auxiliary", "Modal", "Particle"];
  if (term.tags.has("Verb")) {
    let type = types.find((typ) => term.tags.has(typ));
    if (!type) {
      setTag2([term], "Infinitive", world2, null, `2-verb-type''`);
    }
  }
};
var verb_type_default = verbType;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/01-acronym.js
var oneLetterAcronym2 = /^[A-Z]('s|,)?$/;
var isUpperCase = /^[A-Z-]+$/;
var upperThenS = /^[A-Z]+s$/;
var periodAcronym2 = /([A-Z]\.)+[A-Z]?,?$/;
var noPeriodAcronym2 = /[A-Z]{2,}('s|,)?$/;
var lowerCaseAcronym2 = /([a-z]\.)+[a-z]\.?$/;
var oneLetterWord = {
  I: true,
  A: true
};
var places = {
  la: true,
  ny: true,
  us: true,
  dc: true,
  gb: true
};
var isNoPeriodAcronym = function(term, model5) {
  let str = term.text;
  if (isUpperCase.test(str) === false) {
    if (str.length > 3 && upperThenS.test(str) === true) {
      str = str.replace(/s$/, "");
    } else {
      return false;
    }
  }
  if (str.length > 5) {
    return false;
  }
  if (oneLetterWord.hasOwnProperty(str)) {
    return false;
  }
  if (model5.one.lexicon.hasOwnProperty(term.normal)) {
    return false;
  }
  if (periodAcronym2.test(str) === true) {
    return true;
  }
  if (lowerCaseAcronym2.test(str) === true) {
    return true;
  }
  if (oneLetterAcronym2.test(str) === true) {
    return true;
  }
  if (noPeriodAcronym2.test(str) === true) {
    return true;
  }
  return false;
};
var isAcronym3 = function(terms, i5, model5) {
  let term = terms[i5];
  if (term.tags.has("RomanNumeral") || term.tags.has("Acronym") || term.frozen) {
    return null;
  }
  if (isNoPeriodAcronym(term, model5)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-no-period-acronym");
    if (places[term.normal] === true) {
      fastTag_default(term, "Place", "3-place-acronym");
    }
    if (upperThenS.test(term.text) === true) {
      fastTag_default(term, "Plural", "3-plural-acronym");
    }
    return true;
  }
  if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym2.test(term.text)) {
    term.tags.clear();
    fastTag_default(term, ["Acronym", "Noun"], "3-one-letter-acronym");
    return true;
  }
  if (term.tags.has("Organization") && term.text.length <= 3) {
    fastTag_default(term, "Acronym", "3-org-acronym");
    return true;
  }
  if (term.tags.has("Organization") && isUpperCase.test(term.text) && term.text.length <= 6) {
    fastTag_default(term, "Acronym", "3-titlecase-acronym");
    return true;
  }
  return null;
};
var acronym_default = isAcronym3;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/02-neighbours.js
var lookAtWord = function(term, words) {
  if (!term) {
    return null;
  }
  let found = words.find((a4) => term.normal === a4[0]);
  if (found) {
    return found[1];
  }
  return null;
};
var lookAtTag = function(term, tags) {
  if (!term) {
    return null;
  }
  let found = tags.find((a4) => term.tags.has(a4[0]));
  if (found) {
    return found[1];
  }
  return null;
};
var neighbours = function(terms, i5, model5) {
  const { leftTags, leftWords, rightWords, rightTags } = model5.two.neighbours;
  let term = terms[i5];
  if (term.tags.size === 0) {
    let tag2 = null;
    tag2 = tag2 || lookAtWord(terms[i5 - 1], leftWords);
    tag2 = tag2 || lookAtWord(terms[i5 + 1], rightWords);
    tag2 = tag2 || lookAtTag(terms[i5 - 1], leftTags);
    tag2 = tag2 || lookAtTag(terms[i5 + 1], rightTags);
    if (tag2) {
      fastTag_default(term, tag2, "3-[neighbour]");
      fillTags_default(terms, i5, model5);
      terms[i5].confidence = 0.2;
      return true;
    }
  }
  return null;
};
var neighbours_default2 = neighbours;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/03-orgWords.js
var isTitleCase2 = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str);
var isOrg = function(term, i5, yelling) {
  if (!term) {
    return false;
  }
  if (term.tags.has("FirstName") || term.tags.has("Place")) {
    return false;
  }
  if (term.tags.has("ProperNoun") || term.tags.has("Organization") || term.tags.has("Acronym")) {
    return true;
  }
  if (!yelling && isTitleCase2(term.text)) {
    if (i5 === 0) {
      return term.tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs = function(terms, i5, world2, yelling) {
  const orgWords = world2.model.two.orgWords;
  const setTag2 = world2.methods.one.setTag;
  let term = terms[i5];
  let str = term.machine || term.normal;
  if (orgWords[str] === true && isOrg(terms[i5 - 1], i5 - 1, yelling)) {
    setTag2([terms[i5]], "Organization", world2, null, "3-[org-word]");
    for (let t5 = i5; t5 >= 0; t5 -= 1) {
      if (isOrg(terms[t5], t5, yelling)) {
        setTag2([terms[t5]], "Organization", world2, null, "3-[org-word]");
      } else {
        break;
      }
    }
  }
  return null;
};
var orgWords_default2 = tagOrgs;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/04-placeWords.js
var isTitleCase3 = (str) => /^\p{Lu}[\p{Ll}'’]/u.test(str);
var isPossessive = /'s$/;
var placeCont = /* @__PURE__ */ new Set([
  "athletic",
  "city",
  "community",
  "eastern",
  "federal",
  "financial",
  "great",
  "historic",
  "historical",
  "local",
  "memorial",
  "municipal",
  "national",
  "northern",
  "provincial",
  "southern",
  "state",
  "western"
]);
var noBefore = /* @__PURE__ */ new Set(["center", "centre", "way", "range", "bar", "bridge", "field", "pit"]);
var isPlace = function(term, i5, yelling) {
  if (!term) {
    return false;
  }
  let tags = term.tags;
  if (tags.has("Organization") || tags.has("Possessive") || isPossessive.test(term.normal)) {
    return false;
  }
  if (tags.has("ProperNoun") || tags.has("Place")) {
    return true;
  }
  if (!yelling && isTitleCase3(term.text)) {
    if (i5 === 0) {
      return tags.has("Singular");
    }
    return true;
  }
  return false;
};
var tagOrgs2 = function(terms, i5, world2, yelling) {
  const placeWords = world2.model.two.placeWords;
  const setTag2 = world2.methods.one.setTag;
  let term = terms[i5];
  let str = term.machine || term.normal;
  if (placeWords[str] === true) {
    for (let n5 = i5 - 1; n5 >= 0; n5 -= 1) {
      if (placeCont.has(terms[n5].normal)) {
        continue;
      }
      if (isPlace(terms[n5], n5, yelling)) {
        setTag2(terms.slice(n5, i5 + 1), "Place", world2, null, "3-[place-of-foo]");
        continue;
      }
      break;
    }
    if (noBefore.has(str)) {
      return false;
    }
    for (let n5 = i5 + 1; n5 < terms.length; n5 += 1) {
      if (isPlace(terms[n5], n5, yelling)) {
        setTag2(terms.slice(i5, n5 + 1), "Place", world2, null, "3-[foo-place]");
        return true;
      }
      if (terms[n5].normal === "of" || placeCont.has(terms[n5].normal)) {
        continue;
      }
      break;
    }
  }
  return null;
};
var placeWords_default2 = tagOrgs2;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/05-fallback.js
var nounFallback = function(terms, i5, model5) {
  let isEmpty = false;
  let tags = terms[i5].tags;
  if (tags.size === 0) {
    isEmpty = true;
  } else if (tags.size === 1) {
    if (tags.has("Hyphenated") || tags.has("HashTag") || tags.has("Prefix")) {
      isEmpty = true;
    }
  }
  if (isEmpty) {
    fastTag_default(terms[i5], "Noun", "3-[fallback]");
    fillTags_default(terms, i5, model5);
    terms[i5].confidence = 0.1;
  }
};
var fallback_default = nounFallback;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/_adhoc.js
var isTitleCase4 = /^[A-Z][a-z]/;
var isCapital = (terms, i5) => {
  if (terms[i5].tags.has("ProperNoun") && isTitleCase4.test(terms[i5].text)) {
    return "Noun";
  }
  return null;
};
var isAlone = (terms, i5, tag2) => {
  if (i5 === 0 && !terms[1]) {
    return tag2;
  }
  return null;
};
var isEndNoun = function(terms, i5) {
  if (!terms[i5 + 1] && terms[i5 - 1] && terms[i5 - 1].tags.has("Determiner")) {
    return "Noun";
  }
  return null;
};
var isStart = function(terms, i5, tag2) {
  if (i5 === 0 && terms.length > 3) {
    return tag2;
  }
  return null;
};
var adhoc = {
  "Adj|Gerund": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Adj|Noun": (terms, i5) => {
    return isCapital(terms, i5) || isEndNoun(terms, i5);
  },
  "Actor|Verb": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Adj|Past": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Adj|Present": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Noun|Gerund": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Noun|Verb": (terms, i5) => {
    return i5 > 0 && isCapital(terms, i5) || isAlone(terms, i5, "Infinitive");
  },
  "Plural|Verb": (terms, i5) => {
    return isCapital(terms, i5) || isAlone(terms, i5, "PresentTense") || isStart(terms, i5, "Plural");
  },
  "Person|Noun": (terms, i5) => {
    return isCapital(terms, i5);
  },
  "Person|Verb": (terms, i5) => {
    if (i5 !== 0) {
      return isCapital(terms, i5);
    }
    return null;
  },
  "Person|Adj": (terms, i5) => {
    if (i5 === 0 && terms.length > 1) {
      return "Person";
    }
    return isCapital(terms, i5) ? "Person" : null;
  }
};
var adhoc_default = adhoc;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/06-switches.js
var env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
var prefix4 = /^(under|over|mis|re|un|dis|semi)-?/;
var checkWord = (term, obj) => {
  if (!term || !obj) {
    return null;
  }
  let str = term.normal || term.implicit;
  let found = null;
  if (obj.hasOwnProperty(str)) {
    found = obj[str];
  }
  if (found && env.DEBUG_TAGS) {
    console.log(`
  \x1B[2m\x1B[3m     \u2193 - '${str}' \x1B[0m`);
  }
  return found;
};
var checkTag = (term, obj = {}, tagSet) => {
  if (!term || !obj) {
    return null;
  }
  let tags = Array.from(term.tags).sort((a4, b2) => {
    let numA = tagSet[a4] ? tagSet[a4].parents.length : 0;
    let numB = tagSet[b2] ? tagSet[b2].parents.length : 0;
    return numA > numB ? -1 : 1;
  });
  let found = tags.find((tag2) => obj[tag2]);
  if (found && env.DEBUG_TAGS) {
    console.log(`  \x1B[2m\x1B[3m      \u2193 - '${term.normal || term.implicit}' (#${found})  \x1B[0m`);
  }
  found = obj[found];
  return found;
};
var pickTag = function(terms, i5, clues5, model5) {
  var _a2;
  if (!clues5) {
    return null;
  }
  const beforeIndex = ((_a2 = terms[i5 - 1]) == null ? void 0 : _a2.text) !== "also" ? i5 - 1 : Math.max(0, i5 - 2);
  const tagSet = model5.one.tagSet;
  let tag2 = checkWord(terms[i5 + 1], clues5.afterWords);
  tag2 = tag2 || checkWord(terms[beforeIndex], clues5.beforeWords);
  tag2 = tag2 || checkTag(terms[beforeIndex], clues5.beforeTags, tagSet);
  tag2 = tag2 || checkTag(terms[i5 + 1], clues5.afterTags, tagSet);
  return tag2;
};
var doSwitches = function(terms, i5, world2) {
  const model5 = world2.model;
  const setTag2 = world2.methods.one.setTag;
  const { switches: switches2, clues: clues5 } = model5.two;
  const term = terms[i5];
  let str = term.normal || term.implicit || "";
  if (prefix4.test(str) && !switches2[str]) {
    str = str.replace(prefix4, "");
  }
  if (term.switch) {
    let form = term.switch;
    if (term.tags.has("Acronym") || term.tags.has("PhrasalVerb")) {
      return;
    }
    let tag2 = pickTag(terms, i5, clues5[form], model5);
    if (adhoc_default[form]) {
      tag2 = adhoc_default[form](terms, i5) || tag2;
    }
    if (tag2) {
      setTag2([term], tag2, world2, null, `3-[switch] (${form})`);
      fillTags_default(terms, i5, model5);
    } else if (env.DEBUG_TAGS) {
      console.log(`
 -> X  - '${str}'  : (${form})  `);
    }
  }
};
var switches_default = doSwitches;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/3rd-pass/08-imperative.js
var beside = {
  there: true,
  //go there
  this: true,
  //try this
  it: true,
  //do it
  him: true,
  her: true,
  us: true
  //tell us
};
var imperative = function(terms, world2) {
  const setTag2 = world2.methods.one.setTag;
  const multiWords = world2.model.one._multiCache || {};
  let t5 = terms[0];
  let isRight = t5.switch === "Noun|Verb" || t5.tags.has("Infinitive");
  if (isRight && terms.length >= 2) {
    if (terms.length < 4 && !beside[terms[1].normal]) {
      return;
    }
    if (!t5.tags.has("PhrasalVerb") && multiWords.hasOwnProperty(t5.normal)) {
      return;
    }
    let nextNoun = terms[1].tags.has("Noun") || terms[1].tags.has("Determiner");
    if (nextNoun) {
      let soonVerb = terms.slice(1, 3).some((term) => term.tags.has("Verb"));
      if (!soonVerb || t5.tags.has("#PhrasalVerb")) {
        setTag2([t5], "Imperative", world2, null, "3-[imperative]");
      }
    }
  }
};
var imperative_default = imperative;

// node_modules/compromise/src/2-two/preTagger/compute/tagger/index.js
var ignoreCase = function(terms) {
  if (terms.filter((t5) => !t5.tags.has("ProperNoun")).length <= 3) {
    return false;
  }
  const lowerCase = /^[a-z]/;
  return terms.every((t5) => !lowerCase.test(t5.text));
};
var firstPass = function(docs, model5, world2) {
  docs.forEach((terms) => {
    colons_default(terms, 0, model5, world2);
  });
};
var secondPass = function(terms, model5, world2, isYelling) {
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    if (terms[i5].frozen === true) {
      continue;
    }
    tagSwitch_default(terms, i5, model5);
    if (isYelling === false) {
      case_default2(terms, i5, model5);
    }
    suffix_default(terms, i5, model5);
    regex_default(terms, i5, model5, world2);
    prefix_default(terms, i5, model5);
    year_default(terms, i5, model5);
  }
};
var thirdPass = function(terms, model5, world2, isYelling) {
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    let found = acronym_default(terms, i5, model5);
    fillTags_default(terms, i5, model5);
    found = found || neighbours_default2(terms, i5, model5);
    found = found || fallback_default(terms, i5, model5);
  }
  for (let i5 = 0; i5 < terms.length; i5 += 1) {
    if (terms[i5].frozen === true) {
      continue;
    }
    orgWords_default2(terms, i5, world2, isYelling);
    placeWords_default2(terms, i5, world2, isYelling);
    switches_default(terms, i5, world2);
    verb_type_default(terms, i5, model5, world2);
    hyphens_default(terms, i5, model5, world2);
  }
  imperative_default(terms, world2);
};
var preTagger = function(view) {
  const { methods: methods17, model: model5, world: world2 } = view;
  let docs = view.docs;
  firstPass(docs, model5, world2);
  let document2 = methods17.two.quickSplit(docs);
  for (let n5 = 0; n5 < document2.length; n5 += 1) {
    let terms = document2[n5];
    const isYelling = ignoreCase(terms);
    secondPass(terms, model5, world2, isYelling);
    thirdPass(terms, model5, world2, isYelling);
  }
  return document2;
};
var tagger_default2 = preTagger;

// node_modules/compromise/src/2-two/preTagger/compute/root.js
var toRoot = {
  // 'spencer's' -> 'spencer'
  "Possessive": (term) => {
    let str = term.machine || term.normal || term.text;
    str = str.replace(/'s$/, "");
    return str;
  },
  // 'drinks' -> 'drink'
  "Plural": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.noun.toSingular(str, world2.model);
  },
  // ''
  "Copula": () => {
    return "is";
  },
  // 'walked' -> 'walk'
  "PastTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PastTense");
  },
  // 'walking' -> 'walk'
  "Gerund": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "Gerund");
  },
  // 'walks' -> 'walk'
  "PresentTense": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    if (term.tags.has("Infinitive")) {
      return str;
    }
    return world2.methods.two.transform.verb.toInfinitive(str, world2.model, "PresentTense");
  },
  // 'quieter' -> 'quiet'
  "Comparative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromComparative(str, world2.model);
  },
  // 'quietest' -> 'quiet'
  "Superlative": (term, world2) => {
    let str = term.machine || term.normal || term.text;
    return world2.methods.two.transform.adjective.fromSuperlative(str, world2.model);
  },
  // 'suddenly' -> 'sudden'
  "Adverb": (term, world2) => {
    const { fromAdverb } = world2.methods.two.transform.adjective;
    let str = term.machine || term.normal || term.text;
    return fromAdverb(str);
  }
};
var getRoot = function(view) {
  const world2 = view.world;
  const keys = Object.keys(toRoot);
  view.docs.forEach((terms) => {
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      const term = terms[i5];
      for (let k3 = 0; k3 < keys.length; k3 += 1) {
        if (term.tags.has(keys[k3])) {
          const fn = toRoot[keys[k3]];
          let root = fn(term, world2);
          if (term.normal !== root) {
            term.root = root;
          }
          break;
        }
      }
    }
  });
};
var root_default = getRoot;

// node_modules/compromise/src/2-two/preTagger/compute/penn.js
var mapping = {
  // adverbs
  // 'Comparative': 'RBR',
  // 'Superlative': 'RBS',
  Adverb: "RB",
  // adjectives
  Comparative: "JJR",
  Superlative: "JJS",
  Adjective: "JJ",
  TO: "Conjunction",
  // verbs
  Modal: "MD",
  Auxiliary: "MD",
  Gerund: "VBG",
  //throwing
  PastTense: "VBD",
  //threw
  Participle: "VBN",
  //thrown
  PresentTense: "VBZ",
  //throws
  Infinitive: "VB",
  //throw
  Particle: "RP",
  //phrasal particle
  Verb: "VB",
  // throw
  // pronouns
  Pronoun: "PRP",
  // misc
  Cardinal: "CD",
  Conjunction: "CC",
  Determiner: "DT",
  Preposition: "IN",
  // 'Determiner': 'WDT',
  // 'Expression': 'FW',
  QuestionWord: "WP",
  Expression: "UH",
  //nouns
  Possessive: "POS",
  ProperNoun: "NNP",
  Person: "NNP",
  Place: "NNP",
  Organization: "NNP",
  Singular: "NN",
  Plural: "NNS",
  Noun: "NN",
  There: "EX"
  //'there'
  // 'Adverb':'WRB',
  // 'Noun':'PDT', //predeterminer
  // 'Noun':'SYM', //symbol
  // 'Noun':'NFP', //
  //  WDT 	Wh-determiner
  // 	WP 	Wh-pronoun
  // 	WP$ 	Possessive wh-pronoun
  // 	WRB 	Wh-adverb
};
var toPenn = function(term) {
  if (term.tags.has("ProperNoun") && term.tags.has("Plural")) {
    return "NNPS";
  }
  if (term.tags.has("Possessive") && term.tags.has("Pronoun")) {
    return "PRP$";
  }
  if (term.normal === "there") {
    return "EX";
  }
  if (term.normal === "to") {
    return "TO";
  }
  let arr = term.tagRank || [];
  for (let i5 = 0; i5 < arr.length; i5 += 1) {
    if (mapping.hasOwnProperty(arr[i5])) {
      return mapping[arr[i5]];
    }
  }
  return null;
};
var pennTag = function(view) {
  view.compute("tagRank");
  view.docs.forEach((terms) => {
    terms.forEach((term) => {
      term.penn = toPenn(term);
    });
  });
};
var penn_default = pennTag;

// node_modules/compromise/src/2-two/preTagger/compute/index.js
var compute_default8 = { preTagger: tagger_default2, root: root_default, penn: penn_default };

// node_modules/compromise/src/2-two/preTagger/tagSet/nouns.js
var entity = ["Person", "Place", "Organization"];
var nouns_default3 = {
  Noun: {
    not: ["Verb", "Adjective", "Adverb", "Value", "Determiner"]
  },
  Singular: {
    is: "Noun",
    not: ["Plural", "Uncountable"]
  },
  // 'Canada'
  ProperNoun: {
    is: "Noun"
  },
  Person: {
    is: "Singular",
    also: ["ProperNoun"],
    not: ["Place", "Organization", "Date"]
  },
  FirstName: {
    is: "Person"
  },
  MaleName: {
    is: "FirstName",
    not: ["FemaleName", "LastName"]
  },
  FemaleName: {
    is: "FirstName",
    not: ["MaleName", "LastName"]
  },
  LastName: {
    is: "Person",
    not: ["FirstName"]
  },
  // 'dr.'
  Honorific: {
    is: "Person",
    not: ["FirstName", "LastName", "Value"]
  },
  Place: {
    is: "Singular",
    not: ["Person", "Organization"]
  },
  Country: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["City"]
  },
  City: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["Country"]
  },
  // 'california'
  Region: {
    is: "Place",
    also: ["ProperNoun"]
  },
  Address: {
    // is: 'Place',
  },
  Organization: {
    is: "ProperNoun",
    not: ["Person", "Place"]
  },
  SportsTeam: {
    is: "Organization"
  },
  School: {
    is: "Organization"
  },
  Company: {
    is: "Organization"
  },
  Plural: {
    is: "Noun",
    not: ["Singular", "Uncountable"]
  },
  // 'gravity'
  Uncountable: {
    is: "Noun"
  },
  // 'it'
  Pronoun: {
    is: "Noun",
    not: entity
  },
  // 'swimmer'
  Actor: {
    is: "Noun",
    not: ["Place", "Organization"]
  },
  // walking
  Activity: {
    is: "Noun",
    not: ["Person", "Place"]
  },
  // kilometres
  Unit: {
    is: "Noun",
    not: entity
  },
  // canadian
  Demonym: {
    is: "Noun",
    also: ["ProperNoun"],
    not: entity
  },
  // [spencer's] hat
  Possessive: {
    is: "Noun"
  },
  // 'yourself'
  Reflexive: {
    is: "Pronoun"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/verbs.js
var verbs_default2 = {
  Verb: {
    not: ["Noun", "Adjective", "Adverb", "Value", "Expression"]
  },
  // 'he [walks]'
  PresentTense: {
    is: "Verb",
    not: ["PastTense", "FutureTense"]
  },
  // 'will [walk]'
  Infinitive: {
    is: "PresentTense",
    not: ["Gerund"]
  },
  // '[walk] now!'
  Imperative: {
    is: "Verb",
    not: ["PastTense", "Gerund", "Copula"]
  },
  // walking
  Gerund: {
    is: "PresentTense",
    not: ["Copula"]
  },
  // walked
  PastTense: {
    is: "Verb",
    not: ["PresentTense", "Gerund", "FutureTense"]
  },
  // will walk
  FutureTense: {
    is: "Verb",
    not: ["PresentTense", "PastTense"]
  },
  // is/was
  Copula: {
    is: "Verb"
  },
  // '[could] walk'
  Modal: {
    is: "Verb",
    not: ["Infinitive"]
  },
  // 'awaken'
  Participle: {
    is: "PastTense"
  },
  // '[will have had] walked'
  Auxiliary: {
    is: "Verb",
    not: ["PastTense", "PresentTense", "Gerund", "Conjunction"]
  },
  // 'walk out'
  PhrasalVerb: {
    is: "Verb"
  },
  // 'walk [out]'
  Particle: {
    is: "PhrasalVerb",
    not: ["PastTense", "PresentTense", "Copula", "Gerund"]
  },
  // 'walked by'
  Passive: {
    is: "Verb"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/values.js
var values_default = {
  Value: {
    not: ["Verb", "Adjective", "Adverb"]
  },
  Ordinal: {
    is: "Value",
    not: ["Cardinal"]
  },
  Cardinal: {
    is: "Value",
    not: ["Ordinal"]
  },
  Fraction: {
    is: "Value",
    not: ["Noun"]
  },
  Multiple: {
    is: "TextValue"
  },
  RomanNumeral: {
    is: "Cardinal",
    not: ["TextValue"]
  },
  TextValue: {
    is: "Value",
    not: ["NumericValue"]
  },
  NumericValue: {
    is: "Value",
    not: ["TextValue"]
  },
  Money: {
    is: "Cardinal"
  },
  Percent: {
    is: "Value"
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/dates.js
var dates_default = {
  Date: {
    not: ["Verb", "Adverb", "Adjective"]
  },
  Month: {
    is: "Date",
    also: ["Noun"],
    not: ["Year", "WeekDay", "Time"]
  },
  WeekDay: {
    is: "Date",
    also: ["Noun"]
  },
  Year: {
    is: "Date",
    not: ["RomanNumeral"]
  },
  FinancialQuarter: {
    is: "Date",
    not: "Fraction"
  },
  // 'easter'
  Holiday: {
    is: "Date",
    also: ["Noun"]
  },
  // 'summer'
  Season: {
    is: "Date"
  },
  Timezone: {
    is: "Date",
    also: ["Noun"],
    not: ["ProperNoun"]
  },
  Time: {
    is: "Date",
    not: ["AtMention"]
  },
  // 'months'
  Duration: {
    is: "Date",
    also: ["Noun"]
  }
};

// node_modules/compromise/src/2-two/preTagger/tagSet/misc.js
var anything = ["Noun", "Verb", "Adjective", "Adverb", "Value", "QuestionWord"];
var misc_default3 = {
  Adjective: {
    not: ["Noun", "Verb", "Adverb", "Value"]
  },
  Comparable: {
    is: "Adjective"
  },
  Comparative: {
    is: "Adjective"
  },
  Superlative: {
    is: "Adjective",
    not: ["Comparative"]
  },
  NumberRange: {},
  Adverb: {
    not: ["Noun", "Verb", "Adjective", "Value"]
  },
  Determiner: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Conjunction"]
    //allow 'a' to be a Determiner/Value
  },
  Conjunction: {
    not: anything
  },
  Preposition: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Determiner"]
  },
  QuestionWord: {
    not: ["Determiner"]
  },
  Currency: {
    is: "Noun"
  },
  Expression: {
    not: ["Noun", "Adjective", "Verb", "Adverb"]
  },
  Abbreviation: {},
  Url: {
    not: ["HashTag", "PhoneNumber", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  PhoneNumber: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  HashTag: {},
  AtMention: {
    is: "Noun",
    not: ["HashTag", "Email"]
  },
  Emoji: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Emoticon: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Email: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Acronym: {
    not: ["Plural", "RomanNumeral", "Pronoun", "Date"]
  },
  Negative: {
    not: ["Noun", "Adjective", "Value", "Expression"]
  },
  Condition: {
    not: ["Verb", "Adjective", "Noun", "Value"]
  },
  // existential 'there'
  There: {
    not: ["Verb", "Adjective", "Noun", "Value", "Conjunction", "Preposition"]
  },
  // 'co-wrote'
  Prefix: {
    not: ["Abbreviation", "Acronym", "ProperNoun"]
  },
  // hard-nosed, bone-headed
  Hyphenated: {}
};

// node_modules/compromise/src/2-two/preTagger/tagSet/index.js
var allTags = Object.assign({}, nouns_default3, verbs_default2, values_default, dates_default, misc_default3);
var tagSet_default = allTags;

// node_modules/compromise/src/2-two/preTagger/plugin.js
var plugin_default14 = {
  compute: compute_default8,
  methods: methods_default9,
  model: model_default3,
  tags: tagSet_default,
  hooks: ["preTagger"]
};

// node_modules/compromise/src/2-two/contraction-two/api/contract.js
var postPunct = /[,)"';:\-–—.…]/;
var setContraction = function(m6, suffix) {
  if (!m6.found) {
    return;
  }
  let terms = m6.termList();
  for (let i5 = 0; i5 < terms.length - 1; i5++) {
    const t5 = terms[i5];
    if (postPunct.test(t5.post)) {
      return;
    }
  }
  terms[0].implicit = terms[0].normal;
  terms[0].text += suffix;
  terms[0].normal += suffix;
  terms.slice(1).forEach((t5) => {
    t5.implicit = t5.normal;
    t5.text = "";
    t5.normal = "";
  });
  for (let i5 = 0; i5 < terms.length - 1; i5++) {
    terms[i5].post = terms[i5].post.replace(/ /, "");
  }
};
var contract = function() {
  let doc = this.not("@hasContraction");
  let m6 = doc.match("(we|they|you) are");
  setContraction(m6, `'re`);
  m6 = doc.match("(he|she|they|it|we|you) will");
  setContraction(m6, `'ll`);
  m6 = doc.match("(he|she|they|it|we) is");
  setContraction(m6, `'s`);
  m6 = doc.match("#Person is");
  setContraction(m6, `'s`);
  m6 = doc.match("#Person would");
  setContraction(m6, `'d`);
  m6 = doc.match("(is|was|had|would|should|could|do|does|have|has|can) not");
  setContraction(m6, `n't`);
  m6 = doc.match("(i|we|they) have");
  setContraction(m6, `'ve`);
  m6 = doc.match("(would|should|could) have");
  setContraction(m6, `'ve`);
  m6 = doc.match("i am");
  setContraction(m6, `'m`);
  m6 = doc.match("going to");
  return this;
};
var contract_default = contract;

// node_modules/compromise/src/2-two/contraction-two/api/index.js
var titleCase4 = /^\p{Lu}[\p{Ll}'’]/u;
var toTitleCase2 = function(str = "") {
  str = str.replace(/^ *[a-z\u00C0-\u00FF]/, (x2) => x2.toUpperCase());
  return str;
};
var api3 = function(View2) {
  class Contractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Contraction";
    }
    /** i've -> 'i have' */
    expand() {
      this.docs.forEach((terms) => {
        let isTitleCase5 = titleCase4.test(terms[0].text);
        terms.forEach((t5, i5) => {
          t5.text = t5.implicit || "";
          delete t5.implicit;
          if (i5 < terms.length - 1 && t5.post === "") {
            t5.post += " ";
          }
          t5.dirty = true;
        });
        if (isTitleCase5) {
          terms[0].text = toTitleCase2(terms[0].text);
        }
      });
      this.compute("normal");
      return this;
    }
  }
  View2.prototype.contractions = function() {
    let m6 = this.match("@hasContraction+");
    return new Contractions(this.document, m6.pointer);
  };
  View2.prototype.contract = contract_default;
};
var api_default10 = api3;

// node_modules/compromise/src/2-two/contraction-two/compute/_splice.js
var insertContraction2 = function(document2, point, words) {
  let [n5, w2] = point;
  if (!words || words.length === 0) {
    return;
  }
  words = words.map((word, i5) => {
    word.implicit = word.text;
    word.machine = word.text;
    word.pre = "";
    word.post = "";
    word.text = "";
    word.normal = "";
    word.index = [n5, w2 + i5];
    return word;
  });
  if (words[0]) {
    words[0].pre = document2[n5][w2].pre;
    words[words.length - 1].post = document2[n5][w2].post;
    words[0].text = document2[n5][w2].text;
    words[0].normal = document2[n5][w2].normal;
  }
  document2[n5].splice(w2, 1, ...words);
};
var splice_default2 = insertContraction2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-s.js
var hasContraction3 = /'/;
var hasWords = /* @__PURE__ */ new Set([
  "been",
  //the meeting's been ..
  "become"
  //my son's become
]);
var isWords = /* @__PURE__ */ new Set([
  "what",
  //it's what
  "how",
  //it's how
  "when",
  "if",
  //it's if
  "too"
]);
var adjLike = /* @__PURE__ */ new Set(["too", "also", "enough"]);
var isOrHas = (terms, i5) => {
  for (let o4 = i5 + 1; o4 < terms.length; o4 += 1) {
    let t5 = terms[o4];
    if (hasWords.has(t5.normal)) {
      return "has";
    }
    if (isWords.has(t5.normal)) {
      return "is";
    }
    if (t5.tags.has("Gerund")) {
      return "is";
    }
    if (t5.tags.has("Determiner")) {
      return "is";
    }
    if (t5.tags.has("Adjective")) {
      return "is";
    }
    if (t5.switch === "Adj|Past") {
      if (terms[o4 + 1]) {
        if (adjLike.has(terms[o4 + 1].normal)) {
          return "is";
        }
        if (terms[o4 + 1].tags.has("Preposition")) {
          return "is";
        }
      }
    }
    if (t5.tags.has("PastTense")) {
      if (terms[o4 + 1] && terms[o4 + 1].normal === "for") {
        return "is";
      }
      return "has";
    }
  }
  return "is";
};
var apostropheS = function(terms, i5) {
  let before2 = terms[i5].normal.split(hasContraction3)[0];
  if (before2 === "let") {
    return [before2, "us"];
  }
  if (before2 === "there") {
    let t5 = terms[i5 + 1];
    if (t5 && t5.tags.has("Plural")) {
      return [before2, "are"];
    }
  }
  if (isOrHas(terms, i5) === "has") {
    return [before2, "has"];
  }
  return [before2, "is"];
};
var apostrophe_s_default = apostropheS;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-d.js
var hasContraction4 = /'/;
var hadWords = /* @__PURE__ */ new Set([
  "better",
  //had better
  "done",
  //had done
  "before",
  // he'd _ before
  "it",
  // he'd _ it
  "had"
  //she'd had -> she would have..
]);
var wouldWords = /* @__PURE__ */ new Set([
  "have",
  // 'i'd have' -> i would have..
  "be"
  //' she'd be'
]);
var hadOrWould = (terms, i5) => {
  for (let o4 = i5 + 1; o4 < terms.length; o4 += 1) {
    let t5 = terms[o4];
    if (hadWords.has(t5.normal)) {
      return "had";
    }
    if (wouldWords.has(t5.normal)) {
      return "would";
    }
    if (t5.tags.has("PastTense") || t5.switch === "Adj|Past") {
      return "had";
    }
    if (t5.tags.has("PresentTense") || t5.tags.has("Infinitive")) {
      return "would";
    }
    if (t5.tags.has("#Determiner")) {
      return "had";
    }
    if (t5.tags.has("Adjective")) {
      return "would";
    }
  }
  return false;
};
var _apostropheD2 = function(terms, i5) {
  let before2 = terms[i5].normal.split(hasContraction4)[0];
  if (before2 === "how" || before2 === "what") {
    return [before2, "did"];
  }
  if (hadOrWould(terms, i5) === "had") {
    return [before2, "had"];
  }
  return [before2, "would"];
};
var apostrophe_d_default2 = _apostropheD2;

// node_modules/compromise/src/2-two/contraction-two/compute/apostrophe-t.js
var lastNoun = function(terms, i5) {
  for (let n5 = i5 - 1; n5 >= 0; n5 -= 1) {
    if (terms[n5].tags.has("Noun") || terms[n5].tags.has("Pronoun") || terms[n5].tags.has("Plural") || terms[n5].tags.has("Singular")) {
      return terms[n5];
    }
  }
  return null;
};
var apostropheT2 = function(terms, i5) {
  if (terms[i5].normal === "ain't" || terms[i5].normal === "aint") {
    if (terms[i5 + 1] && terms[i5 + 1].normal === "never") {
      return ["have"];
    }
    let noun = lastNoun(terms, i5);
    if (noun) {
      if (noun.normal === "we" || noun.normal === "they") {
        return ["are", "not"];
      }
      if (noun.normal === "i") {
        return ["am", "not"];
      }
      if (noun.tags && noun.tags.has("Plural")) {
        return ["are", "not"];
      }
    }
    return ["is", "not"];
  }
  let before2 = terms[i5].normal.replace(/n't/, "");
  return [before2, "not"];
};
var apostrophe_t_default2 = apostropheT2;

// node_modules/compromise/src/2-two/contraction-two/compute/isPossessive.js
var banList = {
  that: true,
  there: true,
  let: true,
  here: true,
  everywhere: true
};
var beforePossessive = {
  in: true,
  //in sunday's
  by: true,
  //by sunday's
  for: true
  //for sunday's
};
var adjLike2 = /* @__PURE__ */ new Set(["too", "also", "enough", "about"]);
var nounLike = /* @__PURE__ */ new Set(["is", "are", "did", "were", "could", "should", "must", "had", "have"]);
var isPossessive2 = (terms, i5) => {
  let term = terms[i5];
  if (banList.hasOwnProperty(term.machine || term.normal)) {
    return false;
  }
  if (term.tags.has("Possessive")) {
    return true;
  }
  if (term.tags.has("QuestionWord")) {
    return false;
  }
  if (term.normal === `he's` || term.normal === `she's`) {
    return false;
  }
  let nextTerm = terms[i5 + 1];
  if (!nextTerm) {
    return true;
  }
  if (term.normal === `it's`) {
    if (nextTerm.tags.has("#Noun")) {
      return true;
    }
    return false;
  }
  if (nextTerm.switch == "Noun|Gerund") {
    let next2 = terms[i5 + 2];
    if (!next2) {
      if (term.tags.has("Actor") || term.tags.has("ProperNoun")) {
        return true;
      }
      return false;
    }
    if (next2.tags.has("Copula")) {
      return true;
    }
    if (next2.normal === "on" || next2.normal === "in") {
      return false;
    }
    return false;
  }
  if (nextTerm.tags.has("Verb")) {
    if (nextTerm.tags.has("Infinitive")) {
      return true;
    }
    if (nextTerm.tags.has("Gerund")) {
      return false;
    }
    if (nextTerm.tags.has("PresentTense")) {
      return true;
    }
    return false;
  }
  if (nextTerm.switch === "Adj|Noun") {
    let twoTerm = terms[i5 + 2];
    if (!twoTerm) {
      return false;
    }
    if (nounLike.has(twoTerm.normal)) {
      return true;
    }
    if (adjLike2.has(twoTerm.normal)) {
      return false;
    }
  }
  if (nextTerm.tags.has("Noun")) {
    let nextStr = nextTerm.machine || nextTerm.normal;
    if (nextStr === "here" || nextStr === "there" || nextStr === "everywhere") {
      return false;
    }
    if (nextTerm.tags.has("Possessive")) {
      return false;
    }
    if (nextTerm.tags.has("ProperNoun") && !term.tags.has("ProperNoun")) {
      return false;
    }
    return true;
  }
  if (terms[i5 - 1] && beforePossessive[terms[i5 - 1].normal] === true) {
    return true;
  }
  if (nextTerm.tags.has("Adjective")) {
    let twoTerm = terms[i5 + 2];
    if (!twoTerm) {
      return false;
    }
    if (twoTerm.tags.has("Noun") && !twoTerm.tags.has("Pronoun")) {
      let str = nextTerm.normal;
      if (str === "above" || str === "below" || str === "behind") {
        return false;
      }
      return true;
    }
    if (twoTerm.switch === "Noun|Verb") {
      return true;
    }
    return false;
  }
  if (nextTerm.tags.has("Value")) {
    return true;
  }
  return false;
};
var isPossessive_default = isPossessive2;

// node_modules/compromise/src/2-two/contraction-two/compute/index.js
var byApostrophe2 = /'/;
var reIndex = function(terms) {
  terms.forEach((t5, i5) => {
    if (t5.index) {
      t5.index[1] = i5;
    }
  });
};
var reTag2 = function(terms, view, start2, len) {
  let tmp = view.update();
  tmp.document = [terms];
  let end2 = start2 + len;
  if (start2 > 0) {
    start2 -= 1;
  }
  if (terms[end2]) {
    end2 += 1;
  }
  tmp.ptrs = [[0, start2, end2]];
  tmp.compute(["lexicon", "preTagger"]);
  reIndex(terms);
};
var byEnd2 = {
  // how'd
  d: (terms, i5) => apostrophe_d_default2(terms, i5),
  // we ain't
  t: (terms, i5) => apostrophe_t_default2(terms, i5),
  // bob's
  s: (terms, i5, world2) => {
    if (isPossessive_default(terms, i5)) {
      return world2.methods.one.setTag([terms[i5]], "Possessive", world2, null, "2-contraction");
    }
    return apostrophe_s_default(terms, i5);
  }
};
var toDocs2 = function(words, view) {
  let doc = view.fromText(words.join(" "));
  doc.compute("id");
  return doc.docs[0];
};
var contractionTwo = (view) => {
  let { world: world2, document: document2 } = view;
  document2.forEach((terms, n5) => {
    for (let i5 = terms.length - 1; i5 >= 0; i5 -= 1) {
      if (terms[i5].implicit) {
        return;
      }
      let after2 = null;
      if (byApostrophe2.test(terms[i5].normal) === true) {
        after2 = terms[i5].normal.split(byApostrophe2)[1];
      }
      let words = null;
      if (byEnd2.hasOwnProperty(after2)) {
        words = byEnd2[after2](terms, i5, world2);
      }
      if (words) {
        words = toDocs2(words, view);
        splice_default2(document2, [n5, i5], words);
        reTag2(document2[n5], view, i5, words.length);
        continue;
      }
    }
  });
};
var compute_default9 = { contractionTwo };

// node_modules/compromise/src/2-two/contraction-two/plugin.js
var plugin_default15 = {
  compute: compute_default9,
  api: api_default10,
  hooks: ["contractionTwo"]
};

// node_modules/compromise/src/2-two/postTagger/model/adjective/adjective.js
var adjective_default = [
  // all fell apart
  { match: "[(all|both)] #Determiner #Noun", group: 0, tag: "Noun", reason: "all-noun" },
  //sometimes not-adverbs
  { match: "#Copula [(just|alone)]$", group: 0, tag: "Adjective", reason: "not-adverb" },
  //jack is guarded
  { match: "#Singular is #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "is-filled" },
  // smoked poutine is
  { match: "[#PastTense] #Singular is", group: 0, tag: "Adjective", reason: "smoked-poutine" },
  // baked onions are
  { match: "[#PastTense] #Plural are", group: 0, tag: "Adjective", reason: "baked-onions" },
  // well made
  { match: "well [#PastTense]", group: 0, tag: "Adjective", reason: "well-made" },
  // is f*ed up
  { match: "#Copula [fucked up?]", group: 0, tag: "Adjective", reason: "swears-adjective" },
  //jack seems guarded
  { match: "#Singular (seems|appears) #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "seems-filled" },
  // jury is out - preposition ➔ adjective
  { match: "#Copula #Adjective? [(out|in|through)]$", group: 0, tag: "Adjective", reason: "still-out" },
  // shut the door
  { match: "^[#Adjective] (the|your) #Noun", group: 0, notIf: "(all|even)", tag: "Infinitive", reason: "shut-the" },
  // the said card
  { match: "the [said] #Noun", group: 0, tag: "Adjective", reason: "the-said-card" },
  // faith-based, much-appreciated, soft-boiled
  { match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "faith-based" },
  //self-driving
  { match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "self-driving" },
  //dammed-up
  { match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", reason: "dammed-up" },
  //two-fold
  { match: "(#Hyphenated && #Value) fold", tag: "Adjective", reason: "two-fold" },
  //must-win
  { match: "must (#Hyphenated && #Infinitive)", tag: "Adjective", reason: "must-win" },
  // vacuum-sealed
  { match: `(#Hyphenated && #Infinitive) #Hyphenated`, tag: "Adjective", notIf: "#PhrasalVerb", reason: "vacuum-sealed" },
  { match: "too much", tag: "Adverb Adjective", reason: "bit-4" },
  { match: "a bit much", tag: "Determiner Adverb Adjective", reason: "bit-3" },
  // adjective-prefixes - 'un skilled'
  { match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective", group: 0, tag: ["Adjective", "Prefix"], reason: "un-skilled" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-adverb.js
var adverbAdj = `(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)`;
var noLy = "(hard|fast|late|early|high|right|deep|close|direct)";
var adj_adverb_default = [
  // kinda sparkly
  { match: `#Adverb [#Adverb] (and|or|then)`, group: 0, tag: "Adjective", reason: "kinda-sparkly-and" },
  // dark green
  { match: `[${adverbAdj}] #Adjective`, group: 0, tag: "Adverb", reason: "dark-green" },
  // far too
  { match: `#Copula [far too] #Adjective`, group: 0, tag: "Adverb", reason: "far-too" },
  // was still in
  { match: `#Copula [still] (in|#Gerund|#Adjective)`, group: 0, tag: "Adverb", reason: "was-still-walking" },
  // studies hard
  { match: `#Plural ${noLy}`, tag: "#PresentTense #Adverb", reason: "studies-hard" },
  // shops direct
  {
    match: `#Verb [${noLy}] !#Noun?`,
    group: 0,
    notIf: "(#Copula|get|got|getting|become|became|becoming|feel|feels|feeling|#Determiner|#Preposition)",
    tag: "Adverb",
    reason: "shops-direct"
  },
  // studies a lot
  { match: `[#Plural] a lot`, tag: "PresentTense", reason: "studies-a-lot" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-gerund.js
var adj_gerund_default2 = [
  //a staggering cost
  // { match: '(a|an) [#Gerund]', group: 0, tag: 'Adjective', reason: 'a|an' },
  //as amusing as
  { match: "as [#Gerund] as", group: 0, tag: "Adjective", reason: "as-gerund-as" },
  // more amusing than
  { match: "more [#Gerund] than", group: 0, tag: "Adjective", reason: "more-gerund-than" },
  // very amusing
  { match: "(so|very|extremely) [#Gerund]", group: 0, tag: "Adjective", reason: "so-gerund" },
  // found it amusing
  { match: "(found|found) it #Adverb? [#Gerund]", group: 0, tag: "Adjective", reason: "found-it-gerund" },
  // a bit amusing
  { match: "a (little|bit|wee) bit? [#Gerund]", group: 0, tag: "Adjective", reason: "a-bit-gerund" },
  // looking annoying
  {
    match: "#Gerund [#Gerund]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looking-annoying"
  },
  // looked amazing
  {
    match: "(looked|look|looks) #Adverb? [%Adj|Gerund%]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looked-amazing"
  },
  // were really amazing
  // { match: '(looked|look|looks) #Adverb [%Adj|Gerund%]', group: 0, tag: 'Adjective', notIf: '(impersonating|practicing|considering|assuming)', reason: 'looked-amazing' },
  // developing a
  { match: "[%Adj|Gerund%] #Determiner", group: 0, tag: "Gerund", reason: "developing-a" },
  // world's leading manufacturer
  { match: "#Possessive [%Adj|Gerund%] #Noun", group: 0, tag: "Adjective", reason: "leading-manufacturer" },
  // meaning alluring
  { match: "%Noun|Gerund% %Adj|Gerund%", tag: "Gerund #Adjective", reason: "meaning-alluring" },
  // face shocking revelations
  {
    match: "(face|embrace|reveal|stop|start|resume) %Adj|Gerund%",
    tag: "#PresentTense #Adjective",
    reason: "face-shocking"
  },
  // are enduring symbols
  { match: "(are|were) [%Adj|Gerund%] #Plural", group: 0, tag: "Adjective", reason: "are-enduring-symbols" }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-noun.js
var adj_noun_default2 = [
  //the above is clear
  { match: "#Determiner [#Adjective] #Copula", group: 0, tag: "Noun", reason: "the-adj-is" },
  //real evil is
  { match: "#Adjective [#Adjective] #Copula", group: 0, tag: "Noun", reason: "adj-adj-is" },
  //his fine
  { match: "(his|its) [%Adj|Noun%]", group: 0, tag: "Noun", notIf: "#Hyphenated", reason: "his-fine" },
  //is all
  { match: "#Copula #Adverb? [all]", group: 0, tag: "Noun", reason: "is-all" },
  // have fun
  { match: `(have|had) [#Adjective] #Preposition .`, group: 0, tag: "Noun", reason: "have-fun" },
  // brewing giant
  { match: `#Gerund (giant|capital|center|zone|application)`, tag: "Noun", reason: "brewing-giant" },
  // in an instant
  { match: `#Preposition (a|an) [#Adjective]$`, group: 0, tag: "Noun", reason: "an-instant" },
  // no golden would
  { match: `no [#Adjective] #Modal`, group: 0, tag: "Noun", reason: "no-golden" },
  // brand new
  { match: `[brand #Gerund?] new`, group: 0, tag: "Adverb", reason: "brand-new" },
  // some kind
  { match: `(#Determiner|#Comparative|new|different) [kind]`, group: 0, tag: "Noun", reason: "some-kind" },
  // her favourite sport
  { match: `#Possessive [%Adj|Noun%] #Noun`, group: 0, tag: "Adjective", reason: "her-favourite" },
  // must-win
  { match: `must && #Hyphenated .`, tag: "Adjective", reason: "must-win" },
  // the present
  {
    match: `#Determiner [#Adjective]$`,
    tag: "Noun",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "the-south"
  },
  //are that crazy.
  // company-wide
  {
    match: `(#Noun && #Hyphenated) (#Adjective && #Hyphenated)`,
    tag: "Adjective",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "company-wide"
  },
  // the poor were
  {
    match: `#Determiner [#Adjective] (#Copula|#Determiner)`,
    notIf: "(#Comparative|#Superlative)",
    group: 0,
    tag: "Noun",
    reason: "the-poor"
  },
  // professional bodybuilder
  {
    match: `[%Adj|Noun%] #Noun`,
    notIf: "(#Pronoun|#ProperNoun)",
    group: 0,
    tag: "Adjective",
    reason: "stable-foundations"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/adjective/adj-verb.js
var adj_verb_default = [
  // amusing his aunt
  // { match: '[#Adjective] #Possessive #Noun', group: 0, tag: 'Verb', reason: 'gerund-his-noun' },
  // loving you
  // { match: '[#Adjective] (us|you)', group: 0, tag: 'Gerund', reason: 'loving-you' },
  // slowly stunning
  { match: "(slowly|quickly) [#Adjective]", group: 0, tag: "Verb", reason: "slowly-adj" },
  // does mean
  { match: "does (#Adverb|not)? [#Adjective]", group: 0, tag: "PresentTense", reason: "does-mean" },
  // okay by me
  { match: "[(fine|okay|cool|ok)] by me", group: 0, tag: "Adjective", reason: "okay-by-me" },
  // i mean
  { match: "i (#Adverb|do)? not? [mean]", group: 0, tag: "PresentTense", reason: "i-mean" },
  //will secure our
  { match: "will #Adjective", tag: "Auxiliary Infinitive", reason: "will-adj" },
  //he disguised the thing
  { match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun", group: 0, tag: "Verb", reason: "he-adj-the" },
  //is eager to go
  { match: "#Copula [%Adj|Present%] to #Verb", group: 0, tag: "Verb", reason: "adj-to" },
  //is done well
  { match: "#Copula [#Adjective] (well|badly|quickly|slowly)", group: 0, tag: "Verb", reason: "done-well" },
  // rude and insulting
  { match: "#Adjective and [#Gerund] !#Preposition?", group: 0, tag: "Adjective", reason: "rude-and-x" },
  // were over cooked
  { match: "#Copula #Adverb? (over|under) [#PastTense]", group: 0, tag: "Adjective", reason: "over-cooked" },
  // was bland and overcooked
  { match: "#Copula #Adjective+ (and|or) [#PastTense]$", group: 0, tag: "Adjective", reason: "bland-and-overcooked" },
  // got tired of
  { match: "got #Adverb? [#PastTense] of", group: 0, tag: "Adjective", reason: "got-tired-of" },
  //felt loved
  {
    match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]",
    group: 0,
    tag: "Adjective",
    reason: "felt-loved"
  },
  // seem confused
  { match: "(seem|feel|seemed|felt) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "seem-confused" },
  // a bit confused
  { match: "a (bit|little|tad) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "a-bit-confused" },
  // do not be embarrassed
  { match: "not be [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "do-not-be-confused" },
  // is just right
  { match: "#Copula just [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "is-just-right" },
  // as pale as
  { match: "as [#Infinitive] as", group: 0, tag: "Adjective", reason: "as-pale-as" },
  //failed and oppressive
  { match: "[%Adj|Past%] and #Adjective", group: 0, tag: "Adjective", reason: "faled-and-oppressive" },
  // or heightened emotion
  {
    match: "or [#PastTense] #Noun",
    group: 0,
    tag: "Adjective",
    notIf: "(#Copula|#Pronoun)",
    reason: "or-heightened-emotion"
  },
  // became involved
  { match: "(become|became|becoming|becomes) [#Verb]", group: 0, tag: "Adjective", reason: "become-verb" },
  // their declared intentions
  { match: "#Possessive [#PastTense] #Noun", group: 0, tag: "Adjective", reason: "declared-intentions" },
  // is he cool
  { match: "#Copula #Pronoun [%Adj|Present%]", group: 0, tag: "Adjective", reason: "is-he-cool" },
  // is crowded with
  {
    match: "#Copula [%Adj|Past%] with",
    group: 0,
    tag: "Adjective",
    notIf: "(associated|worn|baked|aged|armed|bound|fried|loaded|mixed|packed|pumped|filled|sealed)",
    reason: "is-crowded-with"
  },
  // is empty$
  { match: "#Copula #Adverb? [%Adj|Present%]$", group: 0, tag: "Adjective", reason: "was-empty$" }
];

// node_modules/compromise/src/2-two/postTagger/model/adverb.js
var adverb_default = [
  //still good
  { match: "[still] #Adjective", group: 0, tag: "Adverb", reason: "still-advb" },
  //still make
  { match: "[still] #Verb", group: 0, tag: "Adverb", reason: "still-verb" },
  // so hot
  { match: "[so] #Adjective", group: 0, tag: "Adverb", reason: "so-adv" },
  // way hotter
  { match: "[way] #Comparative", group: 0, tag: "Adverb", reason: "way-adj" },
  // way too hot
  { match: "[way] #Adverb #Adjective", group: 0, tag: "Adverb", reason: "way-too-adj" },
  // all singing
  { match: "[all] #Verb", group: 0, tag: "Adverb", reason: "all-verb" },
  // sing like an angel
  { match: "#Verb  [like]", group: 0, notIf: "(#Modal|#PhrasalVerb)", tag: "Adverb", reason: "verb-like" },
  //barely even walk
  { match: "(barely|hardly) even", tag: "Adverb", reason: "barely-even" },
  //even held
  { match: "[even] #Verb", group: 0, tag: "Adverb", reason: "even-walk" },
  //even worse
  { match: "[even] #Comparative", group: 0, tag: "Adverb", reason: "even-worse" },
  // even the greatest
  { match: "[even] (#Determiner|#Possessive)", group: 0, tag: "#Adverb", reason: "even-the" },
  // even left
  { match: "even left", tag: "#Adverb #Verb", reason: "even-left" },
  // way over
  { match: "[way] #Adjective", group: 0, tag: "#Adverb", reason: "way-over" },
  //cheering hard - dropped -ly's
  {
    match: "#PresentTense [(hard|quick|bright|slow|fast|backwards|forwards)]",
    notIf: "#Copula",
    group: 0,
    tag: "Adverb",
    reason: "lazy-ly"
  },
  // much appreciated
  { match: "[much] #Adjective", group: 0, tag: "Adverb", reason: "bit-1" },
  // is well
  { match: "#Copula [#Adverb]$", group: 0, tag: "Adjective", reason: "is-well" },
  // a bit cold
  { match: "a [(little|bit|wee) bit?] #Adjective", group: 0, tag: "Adverb", reason: "a-bit-cold" },
  // super strong
  { match: `[(super|pretty)] #Adjective`, group: 0, tag: "Adverb", reason: "super-strong" },
  // become overly weakened
  { match: "(become|fall|grow) #Adverb? [#PastTense]", group: 0, tag: "Adjective", reason: "overly-weakened" },
  // a completely beaten man
  { match: "(a|an) #Adverb [#Participle] #Noun", group: 0, tag: "Adjective", reason: "completely-beaten" },
  //a close
  { match: "#Determiner #Adverb? [close]", group: 0, tag: "Adjective", reason: "a-close" },
  //walking close
  { match: "#Gerund #Adverb? [close]", group: 0, tag: "Adverb", notIf: "(getting|becoming|feeling)", reason: "being-close" },
  // a blown motor
  { match: "(the|those|these|a|an) [#Participle] #Noun", group: 0, tag: "Adjective", reason: "blown-motor" },
  // charged back
  { match: "(#PresentTense|#PastTense) [back]", group: 0, tag: "Adverb", notIf: "(#PhrasalVerb|#Copula)", reason: "charge-back" },
  // send around
  { match: "#Verb [around]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "send-around" },
  // later say
  { match: "[later] #PresentTense", group: 0, tag: "Adverb", reason: "later-say" },
  // the well
  { match: "#Determiner [well] !#PastTense?", group: 0, tag: "Noun", reason: "the-well" },
  // high enough
  { match: "#Adjective [enough]", group: 0, tag: "Adverb", reason: "high-enough" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date-phrase.js
var date_phrase_default = [
  // ==== Holiday ====
  { match: "#Holiday (day|eve)", tag: "Holiday", reason: "holiday-day" },
  //5th of March
  { match: "#Value of #Month", tag: "Date", reason: "value-of-month" },
  //5 March
  { match: "#Cardinal #Month", tag: "Date", reason: "cardinal-month" },
  //march 5 to 7
  { match: "#Month #Value to #Value", tag: "Date", reason: "value-to-value" },
  //march the 12th
  { match: "#Month the #Value", tag: "Date", reason: "month-the-value" },
  //june 7
  { match: "(#WeekDay|#Month) #Value", tag: "Date", reason: "date-value" },
  //7 june
  { match: "#Value (#WeekDay|#Month)", tag: "Date", reason: "value-date" },
  //may twenty five
  { match: "(#TextValue && #Date) #TextValue", tag: "Date", reason: "textvalue-date" },
  // 'aug 20-21'
  { match: `#Month #NumberRange`, tag: "Date", reason: "aug 20-21" },
  // wed march 5th
  { match: `#WeekDay #Month #Ordinal`, tag: "Date", reason: "week mm-dd" },
  // aug 5th 2021
  { match: `#Month #Ordinal #Cardinal`, tag: "Date", reason: "mm-dd-yyy" },
  // === timezones ===
  // china standard time
  { match: `(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time`, tag: "Timezone", reason: "std-time" },
  // eastern time
  {
    match: `(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time`,
    tag: "Timezone",
    reason: "eastern-time"
  },
  // 5pm central
  { match: `#Time [(eastern|mountain|pacific|central|est|pst|gmt)]`, group: 0, tag: "Timezone", reason: "5pm-central" },
  // central european time
  { match: `(central|western|eastern) european time`, tag: "Timezone", reason: "cet" }
];

// node_modules/compromise/src/2-two/postTagger/model/dates/date.js
var date_default = [
  // ==== WeekDay ====
  // sun the 5th
  { match: "[sun] the #Ordinal", tag: "WeekDay", reason: "sun-the-5th" },
  //sun feb 2
  { match: "[sun] #Date", group: 0, tag: "WeekDay", reason: "sun-feb" },
  //1pm next sun
  { match: "#Date (on|this|next|last|during)? [sun]", group: 0, tag: "WeekDay", reason: "1pm-sun" },
  //this sat
  { match: `(in|by|before|during|on|until|after|of|within|all) [sat]`, group: 0, tag: "WeekDay", reason: "sat" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [wed]`, group: 0, tag: "WeekDay", reason: "wed" },
  { match: `(in|by|before|during|on|until|after|of|within|all) [march]`, group: 0, tag: "Month", reason: "march" },
  //sat november
  { match: "[sat] #Date", group: 0, tag: "WeekDay", reason: "sat-feb" },
  // ==== Month ====
  //all march
  { match: `#Preposition [(march|may)]`, group: 0, tag: "Month", reason: "in-month" },
  //this march
  { match: `(this|next|last) (march|may) !#Infinitive?`, tag: "#Date #Month", reason: "this-month" },
  // march 5th
  { match: `(march|may) the? #Value`, tag: "#Month #Date #Date", reason: "march-5th" },
  // 5th of march
  { match: `#Value of? (march|may)`, tag: "#Date #Date #Month", reason: "5th-of-march" },
  // march and feb
  { match: `[(march|may)] .? #Date`, group: 0, tag: "Month", reason: "march-and-feb" },
  // feb to march
  { match: `#Date .? [(march|may)]`, group: 0, tag: "Month", reason: "feb-and-march" },
  //quickly march
  { match: `#Adverb [(march|may)]`, group: 0, tag: "Verb", reason: "quickly-march" },
  //march quickly
  { match: `[(march|may)] #Adverb`, group: 0, tag: "Verb", reason: "march-quickly" },
  //12 am
  { match: `#Value (am|pm)`, tag: "Time", reason: "2-am" }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/nouns.js
var infNouns = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)";
var nouns_default4 = [
  //'more' is not always an adverb
  // any more
  { match: "(the|any) [more]", group: 0, tag: "Singular", reason: "more-noun" },
  // more players
  { match: "[more] #Noun", group: 0, tag: "Adjective", reason: "more-noun" },
  // rights of man
  { match: "(right|rights) of .", tag: "Noun", reason: "right-of" },
  // a bit
  { match: "a [bit]", group: 0, tag: "Singular", reason: "bit-2" },
  // a must
  { match: "a [must]", group: 0, tag: "Singular", reason: "must-2" },
  // we all
  { match: "(we|us) [all]", group: 0, tag: "Noun", reason: "we all" },
  // due to weather
  { match: "due to [#Verb]", group: 0, tag: "Noun", reason: "due-to" },
  //some pressing issues
  { match: "some [#Verb] #Plural", group: 0, tag: "Noun", reason: "determiner6" },
  // my first thought
  { match: "#Possessive #Ordinal [#PastTense]", group: 0, tag: "Noun", reason: "first-thought" },
  //the nice swim
  {
    match: "(the|this|those|these) #Adjective [%Verb|Noun%]",
    group: 0,
    tag: "Noun",
    notIf: "#Copula",
    reason: "the-adj-verb"
  },
  // the truly nice swim
  { match: "(the|this|those|these) #Adverb #Adjective [#Verb]", group: 0, tag: "Noun", reason: "determiner4" },
  //the wait to vote
  { match: "the [#Verb] #Preposition .", group: 0, tag: "Noun", reason: "determiner1" },
  //a sense of
  { match: "(a|an|the) [#Verb] of", group: 0, tag: "Noun", reason: "the-verb-of" },
  //the threat of force
  { match: "#Determiner #Noun of [#Verb]", group: 0, tag: "Noun", notIf: "#Gerund", reason: "noun-of-noun" },
  // ended in ruins
  {
    match: "#PastTense #Preposition [#PresentTense]",
    group: 0,
    notIf: "#Gerund",
    tag: "Noun",
    reason: "ended-in-ruins"
  },
  //'u' as pronoun
  { match: "#Conjunction [u]", group: 0, tag: "Pronoun", reason: "u-pronoun-2" },
  { match: "[u] #Verb", group: 0, tag: "Pronoun", reason: "u-pronoun-1" },
  //the western line
  {
    match: "#Determiner [(western|eastern|northern|southern|central)] #Noun",
    group: 0,
    tag: "Noun",
    reason: "western-line"
  },
  //air-flow
  { match: "(#Singular && @hasHyphen) #PresentTense", tag: "Noun", reason: "hyphen-verb" },
  //is no walk
  { match: "is no [#Verb]", group: 0, tag: "Noun", reason: "is-no-verb" },
  //do so
  { match: "do [so]", group: 0, tag: "Noun", reason: "so-noun" },
  // what the hell
  { match: "#Determiner [(shit|damn|hell)]", group: 0, tag: "Noun", reason: "swears-noun" },
  // go to shit
  { match: "to [(shit|hell)]", group: 0, tag: "Noun", reason: "to-swears" },
  // the staff were
  { match: "(the|these) [#Singular] (were|are)", group: 0, tag: "Plural", reason: "singular-were" },
  // a comdominium, or simply condo
  { match: `a #Noun+ or #Adverb+? [#Verb]`, group: 0, tag: "Noun", reason: "noun-or-noun" },
  // walk the walk
  {
    match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]",
    group: 0,
    tag: "Noun",
    notIf: "(seem|appear|include|#Gerund|#Copula)",
    reason: "det-inf"
  },
  // { match: '(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]', group: 0, tag: 'Noun', notIf: '(#Gerund|#Copula)', reason: 'det-pres' },
  // ==== Actor ====
  //Aircraft designer
  { match: "#Noun #Actor", tag: "Actor", notIf: "(#Person|#Pronoun)", reason: "thing-doer" },
  //lighting designer
  { match: "#Gerund #Actor", tag: "Actor", reason: "gerund-doer" },
  // captain sanders
  // { match: '[#Actor+] #ProperNoun', group: 0, tag: 'Honorific', reason: 'sgt-kelly' },
  // co-founder
  { match: `co #Singular`, tag: "Actor", reason: "co-noun" },
  // co-founder
  {
    match: `[#Noun+] #Actor`,
    group: 0,
    tag: "Actor",
    notIf: "(#Honorific|#Pronoun|#Possessive)",
    reason: "air-traffic-controller"
  },
  // fine-artist
  {
    match: `(urban|cardiac|cardiovascular|respiratory|medical|clinical|visual|graphic|creative|dental|exotic|fine|certified|registered|technical|virtual|professional|amateur|junior|senior|special|pharmaceutical|theoretical)+ #Noun? #Actor`,
    tag: "Actor",
    reason: "fine-artist"
  },
  // dance coach
  {
    match: `#Noun+ (coach|chef|king|engineer|fellow|personality|boy|girl|man|woman|master)`,
    tag: "Actor",
    reason: "dance-coach"
  },
  // chief design officer
  { match: `chief . officer`, tag: "Actor", reason: "chief-x-officer" },
  // chief of police
  { match: `chief of #Noun+`, tag: "Actor", reason: "chief-of-police" },
  // president of marketing
  { match: `senior? vice? president of #Noun+`, tag: "Actor", reason: "president-of" },
  // ==== Singular ====
  //the sun
  { match: "#Determiner [sun]", group: 0, tag: "Singular", reason: "the-sun" },
  //did a 900, paid a 20
  { match: "#Verb (a|an) [#Value]$", group: 0, tag: "Singular", reason: "did-a-value" },
  //'the can'
  { match: "the [(can|will|may)]", group: 0, tag: "Singular", reason: "the can" },
  // ==== Possessive ====
  //spencer kelly's
  { match: "#FirstName #Acronym? (#Possessive && #LastName)", tag: "Possessive", reason: "name-poss" },
  //Super Corp's fundraiser
  { match: "#Organization+ #Possessive", tag: "Possessive", reason: "org-possessive" },
  //Los Angeles's fundraiser
  { match: "#Place+ #Possessive", tag: "Possessive", reason: "place-possessive" },
  // Ptolemy's experiments
  { match: "#Possessive #PresentTense #Particle?", notIf: "(#Gerund|her)", tag: "Noun", reason: "possessive-verb" },
  // anna's eating vs anna's eating lunch
  // my presidents house
  { match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun", tag: "Possessive", reason: "my-dads" },
  // 10th of a second
  { match: "#Value of a [second]", group: 0, unTag: "Value", tag: "Singular", reason: "10th-of-a-second" },
  // 10 seconds
  { match: "#Value [seconds]", group: 0, unTag: "Value", tag: "Plural", reason: "10-seconds" },
  // in time
  { match: "in [#Infinitive]", group: 0, tag: "Singular", reason: "in-age" },
  // a minor in
  { match: "a [#Adjective] #Preposition", group: 0, tag: "Noun", reason: "a-minor-in" },
  //the repairer said
  { match: "#Determiner [#Singular] said", group: 0, tag: "Actor", reason: "the-actor-said" },
  //the euro sense
  {
    match: `#Determiner #Noun [${infNouns}] !(#Preposition|to|#Adverb)?`,
    group: 0,
    tag: "Noun",
    reason: "the-noun-sense"
  },
  // photographs of a computer are
  { match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula", group: 0, tag: "Plural", reason: "photographs-of" },
  // fight and win
  { match: "#Infinitive and [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "fight and win" },
  // peace and flowers and love
  { match: "#Noun and [#Verb] and #Noun", group: 0, tag: "Noun", reason: "peace-and-flowers" },
  // the 1992 classic
  { match: "the #Cardinal [%Adj|Noun%]", group: 0, tag: "Noun", reason: "the-1992-classic" },
  // the premier university
  { match: "#Copula the [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "the-premier-university" },
  // scottish - i ate me sandwich
  { match: "i #Verb [me] #Noun", group: 0, tag: "Possessive", reason: "scottish-me" },
  // dance music
  {
    match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)",
    group: 0,
    tag: "Noun",
    reason: "dance-music"
  },
  // wit it
  { match: "[wit] (me|it)", group: 0, tag: "Presposition", reason: "wit-me" },
  //left-her-boots, shoved her hand
  { match: "#PastTense #Possessive [#Verb]", group: 0, tag: "Noun", notIf: "(saw|made)", reason: "left-her-boots" },
  //35 signs
  { match: "#Value [%Plural|Verb%]", group: 0, tag: "Plural", notIf: "(one|1|a|an)", reason: "35-signs" },
  //had time
  { match: "had [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|come|become)", reason: "had-time" },
  //instant access
  { match: "%Adj|Noun% %Noun|Verb%", tag: "#Adjective #Noun", notIf: "#ProperNoun #Noun", reason: "instant-access" },
  // a representative to
  { match: "#Determiner [%Adj|Noun%] #Conjunction", group: 0, tag: "Noun", reason: "a-rep-to" },
  // near death experiences, ambitious sales targets
  {
    match: "#Adjective #Noun [%Plural|Verb%]$",
    group: 0,
    tag: "Plural",
    notIf: "#Pronoun",
    reason: "near-death-experiences"
  },
  // your guild colors
  { match: "#Possessive #Noun [%Plural|Verb%]$", group: 0, tag: "Plural", reason: "your-guild-colors" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/noun-gerund.js
var noun_gerund_default2 = [
  // the planning processes
  { match: "(this|that|the|a|an) [#Gerund #Infinitive]", group: 0, tag: "Singular", reason: "the-planning-process" },
  // the paving stones
  { match: "(that|the) [#Gerund #PresentTense]", group: 0, ifNo: "#Copula", tag: "Plural", reason: "the-paving-stones" },
  // this swimming
  // { match: '(this|that|the) [#Gerund]', group: 0, tag: 'Noun', reason: 'this-gerund' },
  // the remaining claims
  { match: "#Determiner [#Gerund] #Noun", group: 0, tag: "Adjective", reason: "the-gerund-noun" },
  // i think tipping sucks
  { match: `#Pronoun #Infinitive [#Gerund] #PresentTense`, group: 0, tag: "Noun", reason: "tipping-sucks" },
  // early warning
  { match: "#Adjective [#Gerund]", group: 0, tag: "Noun", notIf: "(still|even|just)", reason: "early-warning" },
  //walking is cool
  { match: "[#Gerund] #Adverb? not? #Copula", group: 0, tag: "Activity", reason: "gerund-copula" },
  //are doing is
  { match: "#Copula [(#Gerund|#Activity)] #Copula", group: 0, tag: "Gerund", reason: "are-doing-is" },
  //walking should be fun
  { match: "[#Gerund] #Modal", group: 0, tag: "Activity", reason: "gerund-modal" },
  // finish listening
  // { match: '#Infinitive [#Gerund]', group: 0, tag: 'Activity', reason: 'finish-listening' },
  // the ruling party
  // responsibility for setting
  { match: "#Singular for [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "noun-for-gerund" },
  // better for training
  { match: "#Comparative (for|at) [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "better-for-gerund" },
  // keep the touching
  { match: "#PresentTense the [#Gerund]", group: 0, tag: "Noun", reason: "keep-the-touching" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verb-noun.js
var verb_noun_default = [
  // do the dance
  { match: "#Infinitive (this|that|the) [#Infinitive]", group: 0, tag: "Noun", reason: "do-this-dance" },
  //running-a-show
  { match: "#Gerund #Determiner [#Infinitive]", group: 0, tag: "Noun", reason: "running-a-show" },
  //the-only-reason
  { match: "#Determiner (only|further|just|more|backward) [#Infinitive]", group: 0, tag: "Noun", reason: "the-only-reason" },
  // a stream runs
  { match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb", group: 0, tag: "Noun", reason: "determiner5" },
  //a nice deal
  { match: "#Determiner #Adjective #Adjective? [#Infinitive]", group: 0, tag: "Noun", reason: "a-nice-inf" },
  // the mexican train
  { match: "#Determiner #Demonym [#PresentTense]", group: 0, tag: "Noun", reason: "mexican-train" },
  //next career move
  { match: "#Adjective #Noun+ [#Infinitive] #Copula", group: 0, tag: "Noun", reason: "career-move" },
  // at some point
  { match: "at some [#Infinitive]", group: 0, tag: "Noun", reason: "at-some-inf" },
  // goes to sleep
  { match: "(go|goes|went) to [#Infinitive]", group: 0, tag: "Noun", reason: "goes-to-verb" },
  //a close watch on
  { match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)", group: 0, notIf: "from", tag: "Noun", reason: "a-noun-inf" },
  //a tv show
  { match: "(a|an) #Noun [#Infinitive]$", group: 0, tag: "Noun", reason: "a-noun-inf2" },
  //is mark hughes
  // { match: '#Copula [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'is-pres-noun' },
  // good wait staff
  // { match: '#Adjective [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'good-wait-staff' },
  // running for congress
  { match: "#Gerund #Adjective? for [#Infinitive]", group: 0, tag: "Noun", reason: "running-for" },
  // running to work
  // { match: '#Gerund #Adjective to [#Infinitive]', group: 0, tag: 'Noun', reason: 'running-to' },
  // about love
  { match: "about [#Infinitive]", group: 0, tag: "Singular", reason: "about-love" },
  // singers on stage
  { match: "#Plural on [#Infinitive]", group: 0, tag: "Noun", reason: "on-stage" },
  // any charge
  { match: "any [#Infinitive]", group: 0, tag: "Noun", reason: "any-charge" },
  // no doubt
  { match: "no [#Infinitive]", group: 0, tag: "Noun", reason: "no-doubt" },
  // number of seats
  { match: "number of [#PresentTense]", group: 0, tag: "Noun", reason: "number-of-x" },
  // teaches/taught
  { match: "(taught|teaches|learns|learned) [#PresentTense]", group: 0, tag: "Noun", reason: "teaches-x" },
  // use reverse
  { match: "(try|use|attempt|build|make) [#Verb #Particle?]", notIf: "(#Copula|#Noun|sure|fun|up)", group: 0, tag: "Noun", reason: "do-verb" },
  //make sure of
  // checkmate is
  { match: "^[#Infinitive] (is|was)", group: 0, tag: "Noun", reason: "checkmate-is" },
  // get much sleep
  { match: "#Infinitive much [#Infinitive]", group: 0, tag: "Noun", reason: "get-much" },
  // cause i gotta
  { match: "[cause] #Pronoun #Verb", group: 0, tag: "Conjunction", reason: "cause-cuz" },
  // the cardio dance party
  { match: "the #Singular [#Infinitive] #Noun", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "cardio-dance" },
  // that should smoke
  { match: "#Determiner #Modal [#Noun]", group: 0, tag: "PresentTense", reason: "should-smoke" },
  //this rocks
  { match: "this [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Date)", reason: "this-verbs" },
  //voice that rocks
  { match: "#Noun that [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Pronoun|way)", reason: "voice-that-rocks" },
  //that leads to
  { match: "that [#Plural] to", group: 0, tag: "PresentTense", notIf: "#Preposition", reason: "that-leads-to" },
  //let him glue
  {
    match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
    group: 0,
    tag: "Infinitive",
    reason: "let-him-glue"
  },
  // assign all tasks
  { match: "#Verb (all|every|each|most|some|no) [#PresentTense]", notIf: "#Modal", group: 0, tag: "Noun", reason: "all-presentTense" },
  // PresentTense/Noun ambiguities
  // big dreams, critical thinking
  // have big dreams
  { match: "(had|have|#PastTense) #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "better", reason: "adj-presentTense" },
  // excellent answer spencer
  // { match: '^#Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'start adj-presentTense' },
  // one big reason
  { match: "#Value #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "one-big-reason" },
  // won widespread support
  { match: "#PastTense #Adjective+ [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Copula|better)", reason: "won-wide-support" },
  // many poses
  { match: "(many|few|several|couple) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "many-poses" },
  // very big dreams
  { match: "#Determiner #Adverb #Adjective [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "very-big-dream" },
  // from start to finish
  { match: "from #Noun to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "start-to-finish" },
  // for comparison or contrast
  { match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "for-food-and-gas" },
  // adorable little store
  { match: "#Adjective #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "adorable-little-store" },
  // of basic training
  // { match: '#Preposition #Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'of-basic-training' },
  // justifiying higher costs
  { match: "#Gerund #Adverb? #Comparative [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "higher-costs" },
  { match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "noun-list" },
  // any questions for
  { match: "(many|any|some|several) [#PresentTense] for", group: 0, tag: "Noun", reason: "any-verbs-for" },
  // to facilitate gas exchange with
  { match: `to #PresentTense #Noun [#PresentTense] #Preposition`, group: 0, tag: "Noun", reason: "gas-exchange" },
  // waited until release
  { match: `#PastTense (until|as|through|without) [#PresentTense]`, group: 0, tag: "Noun", reason: "waited-until-release" },
  // selling like hot cakes
  { match: `#Gerund like #Adjective? [#PresentTense]`, group: 0, tag: "Plural", reason: "like-hot-cakes" },
  // some valid reason
  { match: `some #Adjective [#PresentTense]`, group: 0, tag: "Noun", reason: "some-reason" },
  // for some reason
  { match: `for some [#PresentTense]`, group: 0, tag: "Noun", reason: "for-some-reason" },
  // same kind of shouts
  { match: `(same|some|the|that|a) kind of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-kind-of" },
  // a type of shout
  { match: `(same|some|the|that|a) type of [#PresentTense]`, group: 0, tag: "Noun", reason: "some-type-of" },
  // doing better for fights
  { match: `#Gerund #Adjective #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "doing-better-for-x" },
  // get better aim
  { match: `(get|got|have) #Comparative [#PresentTense]`, group: 0, tag: "Noun", reason: "got-better-aim" },
  // whose name was
  { match: "whose [#PresentTense] #Copula", group: 0, tag: "Noun", reason: "whos-name-was" },
  // give up on reason
  { match: `#PhrasalVerb #Particle #Preposition [#PresentTense]`, group: 0, tag: "Noun", reason: "given-up-on-x" },
  //there are reasons
  { match: "there (are|were) #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "there-are" },
  // 30 trains
  { match: "#Value [#PresentTense] of", group: 0, notIf: "(one|1|#Copula|#Infinitive)", tag: "Plural", reason: "2-trains" },
  // compromises are possible
  { match: "[#PresentTense] (are|were) #Adjective", group: 0, tag: "Plural", reason: "compromises-are-possible" },
  // hope i helped
  { match: "^[(hope|guess|thought|think)] #Pronoun #Verb", group: 0, tag: "Infinitive", reason: "suppose-i" },
  //pursue its dreams
  // { match: '#PresentTense #Possessive [#PresentTense]', notIf: '#Gerund', group: 0, tag: 'Plural', reason: 'pursue-its-dreams' },
  // our unyielding support
  { match: "#Possessive #Adjective [#Verb]", group: 0, tag: "Noun", notIf: "#Copula", reason: "our-full-support" },
  // tastes good
  { match: "[(tastes|smells)] #Adverb? #Adjective", group: 0, tag: "PresentTense", reason: "tastes-good" },
  // are you playing golf
  // { match: '^are #Pronoun [#Noun]', group: 0, notIf: '(here|there)', tag: 'Verb', reason: 'are-you-x' },
  // ignoring commute
  { match: "#Copula #Gerund [#PresentTense] !by?", group: 0, tag: "Noun", notIf: "going", reason: "ignoring-commute" },
  // noun-pastTense variables
  { match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]", group: 0, tag: "Noun", reason: "noun-past" },
  // 'verb-to'
  // how to watch
  { match: "how to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "how-to-noun" },
  // which boost it
  { match: "which [%Noun|Verb%] #Noun", group: 0, tag: "Infinitive", reason: "which-boost-it" },
  // asking questions
  { match: "#Gerund [%Plural|Verb%]", group: 0, tag: "Plural", reason: "asking-questions" },
  // ready to stream
  { match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "ready-to-noun" },
  // bring to market
  { match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "bring-to-noun" },
  // can i sleep, would you look
  { match: "#Modal #Noun [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "would-you-look" },
  // is just spam
  { match: "#Copula just [#Infinitive]", group: 0, tag: "Noun", reason: "is-just-spam" },
  // request copies
  { match: "^%Noun|Verb% %Plural|Verb%", tag: "Imperative #Plural", reason: "request-copies" },
  // homemade pickles and drinks
  { match: "#Adjective #Plural and [%Plural|Verb%]", group: 0, tag: "#Plural", reason: "pickles-and-drinks" },
  // the 1968 film
  { match: "#Determiner #Year [#Verb]", group: 0, tag: "Noun", reason: "the-1968-film" },
  // the break up
  { match: "#Determiner [#PhrasalVerb #Particle]", group: 0, tag: "Noun", reason: "the-break-up" },
  // the individual goals
  { match: "#Determiner [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", notIf: "(#Pronoun|#Possessive|#ProperNoun)", reason: "the-individual-goals" },
  // work or prepare
  { match: "[%Noun|Verb%] or #Infinitive", group: 0, tag: "Infinitive", reason: "work-or-prepare" },
  // to give thanks
  { match: "to #Infinitive [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|#Copula|help)", reason: "to-give-thanks" },
  // kills me
  { match: "[#Noun] me", group: 0, tag: "Verb", reason: "kills-me" },
  // removes wrinkles
  { match: "%Plural|Verb% %Plural|Verb%", tag: "#PresentTense #Plural", reason: "removes-wrinkles" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/money.js
var money_default = [
  { match: "#Money and #Money #Currency?", tag: "Money", reason: "money-and-money" },
  // 6 dollars and 5 cents
  { match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)", group: 0, tag: "money", reason: "and-5-cents" },
  // maybe currencies
  { match: "#Value (mark|rand|won|rub|ore)", tag: "#Money #Currency", reason: "4-mark" },
  // 3 pounds
  { match: "a pound", tag: "#Money #Unit", reason: "a-pound" },
  { match: "#Value (pound|pounds)", tag: "#Money #Unit", reason: "4-pounds" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/fractions.js
var fractions_default = [
  // half a penny
  { match: "[(half|quarter)] of? (a|an)", group: 0, tag: "Fraction", reason: "millionth" },
  // nearly half
  { match: "#Adverb [half]", group: 0, tag: "Fraction", reason: "nearly-half" },
  // half the
  { match: "[half] the", group: 0, tag: "Fraction", reason: "half-the" },
  // and a half
  { match: "#Cardinal and a half", tag: "Fraction", reason: "and-a-half" },
  // two-halves
  { match: "#Value (halves|halfs|quarters)", tag: "Fraction", reason: "two-halves" },
  // ---ordinals as fractions---
  // a fifth
  { match: "a #Ordinal", tag: "Fraction", reason: "a-quarter" },
  // seven fifths
  { match: "[#Cardinal+] (#Fraction && /s$/)", tag: "Fraction", reason: "seven-fifths" },
  // doc.match('(#Fraction && /s$/)').lookBefore('#Cardinal+$').tag('Fraction')
  // one third of ..
  { match: "[#Cardinal+ #Ordinal] of .", group: 0, tag: "Fraction", reason: "ordinal-of" },
  // 100th of
  { match: "[(#NumericValue && #Ordinal)] of .", group: 0, tag: "Fraction", reason: "num-ordinal-of" },
  // a twenty fifth
  { match: "(a|one) #Cardinal?+ #Ordinal", tag: "Fraction", reason: "a-ordinal" },
  // //  '3 out of 5'
  { match: "#Cardinal+ out? of every? #Cardinal", tag: "Fraction", reason: "out-of" }
];

// node_modules/compromise/src/2-two/postTagger/model/numbers/numbers.js
var numbers_default = [
  // ==== Ambiguous numbers ====
  // 'second'
  { match: `#Cardinal [second]`, tag: "Unit", reason: "one-second" },
  //'a/an' can mean 1 - "a hour"
  {
    match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
    group: 0,
    tag: "Value",
    reason: "a-is-one"
  },
  // ==== PhoneNumber ====
  //1 800 ...
  { match: "1 #Value #PhoneNumber", tag: "PhoneNumber", reason: "1-800-Value" },
  //(454) 232-9873
  { match: "#NumericValue #PhoneNumber", tag: "PhoneNumber", reason: "(800) PhoneNumber" },
  // ==== Currency ====
  // chinese yuan
  { match: "#Demonym #Currency", tag: "Currency", reason: "demonym-currency" },
  // ten bucks
  { match: "#Value [(buck|bucks|grand)]", group: 0, tag: "Currency", reason: "value-bucks" },
  // ==== Money ====
  { match: "[#Value+] #Currency", group: 0, tag: "Money", reason: "15 usd" },
  // ==== Ordinal ====
  { match: "[second] #Noun", group: 0, tag: "Ordinal", reason: "second-noun" },
  // ==== Units ====
  //5 yan
  { match: "#Value+ [#Currency]", group: 0, tag: "Unit", reason: "5-yan" },
  { match: "#Value [(foot|feet)]", group: 0, tag: "Unit", reason: "foot-unit" },
  //5 kg.
  { match: "#Value [#Abbreviation]", group: 0, tag: "Unit", reason: "value-abbr" },
  { match: "#Value [k]", group: 0, tag: "Unit", reason: "value-k" },
  { match: "#Unit an hour", tag: "Unit", reason: "unit-an-hour" },
  // ==== Magnitudes ====
  //minus 7
  { match: "(minus|negative) #Value", tag: "Value", reason: "minus-value" },
  //seven point five
  { match: "#Value (point|decimal) #Value", tag: "Value", reason: "value-point-value" },
  //quarter million
  { match: "#Determiner [(half|quarter)] #Ordinal", group: 0, tag: "Value", reason: "half-ordinal" },
  // thousand and two
  { match: `#Multiple+ and #Value`, tag: "Value", reason: "magnitude-and-value" },
  // ambiguous units like 'gb'
  // { match: '#Value square? [(kb|mb|gb|tb|ml|pt|qt|tbl|tbsp|km|cm|mm|mi|ft|yd|kg|hg|mg|oz|lb|mph|pa|miles|yard|yards|pound|pounds)]', group: 0, tag: 'Unit', reason: '12-gb' },
  // 5 miles per hour
  { match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]", group: 0, tag: "Unit", reason: "12-miles-per-second" },
  // 5 square miles
  { match: "#Value [(square|cubic)] #Unit", group: 0, tag: "Unit", reason: "square-miles" },
  // 5) The expenses
  { match: "^[#Value] (#Determiner|#Gerund)", group: 0, tag: "Expression", unTag: "Value", reason: "numbered-list" }
];

// node_modules/compromise/src/2-two/postTagger/model/person/person-phrase.js
var person_phrase_default = [
  // ==== FirstNames ====
  //is foo Smith
  { match: "#Copula [(#Noun|#PresentTense)] #LastName", group: 0, tag: "FirstName", reason: "copula-noun-lastname" },
  //pope francis
  {
    match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun",
    tag: "Person",
    reason: "lady-titlecase",
    safe: true
  },
  // ==== Nickname ====
  // Dwayne 'the rock' Johnson
  { match: "#FirstName [#Determiner #Noun] #LastName", group: 0, tag: "Person", reason: "first-noun-last" },
  {
    match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
    tag: "Person",
    reason: "titlecase-acronym-titlecase",
    safe: true
  },
  { match: "#Acronym #LastName", tag: "Person", reason: "acronym-lastname", safe: true },
  { match: "#Person (jr|sr|md)", tag: "Person", reason: "person-honorific" },
  //remove single 'mr'
  { match: "#Honorific #Acronym", tag: "Person", reason: "Honorific-TitleCase" },
  { match: "#Person #Person the? #RomanNumeral", tag: "Person", reason: "roman-numeral" },
  { match: "#FirstName [/^[^aiurck]$/]", group: 0, tag: ["Acronym", "Person"], reason: "john-e" },
  //j.k Rowling
  { match: "#Noun van der? #Noun", tag: "Person", reason: "van der noun", safe: true },
  //king of spain
  { match: "(king|queen|prince|saint|lady) of #Noun", tag: "Person", reason: "king-of-noun", safe: true },
  //lady Florence
  { match: "(prince|lady) #Place", tag: "Person", reason: "lady-place" },
  //saint Foo
  { match: "(king|queen|prince|saint) #ProperNoun", tag: "Person", notIf: "#Place", reason: "saint-foo" },
  // al sharpton
  { match: "al (#Person|#ProperNoun)", tag: "Person", reason: "al-borlen", safe: true },
  //ferdinand de almar
  { match: "#FirstName de #Noun", tag: "Person", reason: "bill-de-noun" },
  //Osama bin Laden
  { match: "#FirstName (bin|al) #Noun", tag: "Person", reason: "bill-al-noun" },
  //John L. Foo
  { match: "#FirstName #Acronym #ProperNoun", tag: "Person", reason: "bill-acronym-title" },
  //Andrew Lloyd Webber
  { match: "#FirstName #FirstName #ProperNoun", tag: "Person", reason: "bill-firstname-title" },
  //Mr Foo
  { match: "#Honorific #FirstName? #ProperNoun", tag: "Person", reason: "dr-john-Title" },
  //peter the great
  { match: "#FirstName the #Adjective", tag: "Person", reason: "name-the-great" },
  // dick van dyke
  { match: "#ProperNoun (van|al|bin) #ProperNoun", tag: "Person", reason: "title-van-title", safe: true },
  //jose de Sucre
  { match: "#ProperNoun (de|du) la? #ProperNoun", tag: "Person", notIf: "#Place", reason: "title-de-title" },
  //Jani K. Smith
  { match: "#Singular #Acronym #LastName", tag: "#FirstName #Person .", reason: "title-acro-noun", safe: true },
  //Foo Ford
  { match: "[#ProperNoun] #Person", group: 0, tag: "Person", reason: "proper-person", safe: true },
  // john keith jones
  {
    match: "#Person [#ProperNoun #ProperNoun]",
    group: 0,
    tag: "Person",
    notIf: "#Possessive",
    reason: "three-name-person",
    safe: true
  },
  //John Foo
  {
    match: "#FirstName #Acronym? [#ProperNoun]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "firstname-titlecase"
  },
  // john stewart
  { match: "#FirstName [#FirstName]", group: 0, tag: "LastName", reason: "firstname-firstname" },
  //Joe K. Sombrero
  { match: "#FirstName #Acronym #Noun", tag: "Person", reason: "n-acro-noun", safe: true },
  //Anthony de Marco
  { match: "#FirstName [(de|di|du|van|von)] #Person", group: 0, tag: "LastName", reason: "de-firstname" },
  // baker jenna smith
  // { match: '[#Actor+] #Person', group: 0, tag: 'Person', reason: 'baker-sam-smith' },
  // sergeant major Harold
  {
    match: "[(lieutenant|corporal|sergeant|captain|qeen|king|admiral|major|colonel|marshal|president|queen|king)+] #ProperNoun",
    group: 0,
    tag: "Honorific",
    reason: "seargeant-john"
  },
  // ==== Honorics ====
  {
    match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person",
    group: 0,
    tag: ["Honorific", "Person"],
    reason: "ambg-honorifics"
  },
  // dr john foobar
  {
    match: "#Honorific #FirstName [#Singular]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "dr-john-foo",
    safe: true
  },
  //his-excellency
  {
    match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person",
    group: 0,
    tag: "Honorific",
    reason: "his-excellency"
  },
  // Lieutenant colonel
  { match: "#Honorific #Actor", tag: "Honorific", reason: "Lieutenant colonel" },
  // first lady, second admiral
  { match: "(first|second|third|1st|2nd|3rd) #Actor", tag: "Honorific", reason: "first lady" },
  // Louis IV
  { match: "#Person #RomanNumeral", tag: "Person", reason: "louis-IV" }
];

// node_modules/compromise/src/2-two/postTagger/model/person/ambig-name.js
var ambig_name_default = [
  // ebenezer scrooge
  {
    match: "#FirstName #Noun$",
    tag: ". #LastName",
    notIf: "(#Possessive|#Organization|#Place|#Pronoun|@hasTitleCase)",
    reason: "firstname-noun"
  },
  // ===person-date===
  { match: "%Person|Date% #Acronym? #ProperNoun", tag: "Person", reason: "jan-thierson" },
  // ===person-noun===
  //Cliff Clavin
  { match: "%Person|Noun% #Acronym? #ProperNoun", tag: "Person", reason: "switch-person", safe: true },
  // olive garden
  { match: "%Person|Noun% #Organization", tag: "Organization", reason: "olive-garden" },
  // ===person-verb===
  // ollie faroo
  { match: "%Person|Verb% #Acronym? #ProperNoun", tag: "Person", reason: "verb-propernoun", ifNo: "#Actor" },
  // chuck will ...
  {
    match: `[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)`,
    group: 0,
    tag: "Person",
    reason: "person-said"
  },
  // ===person-place===
  //sydney harbour
  {
    match: `[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)`,
    group: 0,
    tag: "Place",
    reason: "sydney-harbour"
  },
  // east sydney
  { match: `(west|east|north|south) [%Person|Place%]`, group: 0, tag: "Place", reason: "east-sydney" },
  // ===person-adjective===
  // rusty smith
  // { match: `${personAdj} #Person`, tag: 'Person', reason: 'randy-smith' },
  // rusty a. smith
  // { match: `${personAdj} #Acronym? #ProperNoun`, tag: 'Person', reason: 'rusty-smith' },
  // very rusty
  // { match: `#Adverb [${personAdj}]`, group: 0, tag: 'Adjective', reason: 'really-rich' },
  // ===person-verb===
  // would wade
  { match: `#Modal [%Person|Verb%]`, group: 0, tag: "Verb", reason: "would-mark" },
  // really wade
  { match: `#Adverb [%Person|Verb%]`, group: 0, tag: "Verb", reason: "really-mark" },
  // drew closer
  { match: `[%Person|Verb%] (#Adverb|#Comparative)`, group: 0, tag: "Verb", reason: "drew-closer" },
  // wade smith
  { match: `%Person|Verb% #Person`, tag: "Person", reason: "rob-smith" },
  // wade m. Cooper
  { match: `%Person|Verb% #Acronym #ProperNoun`, tag: "Person", reason: "rob-a-smith" },
  // will go
  { match: "[will] #Verb", group: 0, tag: "Modal", reason: "will-verb" },
  // will Pharell
  { match: "(will && @isTitleCase) #ProperNoun", tag: "Person", reason: "will-name" },
  // jack layton won
  {
    match: "(#FirstName && !#Possessive) [#Singular] #Verb",
    group: 0,
    safe: true,
    tag: "LastName",
    reason: "jack-layton"
  },
  // sherwood anderson told
  { match: "^[#Singular] #Person #Verb", group: 0, safe: true, tag: "Person", reason: "sherwood-anderson" },
  // bought a warhol
  { match: "(a|an) [#Person]$", group: 0, unTag: "Person", reason: "a-warhol" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/verbs.js
var verbs_default3 = [
  //sometimes adverbs - 'pretty good','well above'
  {
    match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
    tag: "#Copula #Adverb #Adjective",
    reason: "sometimes-adverb"
  },
  //i better ..
  { match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense", group: 0, tag: "Modal", reason: "i-better" },
  // adj -> gerund
  // like
  { match: "(#Modal|i|they|we|do) not? [like]", group: 0, tag: "PresentTense", reason: "modal-like" },
  // ==== Tense ====
  //he left
  { match: "#Noun #Adverb? [left]", group: 0, tag: "PastTense", reason: "left-verb" },
  // ==== Copula ====
  //will be running (not copula)
  { match: "will #Adverb? not? #Adverb? [be] #Gerund", group: 0, tag: "Copula", reason: "will-be-copula" },
  //for more complex forms, just tag 'be'
  { match: "will #Adverb? not? #Adverb? [be] #Adjective", group: 0, tag: "Copula", reason: "be-copula" },
  // ==== Infinitive ====
  //march to
  { match: "[march] (up|down|back|toward)", notIf: "#Date", group: 0, tag: "Infinitive", reason: "march-to" },
  //must march
  { match: "#Modal [march]", group: 0, tag: "Infinitive", reason: "must-march" },
  // may be
  { match: `[may] be`, group: 0, tag: "Verb", reason: "may-be" },
  // subject to
  { match: `[(subject|subjects|subjected)] to`, group: 0, tag: "Verb", reason: "subject to" },
  // subject to
  { match: `[home] to`, group: 0, tag: "PresentTense", reason: "home to" },
  // === misc==
  // side with
  // { match: '[(side|fool|monkey)] with', group: 0, tag: 'Infinitive', reason: 'fool-with' },
  // open the door
  { match: "[open] #Determiner", group: 0, tag: "Infinitive", reason: "open-the" },
  //were being run
  { match: `(were|was) being [#PresentTense]`, group: 0, tag: "PastTense", reason: "was-being" },
  //had been broken
  { match: `(had|has|have) [been /en$/]`, group: 0, tag: "Auxiliary Participle", reason: "had-been-broken" },
  //had been smoked
  { match: `(had|has|have) [been /ed$/]`, group: 0, tag: "Auxiliary PastTense", reason: "had-been-smoked" },
  //were being run
  { match: `(had|has) #Adverb? [been] #Adverb? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-been-adj" },
  //had to walk
  { match: `(had|has) to [#Noun] (#Determiner|#Possessive)`, group: 0, tag: "Infinitive", reason: "had-to-noun" },
  // have read
  { match: `have [#PresentTense]`, group: 0, tag: "PastTense", notIf: "(come|gotten)", reason: "have-read" },
  // does that work
  { match: `(does|will|#Modal) that [work]`, group: 0, tag: "PastTense", reason: "does-that-work" },
  // sounds fun
  { match: `[(sound|sounds)] #Adjective`, group: 0, tag: "PresentTense", reason: "sounds-fun" },
  // look good
  { match: `[(look|looks)] #Adjective`, group: 0, tag: "PresentTense", reason: "looks-good" },
  // stops thinking
  { match: `[(start|starts|stop|stops|begin|begins)] #Gerund`, group: 0, tag: "Verb", reason: "starts-thinking" },
  // have read
  { match: `(have|had) read`, tag: "Modal #PastTense", reason: "read-read" },
  //were under cooked
  {
    match: `(is|was|were) [(under|over) #PastTense]`,
    group: 0,
    tag: "Adverb Adjective",
    reason: "was-under-cooked"
  },
  // damn them
  { match: "[shit] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear1-verb" },
  { match: "[damn] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear2-verb" },
  { match: "[fuck] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear3-verb" },
  // jobs that fit
  { match: "#Plural that %Noun|Verb%", tag: ". #Preposition #Infinitive", reason: "jobs-that-work" },
  // works for me
  { match: "[works] for me", group: 0, tag: "PresentTense", reason: "works-for-me" },
  // as we please
  { match: "as #Pronoun [please]", group: 0, tag: "Infinitive", reason: "as-we-please" },
  // verb-prefixes - 'co write'
  { match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb", group: 0, tag: ["Verb", "Prefix"], notIf: "(#Copula|#PhrasalVerb)", reason: "co-write" },
  // dressed and left
  { match: "#PastTense and [%Adj|Past%]", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // melted and fallen
  { match: "[%Adj|Past%] and #PastTense", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // is he stoked
  { match: "#Copula #Pronoun [%Adj|Past%]", group: 0, tag: "Adjective", reason: "is-he-stoked" },
  // to dream of
  { match: "to [%Noun|Verb%] #Preposition", group: 0, tag: "Infinitive", reason: "to-dream-of" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/auxiliary.js
var auxiliary_default = [
  // ==== Auxiliary ====
  // have been
  { match: `will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "will-have-vb" },
  //was walking
  { match: `[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)`, group: 0, tag: "Auxiliary", reason: "copula-walking" },
  //would walk
  { match: `[(#Modal|did)+] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "modal-verb" },
  //would have had
  { match: `#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-have" },
  //support a splattering of auxillaries before a verb
  { match: `[(has|had)] (#Adverb|not)+? #PastTense`, group: 0, tag: "Auxiliary", reason: "had-walked" },
  // will walk
  { match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb", group: 0, tag: "Auxiliary", reason: "have-had" },
  // about to go
  { match: "[about to] #Adverb? #Verb", group: 0, tag: ["Auxiliary", "Verb"], reason: "about-to" },
  //would be walking
  { match: `#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "would-be" },
  //had been walking
  { match: `[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb`, group: 0, tag: "Auxiliary", reason: "had-been" },
  // was being driven
  { match: "[(be|being|been)] #Participle", group: 0, tag: "Auxiliary", reason: "being-driven" },
  // may want
  { match: "[may] #Adverb? #Infinitive", group: 0, tag: "Auxiliary", reason: "may-want" },
  // was being walked
  { match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense", group: 0, tag: "Auxiliary", reason: "being-walked" },
  // will be walked
  { match: "will [be] #PastTense", group: 0, tag: "Auxiliary", reason: "will-be-x" },
  // been walking
  { match: "[(be|been)] (#Adverb|not)+? #Gerund", group: 0, tag: "Auxiliary", reason: "been-walking" },
  // used to walk
  { match: "[used to] #PresentTense", group: 0, tag: "Auxiliary", reason: "used-to-walk" },
  // was going to walk
  { match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense", group: 0, tag: "Auxiliary", reason: "going-to-walk" },
  // tell me
  { match: "#Imperative [(me|him|her)]", group: 0, tag: "Reflexive", reason: "tell-him" },
  // there is no x
  { match: "(is|was) #Adverb? [no]", group: 0, tag: "Negative", reason: "is-no" },
  // been told
  { match: "[(been|had|became|came)] #PastTense", group: 0, notIf: "#PhrasalVerb", tag: "Auxiliary", reason: "been-told" },
  // being born
  { match: "[(being|having|getting)] #Verb", group: 0, tag: "Auxiliary", reason: "being-born" },
  // be walking
  { match: "[be] #Gerund", group: 0, tag: "Auxiliary", reason: "be-walking" },
  // better go
  { match: "[better] #PresentTense", group: 0, tag: "Modal", notIf: "(#Copula|#Gerund)", reason: "better-go" },
  // even better
  { match: "even better", tag: "Adverb #Comparative", reason: "even-better" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/phrasal.js
var phrasal_default = [
  // ==== Phrasal ====
  //'foo-up'
  { match: "(#Verb && @hasHyphen) up", tag: "PhrasalVerb", reason: "foo-up" },
  { match: "(#Verb && @hasHyphen) off", tag: "PhrasalVerb", reason: "foo-off" },
  { match: "(#Verb && @hasHyphen) over", tag: "PhrasalVerb", reason: "foo-over" },
  { match: "(#Verb && @hasHyphen) out", tag: "PhrasalVerb", reason: "foo-out" },
  // walk in on
  {
    match: "[#Verb (in|out|up|down|off|back)] (on|in)",
    notIf: "#Copula",
    tag: "PhrasalVerb Particle",
    reason: "walk-in-on"
  },
  // went on for
  { match: "(lived|went|crept|go) [on] for", group: 0, tag: "PhrasalVerb", reason: "went-on" },
  // the curtains come down
  { match: "#Verb (up|down|in|on|for)$", tag: "PhrasalVerb #Particle", notIf: "#PhrasalVerb", reason: "come-down$" },
  // got me thinking
  // { match: '(got|had) me [#Noun]', group: 0, tag: 'Verb', reason: 'got-me-gerund' },
  // help stop
  { match: "help [(stop|end|make|start)]", group: 0, tag: "Infinitive", reason: "help-stop" },
  // work in the office
  { match: "#PhrasalVerb (in && #Particle) #Determiner", tag: "#Verb #Preposition #Determiner", unTag: "PhrasalVerb", reason: "work-in-the" },
  // start listening
  { match: "[(stop|start|finish|help)] #Gerund", group: 0, tag: "Infinitive", reason: "start-listening" },
  // mis-fired
  // { match: '[(mis)] #Verb', group: 0, tag: 'Verb', reason: 'mis-firedsa' },
  //back it up
  {
    match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
    group: 0,
    tag: "Adverb",
    reason: "phrasal-pronoun-advb"
  }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/imperative.js
var notIf2 = "(i|we|they)";
var imperative_default2 = [
  // do not go
  { match: "^do not? [#Infinitive #Particle?]", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-eat" },
  // please go
  { match: "^please do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "please-go" },
  // just go
  { match: "^just do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "just-go" },
  // do it better
  { match: "^[#Infinitive] it #Comparative", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-better" },
  // do it again
  { match: "^[#Infinitive] it (please|now|again|plz)", notIf: notIf2, group: 0, tag: "Imperative", reason: "do-it-please" },
  // go quickly.
  { match: "^[#Infinitive] (#Adjective|#Adverb)$", group: 0, tag: "Imperative", notIf: "(so|such|rather|enough)", reason: "go-quickly" },
  // turn down the noise
  { match: "^[#Infinitive] (up|down|over) #Determiner", group: 0, tag: "Imperative", reason: "turn-down" },
  // eat my shorts
  { match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)", group: 0, notIf: "like", tag: "Imperative", reason: "eat-my-shorts" },
  // tell him the story
  { match: "^[#Infinitive] (him|her|it|us|me|there)", group: 0, tag: "Imperative", reason: "tell-him" },
  // avoid loud noises
  { match: "^[#Infinitive] #Adjective #Noun$", group: 0, tag: "Imperative", reason: "avoid-loud-noises" },
  // call and reserve
  { match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive", group: 0, tag: "Imperative", reason: "call-and-reserve" },
  // one-word imperatives
  { match: "^(go|stop|wait|hurry) please?$", tag: "Imperative", reason: "go" },
  // somebody call
  { match: "^(somebody|everybody) [#Infinitive]", group: 0, tag: "Imperative", reason: "somebody-call" },
  // let's leave
  { match: "^let (us|me) [#Infinitive]", group: 0, tag: "Imperative", reason: "lets-leave" },
  // shut the door
  { match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun", group: 0, tag: "Imperative", reason: "shut-the-door" },
  // turn off the light
  { match: "^[#PhrasalVerb #Particle] #Determiner #Noun", group: 0, tag: "Imperative", reason: "turn-off-the-light" },
  // go to toronto
  { match: "^[go] to .", group: 0, tag: "Imperative", reason: "go-to-toronto" },
  // would you recommend
  { match: "^#Modal you [#Infinitive]", group: 0, tag: "Imperative", reason: "would-you-" },
  // never say
  { match: "^never [#Infinitive]", group: 0, tag: "Imperative", reason: "never-stop" },
  // come have a drink
  { match: "^come #Infinitive", tag: "Imperative", notIf: "on", reason: "come-have" },
  // come and have a drink
  { match: "^come and? #Infinitive", tag: "Imperative . Imperative", notIf: "#PhrasalVerb", reason: "come-and-have" },
  // stay away
  { match: "^stay (out|away|back)", tag: "Imperative", reason: "stay-away" },
  // stay cool
  { match: "^[(stay|be|keep)] #Adjective", group: 0, tag: "Imperative", reason: "stay-cool" },
  // keep it silent
  { match: "^[keep it] #Adjective", group: 0, tag: "Imperative", reason: "keep-it-cool" },
  // don't be late
  { match: "^do not [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-be" },
  // allow yourself
  { match: "[#Infinitive] (yourself|yourselves)", group: 0, tag: "Imperative", reason: "allow-yourself" },
  // look what
  { match: "[#Infinitive] what .", group: 0, tag: "Imperative", reason: "look-what" },
  // continue playing
  { match: "^[#Infinitive] #Gerund", group: 0, tag: "Imperative", reason: "keep-playing" },
  // go to it
  { match: "^[#Infinitive] (to|for|into|toward|here|there)", group: 0, tag: "Imperative", reason: "go-to" },
  // relax and unwind
  { match: "^[#Infinitive] (and|or) #Infinitive", group: 0, tag: "Imperative", reason: "inf-and-inf" },
  // commit to
  { match: "^[%Noun|Verb%] to", group: 0, tag: "Imperative", reason: "commit-to" },
  // maintain eye contact
  { match: "^[#Infinitive] #Adjective? #Singular #Singular", group: 0, tag: "Imperative", reason: "maintain-eye-contact" },
  // don't forget to clean
  { match: "do not (forget|omit|neglect) to [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-forget" },
  // pay attention
  { match: "^[(ask|wear|pay|look|help|show|watch|act|fix|kill|stop|start|turn|try|win)] #Noun", group: 0, tag: "Imperative", reason: "pay-attention" }
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/adj-gerund.js
var adj_gerund_default3 = [
  // that were growing
  { match: "(that|which) were [%Adj|Gerund%]", group: 0, tag: "Gerund", reason: "that-were-growing" },
  // was dissapointing
  // { match: '#Copula [%Adj|Gerund%]$', group: 0, tag: 'Adjective', reason: 'was-disappointing$' },
  // repairing crubling roads
  { match: "#Gerund [#Gerund] #Plural", group: 0, tag: "Adjective", reason: "hard-working-fam" }
  // { match: '(that|which) were [%Adj|Gerund%]', group: 0, tag: 'Gerund', reason: 'that-were-growing' },
];

// node_modules/compromise/src/2-two/postTagger/model/verbs/passive.js
var passive_default = [
  // got walked, was walked, were walked
  { match: "(got|were|was|is|are|am) (#PastTense|#Participle)", tag: "Passive", reason: "got-walked" },
  // was being walked
  { match: "(was|were|is|are|am) being (#PastTense|#Participle)", tag: "Passive", reason: "was-being" },
  // had been walked, have been eaten
  { match: "(had|have|has) been (#PastTense|#Participle)", tag: "Passive", reason: "had-been" },
  // will be cleaned
  { match: "will be being? (#PastTense|#Participle)", tag: "Passive", reason: "will-be-cleaned" },
  // suffered by the country
  { match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun", group: 0, tag: "Passive", reason: "suffered-by" }
];

// node_modules/compromise/src/2-two/postTagger/model/_misc.js
var matches = [
  // u r cool
  { match: "u r", tag: "#Pronoun #Copula", reason: "u r" },
  { match: "#Noun [(who|whom)]", group: 0, tag: "Determiner", reason: "captain-who" },
  // ==== Conditions ====
  // had he survived,
  { match: "[had] #Noun+ #PastTense", group: 0, tag: "Condition", reason: "had-he" },
  // were he to survive
  { match: "[were] #Noun+ to #Infinitive", group: 0, tag: "Condition", reason: "were-he" },
  // some sort of
  { match: "some sort of", tag: "Adjective Noun Conjunction", reason: "some-sort-of" },
  // some of
  // { match: 'some of', tag: 'Noun Conjunction', reason: 'some-of' },
  // of some sort
  { match: "of some sort", tag: "Conjunction Adjective Noun", reason: "of-some-sort" },
  // such skill
  { match: "[such] (a|an|is)? #Noun", group: 0, tag: "Determiner", reason: "such-skill" },
  // another one
  // { match: '[another] (#Noun|#Value)', group: 0, tag: 'Adjective', reason: 'another-one' },
  // right after
  { match: "[right] (before|after|in|into|to|toward)", group: 0, tag: "#Adverb", reason: "right-into" },
  // at about
  { match: "#Preposition [about]", group: 0, tag: "Adjective", reason: "at-about" },
  // are ya
  { match: "(are|#Modal|see|do|for) [ya]", group: 0, tag: "Pronoun", reason: "are-ya" },
  // long live
  { match: "[long live] .", group: 0, tag: "#Adjective #Infinitive", reason: "long-live" },
  // plenty of
  { match: "[plenty] of", group: 0, tag: "#Uncountable", reason: "plenty-of" },
  // 'there' as adjective
  { match: "(always|nearly|barely|practically) [there]", group: 0, tag: "Adjective", reason: "always-there" },
  // existential 'there'
  // there she is
  { match: "[there] (#Adverb|#Pronoun)? #Copula", group: 0, tag: "There", reason: "there-is" },
  // is there food
  { match: "#Copula [there] .", group: 0, tag: "There", reason: "is-there" },
  // should there
  { match: "#Modal #Adverb? [there]", group: 0, tag: "There", reason: "should-there" },
  // do you
  { match: "^[do] (you|we|they)", group: 0, tag: "QuestionWord", reason: "do-you" },
  // does he
  { match: "^[does] (he|she|it|#ProperNoun)", group: 0, tag: "QuestionWord", reason: "does-he" },
  // the person who
  { match: "#Determiner #Noun+ [who] #Verb", group: 0, tag: "Preposition", reason: "the-x-who" },
  // the person which
  { match: "#Determiner #Noun+ [which] #Verb", group: 0, tag: "Preposition", reason: "the-x-which" },
  // a while
  { match: "a [while]", group: 0, tag: "Noun", reason: "a-while" },
  // guess who
  { match: "guess who", tag: "#Infinitive #QuestionWord", reason: "guess-who" },
  // swear words
  { match: "[fucking] !#Verb", group: 0, tag: "#Gerund", reason: "f-as-gerund" }
];
var misc_default4 = matches;

// node_modules/compromise/src/2-two/postTagger/model/nouns/organizations.js
var organizations_default2 = [
  // Foo University
  // { match: `#Noun ${orgMap}`, tag: 'Organization', safe: true, reason: 'foo-university' },
  // // University of Toronto
  // { match: `${orgMap} of #Place`, tag: 'Organization', safe: true, reason: 'university-of-foo' },
  // // foo regional health authority
  // { match: `${orgMap} (health|local|regional)+ authority`, tag: 'Organization', reason: 'regional-health' },
  // // foo stock exchange
  // { match: `${orgMap} (stock|mergantile)+ exchange`, tag: 'Organization', reason: 'stock-exchange' },
  // // foo news service
  // { match: `${orgMap} (daily|evening|local)+ news service?`, tag: 'Organization', reason: 'foo-news' },
  //University of Foo
  { match: "university of #Place", tag: "Organization", reason: "university-of-Foo" },
  //John & Joe's
  { match: "#Noun (&|n) #Noun", tag: "Organization", reason: "Noun-&-Noun" },
  // teachers union of Ontario
  { match: "#Organization of the? #ProperNoun", tag: "Organization", reason: "org-of-place", safe: true },
  //walmart USA
  { match: "#Organization #Country", tag: "Organization", reason: "org-country" },
  //organization
  { match: "#ProperNoun #Organization", tag: "Organization", notIf: "#FirstName", reason: "titlecase-org" },
  //FitBit Inc
  { match: "#ProperNoun (ltd|co|inc|dept|assn|bros)", tag: "Organization", reason: "org-abbrv" },
  // the OCED
  { match: "the [#Acronym]", group: 0, tag: "Organization", reason: "the-acronym", safe: true },
  // government of india
  { match: "government of the? [#Place+]", tag: "Organization", reason: "government-of-x" },
  // school board
  { match: "(health|school|commerce) board", tag: "Organization", reason: "school-board" },
  // special comittee
  {
    match: "(nominating|special|conference|executive|steering|central|congressional) committee",
    tag: "Organization",
    reason: "special-comittee"
  },
  // global trade union
  {
    match: "(world|global|international|national|#Demonym) #Organization",
    tag: "Organization",
    reason: "global-org"
  },
  // schools
  { match: "#Noun+ (public|private) school", tag: "School", reason: "noun-public-school" },
  // new york yankees
  { match: "#Place+ #SportsTeam", tag: "SportsTeam", reason: "place-sportsteam" },
  // 'manchester united'
  {
    match: "(dc|atlanta|minnesota|manchester|newcastle|sheffield) united",
    tag: "SportsTeam",
    reason: "united-sportsteam"
  },
  // 'toronto fc'
  { match: "#Place+ fc", tag: "SportsTeam", reason: "fc-sportsteam" }
];

// node_modules/compromise/src/2-two/postTagger/model/nouns/places.js
var places_default2 = [
  // ==== Region ====
  // West Norforlk
  { match: "(west|north|south|east|western|northern|southern|eastern)+ #Place", tag: "Region", reason: "west-norfolk" },
  //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
  {
    match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]",
    group: 0,
    tag: "Region",
    reason: "us-state"
  },
  // portland oregon
  { match: "portland [or]", group: 0, tag: "Region", reason: "portland-or" },
  //words removed from preTagger/placeWords
  {
    match: "#ProperNoun+ (cliff|place|range|pit|place|point|room|grounds|ruins)",
    tag: "Place",
    reason: "foo-point"
  },
  // in Foo California
  { match: "in [#ProperNoun] #Place", group: 0, tag: "Place", reason: "propernoun-place" },
  // Address
  {
    match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)",
    tag: "Address",
    reason: "address-st"
  }
  // Sports Arenas and Complexs
  // {
  //   match:
  //     '(#Place+|#Place|#ProperNoun) (memorial|athletic|community|financial)? (sportsplex|stadium|sports centre|sports field|soccer complex|soccer centre|sports complex|civic centre|centre|arena|gardens|complex|coliseum|auditorium|place|building)',
  //   tag: 'Place',
  //   reason: 'sport-complex',
  // },
];

// node_modules/compromise/src/2-two/postTagger/model/conjunctions.js
var conjunctions_default = [
  // ==== Conjunctions ====
  { match: "[so] #Noun", group: 0, tag: "Conjunction", reason: "so-conj" },
  //how he is driving
  {
    match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
    group: 0,
    tag: "Conjunction",
    reason: "how-he-is-x"
  },
  // when he
  { match: "#Copula [(who|what|where|why|how|when)] #Noun", group: 0, tag: "Conjunction", reason: "when-he" },
  // says that he..
  { match: "#Verb [that] #Pronoun", group: 0, tag: "Conjunction", reason: "said-that-he" },
  // things that are required
  { match: "#Noun [that] #Copula", group: 0, tag: "Conjunction", reason: "that-are" },
  // things that seem cool
  { match: "#Noun [that] #Verb #Adjective", group: 0, tag: "Conjunction", reason: "that-seem" },
  // wasn't that wide..
  { match: "#Noun #Copula not? [that] #Adjective", group: 0, tag: "Adverb", reason: "that-adj" },
  // ==== Prepositions ====
  //all students
  { match: "#Verb #Adverb? #Noun [(that|which)]", group: 0, tag: "Preposition", reason: "that-prep" },
  //work, which has been done.
  { match: "@hasComma [which] (#Pronoun|#Verb)", group: 0, tag: "Preposition", reason: "which-copula" },
  //folks like her
  { match: "#Noun [like] #Noun", group: 0, tag: "Preposition", reason: "noun-like" },
  //like the time
  { match: "^[like] #Determiner", group: 0, tag: "Preposition", reason: "like-the" },
  //a day like this
  { match: "a #Noun [like] (#Noun|#Determiner)", group: 0, tag: "Preposition", reason: "a-noun-like" },
  // really like
  { match: "#Adverb [like]", group: 0, tag: "Verb", reason: "really-like" },
  // nothing like
  { match: "(not|nothing|never) [like]", group: 0, tag: "Preposition", reason: "nothing-like" },
  // treat them like
  { match: "#Infinitive #Pronoun [like]", group: 0, tag: "Preposition", reason: "treat-them-like" },
  // ==== Questions ====
  // where
  // why
  // when
  // who
  // whom
  // whose
  // what
  // which
  //the word 'how many'
  // { match: '^(how|which)', tag: 'QuestionWord', reason: 'how-question' },
  // how-he, when the
  { match: "[#QuestionWord] (#Pronoun|#Determiner)", group: 0, tag: "Preposition", reason: "how-he" },
  // when stolen
  { match: "[#QuestionWord] #Participle", group: 0, tag: "Preposition", reason: "when-stolen" },
  // how is
  { match: "[how] (#Determiner|#Copula|#Modal|#PastTense)", group: 0, tag: "QuestionWord", reason: "how-is" },
  // children who dance
  { match: "#Plural [(who|which|when)] .", group: 0, tag: "Preposition", reason: "people-who" }
];

// node_modules/compromise/src/2-two/postTagger/model/expressions.js
var expressions_default = [
  //swear-words as non-expression POS
  { match: "holy (shit|fuck|hell)", tag: "Expression", reason: "swears-expression" },
  // well..
  { match: "^[(well|so|okay|now)] !#Adjective?", group: 0, tag: "Expression", reason: "well-" },
  // well..
  { match: "^come on", tag: "Expression", reason: "come-on" },
  // sorry
  { match: "(say|says|said) [sorry]", group: 0, tag: "Expression", reason: "say-sorry" },
  // ok,
  { match: "^(ok|alright|shoot|hell|anyways)", tag: "Expression", reason: "ok-" },
  // c'mon marge..
  // { match: '^[come on] #Noun', group: 0, tag: 'Expression', reason: 'come-on' },
  // say,
  { match: "^(say && @hasComma)", tag: "Expression", reason: "say-" },
  { match: "^(like && @hasComma)", tag: "Expression", reason: "like-" },
  // dude we should
  { match: "^[(dude|man|girl)] #Pronoun", group: 0, tag: "Expression", reason: "dude-i" }
];

// node_modules/compromise/src/2-two/postTagger/model/index.js
var matches2 = [].concat(
  // order matters top-matches can get overwritten
  passive_default,
  adjective_default,
  adj_adverb_default,
  adj_gerund_default2,
  adj_noun_default2,
  adverb_default,
  date_default,
  date_phrase_default,
  nouns_default4,
  noun_gerund_default2,
  verb_noun_default,
  money_default,
  fractions_default,
  numbers_default,
  person_phrase_default,
  ambig_name_default,
  verbs_default3,
  adj_verb_default,
  auxiliary_default,
  phrasal_default,
  imperative_default2,
  adj_gerund_default3,
  misc_default4,
  organizations_default2,
  places_default2,
  conjunctions_default,
  expressions_default
);
var model_default4 = {
  two: {
    matches: matches2
  }
};

// node_modules/compromise/src/2-two/postTagger/compute/index.js
var net = null;
var postTagger = function(view) {
  const { world: world2 } = view;
  const { model: model5, methods: methods17 } = world2;
  net = net || methods17.one.buildNet(model5.two.matches, world2);
  let document2 = methods17.two.quickSplit(view.document);
  let ptrs = document2.map((terms) => {
    let t5 = terms[0];
    return [t5.index[0], t5.index[1], t5.index[1] + terms.length];
  });
  let m6 = view.update(ptrs);
  m6.cache();
  m6.sweep(net);
  view.uncache();
  view.unfreeze();
  return view;
};
var tagger2 = (view) => view.compute(["lexicon", "preTagger", "postTagger"]);
var compute_default10 = { postTagger, tagger: tagger2 };

// node_modules/compromise/src/2-two/postTagger/api.js
var round = (n5) => Math.round(n5 * 100) / 100;
function api_default11(View2) {
  View2.prototype.confidence = function() {
    let sum = 0;
    let count = 0;
    this.docs.forEach((terms) => {
      terms.forEach((term) => {
        count += 1;
        sum += term.confidence || 1;
      });
    });
    if (count === 0) {
      return 1;
    }
    return round(sum / count);
  };
  View2.prototype.tagger = function() {
    return this.compute(["tagger"]);
  };
}

// node_modules/compromise/src/2-two/postTagger/plugin.js
var plugin2 = {
  api: api_default11,
  compute: compute_default10,
  model: model_default4,
  hooks: ["postTagger"]
};
var plugin_default16 = plugin2;

// node_modules/compromise/src/2-two/lazy/maybeMatch.js
var getWords = function(net3) {
  return Object.keys(net3.hooks).filter((w2) => !w2.startsWith("#") && !w2.startsWith("%"));
};
var maybeMatch = function(doc, net3) {
  let words = getWords(net3);
  if (words.length === 0) {
    return doc;
  }
  if (!doc._cache) {
    doc.cache();
  }
  let cache3 = doc._cache;
  return doc.filter((_m, i5) => {
    return words.some((str) => cache3[i5].has(str));
  });
};
var maybeMatch_default = maybeMatch;

// node_modules/compromise/src/2-two/lazy/lazyParse.js
var lazyParse = function(input, reg) {
  let net3 = reg;
  if (typeof reg === "string") {
    net3 = this.buildNet([{ match: reg }]);
  }
  let doc = this.tokenize(input);
  let m6 = maybeMatch_default(doc, net3);
  if (m6.found) {
    m6.compute(["index", "tagger"]);
    return m6.match(reg);
  }
  return doc.none();
};
var lazyParse_default = lazyParse;

// node_modules/compromise/src/2-two/lazy/plugin.js
var plugin_default17 = {
  lib: {
    lazy: lazyParse_default
  }
};

// node_modules/compromise/src/2-two/swap/api/swap-verb.js
var matchVerb = function(m6, lemma) {
  const conjugate2 = m6.methods.two.transform.verb.conjugate;
  let all4 = conjugate2(lemma, m6.model);
  if (m6.has("#Gerund")) {
    return all4.Gerund;
  }
  if (m6.has("#PastTense")) {
    return all4.PastTense;
  }
  if (m6.has("#PresentTense")) {
    return all4.PresentTense;
  }
  if (m6.has("#Gerund")) {
    return all4.Gerund;
  }
  return lemma;
};
var swapVerb = function(vb3, lemma) {
  let str = lemma;
  vb3.forEach((m6) => {
    if (!m6.has("#Infinitive")) {
      str = matchVerb(m6, lemma);
    }
    m6.replaceWith(str);
  });
  return vb3;
};
var swap_verb_default = swapVerb;

// node_modules/compromise/src/2-two/swap/api/swap.js
var swapNoun = function(m6, lemma) {
  let str = lemma;
  if (m6.has("#Plural")) {
    const toPlural = m6.methods.two.transform.noun.toPlural;
    str = toPlural(lemma, m6.model);
  }
  m6.replaceWith(str, { possessives: true });
};
var swapAdverb = function(m6, lemma) {
  const { toAdverb: toAdverb2 } = m6.methods.two.transform.adjective;
  let str = lemma;
  let adv = toAdverb2(str);
  if (adv) {
    m6.replaceWith(adv);
  }
};
var swapAdjective = function(m6, lemma) {
  const { toComparative: toComparative3, toSuperlative: toSuperlative3 } = m6.methods.two.transform.adjective;
  let str = lemma;
  if (m6.has("#Comparative")) {
    str = toComparative3(str, m6.model);
  } else if (m6.has("#Superlative")) {
    str = toSuperlative3(str, m6.model);
  }
  if (str) {
    m6.replaceWith(str);
  }
};
var swap = function(from, to, tag2) {
  let reg = from.split(/ /g).map((str) => str.toLowerCase().trim());
  reg = reg.filter((str) => str);
  reg = reg.map((str) => `{${str}}`).join(" ");
  let m6 = this.match(reg);
  if (tag2) {
    m6 = m6.if(tag2);
  }
  if (m6.has("#Verb")) {
    return swap_verb_default(m6, to);
  }
  if (m6.has("#Noun")) {
    return swapNoun(m6, to);
  }
  if (m6.has("#Adverb")) {
    return swapAdverb(m6, to);
  }
  if (m6.has("#Adjective")) {
    return swapAdjective(m6, to);
  }
  return this;
};
var swap_default = swap;

// node_modules/compromise/src/2-two/swap/plugin.js
var api4 = function(View2) {
  View2.prototype.swap = swap_default;
};
var plugin_default18 = {
  api: api4
};

// node_modules/compromise/src/two.js
one_default.plugin(plugin_default14);
one_default.plugin(plugin_default15);
one_default.plugin(plugin_default16);
one_default.plugin(plugin_default17);
one_default.plugin(plugin_default18);
var two_default = one_default;

// node_modules/compromise/src/3-three/adjectives/plugin.js
var toRoot2 = function(adj) {
  const { fromComparative: fromComparative3, fromSuperlative: fromSuperlative3 } = adj.methods.two.transform.adjective;
  let str = adj.text("normal");
  if (adj.has("#Comparative")) {
    return fromComparative3(str, adj.model);
  }
  if (adj.has("#Superlative")) {
    return fromSuperlative3(str, adj.model);
  }
  return str;
};
var api5 = function(View2) {
  class Adjectives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adjectives";
    }
    json(opts2 = {}) {
      const { toAdverb: toAdverb2, toNoun: toNoun2, toSuperlative: toSuperlative3, toComparative: toComparative3 } = this.methods.two.transform.adjective;
      opts2.normal = true;
      return this.map((m6) => {
        let json = m6.toView().json(opts2)[0] || {};
        let str = toRoot2(m6);
        json.adjective = {
          adverb: toAdverb2(str, this.model),
          noun: toNoun2(str, this.model),
          superlative: toSuperlative3(str, this.model),
          comparative: toComparative3(str, this.model)
        };
        return json;
      }, []);
    }
    adverbs() {
      return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
    }
    conjugate(n5) {
      const { toComparative: toComparative3, toSuperlative: toSuperlative3, toNoun: toNoun2, toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n5).map((adj) => {
        let root = toRoot2(adj);
        return {
          Adjective: root,
          Comparative: toComparative3(root, this.model),
          Superlative: toSuperlative3(root, this.model),
          Noun: toNoun2(root, this.model),
          Adverb: toAdverb2(root, this.model)
        };
      }, []);
    }
    toComparative(n5) {
      const { toComparative: toComparative3 } = this.methods.two.transform.adjective;
      return this.getNth(n5).map((adj) => {
        let root = toRoot2(adj);
        let str = toComparative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toSuperlative(n5) {
      const { toSuperlative: toSuperlative3 } = this.methods.two.transform.adjective;
      return this.getNth(n5).map((adj) => {
        let root = toRoot2(adj);
        let str = toSuperlative3(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toAdverb(n5) {
      const { toAdverb: toAdverb2 } = this.methods.two.transform.adjective;
      return this.getNth(n5).map((adj) => {
        let root = toRoot2(adj);
        let str = toAdverb2(root, this.model);
        return adj.replaceWith(str);
      });
    }
    toNoun(n5) {
      const { toNoun: toNoun2 } = this.methods.two.transform.adjective;
      return this.getNth(n5).map((adj) => {
        let root = toRoot2(adj);
        let str = toNoun2(root, this.model);
        return adj.replaceWith(str);
      });
    }
  }
  View2.prototype.adjectives = function(n5) {
    let m6 = this.match("#Adjective");
    m6 = m6.getNth(n5);
    return new Adjectives(m6.document, m6.pointer);
  };
  View2.prototype.superlatives = function(n5) {
    let m6 = this.match("#Superlative");
    m6 = m6.getNth(n5);
    return new Adjectives(m6.document, m6.pointer);
  };
  View2.prototype.comparatives = function(n5) {
    let m6 = this.match("#Comparative");
    m6 = m6.getNth(n5);
    return new Adjectives(m6.document, m6.pointer);
  };
};
var plugin_default19 = { api: api5 };

// node_modules/compromise/src/3-three/adverbs/plugin.js
var toRoot3 = function(adj) {
  let str = adj.compute("root").text("root");
  return str;
};
var api6 = function(View2) {
  class Adverbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Adverbs";
    }
    conjugate(n5) {
      return this.getNth(n5).map((adv) => {
        let adj = toRoot3(adv);
        return {
          Adverb: adv.text("normal"),
          Adjective: adj
        };
      }, []);
    }
    json(opts2 = {}) {
      const fromAdverb = this.methods.two.transform.adjective.fromAdverb;
      opts2.normal = true;
      return this.map((m6) => {
        let json = m6.toView().json(opts2)[0] || {};
        json.adverb = {
          adjective: fromAdverb(json.normal)
        };
        return json;
      }, []);
    }
  }
  View2.prototype.adverbs = function(n5) {
    let m6 = this.match("#Adverb");
    m6 = m6.getNth(n5);
    return new Adverbs(m6.document, m6.pointer);
  };
};
var plugin_default20 = { api: api6 };

// node_modules/compromise/src/3-three/chunker/api/clauses.js
var byComma = function(doc) {
  let commas = doc.match("@hasComma");
  commas = commas.filter((m6) => {
    if (m6.growLeft(".").wordCount() === 1) {
      return false;
    }
    if (m6.growRight(". .").wordCount() === 1) {
      return false;
    }
    let more = m6.grow(".");
    more = more.ifNo("@hasComma @hasComma");
    more = more.ifNo("@hasComma (and|or) .");
    more = more.ifNo("(#City && @hasComma) #Country");
    more = more.ifNo("(#WeekDay && @hasComma) #Date");
    more = more.ifNo("(#Date+ && @hasComma) #Value");
    more = more.ifNo("(#Adjective && @hasComma) #Adjective");
    return more.found;
  });
  return doc.splitAfter(commas);
};
var splitParentheses = function(doc) {
  let matches3 = doc.parentheses();
  matches3 = matches3.filter((m6) => {
    return m6.wordCount() >= 3 && m6.has("#Verb") && m6.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var splitQuotes = function(doc) {
  let matches3 = doc.quotations();
  matches3 = matches3.filter((m6) => {
    return m6.wordCount() >= 3 && m6.has("#Verb") && m6.has("#Noun");
  });
  return doc.splitOn(matches3);
};
var clauses = function(n5) {
  let found = this;
  found = splitParentheses(found);
  found = splitQuotes(found);
  found = byComma(found);
  found = found.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)");
  found = found.splitAfter("^#Pronoun (said|says)");
  found = found.splitBefore("(said|says) #ProperNoun$");
  found = found.splitBefore(". . if .{4}");
  found = found.splitBefore("and while");
  found = found.splitBefore("now that");
  found = found.splitBefore("ever since");
  found = found.splitBefore("(supposing|although)");
  found = found.splitBefore("even (while|if|though)");
  found = found.splitBefore("(whereas|whose)");
  found = found.splitBefore("as (though|if)");
  found = found.splitBefore("(til|until)");
  let m6 = found.match("#Verb .* [but] .* #Verb", 0);
  if (m6.found) {
    found = found.splitBefore(m6);
  }
  let condition = found.if("if .{2,9} then .").match("then");
  found = found.splitBefore(condition);
  if (typeof n5 === "number") {
    found = found.get(n5);
  }
  return found;
};
var clauses_default = clauses;

// node_modules/compromise/src/3-three/chunker/api/chunks.js
var chunks = function(doc) {
  let all4 = [];
  let lastOne = null;
  let m6 = doc.clauses();
  m6.docs.forEach((terms) => {
    terms.forEach((term) => {
      if (!term.chunk || term.chunk !== lastOne) {
        lastOne = term.chunk;
        all4.push([term.index[0], term.index[1], term.index[1] + 1]);
      } else {
        all4[all4.length - 1][2] = term.index[1] + 1;
      }
    });
    lastOne = null;
  });
  let parts = doc.update(all4);
  return parts;
};
var chunks_default2 = chunks;

// node_modules/compromise/src/3-three/chunker/api/api.js
var api7 = function(View2) {
  class Chunks extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Chunks";
    }
    isVerb() {
      return this.filter((c5) => c5.has("<Verb>"));
    }
    isNoun() {
      return this.filter((c5) => c5.has("<Noun>"));
    }
    isAdjective() {
      return this.filter((c5) => c5.has("<Adjective>"));
    }
    isPivot() {
      return this.filter((c5) => c5.has("<Pivot>"));
    }
    // chunk-friendly debug
    debug() {
      this.toView().debug("chunks");
      return this;
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m6 = new Chunks(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  View2.prototype.chunks = function(n5) {
    let m6 = chunks_default2(this);
    m6 = m6.getNth(n5);
    return new Chunks(this.document, m6.pointer);
  };
  View2.prototype.clauses = clauses_default;
};
var api_default12 = api7;

// node_modules/compromise/src/3-three/chunker/compute/01-easy.js
var byWord2 = {
  this: "Noun",
  then: "Pivot"
};
var easyMode = function(document2) {
  for (let n5 = 0; n5 < document2.length; n5 += 1) {
    for (let t5 = 0; t5 < document2[n5].length; t5 += 1) {
      let term = document2[n5][t5];
      if (byWord2.hasOwnProperty(term.normal) === true) {
        term.chunk = byWord2[term.normal];
        continue;
      }
      if (term.tags.has("Verb")) {
        term.chunk = "Verb";
        continue;
      }
      if (term.tags.has("Noun") || term.tags.has("Determiner")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("Value")) {
        term.chunk = "Noun";
        continue;
      }
      if (term.tags.has("QuestionWord")) {
        term.chunk = "Pivot";
        continue;
      }
    }
  }
};
var easy_default = easyMode;

// node_modules/compromise/src/3-three/chunker/compute/02-neighbours.js
var byNeighbour = function(document2) {
  for (let n5 = 0; n5 < document2.length; n5 += 1) {
    for (let t5 = 0; t5 < document2[n5].length; t5 += 1) {
      let term = document2[n5][t5];
      if (term.chunk) {
        continue;
      }
      let onRight = document2[n5][t5 + 1];
      let onLeft = document2[n5][t5 - 1];
      if (term.tags.has("Adjective")) {
        if (onLeft && onLeft.tags.has("Copula")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Determiner")) {
          term.chunk = "Noun";
          continue;
        }
        if (onRight && onRight.tags.has("Noun")) {
          term.chunk = "Noun";
          continue;
        }
        continue;
      }
      if (term.tags.has("Adverb") || term.tags.has("Negative")) {
        if (onLeft && onLeft.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onLeft && onLeft.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
        if (onRight && onRight.tags.has("Adjective")) {
          term.chunk = "Adjective";
          continue;
        }
        if (onRight && onRight.tags.has("Verb")) {
          term.chunk = "Verb";
          continue;
        }
      }
    }
  }
};
var neighbours_default3 = byNeighbour;

// node_modules/compromise/src/3-three/chunker/compute/03-matcher.js
var rules = [
  // === Conjunction ===
  // that the houses
  { match: "[that] #Determiner #Noun", group: 0, chunk: "Pivot" },
  // estimated that
  { match: "#PastTense [that]", group: 0, chunk: "Pivot" },
  // so the
  { match: "[so] #Determiner", group: 0, chunk: "Pivot" },
  // === Adjective ===
  // was really nice
  { match: "#Copula #Adverb+? [#Adjective]", group: 0, chunk: "Adjective" },
  // was nice
  // { match: '#Copula [#Adjective]', group: 0, chunk: 'Adjective' },
  // nice and cool
  { match: "#Adjective and #Adjective", chunk: "Adjective" },
  // really nice
  // { match: '#Adverb+ #Adjective', chunk: 'Adjective' },
  // === Verb ===
  // quickly and suddenly run
  { match: "#Adverb+ and #Adverb #Verb", chunk: "Verb" },
  // sitting near
  { match: "#Gerund #Adjective$", chunk: "Verb" },
  // going to walk
  { match: "#Gerund to #Verb", chunk: "Verb" },
  // come and have a drink
  { match: "#PresentTense and #PresentTense", chunk: "Verb" },
  // really not
  { match: "#Adverb #Negative", chunk: "Verb" },
  // want to see
  { match: "(want|wants|wanted) to #Infinitive", chunk: "Verb" },
  // walk ourselves
  { match: "#Verb #Reflexive", chunk: "Verb" },
  // tell him the story
  // { match: '#PresentTense [#Pronoun] #Determiner', group: 0, chunk: 'Verb' },
  // tries to walk
  { match: "#Verb [to] #Adverb? #Infinitive", group: 0, chunk: "Verb" },
  // upon seeing
  { match: "[#Preposition] #Gerund", group: 0, chunk: "Verb" },
  // ensure that
  { match: "#Infinitive [that] <Noun>", group: 0, chunk: "Verb" },
  // === Noun ===
  // the brown fox
  // { match: '#Determiner #Adjective+ #Noun', chunk: 'Noun' },
  // the fox
  // { match: '(the|this) <Noun>', chunk: 'Noun' },
  // brown fox
  // { match: '#Adjective+ <Noun>', chunk: 'Noun' },
  // --- of ---
  // son of a gun
  { match: "#Noun of #Determiner? #Noun", chunk: "Noun" },
  // 3 beautiful women
  { match: "#Value+ #Adverb? #Adjective", chunk: "Noun" },
  // the last russian tsar
  { match: "the [#Adjective] #Noun", chunk: "Noun" },
  // breakfast in bed
  { match: "#Singular in #Determiner? #Singular", chunk: "Noun" },
  // Some citizens in this Canadian capital
  { match: "#Plural [in] #Determiner? #Noun", group: 0, chunk: "Pivot" },
  // indoor and outdoor seating
  { match: "#Noun and #Determiner? #Noun", notIf: "(#Possessive|#Pronoun)", chunk: "Noun" }
  //  boys and girls
  // { match: '#Plural and #Determiner? #Plural', chunk: 'Noun' },
  // tomatoes and cheese
  // { match: '#Noun and #Determiner? #Noun', notIf: '#Pronoun', chunk: 'Noun' },
  // that is why
  // { match: '[that] (is|was)', group: 0, chunk: 'Noun' },
];
var net2 = null;
var matcher = function(view, _4, world2) {
  const { methods: methods17 } = world2;
  net2 = net2 || methods17.one.buildNet(rules, world2);
  view.sweep(net2);
};
var matcher_default = matcher;

// node_modules/compromise/src/3-three/chunker/compute/04-fallback.js
var setChunk = function(term, chunk) {
  const env2 = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
  if (env2.DEBUG_CHUNKS) {
    let str = (term.normal + "'").padEnd(8);
    console.log(`  | '${str}  \u2192  \x1B[34m${chunk.padEnd(12)}\x1B[0m \x1B[2m -fallback- \x1B[0m`);
  }
  term.chunk = chunk;
};
var fallback = function(document2) {
  for (let n5 = 0; n5 < document2.length; n5 += 1) {
    for (let t5 = 0; t5 < document2[n5].length; t5 += 1) {
      let term = document2[n5][t5];
      if (term.chunk === void 0) {
        if (term.tags.has("Conjunction")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Preposition")) {
          setChunk(term, "Pivot");
        } else if (term.tags.has("Adverb")) {
          setChunk(term, "Verb");
        } else {
          term.chunk = "Noun";
        }
      }
    }
  }
};
var fallback_default2 = fallback;

// node_modules/compromise/src/3-three/chunker/compute/05-fixUp.js
var fixUp = function(docs) {
  let byChunk = [];
  let current = null;
  docs.forEach((terms) => {
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let term = terms[i5];
      if (current && term.chunk === current) {
        byChunk[byChunk.length - 1].terms.push(term);
      } else {
        byChunk.push({ chunk: term.chunk, terms: [term] });
        current = term.chunk;
      }
    }
  });
  byChunk.forEach((c5) => {
    if (c5.chunk === "Verb") {
      const hasVerb = c5.terms.find((t5) => t5.tags.has("Verb"));
      if (!hasVerb) {
        c5.terms.forEach((t5) => t5.chunk = null);
      }
    }
  });
};
var fixUp_default = fixUp;

// node_modules/compromise/src/3-three/chunker/compute/index.js
var findChunks = function(view) {
  const { document: document2, world: world2 } = view;
  easy_default(document2);
  neighbours_default3(document2);
  matcher_default(view, document2, world2);
  fallback_default2(document2, world2);
  fixUp_default(document2, world2);
};
var compute_default11 = { chunks: findChunks };

// node_modules/compromise/src/3-three/chunker/plugin.js
var plugin_default21 = {
  compute: compute_default11,
  api: api_default12,
  hooks: ["chunks"]
};

// node_modules/compromise/src/3-three/misc/acronyms/index.js
var hasPeriod2 = /\./g;
var api8 = function(View2) {
  class Acronyms extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Acronyms";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod2, "");
          term.normal = term.normal.replace(hasPeriod2, "");
        });
      });
      return this;
    }
    addPeriods() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(hasPeriod2, "");
          term.normal = term.normal.replace(hasPeriod2, "");
          term.text = term.text.split("").join(".") + ".";
          term.normal = term.normal.split("").join(".") + ".";
        });
      });
      return this;
    }
  }
  View2.prototype.acronyms = function(n5) {
    let m6 = this.match("#Acronym");
    m6 = m6.getNth(n5);
    return new Acronyms(m6.document, m6.pointer);
  };
};
var acronyms_default2 = api8;

// node_modules/compromise/src/3-three/misc/parentheses/fns.js
var hasOpen2 = /\(/;
var hasClosed2 = /\)/;
var findEnd = function(terms, i5) {
  for (; i5 < terms.length; i5 += 1) {
    if (terms[i5].post && hasClosed2.test(terms[i5].post)) {
      let [, index4] = terms[i5].index;
      index4 = index4 || 0;
      return index4;
    }
  }
  return null;
};
var find2 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let term = terms[i5];
      if (!isOpen && term.pre && hasOpen2.test(term.pre)) {
        let end2 = findEnd(terms, i5);
        if (end2 !== null) {
          let [n5, start2] = terms[i5].index;
          ptrs.push([n5, start2, end2 + 1, terms[i5].id]);
          i5 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip = function(m6) {
  m6.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen2, "");
    let last = terms[terms.length - 1];
    last.post = last.post.replace(hasClosed2, "");
  });
  return m6;
};

// node_modules/compromise/src/3-three/misc/parentheses/index.js
var api9 = function(View2) {
  class Parentheses extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip(this);
    }
  }
  View2.prototype.parentheses = function(n5) {
    let m6 = find2(this);
    m6 = m6.getNth(n5);
    return new Parentheses(m6.document, m6.pointer);
  };
};
var parentheses_default = api9;

// node_modules/compromise/src/3-three/misc/possessives/index.js
var apostropheS2 = /'s$/;
var find3 = function(doc) {
  let m6 = doc.match("#Possessive+");
  if (m6.has("#Person")) {
    m6 = m6.growLeft("#Person+");
  }
  if (m6.has("#Place")) {
    m6 = m6.growLeft("#Place+");
  }
  if (m6.has("#Organization")) {
    m6 = m6.growLeft("#Organization+");
  }
  return m6;
};
var api10 = function(View2) {
  class Possessives extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      this.docs.forEach((terms) => {
        terms.forEach((term) => {
          term.text = term.text.replace(apostropheS2, "");
          term.normal = term.normal.replace(apostropheS2, "");
        });
      });
      return this;
    }
  }
  View2.prototype.possessives = function(n5) {
    let m6 = find3(this);
    m6 = m6.getNth(n5);
    return new Possessives(m6.document, m6.pointer);
  };
};
var possessives_default = api10;

// node_modules/compromise/src/3-three/misc/quotations/fns.js
var pairs2 = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "\uFF02": "\uFF02",
  // 'StraightDoubleQuotesWide'
  "'": "'",
  // 'StraightSingleQuotes'
  "\u201C": "\u201D",
  // 'CommaDoubleQuotes'
  "\u2018": "\u2019",
  // 'CommaSingleQuotes'
  "\u201F": "\u201D",
  // 'CurlyDoubleQuotesReversed'
  "\u201B": "\u2019",
  // 'CurlySingleQuotesReversed'
  "\u201E": "\u201D",
  // 'LowCurlyDoubleQuotes'
  "\u2E42": "\u201D",
  // 'LowCurlyDoubleQuotesReversed'
  "\u201A": "\u2019",
  // 'LowCurlySingleQuotes'
  "\xAB": "\xBB",
  // 'AngleDoubleQuotes' «, »
  "\u2039": "\u203A",
  // 'AngleSingleQuotes'
  // Prime 'non quotation'
  "\u2035": "\u2032",
  // 'PrimeSingleQuotes'
  "\u2036": "\u2033",
  // 'PrimeDoubleQuotes'
  "\u2037": "\u2034",
  // 'PrimeTripleQuotes'
  // Prime 'quotation' variation
  "\u301D": "\u301E",
  // 'PrimeDoubleQuotes'
  "`": "\xB4",
  // 'PrimeSingleQuotes'
  "\u301F": "\u301E"
  // 'LowPrimeDoubleQuotesReversed'
};
var hasOpen3 = RegExp("[" + Object.keys(pairs2).join("") + "]");
var hasClosed3 = RegExp("[" + Object.values(pairs2).join("") + "]");
var findEnd2 = function(terms, i5) {
  const have = terms[i5].pre.match(hasOpen3)[0] || "";
  if (!have || !pairs2[have]) {
    return null;
  }
  const want = pairs2[have];
  for (; i5 < terms.length; i5 += 1) {
    if (terms[i5].post && terms[i5].post.match(want)) {
      return i5;
    }
  }
  return null;
};
var find4 = function(doc) {
  let ptrs = [];
  doc.docs.forEach((terms) => {
    let isOpen = false;
    for (let i5 = 0; i5 < terms.length; i5 += 1) {
      let term = terms[i5];
      if (!isOpen && term.pre && hasOpen3.test(term.pre)) {
        let end2 = findEnd2(terms, i5);
        if (end2 !== null) {
          let [n5, start2] = terms[i5].index;
          ptrs.push([n5, start2, end2 + 1, terms[i5].id]);
          i5 = end2;
        }
      }
    }
  });
  return doc.update(ptrs);
};
var strip2 = function(m6) {
  m6.docs.forEach((terms) => {
    terms[0].pre = terms[0].pre.replace(hasOpen3, "");
    let lastTerm = terms[terms.length - 1];
    lastTerm.post = lastTerm.post.replace(hasClosed3, "");
  });
};

// node_modules/compromise/src/3-three/misc/quotations/index.js
var api11 = function(View2) {
  class Quotations extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Possessives";
    }
    strip() {
      return strip2(this);
    }
  }
  View2.prototype.quotations = function(n5) {
    let m6 = find4(this);
    m6 = m6.getNth(n5);
    return new Quotations(m6.document, m6.pointer);
  };
};
var quotations_default = api11;

// node_modules/compromise/src/3-three/misc/selections/index.js
var phoneNumbers = function(n5) {
  let m6 = this.splitAfter("@hasComma");
  m6 = m6.match("#PhoneNumber+");
  m6 = m6.getNth(n5);
  return m6;
};
var selections = [
  ["hyphenated", "@hasHyphen ."],
  ["hashTags", "#HashTag"],
  ["emails", "#Email"],
  ["emoji", "#Emoji"],
  ["emoticons", "#Emoticon"],
  ["atMentions", "#AtMention"],
  ["urls", "#Url"],
  // ['pronouns', '#Pronoun'],
  ["conjunctions", "#Conjunction"],
  ["prepositions", "#Preposition"],
  ["abbreviations", "#Abbreviation"],
  ["honorifics", "#Honorific"]
];
var aliases2 = [
  ["emojis", "emoji"],
  ["atmentions", "atMentions"]
];
var addMethods = function(View2) {
  selections.forEach((a4) => {
    View2.prototype[a4[0]] = function(n5) {
      let m6 = this.match(a4[1]);
      return typeof n5 === "number" ? m6.get(n5) : m6;
    };
  });
  View2.prototype.phoneNumbers = phoneNumbers;
  aliases2.forEach((a4) => {
    View2.prototype[a4[0]] = View2.prototype[a4[1]];
  });
};
var selections_default = addMethods;

// node_modules/compromise/src/3-three/misc/plugin.js
var plugin_default22 = {
  api: function(View2) {
    acronyms_default2(View2);
    parentheses_default(View2);
    possessives_default(View2);
    quotations_default(View2);
    selections_default(View2);
  }
};

// node_modules/compromise/src/3-three/normalize/methods.js
var termLoop2 = function(view, cb) {
  view.docs.forEach((terms) => {
    terms.forEach(cb);
  });
};
var methods_default10 = {
  // remove titlecasing, uppercase
  "case": (doc) => {
    termLoop2(doc, (term) => {
      term.text = term.text.toLowerCase();
    });
  },
  // visually romanize/anglicize 'Björk' into 'Bjork'.
  "unicode": (doc) => {
    const world2 = doc.world;
    const killUnicode2 = world2.methods.one.killUnicode;
    termLoop2(doc, (term) => term.text = killUnicode2(term.text, world2));
  },
  // remove hyphens, newlines, and force one space between words
  "whitespace": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/\s+/g, " ");
      term.post = term.post.replace(/\s([.,?!:;])/g, "$1");
      term.pre = term.pre.replace(/\s+/g, "");
    });
  },
  // remove commas, semicolons - but keep sentence-ending punctuation
  "punctuation": (doc) => {
    termLoop2(doc, (term) => {
      term.post = term.post.replace(/[–—-]/g, " ");
      term.post = term.post.replace(/[,:;]/g, "");
      term.post = term.post.replace(/\.{2,}/g, "");
      term.post = term.post.replace(/\?{2,}/g, "?");
      term.post = term.post.replace(/!{2,}/g, "!");
      term.post = term.post.replace(/\?!+/g, "?");
    });
    let docs = doc.docs;
    let terms = docs[docs.length - 1];
    if (terms && terms.length > 0) {
      let lastTerm = terms[terms.length - 1];
      lastTerm.post = lastTerm.post.replace(/ /g, "");
    }
  },
  // ====== subsets ===
  // turn "isn't" to "is not"
  "contractions": (doc) => {
    doc.contractions().expand();
  },
  //remove periods from acronyms, like 'F.B.I.'
  "acronyms": (doc) => {
    doc.acronyms().strip();
  },
  //remove words inside brackets (like these)
  "parentheses": (doc) => {
    doc.parentheses().strip();
  },
  // turn "Google's tax return" to "Google tax return"
  "possessives": (doc) => {
    doc.possessives().strip();
  },
  // turn "tax return" to tax return
  "quotations": (doc) => {
    doc.quotations().strip();
  },
  // remove them
  "emoji": (doc) => {
    doc.emojis().remove();
  },
  //turn 'Vice Admiral John Smith' to 'John Smith'
  "honorifics": (doc) => {
    doc.match("#Honorific+ #Person").honorifics().remove();
  },
  // remove needless adverbs
  "adverbs": (doc) => {
    doc.adverbs().remove();
  },
  // turn "batmobiles" into "batmobile"
  "nouns": (doc) => {
    doc.nouns().toSingular();
  },
  // turn all verbs into Infinitive form - "I walked" → "I walk"
  "verbs": (doc) => {
    doc.verbs().toInfinitive();
  },
  // turn "fifty" into "50"
  "numbers": (doc) => {
    doc.numbers().toNumber();
  },
  /** remove bullets from beginning of phrase */
  "debullet": (doc) => {
    const hasBullet = /^\s*([-–—*•])\s*$/;
    doc.docs.forEach((terms) => {
      if (hasBullet.test(terms[0].pre)) {
        terms[0].pre = terms[0].pre.replace(hasBullet, "");
      }
    });
    return doc;
  }
};

// node_modules/compromise/src/3-three/normalize/api.js
var split2 = (str) => {
  return str.split("|").reduce((h4, k3) => {
    h4[k3] = true;
    return h4;
  }, {});
};
var light = "unicode|punctuation|whitespace|acronyms";
var medium = "|case|contractions|parentheses|quotations|emoji|honorifics|debullet";
var heavy = "|possessives|adverbs|nouns|verbs";
var presets = {
  light: split2(light),
  medium: split2(light + medium),
  heavy: split2(light + medium + heavy)
};
function api_default13(View2) {
  View2.prototype.normalize = function(opts2 = "light") {
    if (typeof opts2 === "string") {
      opts2 = presets[opts2];
    }
    Object.keys(opts2).forEach((fn) => {
      if (methods_default10.hasOwnProperty(fn)) {
        methods_default10[fn](this, opts2[fn]);
      }
    });
    return this;
  };
}

// node_modules/compromise/src/3-three/normalize/plugin.js
var plugin_default23 = {
  api: api_default13
};

// node_modules/compromise/src/3-three/nouns/find.js
var findNouns = function(doc) {
  let m6 = doc.clauses().match("<Noun>");
  let commas = m6.match("@hasComma");
  commas = commas.not("#Place");
  if (commas.found) {
    m6 = m6.splitAfter(commas);
  }
  m6 = m6.splitOn("#Expression");
  m6 = m6.splitOn("(he|she|we|you|they|i)");
  m6 = m6.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0);
  m6 = m6.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0);
  m6 = m6.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0);
  m6 = m6.splitOn("[(here|there)] #Noun", 0);
  m6 = m6.splitOn("[#Noun] (here|there)", 0);
  m6 = m6.splitBefore("(our|my|their|your)");
  m6 = m6.splitOn("#Noun [#Determiner]", 0);
  m6 = m6.if("#Noun");
  return m6;
};
var find_default = findNouns;

// node_modules/compromise/src/3-three/nouns/api/isSubordinate.js
var list2 = [
  "after",
  "although",
  "as if",
  "as long as",
  "as",
  "because",
  "before",
  "even if",
  "even though",
  "ever since",
  "if",
  "in order that",
  "provided that",
  "since",
  "so that",
  "than",
  "that",
  "though",
  "unless",
  "until",
  "what",
  "whatever",
  "when",
  "whenever",
  "where",
  "whereas",
  "wherever",
  "whether",
  "which",
  "whichever",
  "who",
  "whoever",
  "whom",
  "whomever",
  "whose"
];
var isSubordinate = function(m6) {
  if (m6.before("#Preposition$").found) {
    return true;
  }
  let leadIn = m6.before();
  if (!leadIn.found) {
    return false;
  }
  for (let i5 = 0; i5 < list2.length; i5 += 1) {
    if (m6.has(list2[i5])) {
      return true;
    }
  }
  return false;
};
var isSubordinate_default = isSubordinate;

// node_modules/compromise/src/3-three/nouns/api/isPlural.js
var notPlural2 = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)";
var isPlural2 = function(m6, root) {
  if (m6.has("#Plural")) {
    return true;
  }
  if (m6.has("#Noun and #Noun")) {
    return true;
  }
  if (m6.has("(we|they)")) {
    return true;
  }
  if (root.has(notPlural2) === true) {
    return false;
  }
  if (m6.has("#Singular")) {
    return false;
  }
  let str = root.text("normal");
  return str.length > 3 && str.endsWith("s") && !str.endsWith("ss");
};
var isPlural_default = isPlural2;

// node_modules/compromise/src/3-three/nouns/api/parse.js
var getRoot2 = function(m6) {
  let tmp = m6.clone();
  tmp = tmp.match("#Noun+");
  tmp = tmp.remove("(#Adjective|#Preposition|#Determiner|#Value)");
  tmp = tmp.not("#Possessive");
  tmp = tmp.first();
  if (!tmp.found) {
    return m6;
  }
  return tmp;
};
var parseNoun = function(m6) {
  let root = getRoot2(m6);
  return {
    determiner: m6.match("#Determiner").eq(0),
    adjectives: m6.match("#Adjective"),
    number: m6.values(),
    isPlural: isPlural_default(m6, root),
    isSubordinate: isSubordinate_default(m6),
    root
  };
};
var parse_default3 = parseNoun;

// node_modules/compromise/src/3-three/nouns/api/toJSON.js
var toText2 = (m6) => m6.text();
var toArray2 = (m6) => m6.json({ terms: false, normal: true }).map((s5) => s5.normal);
var getNum = function(m6) {
  let num = null;
  if (!m6.found) {
    return num;
  }
  let val = m6.values(0);
  if (val.found) {
    let obj = val.parse()[0] || {};
    return obj.num;
  }
  return num;
};
var toJSON2 = function(m6) {
  let res = parse_default3(m6);
  return {
    root: toText2(res.root),
    number: getNum(res.number),
    determiner: toText2(res.determiner),
    adjectives: toArray2(res.adjectives),
    isPlural: res.isPlural,
    isSubordinate: res.isSubordinate
  };
};
var toJSON_default = toJSON2;

// node_modules/compromise/src/3-three/nouns/api/hasPlural.js
var hasPlural = function(root) {
  if (root.has("^(#Uncountable|#ProperNoun|#Place|#Pronoun|#Acronym)+$")) {
    return false;
  }
  return true;
};
var hasPlural_default = hasPlural;

// node_modules/compromise/src/3-three/nouns/api/toPlural.js
var keep = { tags: true };
var nounToPlural = function(m6, parsed) {
  if (parsed.isPlural === true) {
    return m6;
  }
  if (parsed.root.has("#Possessive")) {
    parsed.root = parsed.root.possessives().strip();
  }
  if (!hasPlural_default(parsed.root)) {
    return m6;
  }
  const { methods: methods17, model: model5 } = m6.world;
  const { toPlural } = methods17.two.transform.noun;
  let str = parsed.root.text({ keepPunct: false });
  let plural2 = toPlural(str, model5);
  m6.match(parsed.root).replaceWith(plural2, keep).tag("Plural", "toPlural");
  if (parsed.determiner.has("(a|an)")) {
    m6.remove(parsed.determiner);
  }
  let copula = parsed.root.after("not? #Adverb+? [#Copula]", 0);
  if (copula.found) {
    if (copula.has("is")) {
      m6.replace(copula, "are");
    } else if (copula.has("was")) {
      m6.replace(copula, "were");
    }
  }
  return m6;
};
var toPlural_default2 = nounToPlural;

// node_modules/compromise/src/3-three/nouns/api/toSingular.js
var keep2 = { tags: true };
var nounToSingular = function(m6, parsed) {
  if (parsed.isPlural === false) {
    return m6;
  }
  const { methods: methods17, model: model5 } = m6.world;
  const { toSingular: toSingular2 } = methods17.two.transform.noun;
  let str = parsed.root.text("normal");
  let single = toSingular2(str, model5);
  m6.replace(parsed.root, single, keep2).tag("Singular", "toPlural");
  return m6;
};
var toSingular_default2 = nounToSingular;

// node_modules/compromise/src/3-three/nouns/api/api.js
var api12 = function(View2) {
  class Nouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Nouns";
    }
    parse(n5) {
      return this.getNth(n5).map(parse_default3);
    }
    json(n5) {
      let opts2 = typeof n5 === "object" ? n5 : {};
      return this.getNth(n5).map((m6) => {
        let json = m6.toView().json(opts2)[0] || {};
        if (opts2 && opts2.noun !== false) {
          json.noun = toJSON_default(m6);
        }
        return json;
      }, []);
    }
    conjugate(n5) {
      const methods17 = this.world.methods.two.transform.noun;
      return this.getNth(n5).map((m6) => {
        let parsed = parse_default3(m6);
        let root = parsed.root.compute("root").text("root");
        let res = {
          Singular: root
        };
        if (hasPlural_default(parsed.root)) {
          res.Plural = methods17.toPlural(root, this.model);
        }
        if (res.Singular === res.Plural) {
          delete res.Plural;
        }
        return res;
      }, []);
    }
    isPlural(n5) {
      let res = this.filter((m6) => parse_default3(m6).isPlural);
      return res.getNth(n5);
    }
    isSingular(n5) {
      let res = this.filter((m6) => !parse_default3(m6).isPlural);
      return res.getNth(n5);
    }
    adjectives(n5) {
      let res = this.update([]);
      this.forEach((m6) => {
        let adj = parse_default3(m6).adjectives;
        if (adj.found) {
          res = res.concat(adj);
        }
      });
      return res.getNth(n5);
    }
    toPlural(n5) {
      return this.getNth(n5).map((m6) => {
        return toPlural_default2(m6, parse_default3(m6));
      });
    }
    toSingular(n5) {
      return this.getNth(n5).map((m6) => {
        let res = parse_default3(m6);
        return toSingular_default2(m6, res);
      });
    }
    // create a new View, from this one
    update(pointer) {
      let m6 = new Nouns(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  View2.prototype.nouns = function(n5) {
    let m6 = find_default(this);
    m6 = m6.getNth(n5);
    return new Nouns(this.document, m6.pointer);
  };
};
var api_default14 = api12;

// node_modules/compromise/src/3-three/nouns/plugin.js
var plugin_default24 = {
  api: api_default14
};

// node_modules/compromise/src/3-three/numbers/fractions/find.js
var findFractions = function(doc, n5) {
  let m6 = doc.match("#Fraction+");
  m6 = m6.filter((r3) => {
    return !r3.lookBehind("#Value and$").found;
  });
  m6 = m6.notIf("#Value seconds");
  if (typeof n5 === "number") {
    m6 = m6.eq(n5);
  }
  return m6;
};
var find_default2 = findFractions;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/findModifiers.js
var findModifiers = (str) => {
  const mults = [
    {
      reg: /^(minus|negative)[\s-]/i,
      mult: -1
    },
    {
      reg: /^(a\s)?half[\s-](of\s)?/i,
      mult: 0.5
    }
    //  {
    //   reg: /^(a\s)?quarter[\s\-]/i,
    //   mult: 0.25
    // }
  ];
  for (let i5 = 0; i5 < mults.length; i5++) {
    if (mults[i5].reg.test(str) === true) {
      return {
        amount: mults[i5].mult,
        str: str.replace(mults[i5].reg, "")
      };
    }
  }
  return {
    amount: 1,
    str
  };
};
var findModifiers_default = findModifiers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/data.js
var data_default3 = {
  ones: {
    zeroth: 0,
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9
  },
  teens: {
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19
  },
  tens: {
    twentieth: 20,
    thirtieth: 30,
    fortieth: 40,
    fourtieth: 40,
    fiftieth: 50,
    sixtieth: 60,
    seventieth: 70,
    eightieth: 80,
    ninetieth: 90,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90
  },
  multiples: {
    hundredth: 100,
    thousandth: 1e3,
    millionth: 1e6,
    billionth: 1e9,
    trillionth: 1e12,
    quadrillionth: 1e15,
    quintillionth: 1e18,
    sextillionth: 1e21,
    septillionth: 1e24,
    hundred: 100,
    thousand: 1e3,
    million: 1e6,
    billion: 1e9,
    trillion: 1e12,
    quadrillion: 1e15,
    quintillion: 1e18,
    sextillion: 1e21,
    septillion: 1e24,
    grand: 1e3
  }
};

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/validate.js
var isValid = (w2, has2) => {
  if (data_default3.ones.hasOwnProperty(w2)) {
    if (has2.ones || has2.teens) {
      return false;
    }
  } else if (data_default3.teens.hasOwnProperty(w2)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  } else if (data_default3.tens.hasOwnProperty(w2)) {
    if (has2.ones || has2.teens || has2.tens) {
      return false;
    }
  }
  return true;
};
var validate_default2 = isValid;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseDecimals.js
var parseDecimals = function(arr) {
  let str = "0.";
  for (let i5 = 0; i5 < arr.length; i5++) {
    let w2 = arr[i5];
    if (data_default3.ones.hasOwnProperty(w2) === true) {
      str += data_default3.ones[w2];
    } else if (data_default3.teens.hasOwnProperty(w2) === true) {
      str += data_default3.teens[w2];
    } else if (data_default3.tens.hasOwnProperty(w2) === true) {
      str += data_default3.tens[w2];
    } else if (/^[0-9]$/.test(w2) === true) {
      str += w2;
    } else {
      return 0;
    }
  }
  return parseFloat(str);
};
var parseDecimals_default = parseDecimals;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/parseNumeric.js
var parseNumeric = (str) => {
  str = str.replace(/1st$/, "1");
  str = str.replace(/2nd$/, "2");
  str = str.replace(/3rd$/, "3");
  str = str.replace(/([4567890])r?th$/, "$1");
  str = str.replace(/^[$€¥£¢]/, "");
  str = str.replace(/[%$€¥£¢]$/, "");
  str = str.replace(/,/g, "");
  str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1");
  return str;
};
var parseNumeric_default = parseNumeric;

// node_modules/compromise/src/3-three/numbers/numbers/parse/toNumber/index.js
var improperFraction = /^([0-9,. ]+)\/([0-9,. ]+)$/;
var casualForms = {
  "a few": 3,
  "a couple": 2,
  "a dozen": 12,
  "two dozen": 24,
  zero: 0
};
var section_sum = (obj) => {
  return Object.keys(obj).reduce((sum, k3) => {
    sum += obj[k3];
    return sum;
  }, 0);
};
var parse4 = function(str) {
  if (casualForms.hasOwnProperty(str) === true) {
    return casualForms[str];
  }
  if (str === "a" || str === "an") {
    return 1;
  }
  const modifier = findModifiers_default(str);
  str = modifier.str;
  let last_mult = null;
  let has2 = {};
  let sum = 0;
  let isNegative = false;
  const terms = str.split(/[ -]/);
  for (let i5 = 0; i5 < terms.length; i5++) {
    let w2 = terms[i5];
    w2 = parseNumeric_default(w2);
    if (!w2 || w2 === "and") {
      continue;
    }
    if (w2 === "-" || w2 === "negative") {
      isNegative = true;
      continue;
    }
    if (w2.charAt(0) === "-") {
      isNegative = true;
      w2 = w2.substring(1);
    }
    if (w2 === "point") {
      sum += section_sum(has2);
      sum += parseDecimals_default(terms.slice(i5 + 1, terms.length));
      sum *= modifier.amount;
      return sum;
    }
    const fm = w2.match(improperFraction);
    if (fm) {
      const num = parseFloat(fm[1].replace(/[, ]/g, ""));
      const denom = parseFloat(fm[2].replace(/[, ]/g, ""));
      if (denom) {
        sum += num / denom || 0;
      }
      continue;
    }
    if (data_default3.tens.hasOwnProperty(w2)) {
      if (has2.ones && Object.keys(has2).length === 1) {
        sum = has2.ones * 100;
        has2 = {};
      }
    }
    if (validate_default2(w2, has2) === false) {
      return null;
    }
    if (/^[0-9.]+$/.test(w2)) {
      has2.ones = parseFloat(w2);
    } else if (data_default3.ones.hasOwnProperty(w2) === true) {
      has2.ones = data_default3.ones[w2];
    } else if (data_default3.teens.hasOwnProperty(w2) === true) {
      has2.teens = data_default3.teens[w2];
    } else if (data_default3.tens.hasOwnProperty(w2) === true) {
      has2.tens = data_default3.tens[w2];
    } else if (data_default3.multiples.hasOwnProperty(w2) === true) {
      let mult = data_default3.multiples[w2];
      if (mult === last_mult) {
        return null;
      }
      if (mult === 100 && terms[i5 + 1] !== void 0) {
        const w22 = terms[i5 + 1];
        if (data_default3.multiples[w22]) {
          mult *= data_default3.multiples[w22];
          i5 += 1;
        }
      }
      if (last_mult === null || mult < last_mult) {
        sum += (section_sum(has2) || 1) * mult;
        last_mult = mult;
        has2 = {};
      } else {
        sum += section_sum(has2);
        last_mult = mult;
        sum = (sum || 1) * mult;
        has2 = {};
      }
    }
  }
  sum += section_sum(has2);
  sum *= modifier.amount;
  sum *= isNegative ? -1 : 1;
  if (sum === 0 && Object.keys(has2).length === 0) {
    return null;
  }
  return sum;
};
var toNumber_default = parse4;

// node_modules/compromise/src/3-three/numbers/fractions/parse.js
var endS = /s$/;
var parseNumber = function(m6) {
  let str = m6.text("reduced");
  return toNumber_default(str);
};
var mapping2 = {
  half: 2,
  halve: 2,
  quarter: 4
};
var slashForm = function(m6) {
  let str = m6.text("reduced");
  let found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
  if (found && found[1] && found[0]) {
    return {
      numerator: Number(found[1]),
      denominator: Number(found[2])
    };
  }
  return null;
};
var nOutOfN = function(m6) {
  let found = m6.match("[<num>#Value+] out of every? [<den>#Value+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (!num || !den) {
    return null;
  }
  num = parseNumber(num);
  den = parseNumber(den);
  if (!num || !den) {
    return null;
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var nOrinalth = function(m6) {
  let found = m6.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
  if (found.found !== true) {
    return null;
  }
  let { num, den } = found.groups();
  if (num.has("a")) {
    num = 1;
  } else {
    num = parseNumber(num);
  }
  let str = den.text("reduced");
  if (endS.test(str)) {
    str = str.replace(endS, "");
    den = den.replaceWith(str);
  }
  if (mapping2.hasOwnProperty(str)) {
    den = mapping2[str];
  } else {
    den = parseNumber(den);
  }
  if (typeof num === "number" && typeof den === "number") {
    return {
      numerator: num,
      denominator: den
    };
  }
  return null;
};
var oneNth = function(m6) {
  let found = m6.match("^#Ordinal$");
  if (found.found !== true) {
    return null;
  }
  if (m6.lookAhead("^of .")) {
    let num = parseNumber(found);
    return {
      numerator: 1,
      denominator: num
    };
  }
  return null;
};
var named = function(m6) {
  let str = m6.text("reduced");
  if (mapping2.hasOwnProperty(str)) {
    return { numerator: 1, denominator: mapping2[str] };
  }
  return null;
};
var round2 = (n5) => {
  let rounded = Math.round(n5 * 1e3) / 1e3;
  if (rounded === 0 && n5 !== 0) {
    return n5;
  }
  return rounded;
};
var parseFraction = function(m6) {
  m6 = m6.clone();
  let res = named(m6) || slashForm(m6) || nOutOfN(m6) || nOrinalth(m6) || oneNth(m6) || null;
  if (res !== null) {
    if (res.numerator && res.denominator) {
      res.decimal = res.numerator / res.denominator;
      res.decimal = round2(res.decimal);
    }
  }
  return res;
};
var parse_default4 = parseFraction;

// node_modules/compromise/src/3-three/numbers/numbers/_toString.js
var numToString = function(n5) {
  if (n5 < 1e6) {
    return String(n5);
  }
  let str;
  if (typeof n5 === "number") {
    str = n5.toFixed(0);
  } else {
    str = n5;
  }
  if (str.indexOf("e+") === -1) {
    return str;
  }
  return str.replace(".", "").split("e+").reduce(function(p7, b2) {
    return p7 + Array(b2 - p7.length + 2).join(0);
  });
};
var toString_default = numToString;

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/data.js
var tens_mapping = [
  ["ninety", 90],
  ["eighty", 80],
  ["seventy", 70],
  ["sixty", 60],
  ["fifty", 50],
  ["forty", 40],
  ["thirty", 30],
  ["twenty", 20]
];
var ones_mapping = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
];
var sequence = [
  [1e24, "septillion"],
  [1e20, "hundred sextillion"],
  [1e21, "sextillion"],
  [1e20, "hundred quintillion"],
  [1e18, "quintillion"],
  [1e17, "hundred quadrillion"],
  [1e15, "quadrillion"],
  [1e14, "hundred trillion"],
  [1e12, "trillion"],
  [1e11, "hundred billion"],
  [1e9, "billion"],
  [1e8, "hundred million"],
  [1e6, "million"],
  [1e5, "hundred thousand"],
  [1e3, "thousand"],
  [100, "hundred"],
  [1, "one"]
];

// node_modules/compromise/src/3-three/numbers/numbers/format/toText/index.js
var breakdown_magnitudes = function(num) {
  let working = num;
  let have = [];
  sequence.forEach((a4) => {
    if (num >= a4[0]) {
      let howmany = Math.floor(working / a4[0]);
      working -= howmany * a4[0];
      if (howmany) {
        have.push({
          unit: a4[1],
          count: howmany
        });
      }
    }
  });
  return have;
};
var breakdown_hundred = function(num) {
  let arr = [];
  if (num > 100) {
    return arr;
  }
  for (let i5 = 0; i5 < tens_mapping.length; i5++) {
    if (num >= tens_mapping[i5][1]) {
      num -= tens_mapping[i5][1];
      arr.push(tens_mapping[i5][0]);
    }
  }
  if (ones_mapping[num]) {
    arr.push(ones_mapping[num]);
  }
  return arr;
};
var handle_decimal = (num) => {
  const names = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  let arr = [];
  let str = toString_default(num);
  let decimal = str.match(/\.([0-9]+)/);
  if (!decimal || !decimal[0]) {
    return arr;
  }
  arr.push("point");
  let decimals = decimal[0].split("");
  for (let i5 = 0; i5 < decimals.length; i5++) {
    arr.push(names[decimals[i5]]);
  }
  return arr;
};
var toText3 = function(obj) {
  let num = obj.num;
  if (num === 0 || num === "0") {
    return "zero";
  }
  if (num > 1e21) {
    num = toString_default(num);
  }
  let arr = [];
  if (num < 0) {
    arr.push("minus");
    num = Math.abs(num);
  }
  let units = breakdown_magnitudes(num);
  for (let i5 = 0; i5 < units.length; i5++) {
    let unit_name = units[i5].unit;
    if (unit_name === "one") {
      unit_name = "";
      if (arr.length > 1) {
        arr.push("and");
      }
    }
    arr = arr.concat(breakdown_hundred(units[i5].count));
    arr.push(unit_name);
  }
  arr = arr.concat(handle_decimal(num));
  arr = arr.filter((s5) => s5);
  if (arr.length === 0) {
    arr[0] = "";
  }
  return arr.join(" ");
};
var toText_default = toText3;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toCardinal.js
var toCardinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let a4 = toText_default({ num: obj.numerator });
  let b2 = toText_default({ num: obj.denominator });
  return `${a4} out of ${b2}`;
};
var toCardinal_default = toCardinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/textOrdinal.js
var irregulars = {
  one: "first",
  two: "second",
  three: "third",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fourty: "fourtieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
};
var textOrdinal = (obj) => {
  let words = toText_default(obj).split(" ");
  let last = words[words.length - 1];
  if (irregulars.hasOwnProperty(last)) {
    words[words.length - 1] = irregulars[last];
  } else {
    words[words.length - 1] = last.replace(/y$/, "i") + "th";
  }
  return words.join(" ");
};
var textOrdinal_default = textOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/convert/toOrdinal.js
var toOrdinal = function(obj) {
  if (!obj.numerator || !obj.denominator) {
    return "";
  }
  let start2 = toText_default({ num: obj.numerator });
  let end2 = textOrdinal_default({ num: obj.denominator });
  if (obj.denominator === 2) {
    end2 = "half";
  }
  if (start2 && end2) {
    if (obj.numerator !== 1) {
      end2 += "s";
    }
    return `${start2} ${end2}`;
  }
  return "";
};
var toOrdinal_default = toOrdinal;

// node_modules/compromise/src/3-three/numbers/fractions/api.js
var plugin3 = function(View2) {
  class Fractions extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Fractions";
    }
    parse(n5) {
      return this.getNth(n5).map(parse_default4);
    }
    get(n5) {
      return this.getNth(n5).map(parse_default4);
    }
    json(n5) {
      return this.getNth(n5).map((p7) => {
        let json = p7.toView().json(n5)[0];
        let parsed = parse_default4(p7);
        json.fraction = parsed;
        return json;
      }, []);
    }
    // become 0.5
    toDecimal(n5) {
      this.getNth(n5).forEach((m6) => {
        let { decimal } = parse_default4(m6);
        m6 = m6.replaceWith(String(decimal), true);
        m6.tag("NumericValue");
        m6.unTag("Fraction");
      });
      return this;
    }
    toFraction(n5) {
      this.getNth(n5).forEach((m6) => {
        let obj = parse_default4(m6);
        if (obj && typeof obj.numerator === "number" && typeof obj.denominator === "number") {
          let str = `${obj.numerator}/${obj.denominator}`;
          this.replace(m6, str);
        }
      });
      return this;
    }
    toOrdinal(n5) {
      this.getNth(n5).forEach((m6) => {
        let obj = parse_default4(m6);
        let str = toOrdinal_default(obj);
        if (m6.after("^#Noun").found) {
          str += " of";
        }
        m6.replaceWith(str);
      });
      return this;
    }
    toCardinal(n5) {
      this.getNth(n5).forEach((m6) => {
        let obj = parse_default4(m6);
        let str = toCardinal_default(obj);
        m6.replaceWith(str);
      });
      return this;
    }
    toPercentage(n5) {
      this.getNth(n5).forEach((m6) => {
        let { decimal } = parse_default4(m6);
        let percent = decimal * 100;
        percent = Math.round(percent * 100) / 100;
        m6.replaceWith(`${percent}%`);
      });
      return this;
    }
  }
  View2.prototype.fractions = function(n5) {
    let m6 = find_default2(this);
    m6 = m6.getNth(n5);
    return new Fractions(this.document, m6.pointer);
  };
};
var api_default15 = plugin3;

// node_modules/compromise/src/3-three/numbers/numbers/find.js
var ones = "one|two|three|four|five|six|seven|eight|nine";
var tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty";
var teens = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen";
var findNumbers = function(doc) {
  let m6 = doc.match("#Value+");
  if (m6.has("#NumericValue #NumericValue")) {
    if (m6.has("#Value @hasComma #Value")) {
      m6.splitAfter("@hasComma");
    } else if (m6.has("#NumericValue #Fraction")) {
      m6.splitAfter("#NumericValue #Fraction");
    } else {
      m6 = m6.splitAfter("#NumericValue");
    }
  }
  if (m6.has("#Value #Value #Value") && !m6.has("#Multiple")) {
    if (m6.has("(" + tens + ") #Cardinal #Cardinal")) {
      m6 = m6.splitAfter("(" + tens + ") #Cardinal");
    }
  }
  if (m6.has("#Value #Value")) {
    if (m6.has("#NumericValue #NumericValue")) {
      m6 = m6.splitOn("#Year");
    }
    if (m6.has("(" + tens + ") (" + teens + ")")) {
      m6 = m6.splitAfter("(" + tens + ")");
    }
    let double = m6.match("#Cardinal #Cardinal");
    if (double.found && !m6.has("(point|decimal|#Fraction)")) {
      if (!double.has("#Cardinal (#Multiple|point|decimal)")) {
        let noMultiple = m6.has(`(${ones}) (${tens})`);
        let tensVal = double.has("(" + tens + ") #Cardinal");
        let multVal = double.has("#Multiple #Value");
        if (!noMultiple && !tensVal && !multVal) {
          double.terms().forEach((d3) => {
            m6 = m6.splitOn(d3);
          });
        }
      }
    }
    if (m6.match("#Ordinal #Ordinal").match("#TextValue").found && !m6.has("#Multiple")) {
      if (!m6.has("(" + tens + ") #Ordinal")) {
        m6 = m6.splitAfter("#Ordinal");
      }
    }
    m6 = m6.splitBefore("#Ordinal [#Cardinal]", 0);
    if (m6.has("#TextValue #NumericValue") && !m6.has("(" + tens + "|#Multiple)")) {
      m6 = m6.splitBefore("#TextValue #NumericValue");
    }
  }
  m6 = m6.splitAfter("#NumberRange");
  m6 = m6.splitBefore("#Year");
  return m6;
};
var find_default3 = findNumbers;

// node_modules/compromise/src/3-three/numbers/numbers/parse/index.js
var parseNumeric2 = function(str, m6) {
  str = str.replace(/,/g, "");
  let arr = str.split(/([0-9.,]*)/);
  let [prefix5, num] = arr;
  let suffix = arr.slice(2).join("");
  if (num !== "" && m6.length < 2) {
    num = Number(num || str);
    if (typeof num !== "number") {
      num = null;
    }
    suffix = suffix || "";
    if (suffix === "st" || suffix === "nd" || suffix === "rd" || suffix === "th") {
      suffix = "";
    }
    return {
      prefix: prefix5 || "",
      num,
      suffix
    };
  }
  return null;
};
var parseNumber2 = function(m6) {
  if (typeof m6 === "string") {
    return { num: toNumber_default(m6) };
  }
  let str = m6.text("reduced");
  let unit = m6.growRight("#Unit").match("#Unit$").text("machine");
  let hasComma = /[0-9],[0-9]/.test(m6.text("text"));
  if (m6.terms().length === 1 && !m6.has("#Multiple")) {
    let res = parseNumeric2(str, m6);
    if (res !== null) {
      res.hasComma = hasComma;
      res.unit = unit;
      return res;
    }
  }
  let frPart = m6.match("#Fraction{2,}$");
  frPart = frPart.found === false ? m6.match("^#Fraction$") : frPart;
  let fraction = null;
  if (frPart.found) {
    if (frPart.has("#Value and #Value #Fraction")) {
      frPart = frPart.match("and #Value #Fraction");
    }
    fraction = parse_default4(frPart);
    m6 = m6.not(frPart);
    m6 = m6.not("and$");
    str = m6.text("reduced");
  }
  let num = 0;
  if (str) {
    num = toNumber_default(str) || 0;
  }
  if (fraction && fraction.decimal) {
    num += fraction.decimal;
  }
  return {
    hasComma,
    prefix: "",
    num,
    suffix: "",
    isOrdinal: m6.has("#Ordinal"),
    isText: m6.has("#TextValue"),
    isFraction: m6.has("#Fraction"),
    isMoney: m6.has("#Money"),
    unit
  };
};
var parse_default5 = parseNumber2;

// node_modules/compromise/src/3-three/numbers/numbers/format/toOrdinal/numOrdinal.js
var numOrdinal = function(obj) {
  let num = obj.num;
  if (!num && num !== 0) {
    return null;
  }
  let tens2 = num % 100;
  if (tens2 > 10 && tens2 < 20) {
    return String(num) + "th";
  }
  const mapping3 = {
    0: "th",
    1: "st",
    2: "nd",
    3: "rd"
  };
  let str = toString_default(num);
  let last = str.slice(str.length - 1, str.length);
  if (mapping3[last]) {
    str += mapping3[last];
  } else {
    str += "th";
  }
  return str;
};
var numOrdinal_default = numOrdinal;

// node_modules/compromise/src/3-three/numbers/numbers/format/suffix.js
var prefixes = {
  "\xA2": "cents",
  $: "dollars",
  "\xA3": "pounds",
  "\xA5": "yen",
  "\u20AC": "euros",
  "\u20A1": "col\xF3n",
  "\u0E3F": "baht",
  "\u20AD": "kip",
  "\u20A9": "won",
  "\u20B9": "rupees",
  "\u20BD": "ruble",
  "\u20BA": "liras"
};
var suffixes4 = {
  "%": "percent",
  // s: 'seconds',
  // cm: 'centimetres',
  // km: 'kilometres',
  // ft: 'feet',
  "\xB0": "degrees"
};
var addSuffix = function(obj) {
  let res = {
    suffix: "",
    prefix: obj.prefix
  };
  if (prefixes.hasOwnProperty(obj.prefix)) {
    res.suffix += " " + prefixes[obj.prefix];
    res.prefix = "";
  }
  if (suffixes4.hasOwnProperty(obj.suffix)) {
    res.suffix += " " + suffixes4[obj.suffix];
  }
  if (res.suffix && obj.num === 1) {
    res.suffix = res.suffix.replace(/s$/, "");
  }
  if (!res.suffix && obj.suffix) {
    res.suffix += " " + obj.suffix;
  }
  return res;
};
var suffix_default2 = addSuffix;

// node_modules/compromise/src/3-three/numbers/numbers/format/index.js
var format = function(obj, fmt2) {
  if (fmt2 === "TextOrdinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + textOrdinal_default(obj) + suffix;
  }
  if (fmt2 === "Ordinal") {
    return obj.prefix + numOrdinal_default(obj) + obj.suffix;
  }
  if (fmt2 === "TextCardinal") {
    let { prefix: prefix5, suffix } = suffix_default2(obj);
    return prefix5 + toText_default(obj) + suffix;
  }
  let num = obj.num;
  if (obj.hasComma) {
    num = num.toLocaleString();
  }
  return obj.prefix + String(num) + obj.suffix;
};
var format_default = format;

// node_modules/compromise/src/3-three/numbers/numbers/isUnit.js
var isArray11 = (arr) => Object.prototype.toString.call(arr) === "[object Array]";
var coerceToObject = function(input) {
  if (typeof input === "string" || typeof input === "number") {
    let tmp = {};
    tmp[input] = true;
    return tmp;
  }
  if (isArray11(input)) {
    return input.reduce((h4, s5) => {
      h4[s5] = true;
      return h4;
    }, {});
  }
  return input || {};
};
var isUnit = function(doc, input = {}) {
  input = coerceToObject(input);
  return doc.filter((p7) => {
    let { unit } = parse_default5(p7);
    if (unit && input[unit] === true) {
      return true;
    }
    return false;
  });
};
var isUnit_default = isUnit;

// node_modules/compromise/src/3-three/numbers/numbers/api.js
var addMethod = function(View2) {
  class Numbers extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Numbers";
    }
    parse(n5) {
      return this.getNth(n5).map(parse_default5);
    }
    get(n5) {
      return this.getNth(n5).map(parse_default5).map((o4) => o4.num);
    }
    json(n5) {
      let opts2 = typeof n5 === "object" ? n5 : {};
      return this.getNth(n5).map((p7) => {
        let json = p7.toView().json(opts2)[0];
        let parsed = parse_default5(p7);
        json.number = {
          prefix: parsed.prefix,
          num: parsed.num,
          suffix: parsed.suffix,
          hasComma: parsed.hasComma,
          unit: parsed.unit
        };
        return json;
      }, []);
    }
    /** any known measurement unit, for the number */
    units() {
      return this.growRight("#Unit").match("#Unit$");
    }
    /** return values that match a given unit */
    isUnit(allowed) {
      return isUnit_default(this, allowed);
    }
    /** return only ordinal numbers */
    isOrdinal() {
      return this.if("#Ordinal");
    }
    /** return only cardinal numbers*/
    isCardinal() {
      return this.if("#Cardinal");
    }
    /** convert to numeric form like '8' or '8th' */
    toNumber() {
      let m6 = this.if("#TextValue");
      m6.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("NumericValue");
      });
      return this;
    }
    /** add commas, or nicer formatting for numbers */
    toLocaleString() {
      let m6 = this;
      m6.forEach((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return;
        }
        let num = obj.num.toLocaleString();
        if (val.has("#Ordinal")) {
          let str = format_default(obj, "Ordinal");
          let end2 = str.match(/[a-z]+$/);
          if (end2) {
            num += end2[0] || "";
          }
        }
        val.replaceWith(num, { tags: true });
      });
      return this;
    }
    /** convert to numeric form like 'eight' or 'eighth' */
    toText() {
      let m6 = this;
      let res = m6.map((val) => {
        if (val.has("#TextValue")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("TextValue");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert ordinal to cardinal form, like 'eight', or '8' */
    toCardinal() {
      let m6 = this;
      let res = m6.map((val) => {
        if (!val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextCardinal" : "Cardinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Cardinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** convert cardinal to ordinal form, like 'eighth', or '8th' */
    toOrdinal() {
      let m6 = this;
      let res = m6.map((val) => {
        if (val.has("#Ordinal")) {
          return val;
        }
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#TextValue") ? "TextOrdinal" : "Ordinal";
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        val.tag("Ordinal");
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** return only numbers that are == n */
    isEqual(n5) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num === n5;
      });
    }
    /** return only numbers that are > n*/
    greaterThan(n5) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > n5;
      });
    }
    /** return only numbers that are < n*/
    lessThan(n5) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num < n5;
      });
    }
    /** return only numbers > min and < max */
    between(min2, max4) {
      return this.filter((val) => {
        let num = parse_default5(val).num;
        return num > min2 && num < max4;
      });
    }
    /** set these number to n */
    set(n5) {
      if (n5 === void 0) {
        return this;
      }
      if (typeof n5 === "string") {
        n5 = parse_default5(n5).num;
      }
      let m6 = this;
      let res = m6.map((val) => {
        let obj = parse_default5(val);
        obj.num = n5;
        if (obj.num === null) {
          return val;
        }
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (val.has("#TextValue")) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        if (obj.hasComma && fmt2 === "Cardinal") {
          str = Number(str).toLocaleString();
        }
        val = val.not("#Currency");
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    add(n5) {
      if (!n5) {
        return this;
      }
      if (typeof n5 === "string") {
        n5 = parse_default5(n5).num;
      }
      let m6 = this;
      let res = m6.map((val) => {
        let obj = parse_default5(val);
        if (obj.num === null) {
          return val;
        }
        obj.num += n5;
        let fmt2 = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
        if (obj.isText) {
          fmt2 = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
        }
        let str = format_default(obj, fmt2);
        val.replaceWith(str, { tags: true });
        return val;
      });
      return new Numbers(res.document, res.pointer);
    }
    /** decrease each number by n*/
    subtract(n5, agree) {
      return this.add(n5 * -1, agree);
    }
    /** increase each number by 1 */
    increment(agree) {
      return this.add(1, agree);
    }
    /** decrease each number by 1 */
    decrement(agree) {
      return this.add(-1, agree);
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m6 = new Numbers(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  Numbers.prototype.toNice = Numbers.prototype.toLocaleString;
  Numbers.prototype.isBetween = Numbers.prototype.between;
  Numbers.prototype.minus = Numbers.prototype.subtract;
  Numbers.prototype.plus = Numbers.prototype.add;
  Numbers.prototype.equals = Numbers.prototype.isEqual;
  View2.prototype.numbers = function(n5) {
    let m6 = find_default3(this);
    m6 = m6.getNth(n5);
    return new Numbers(this.document, m6.pointer);
  };
  View2.prototype.percentages = function(n5) {
    let m6 = find_default3(this);
    m6 = m6.filter((v4) => v4.has("#Percent") || v4.after("^percent"));
    m6 = m6.getNth(n5);
    return new Numbers(this.document, m6.pointer);
  };
  View2.prototype.money = function(n5) {
    let m6 = find_default3(this);
    m6 = m6.filter((v4) => v4.has("#Money") || v4.after("^#Currency"));
    m6 = m6.getNth(n5);
    return new Numbers(this.document, m6.pointer);
  };
  View2.prototype.values = View2.prototype.numbers;
};
var api_default16 = addMethod;

// node_modules/compromise/src/3-three/numbers/plugin.js
var api13 = function(View2) {
  api_default15(View2);
  api_default16(View2);
};
var plugin_default25 = {
  api: api13,
  // add @greaterThan, @lessThan
  mutate: (world2) => {
    let termMethods = world2.methods.one.termMethods;
    termMethods.lessThan = function(term) {
      console.log(term);
    };
  }
};

// node_modules/compromise/src/3-three/redact/plugin.js
var defaults3 = {
  people: true,
  emails: true,
  phoneNumbers: true,
  places: true
};
var redact = function(opts2 = {}) {
  opts2 = Object.assign({}, defaults3, opts2);
  if (opts2.people !== false) {
    this.people().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.emails !== false) {
    this.emails().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.places !== false) {
    this.places().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  if (opts2.phoneNumbers !== false) {
    this.phoneNumbers().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
  }
  return this;
};
var plugin4 = {
  api: function(View2) {
    View2.prototype.redact = redact;
  }
};
var plugin_default26 = plugin4;

// node_modules/compromise/src/3-three/sentences/questions.js
var isQuestion = function(doc) {
  let clauses2 = doc.clauses();
  if (/\.\.$/.test(doc.out("text"))) {
    return false;
  }
  if (doc.has("^#QuestionWord") && doc.has("@hasComma")) {
    return false;
  }
  if (doc.has("or not$")) {
    return true;
  }
  if (doc.has("^#QuestionWord")) {
    return true;
  }
  if (doc.has("^(do|does|did|is|was|can|could|will|would|may) #Noun")) {
    return true;
  }
  if (doc.has("^(have|must) you")) {
    return true;
  }
  if (clauses2.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$")) {
    return true;
  }
  return false;
};
var findQuestions = function(view) {
  const hasQ = /\?/;
  const { document: document2 } = view;
  return view.filter((m6) => {
    let terms = m6.docs[0] || [];
    let lastTerm = terms[terms.length - 1];
    if (!lastTerm || document2[lastTerm.index[0]].length !== terms.length) {
      return false;
    }
    if (hasQ.test(lastTerm.post)) {
      return true;
    }
    return isQuestion(m6);
  });
};
var questions_default = findQuestions;

// node_modules/compromise/src/3-three/sentences/parse/mainClause.js
var subordinate = `(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)`;
var relative = `(that|which|whichever|who|whoever|whom|whose|whomever)`;
var mainClause = function(s5) {
  let m6 = s5;
  if (m6.length === 1) {
    return m6;
  }
  m6 = m6.if("#Verb");
  if (m6.length === 1) {
    return m6;
  }
  m6 = m6.ifNo(subordinate);
  m6 = m6.ifNo("^even (if|though)");
  m6 = m6.ifNo("^so that");
  m6 = m6.ifNo("^rather than");
  m6 = m6.ifNo("^provided that");
  if (m6.length === 1) {
    return m6;
  }
  m6 = m6.ifNo(relative);
  if (m6.length === 1) {
    return m6;
  }
  m6 = m6.ifNo("(^despite|^during|^before|^through|^throughout)");
  if (m6.length === 1) {
    return m6;
  }
  m6 = m6.ifNo("^#Gerund");
  if (m6.length === 1) {
    return m6;
  }
  if (m6.length === 0) {
    m6 = s5;
  }
  return m6.eq(0);
};
var mainClause_default = mainClause;

// node_modules/compromise/src/3-three/sentences/parse/index.js
var grammar = function(vb3) {
  let tense = null;
  if (vb3.has("#PastTense")) {
    tense = "PastTense";
  } else if (vb3.has("#FutureTense")) {
    tense = "FutureTense";
  } else if (vb3.has("#PresentTense")) {
    tense = "PresentTense";
  }
  return {
    tense
  };
};
var parse5 = function(s5) {
  let clauses2 = s5.clauses();
  let main = mainClause_default(clauses2);
  let chunks2 = main.chunks();
  let subj = s5.none();
  let verb = s5.none();
  let pred = s5.none();
  chunks2.forEach((ch, i5) => {
    if (i5 === 0 && !ch.has("<Verb>")) {
      subj = ch;
      return;
    }
    if (!verb.found && ch.has("<Verb>")) {
      verb = ch;
      return;
    }
    if (verb.found) {
      pred = pred.concat(ch);
    }
  });
  if (verb.found && !subj.found) {
    subj = verb.before("<Noun>+").first();
  }
  return {
    subj,
    verb,
    pred,
    grammar: grammar(verb)
  };
};
var parse_default6 = parse5;

// node_modules/compromise/src/3-three/sentences/conjugate/toPast.js
var toPast2 = function(s5) {
  let verbs = s5.verbs();
  let first = verbs.eq(0);
  if (first.has("#PastTense")) {
    return s5;
  }
  first.toPastTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v4) => !v4.lookBehind("to$").found);
    verbs = verbs.if("#PresentTense");
    verbs = verbs.notIf("#Gerund");
    let list5 = s5.match("to #Verb+ #Conjunction #Verb").terms();
    verbs = verbs.not(list5);
    if (verbs.found) {
      verbs.verbs().toPastTense();
    }
  }
  return s5;
};
var toPast_default = toPast2;

// node_modules/compromise/src/3-three/sentences/conjugate/toPresent.js
var toPresent2 = function(s5) {
  let verbs = s5.verbs();
  let first = verbs.eq(0);
  first.toPresentTense();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    verbs = verbs.filter((v4) => !v4.lookBehind("to$").found);
    verbs = verbs.notIf("#Gerund");
    if (verbs.found) {
      verbs.verbs().toPresentTense();
    }
  }
  return s5;
};
var toPresent_default = toPresent2;

// node_modules/compromise/src/3-three/sentences/conjugate/toFuture.js
var toFuture = function(s5) {
  let verbs = s5.verbs();
  let first = verbs.eq(0);
  first.toFutureTense();
  s5 = s5.fullSentence();
  verbs = s5.verbs();
  if (verbs.length > 1) {
    verbs = verbs.slice(1);
    let toChange = verbs.filter((vb3) => {
      if (vb3.lookBehind("to$").found) {
        return false;
      }
      if (vb3.has("#Copula #Gerund")) {
        return true;
      }
      if (vb3.has("#Gerund")) {
        return false;
      }
      if (vb3.has("#Copula")) {
        return true;
      }
      if (vb3.has("#PresentTense") && !vb3.has("#Infinitive") && vb3.lookBefore("(he|she|it|that|which)$").found) {
        return false;
      }
      return true;
    });
    if (toChange.found) {
      toChange.forEach((m6) => {
        if (m6.has("#Copula")) {
          m6.match("was").replaceWith("is");
          m6.match("is").replaceWith("will be");
          return;
        }
        m6.toInfinitive();
      });
    }
  }
  return s5;
};
var toFuture_default = toFuture;

// node_modules/compromise/src/3-three/sentences/conjugate/toNegative.js
var toNegative = function(s5) {
  s5.verbs().first().toNegative().compute("chunks");
  return s5;
};
var toPositive = function(s5) {
  s5.verbs().first().toPositive().compute("chunks");
  return s5;
};

// node_modules/compromise/src/3-three/sentences/conjugate/toInfinitive.js
var toInfinitive2 = function(s5) {
  s5.verbs().toInfinitive();
  return s5;
};
var toInfinitive_default2 = toInfinitive2;

// node_modules/compromise/src/3-three/sentences/api.js
var api14 = function(View2) {
  class Sentences extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Sentences";
    }
    json(opts2 = {}) {
      return this.map((m6) => {
        let json = m6.toView().json(opts2)[0] || {};
        let { subj, verb, pred, grammar: grammar2 } = parse_default6(m6);
        json.sentence = {
          subject: subj.text("normal"),
          verb: verb.text("normal"),
          predicate: pred.text("normal"),
          grammar: grammar2
        };
        return json;
      }, []);
    }
    toPastTense(n5) {
      return this.getNth(n5).map((s5) => {
        let parsed = parse_default6(s5);
        return toPast_default(s5, parsed);
      });
    }
    toPresentTense(n5) {
      return this.getNth(n5).map((s5) => {
        let parsed = parse_default6(s5);
        return toPresent_default(s5, parsed);
      });
    }
    toFutureTense(n5) {
      return this.getNth(n5).map((s5) => {
        let parsed = parse_default6(s5);
        s5 = toFuture_default(s5, parsed);
        return s5;
      });
    }
    toInfinitive(n5) {
      return this.getNth(n5).map((s5) => {
        let parsed = parse_default6(s5);
        return toInfinitive_default2(s5, parsed);
      });
    }
    toNegative(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toNegative(vb3, parsed);
      });
    }
    toPositive(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default6(vb3);
        return toPositive(vb3, parsed);
      });
    }
    isQuestion(n5) {
      return this.questions(n5);
    }
    isExclamation(n5) {
      let res = this.filter((s5) => s5.lastTerm().has("@hasExclamation"));
      return res.getNth(n5);
    }
    isStatement(n5) {
      let res = this.filter((s5) => !s5.isExclamation().found && !s5.isQuestion().found);
      return res.getNth(n5);
    }
    // overloaded - keep Sentences class
    update(pointer) {
      let m6 = new Sentences(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  Sentences.prototype.toPresent = Sentences.prototype.toPresentTense;
  Sentences.prototype.toPast = Sentences.prototype.toPastTense;
  Sentences.prototype.toFuture = Sentences.prototype.toFutureTense;
  const methods17 = {
    sentences: function(n5) {
      let m6 = this.map((s5) => s5.fullSentence());
      m6 = m6.getNth(n5);
      return new Sentences(this.document, m6.pointer);
    },
    questions: function(n5) {
      let m6 = questions_default(this);
      return m6.getNth(n5);
    }
  };
  Object.assign(View2.prototype, methods17);
};
var api_default17 = api14;

// node_modules/compromise/src/3-three/sentences/plugin.js
var plugin_default27 = { api: api_default17 };

// node_modules/compromise/src/3-three/topics/people/find.js
var find5 = function(doc) {
  let m6 = doc.match("#Honorific+? #Person+");
  let poss = m6.match("#Possessive").notIf("(his|her)");
  m6 = m6.splitAfter(poss);
  return m6;
};
var find_default4 = find5;

// node_modules/compromise/src/3-three/topics/people/parse.js
var parse6 = function(m6) {
  let res = {};
  res.firstName = m6.match("#FirstName+");
  res.lastName = m6.match("#LastName+");
  res.honorific = m6.match("#Honorific+");
  let last = res.lastName;
  let first = res.firstName;
  if (!first.found || !last.found) {
    if (!first.found && !last.found && m6.has("^#Honorific .$")) {
      res.lastName = m6.match(".$");
      return res;
    }
  }
  return res;
};
var parse_default7 = parse6;

// node_modules/compromise/src/3-three/topics/people/gender.js
var m2 = "male";
var f2 = "female";
var honorifics = {
  mr: m2,
  mrs: f2,
  miss: f2,
  madam: f2,
  // british stuff
  king: m2,
  queen: f2,
  duke: m2,
  duchess: f2,
  baron: m2,
  baroness: f2,
  count: m2,
  countess: f2,
  prince: m2,
  princess: f2,
  sire: m2,
  dame: f2,
  lady: f2,
  ayatullah: m2,
  //i think?
  congressman: m2,
  congresswoman: f2,
  "first lady": f2,
  // marked as non-binary
  mx: null
};
var predictGender = function(parsed, person) {
  let { firstName, honorific } = parsed;
  if (firstName.has("#FemaleName")) {
    return f2;
  }
  if (firstName.has("#MaleName")) {
    return m2;
  }
  if (honorific.found) {
    let hon = honorific.text("normal");
    hon = hon.replace(/\./g, "");
    if (honorifics.hasOwnProperty(hon)) {
      return honorifics[hon];
    }
    if (/^her /.test(hon)) {
      return f2;
    }
    if (/^his /.test(hon)) {
      return m2;
    }
  }
  let after2 = person.after();
  if (!after2.has("#Person") && after2.has("#Pronoun")) {
    let pro = after2.match("#Pronoun");
    if (pro.has("(they|their)")) {
      return null;
    }
    let hasMasc = pro.has("(he|his)");
    let hasFem = pro.has("(she|her|hers)");
    if (hasMasc && !hasFem) {
      return m2;
    }
    if (hasFem && !hasMasc) {
      return f2;
    }
  }
  return null;
};
var gender_default = predictGender;

// node_modules/compromise/src/3-three/topics/people/api.js
var addMethod2 = function(View2) {
  class People extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "People";
    }
    parse(n5) {
      return this.getNth(n5).map(parse_default7);
    }
    json(n5) {
      let opts2 = typeof n5 === "object" ? n5 : {};
      return this.getNth(n5).map((p7) => {
        let json = p7.toView().json(opts2)[0];
        let parsed = parse_default7(p7);
        json.person = {
          firstName: parsed.firstName.text("normal"),
          lastName: parsed.lastName.text("normal"),
          honorific: parsed.honorific.text("normal"),
          presumed_gender: gender_default(parsed, p7)
        };
        return json;
      }, []);
    }
    // used for co-reference resolution only
    presumedMale() {
      return this.filter((m6) => {
        return m6.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)");
      });
    }
    presumedFemale() {
      return this.filter((m6) => {
        return m6.has("(#FemaleName|mrs|miss|queen|princess|madam)");
      });
    }
    // overloaded - keep People class
    update(pointer) {
      let m6 = new People(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  View2.prototype.people = function(n5) {
    let m6 = find_default4(this);
    m6 = m6.getNth(n5);
    return new People(this.document, m6.pointer);
  };
};
var api_default18 = addMethod2;

// node_modules/compromise/src/3-three/topics/places/find.js
var find6 = function(doc) {
  let m6 = doc.match("(#Place|#Address)+");
  let splits = m6.match("@hasComma");
  splits = splits.filter((c5) => {
    if (c5.has("(asia|africa|europe|america)$")) {
      return true;
    }
    if (c5.has("(#City|#Region|#ProperNoun)$") && c5.after("^(#Country|#Region)").found) {
      return false;
    }
    return true;
  });
  m6 = m6.splitAfter(splits);
  return m6;
};
var find_default5 = find6;

// node_modules/compromise/src/3-three/topics/places/api.js
var addMethod3 = function(View2) {
  View2.prototype.places = function(n5) {
    let m6 = find_default5(this);
    m6 = m6.getNth(n5);
    return new View2(this.document, m6.pointer);
  };
};
var api_default19 = addMethod3;

// node_modules/compromise/src/3-three/topics/orgs/api.js
var api15 = function(View2) {
  View2.prototype.organizations = function(n5) {
    let m6 = this.match("#Organization+");
    return m6.getNth(n5);
  };
};
var api_default20 = api15;

// node_modules/compromise/src/3-three/topics/topics.js
var find7 = function(n5) {
  let r3 = this.clauses();
  let m6 = r3.people();
  m6 = m6.concat(r3.places());
  m6 = m6.concat(r3.organizations());
  m6 = m6.not("(someone|man|woman|mother|brother|sister|father)");
  m6 = m6.sort("seq");
  m6 = m6.getNth(n5);
  return m6;
};
var api16 = function(View2) {
  View2.prototype.topics = find7;
};
var topics_default = api16;

// node_modules/compromise/src/3-three/topics/plugin.js
var api17 = function(View2) {
  api_default18(View2);
  api_default19(View2);
  api_default20(View2);
  topics_default(View2);
};
var plugin_default28 = { api: api17 };

// node_modules/compromise/src/3-three/verbs/find.js
var findVerbs = function(doc) {
  let m6 = doc.match("<Verb>");
  m6 = m6.not("#Conjunction");
  m6 = m6.not("#Preposition");
  m6 = m6.splitAfter("@hasComma");
  m6 = m6.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0);
  m6 = m6.splitBefore("(#Verb && !#Copula) [being] #Verb", 0);
  m6 = m6.splitBefore("#Verb [to be] #Verb", 0);
  m6 = m6.splitAfter("[help] #PresentTense", 0);
  m6 = m6.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0);
  m6 = m6.splitBefore("(#PresentTense|#PastTense) [will be]$", 0);
  m6 = m6.splitBefore("(#PresentTense|#PastTense) [(had|has)]", 0);
  m6 = m6.not("#Reflexive$");
  m6 = m6.not("#Adjective");
  m6 = m6.splitAfter("[#PastTense] #PastTense", 0);
  m6 = m6.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0);
  m6 = m6.splitAfter("#Copula [#Gerund] #PastTense", 0);
  m6 = m6.if("#Verb");
  if (m6.has("(#Verb && !#Auxiliary) #Adverb+? #Copula")) {
    m6 = m6.splitBefore("#Copula");
  }
  return m6;
};
var find_default6 = findVerbs;

// node_modules/compromise/src/3-three/verbs/api/parse/root.js
var getMain = function(vb3) {
  let root = vb3;
  if (vb3.wordCount() > 1) {
    root = vb3.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)");
  }
  if (root.length > 1 && !root.has("#Phrasal #Particle")) {
    root = root.last();
  }
  root = root.not("(want|wants|wanted) to");
  if (!root.found) {
    root = vb3.not("#Negative");
    return root;
  }
  return root;
};
var root_default2 = getMain;

// node_modules/compromise/src/3-three/verbs/api/parse/adverbs.js
var getAdverbs = function(vb3, root) {
  let res = {
    pre: vb3.none(),
    post: vb3.none()
  };
  if (!vb3.has("#Adverb")) {
    return res;
  }
  let parts = vb3.splitOn(root);
  if (parts.length === 3) {
    return {
      pre: parts.eq(0).adverbs(),
      post: parts.eq(2).adverbs()
    };
  }
  if (parts.eq(0).isDoc(root)) {
    res.post = parts.eq(1).adverbs();
    return res;
  }
  res.pre = parts.eq(0).adverbs();
  return res;
};
var adverbs_default = getAdverbs;

// node_modules/compromise/src/3-three/verbs/api/parse/index.js
var getAuxiliary = function(vb3, root) {
  let parts = vb3.splitBefore(root);
  if (parts.length <= 1) {
    return vb3.none();
  }
  let aux = parts.eq(0);
  aux = aux.not("(#Adverb|#Negative|#Prefix)");
  return aux;
};
var getNegative = function(vb3) {
  return vb3.match("#Negative");
};
var getPhrasal = function(root) {
  if (!root.has("(#Particle|#PhrasalVerb)")) {
    return {
      verb: root.none(),
      particle: root.none()
    };
  }
  let particle = root.match("#Particle$");
  return {
    verb: root.not(particle),
    particle
  };
};
var parseVerb = function(view) {
  let vb3 = view.clone();
  vb3.contractions().expand();
  const root = root_default2(vb3);
  let res = {
    root,
    prefix: vb3.match("#Prefix"),
    adverbs: adverbs_default(vb3, root),
    auxiliary: getAuxiliary(vb3, root),
    negative: getNegative(vb3),
    phrasal: getPhrasal(root)
  };
  return res;
};
var parse_default8 = parseVerb;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/forms.js
var present = { tense: "PresentTense" };
var conditional = { conditional: true };
var future = { tense: "FutureTense" };
var prog = { progressive: true };
var past2 = { tense: "PastTense" };
var complete = { complete: true, progressive: false };
var passive = { passive: true };
var plural = { plural: true };
var singular = { plural: false };
var getData = function(tags) {
  let data = {};
  tags.forEach((o4) => {
    Object.assign(data, o4);
  });
  return data;
};
var verbForms = {
  // === Simple ===
  "imperative": [
    // walk!
    ["#Imperative", []]
  ],
  "want-infinitive": [
    ["^(want|wants|wanted) to #Infinitive$", [present]],
    ["^wanted to #Infinitive$", [past2]],
    ["^will want to #Infinitive$", [future]]
  ],
  "gerund-phrase": [
    // started looking
    ["^#PastTense #Gerund$", [past2]],
    // starts looking
    ["^#PresentTense #Gerund$", [present]],
    // start looking
    ["^#Infinitive #Gerund$", [present]],
    // will start looking
    ["^will #Infinitive #Gerund$", [future]],
    // have started looking
    ["^have #PastTense #Gerund$", [past2]],
    // will have started looking
    ["^will have #PastTense #Gerund$", [past2]]
  ],
  "simple-present": [
    // he walks',
    ["^#PresentTense$", [present]],
    // we walk
    ["^#Infinitive$", [present]]
  ],
  "simple-past": [
    // he walked',
    ["^#PastTense$", [past2]]
  ],
  "simple-future": [
    // he will walk
    ["^will #Adverb? #Infinitive", [future]]
  ],
  // === Progressive ===
  "present-progressive": [
    // he is walking
    ["^(is|are|am) #Gerund$", [present, prog]]
  ],
  "past-progressive": [
    // he was walking
    ["^(was|were) #Gerund$", [past2, prog]]
  ],
  "future-progressive": [
    // he will be
    ["^will be #Gerund$", [future, prog]]
  ],
  // === Perfect ===
  "present-perfect": [
    // he has walked
    ["^(has|have) #PastTense$", [past2, complete]]
    //past?
  ],
  "past-perfect": [
    // he had walked
    ["^had #PastTense$", [past2, complete]],
    // had been to see
    ["^had #PastTense to #Infinitive", [past2, complete]]
  ],
  "future-perfect": [
    // he will have
    ["^will have #PastTense$", [future, complete]]
  ],
  // === Progressive-perfect ===
  "present-perfect-progressive": [
    // he has been walking
    ["^(has|have) been #Gerund$", [past2, prog]]
    //present?
  ],
  "past-perfect-progressive": [
    // he had been
    ["^had been #Gerund$", [past2, prog]]
  ],
  "future-perfect-progressive": [
    // will have been
    ["^will have been #Gerund$", [future, prog]]
  ],
  // ==== Passive ===
  "passive-past": [
    // got walked, was walked, were walked
    ["(got|were|was) #Passive", [past2, passive]],
    // was being walked
    ["^(was|were) being #Passive", [past2, passive]],
    // had been walked, have been eaten
    ["^(had|have) been #Passive", [past2, passive]]
  ],
  "passive-present": [
    // is walked, are stolen
    ["^(is|are|am) #Passive", [present, passive]],
    // is being walked
    ["^(is|are|am) being #Passive", [present, passive]],
    // has been cleaned
    ["^has been #Passive", [present, passive]]
  ],
  "passive-future": [
    // will have been walked
    ["will have been #Passive", [future, passive, conditional]],
    // will be cleaned
    ["will be being? #Passive", [future, passive, conditional]]
  ],
  // === Conditional ===
  "present-conditional": [
    // would be walked
    ["would be #PastTense", [present, conditional]]
  ],
  "past-conditional": [
    // would have been walked
    ["would have been #PastTense", [past2, conditional]]
  ],
  // ==== Auxiliary ===
  "auxiliary-future": [
    // going to drink
    ["(is|are|am|was) going to (#Infinitive|#PresentTense)", [future]]
  ],
  "auxiliary-past": [
    // he did walk
    ["^did #Infinitive$", [past2, singular]],
    // used to walk
    ["^used to #Infinitive$", [past2, complete]]
  ],
  "auxiliary-present": [
    // we do walk
    ["^(does|do) #Infinitive$", [present, complete, plural]]
  ],
  // === modals ===
  "modal-past": [
    // he could have walked
    ["^(could|must|should|shall) have #PastTense$", [past2]]
  ],
  "modal-infinitive": [
    // he can walk
    ["^#Modal #Infinitive$", []]
  ],
  "infinitive": [
    // walk
    ["^#Infinitive$", []]
  ]
};
var list3 = [];
Object.keys(verbForms).map((k3) => {
  verbForms[k3].forEach((a4) => {
    list3.push({
      name: k3,
      match: a4[0],
      data: getData(a4[1])
    });
  });
});
var forms_default = list3;

// node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js
var cleanUp2 = function(vb3, res) {
  vb3 = vb3.clone();
  if (res.adverbs.post && res.adverbs.post.found) {
    vb3.remove(res.adverbs.post);
  }
  if (res.adverbs.pre && res.adverbs.pre.found) {
    vb3.remove(res.adverbs.pre);
  }
  if (vb3.has("#Negative")) {
    vb3 = vb3.remove("#Negative");
  }
  if (vb3.has("#Prefix")) {
    vb3 = vb3.remove("#Prefix");
  }
  if (res.root.has("#PhrasalVerb #Particle")) {
    vb3.remove("#Particle$");
  }
  vb3 = vb3.not("#Adverb");
  return vb3;
};
var isInfinitive = function(vb3) {
  if (vb3.has("#Infinitive")) {
    let m6 = vb3.growLeft("to");
    if (m6.has("^to #Infinitive")) {
      return true;
    }
  }
  return false;
};
var getGrammar = function(vb3, res) {
  let grammar2 = {};
  vb3 = cleanUp2(vb3, res);
  for (let i5 = 0; i5 < forms_default.length; i5 += 1) {
    let todo = forms_default[i5];
    if (vb3.has(todo.match) === true) {
      grammar2.form = todo.name;
      Object.assign(grammar2, todo.data);
      break;
    }
  }
  if (!grammar2.form) {
    if (vb3.has("^#Verb$")) {
      grammar2.form = "infinitive";
    }
  }
  if (!grammar2.tense) {
    grammar2.tense = res.root.has("#PastTense") ? "PastTense" : "PresentTense";
  }
  grammar2.copula = res.root.has("#Copula");
  grammar2.isInfinitive = isInfinitive(vb3);
  return grammar2;
};
var grammar_default = getGrammar;

// node_modules/compromise/src/3-three/verbs/api/parse/getSubject.js
var shouldSkip = function(last) {
  if (last.length <= 1) {
    return false;
  }
  let obj = last.parse()[0] || {};
  return obj.isSubordinate;
};
var noSubClause = function(before2) {
  let parts = before2.clauses();
  parts = parts.filter((m6, i5) => {
    if (m6.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)")) {
      return false;
    }
    if (i5 > 0 && m6.has("^#Verb . #Noun+$")) {
      return false;
    }
    if (i5 > 0 && m6.has("^#Adverb")) {
      return false;
    }
    return true;
  });
  if (parts.length === 0) {
    return before2;
  }
  return parts;
};
var lastNoun2 = function(vb3) {
  let before2 = vb3.before();
  before2 = noSubClause(before2);
  let nouns = before2.nouns();
  let last = nouns.last();
  let pronoun = last.match("(i|he|she|we|you|they)");
  if (pronoun.found) {
    return pronoun.nouns();
  }
  let det = nouns.if("^(that|this|those)");
  if (det.found) {
    return det;
  }
  if (nouns.found === false) {
    det = before2.match("^(that|this|those)");
    if (det.found) {
      return det;
    }
  }
  last = nouns.last();
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  if (shouldSkip(last)) {
    nouns.remove(last);
    last = nouns.last();
  }
  return last;
};
var isPlural3 = function(subj, vb3) {
  if (vb3.has("(are|were|does)")) {
    return true;
  }
  if (subj.has("(those|they|we)")) {
    return true;
  }
  if (subj.found && subj.isPlural) {
    return subj.isPlural().found;
  }
  return false;
};
var getSubject = function(vb3) {
  let subj = lastNoun2(vb3);
  return {
    subject: subj,
    plural: isPlural3(subj, vb3)
  };
};
var getSubject_default = getSubject;

// node_modules/compromise/src/3-three/verbs/api/lib.js
var noop = (vb3) => vb3;
var isPlural4 = (vb3, parsed) => {
  let subj = getSubject_default(vb3, parsed);
  let m6 = subj.subject;
  if (m6.has("i") || m6.has("we")) {
    return true;
  }
  return subj.plural;
};
var wasWere = (vb3, parsed) => {
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (plural2 || subject.has("we")) {
    return "were";
  }
  return "was";
};
var isAreAm = function(vb3, parsed) {
  if (vb3.has("were")) {
    return "are";
  }
  let { subject, plural: plural2 } = getSubject_default(vb3, parsed);
  if (subject.has("i")) {
    return "am";
  }
  if (subject.has("we") || plural2) {
    return "are";
  }
  return "is";
};
var doDoes = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m6 = subj.subject;
  if (m6.has("i") || m6.has("we")) {
    return "do";
  }
  if (subj.plural) {
    return "do";
  }
  return "does";
};
var getTense2 = function(m6) {
  if (m6.has("#Infinitive")) {
    return "Infinitive";
  }
  if (m6.has("#Participle")) {
    return "Participle";
  }
  if (m6.has("#PastTense")) {
    return "PastTense";
  }
  if (m6.has("#Gerund")) {
    return "Gerund";
  }
  if (m6.has("#PresentTense")) {
    return "PresentTense";
  }
  return void 0;
};
var toInf = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  let str = parsed.root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(vb3));
  if (str) {
    vb3.replace(parsed.root, str);
  }
  return vb3;
};
var noWill = (vb3) => {
  if (vb3.has("will not")) {
    return vb3.replace("will not", "have not");
  }
  return vb3.remove("will");
};

// node_modules/compromise/src/3-three/verbs/api/toJSON.js
var toArray3 = function(m6) {
  if (!m6 || !m6.isView) {
    return [];
  }
  const opts2 = { normal: true, terms: false, text: false };
  return m6.json(opts2).map((s5) => s5.normal);
};
var toText4 = function(m6) {
  if (!m6 || !m6.isView) {
    return "";
  }
  return m6.text("normal");
};
var toInf2 = function(root) {
  const { toInfinitive: toInfinitive3 } = root.methods.two.transform.verb;
  let str = root.text("normal");
  return toInfinitive3(str, root.model, getTense2(root));
};
var toJSON3 = function(vb3) {
  let parsed = parse_default8(vb3);
  vb3 = vb3.clone().toView();
  const info = grammar_default(vb3, parsed);
  return {
    root: parsed.root.text(),
    preAdverbs: toArray3(parsed.adverbs.pre),
    postAdverbs: toArray3(parsed.adverbs.post),
    auxiliary: toText4(parsed.auxiliary),
    negative: parsed.negative.found,
    prefix: toText4(parsed.prefix),
    infinitive: toInf2(parsed.root),
    grammar: info
  };
};
var toJSON_default2 = toJSON3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toInfinitive.js
var keep3 = { tags: true };
var toInf3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let aux = auxiliary.terms().harden();
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3.replace(root, str, keep3).tag("Verb").firstTerm().tag("Infinitive");
  }
  if (aux.found) {
    vb3.remove(aux);
  }
  if (parsed.negative.found) {
    if (!vb3.has("not")) {
      vb3.prepend("not");
    }
    let does = doDoes(vb3, parsed);
    vb3.prepend(does);
  }
  vb3.fullSentence().compute(["lexicon", "preTagger", "postTagger", "chunks"]);
  return vb3;
};
var toInfinitive_default3 = toInf3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPast.js
var keep4 = { tags: true };
var fns6 = {
  noAux: (vb3, parsed) => {
    if (parsed.auxiliary.found) {
      vb3 = vb3.remove(parsed.auxiliary);
    }
    return vb3;
  },
  // walk->walked
  simple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    if (root.has("#Modal")) {
      return vb3;
    }
    let str = root.text({ keepPunct: false });
    str = toInfinitive3(str, vb3.model, getTense2(root));
    let all4 = conjugate2(str, vb3.model);
    str = all4.PastTense;
    str = str === "been" ? "was" : str;
    if (str === "was") {
      str = wasWere(vb3, parsed);
    }
    if (str) {
      vb3.replace(root, str, keep4);
    }
    return vb3;
  },
  both: function(vb3, parsed) {
    if (parsed.negative.found) {
      vb3.replace("will", "did");
      return vb3;
    }
    vb3 = fns6.simple(vb3, parsed);
    vb3 = fns6.noAux(vb3, parsed);
    return vb3;
  },
  hasHad: (vb3) => {
    vb3.replace("has", "had", keep4);
    return vb3;
  },
  // some verbs have this weird past-tense form
  // drive -> driven, (!drove)
  hasParticiple: (vb3, parsed) => {
    const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
    const root = parsed.root;
    let str = root.text("normal");
    str = toInfinitive3(str, vb3.model, getTense2(root));
    return conjugate2(str, vb3.model).Participle;
  }
};
var forms = {
  // walk -> walked
  "infinitive": fns6.simple,
  // he walks -> he walked
  "simple-present": fns6.simple,
  // he walked
  "simple-past": noop,
  // he will walk -> he walked
  "simple-future": fns6.both,
  // he is walking
  "present-progressive": (vb3) => {
    vb3.replace("are", "were", keep4);
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // he was walking
  "past-progressive": noop,
  // he will be walking
  "future-progressive": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("was");
    vb3.remove("(will|be)");
    return vb3;
  },
  // has walked -> had walked (?)
  "present-perfect": fns6.hasHad,
  // had walked
  "past-perfect": noop,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => {
    vb3.match(parsed.root).insertBefore("had");
    if (vb3.has("will")) {
      vb3 = noWill(vb3);
    }
    vb3.remove("have");
    return vb3;
  },
  // has been walking -> had been
  "present-perfect-progressive": fns6.hasHad,
  // had been walking
  "past-perfect-progressive": noop,
  // will have been -> had
  "future-perfect-progressive": (vb3) => {
    vb3.remove("will");
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // got walked
  "passive-past": (vb3) => {
    vb3.replace("have", "had", keep4);
    return vb3;
  },
  // is being walked  -> 'was being walked'
  "passive-present": (vb3) => {
    vb3.replace("(is|are)", "was", keep4);
    return vb3;
  },
  // will be walked -> had been walked
  "passive-future": (vb3, parsed) => {
    if (parsed.auxiliary.has("will be")) {
      vb3.match(parsed.root).insertBefore("had been");
      vb3.remove("(will|be)");
    }
    if (parsed.auxiliary.has("will have been")) {
      vb3.replace("have", "had", keep4);
      vb3.remove("will");
    }
    return vb3;
  },
  // would be walked -> 'would have been walked'
  "present-conditional": (vb3) => {
    vb3.replace("be", "have been");
    return vb3;
  },
  // would have been walked
  "past-conditional": noop,
  // is going to drink -> was going to drink
  "auxiliary-future": (vb3) => {
    vb3.replace("(is|are|am)", "was", keep4);
    return vb3;
  },
  // used to walk
  "auxiliary-past": noop,
  // we do walk -> we did walk
  "auxiliary-present": (vb3) => {
    vb3.replace("(do|does)", "did", keep4);
    return vb3;
  },
  // must walk -> 'must have walked'
  "modal-infinitive": (vb3, parsed) => {
    if (vb3.has("can")) {
      vb3.replace("can", "could", keep4);
    } else {
      fns6.simple(vb3, parsed);
      vb3.match("#Modal").insertAfter("have").tag("Auxiliary");
    }
    return vb3;
  },
  // must have walked
  "modal-past": noop,
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants)", "wanted", keep4);
    vb3.remove("will");
    return vb3;
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    fns6.simple(vb3, parsed);
    noWill(vb3);
    return vb3;
  }
};
var toPast3 = function(vb3, parsed, form) {
  if (forms.hasOwnProperty(form)) {
    vb3 = forms[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPast_default2 = toPast3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toParticiple.js
var haveHas = function(vb3, parsed) {
  let subj = getSubject_default(vb3, parsed);
  let m6 = subj.subject;
  if (m6.has("(i|we|you)")) {
    return "have";
  }
  if (subj.plural === false) {
    return "has";
  }
  if (m6.has("he") || m6.has("she") || m6.has("#Person")) {
    return "has";
  }
  return "have";
};
var simple = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (root.has("#Modal")) {
    return vb3;
  }
  let str = root.text({ keepPunct: false });
  str = toInfinitive3(str, vb3.model, getTense2(root));
  let all4 = conjugate2(str, vb3.model);
  str = all4.Participle || all4.PastTense;
  if (str) {
    vb3 = vb3.replace(root, str);
    let have = haveHas(vb3, parsed);
    vb3.prepend(have).match(have).tag("Auxiliary");
    vb3.remove(auxiliary);
  }
  return vb3;
};
var forms2 = {
  // walk -> walked
  "infinitive": simple,
  // he walks -> he walked
  "simple-present": simple,
  // he walked
  // 'simple-past': noop,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => vb3.replace("will", haveHas(vb3, parsed)),
  // he is walking
  // 'present-progressive': noop,
  // he was walking
  // 'past-progressive': noop,
  // he will be walking
  // 'future-progressive': noop,
  // has walked -> had walked (?)
  "present-perfect": noop,
  // had walked
  "past-perfect": noop,
  // will have walked -> had walked
  "future-perfect": (vb3, parsed) => vb3.replace("will have", haveHas(vb3, parsed)),
  // has been walking -> had been
  "present-perfect-progressive": noop,
  // had been walking
  "past-perfect-progressive": noop,
  // will have been -> had
  "future-perfect-progressive": noop
  // got walked
  // 'passive-past': noop,
  // is being walked  -> 'was being walked'
  // 'passive-present': noop,
  // will be walked -> had been walked
  // 'passive-future': noop,
  // would be walked -> 'would have been walked'
  // 'present-conditional': noop,
  // would have been walked
  // 'past-conditional': noop,
  // is going to drink -> was going to drink
  // 'auxiliary-future': noop,
  // used to walk
  // 'auxiliary-past': noop,
  // we do walk -> we did walk
  // 'auxiliary-present': noop,
  // must walk -> 'must have walked'
  // 'modal-infinitive': noop,
  // must have walked
  // 'modal-past': noop,
  // wanted to walk
  // 'want-infinitive': noop,
  // started looking
  // 'gerund-phrase': noop,
};
var toPast4 = function(vb3, parsed, form) {
  if (forms2.hasOwnProperty(form)) {
    vb3 = forms2[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  vb3 = simple(vb3, parsed, form);
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toParticiple_default = toPast4;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toPresent.js
var keep5 = { tags: true };
var simple2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).PresentTense;
  }
  if (root.has("#Copula")) {
    str = isAreAm(vb3, parsed);
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("PresentTense");
  }
  return vb3;
};
var toGerund2 = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (isPlural4(vb3, parsed) === false) {
    str = conjugate2(str, vb3.model).Gerund;
  }
  if (str) {
    vb3 = vb3.replace(root, str, keep5);
    vb3.not("#Particle").tag("Gerund");
  }
  return vb3;
};
var vbToInf = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const root = parsed.root;
  let str = parsed.root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(parsed.root, str, keep5);
  }
  return vb3;
};
var forms3 = {
  // walk
  "infinitive": simple2,
  // he walks -> he walked
  "simple-present": (vb3, parsed) => {
    const { conjugate: conjugate2 } = vb3.methods.two.transform.verb;
    let { root } = parsed;
    if (root.has("#Infinitive")) {
      let subj = getSubject_default(vb3, parsed);
      let m6 = subj.subject;
      if (isPlural4(vb3, parsed) || m6.has("i")) {
        return vb3;
      }
      let str = root.text("normal");
      let pres = conjugate2(str, vb3.model).PresentTense;
      if (str !== pres) {
        vb3.replace(root, pres, keep5);
      }
    } else {
      return simple2(vb3, parsed);
    }
    return vb3;
  },
  // he walked
  "simple-past": simple2,
  // he will walk -> he walked
  "simple-future": (vb3, parsed) => {
    const { root, auxiliary } = parsed;
    if (auxiliary.has("will") && root.has("be")) {
      let str = isAreAm(vb3, parsed);
      vb3.replace(root, str);
      vb3 = vb3.remove("will");
      vb3.replace("not " + str, str + " not");
    } else {
      simple2(vb3, parsed);
      vb3 = vb3.remove("will");
    }
    return vb3;
  },
  // is walking ->
  "present-progressive": noop,
  // was walking -> is walking
  "past-progressive": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    return vb3.replace("(were|was)", str, keep5);
  },
  // will be walking -> is walking
  "future-progressive": (vb3) => {
    vb3.match("will").insertBefore("is");
    vb3.remove("be");
    return vb3.remove("will");
  },
  // has walked ->  (?)
  "present-perfect": (vb3, parsed) => {
    simple2(vb3, parsed);
    vb3 = vb3.remove("(have|had|has)");
    return vb3;
  },
  // had walked -> has walked
  "past-perfect": (vb3, parsed) => {
    let subj = getSubject_default(vb3, parsed);
    let m6 = subj.subject;
    if (isPlural4(vb3, parsed) || m6.has("i")) {
      vb3 = toInf(vb3, parsed);
      vb3.remove("had");
      return vb3;
    }
    vb3.replace("had", "has", keep5);
    return vb3;
  },
  // will have walked -> has walked
  "future-perfect": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // has been walking
  "present-perfect-progressive": noop,
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "has", keep5),
  // will have been -> has been
  "future-perfect-progressive": (vb3) => {
    vb3.match("will").insertBefore("has");
    return vb3.remove("have").remove("will");
  },
  // got walked -> is walked
  // was walked -> is walked
  // had been walked -> is walked
  "passive-past": (vb3, parsed) => {
    let str = isAreAm(vb3, parsed);
    if (vb3.has("(had|have|has)") && vb3.has("been")) {
      vb3.replace("(had|have|has)", str, keep5);
      vb3.replace("been", "being");
      return vb3;
    }
    return vb3.replace("(got|was|were)", str);
  },
  // is being walked  ->
  "passive-present": noop,
  // will be walked -> is being walked
  "passive-future": (vb3) => {
    vb3.replace("will", "is");
    return vb3.replace("be", "being");
  },
  // would be walked ->
  "present-conditional": noop,
  // would have been walked ->
  "past-conditional": (vb3) => {
    vb3.replace("been", "be");
    return vb3.remove("have");
  },
  // is going to drink -> is drinking
  "auxiliary-future": (vb3, parsed) => {
    toGerund2(vb3, parsed);
    vb3.remove("(going|to)");
    return vb3;
  },
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3, parsed) => {
    if (parsed.auxiliary.has("did")) {
      let str = doDoes(vb3, parsed);
      vb3.replace(parsed.auxiliary, str);
      return vb3;
    }
    toGerund2(vb3, parsed);
    vb3.replace(parsed.auxiliary, "is");
    return vb3;
  },
  // we do walk ->
  "auxiliary-present": noop,
  // must walk -> 'must have walked'
  "modal-infinitive": noop,
  // must have walked
  "modal-past": (vb3, parsed) => {
    vbToInf(vb3, parsed);
    return vb3.remove("have");
  },
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple2(vb3, parsed);
    return vb3.remove("(will|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3, parsed) => {
    let str = "wants";
    if (isPlural4(vb3, parsed)) {
      str = "want";
    }
    vb3.replace("(want|wanted|wants)", str, keep5);
    vb3.remove("will");
    return vb3;
  }
};
var toPresent3 = function(vb3, parsed, form) {
  if (forms3.hasOwnProperty(form)) {
    vb3 = forms3[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toPresent_default2 = toPresent3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toFuture.js
var keep6 = { tags: true };
var simple3 = (vb3, parsed) => {
  const { toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (root.has("#Modal")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    vb3 = vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("Verb");
  }
  vb3.prepend("will").match("will").tag("Auxiliary");
  vb3.remove(auxiliary);
  return vb3;
};
var progressive = (vb3, parsed) => {
  const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  if (str) {
    str = conjugate2(str, vb3.model).Gerund;
    vb3.replace(root, str, keep6);
    vb3.not("#Particle").tag("PresentTense");
  }
  vb3.remove(auxiliary);
  vb3.prepend("will be").match("will be").tag("Auxiliary");
  return vb3;
};
var forms4 = {
  // walk ->
  "infinitive": simple3,
  // he walks ->
  "simple-present": simple3,
  // he walked
  "simple-past": simple3,
  // he will walk ->
  "simple-future": noop,
  // is walking ->
  "present-progressive": progressive,
  // was walking ->
  "past-progressive": progressive,
  // will be walking ->
  "future-progressive": noop,
  // has walked ->
  "present-perfect": (vb3) => {
    vb3.match("(have|has)").replaceWith("will have");
    return vb3;
  },
  // had walked ->
  "past-perfect": (vb3) => vb3.replace("(had|has)", "will have"),
  // will have walked ->
  "future-perfect": noop,
  // has been walking
  "present-perfect-progressive": (vb3) => vb3.replace("has", "will have"),
  // had been walking
  "past-perfect-progressive": (vb3) => vb3.replace("had", "will have"),
  // will have been ->
  "future-perfect-progressive": noop,
  // got walked ->
  // was walked ->
  // was being walked ->
  // had been walked ->
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      return vb3.replace("got", "will get");
    }
    if (vb3.has("(was|were)")) {
      vb3.replace("(was|were)", "will be");
      return vb3.remove("being");
    }
    if (vb3.has("(have|has|had) been")) {
      return vb3.replace("(have|has|had) been", "will be");
    }
    return vb3;
  },
  // is being walked  ->
  "passive-present": (vb3) => {
    vb3.replace("being", "will be");
    vb3.remove("(is|are|am)");
    return vb3;
  },
  // will be walked ->
  "passive-future": noop,
  // would be walked ->
  "present-conditional": (vb3) => vb3.replace("would", "will"),
  // would have been walked ->
  "past-conditional": (vb3) => vb3.replace("would", "will"),
  // is going to drink ->
  "auxiliary-future": noop,
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (vb3) => {
    if (vb3.has("used") && vb3.has("to")) {
      vb3.replace("used", "will");
      return vb3.remove("to");
    }
    vb3.replace("did", "will");
    return vb3;
  },
  // we do walk ->
  // he does walk ->
  "auxiliary-present": (vb3) => {
    return vb3.replace("(do|does)", "will");
  },
  // must walk ->
  "modal-infinitive": noop,
  // must have walked
  "modal-past": noop,
  // started looking
  "gerund-phrase": (vb3, parsed) => {
    parsed.root = parsed.root.not("#Gerund$");
    simple3(vb3, parsed);
    return vb3.remove("(had|have)");
  },
  // wanted to walk
  "want-infinitive": (vb3) => {
    vb3.replace("(want|wants|wanted)", "will want");
    return vb3;
  }
};
var toFuture2 = function(vb3, parsed, form) {
  if (vb3.has("will") || vb3.has("going to")) {
    return vb3;
  }
  if (forms4.hasOwnProperty(form)) {
    vb3 = forms4[form](vb3, parsed);
    vb3.fullSentence().compute(["tagger", "chunks"]);
    return vb3;
  }
  return vb3;
};
var toFuture_default2 = toFuture2;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toGerund.js
var keep7 = { tags: true };
var toGerund3 = function(vb3, parsed) {
  const { toInfinitive: toInfinitive3, conjugate: conjugate2 } = vb3.methods.two.transform.verb;
  const { root, auxiliary } = parsed;
  if (vb3.has("#Gerund")) {
    return vb3;
  }
  let str = root.text("normal");
  str = toInfinitive3(str, vb3.model, getTense2(root));
  let gerund = conjugate2(str, vb3.model).Gerund;
  if (gerund) {
    let aux = isAreAm(vb3, parsed);
    vb3.replace(root, gerund, keep7);
    vb3.remove(auxiliary);
    vb3.prepend(aux);
  }
  vb3.replace("not is", "is not");
  vb3.replace("not are", "are not");
  vb3.fullSentence().compute(["tagger", "chunks"]);
  return vb3;
};
var toGerund_default = toGerund3;

// node_modules/compromise/src/3-three/verbs/api/conjugate/toNegative.js
var keep8 = { tags: true };
var doesNot = function(vb3, parsed) {
  let does = doDoes(vb3, parsed);
  vb3.prepend(does + " not");
  return vb3;
};
var isWas = function(vb3) {
  let m6 = vb3.match("be");
  if (m6.found) {
    m6.prepend("not");
    return vb3;
  }
  m6 = vb3.match("(is|was|am|are|will|were)");
  if (m6.found) {
    m6.append("not");
    return vb3;
  }
  return vb3;
};
var hasCopula = (vb3) => vb3.has("(is|was|am|are|will|were|be)");
var forms5 = {
  // he walks' -> 'he does not walk'
  "simple-present": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3 = doesNot(vb3, parsed);
    return vb3;
  },
  // 'he walked' -> 'he did not walk'
  "simple-past": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    vb3 = toInf(vb3, parsed);
    vb3.prepend("did not");
    return vb3;
  },
  // walk! -> 'do not walk'
  "imperative": (vb3) => {
    vb3.prepend("do not");
    return vb3;
  },
  // walk -> does not walk
  "infinitive": (vb3, parsed) => {
    if (hasCopula(vb3) === true) {
      return isWas(vb3, parsed);
    }
    return doesNot(vb3, parsed);
  },
  "passive-past": (vb3) => {
    if (vb3.has("got")) {
      vb3.replace("got", "get", keep8);
      vb3.prepend("did not");
      return vb3;
    }
    let m6 = vb3.match("(was|were|had|have)");
    if (m6.found) {
      m6.append("not");
    }
    return vb3;
  },
  "auxiliary-past": (vb3) => {
    if (vb3.has("used")) {
      vb3.prepend("did not");
      return vb3;
    }
    let m6 = vb3.match("(did|does|do)");
    if (m6.found) {
      m6.append("not");
    }
    return vb3;
  },
  // wants to walk
  "want-infinitive": (vb3, parsed) => {
    vb3 = doesNot(vb3, parsed);
    vb3 = vb3.replace("wants", "want", keep8);
    return vb3;
  }
};
var toNegative2 = function(vb3, parsed, form) {
  if (vb3.has("#Negative")) {
    return vb3;
  }
  if (forms5.hasOwnProperty(form)) {
    vb3 = forms5[form](vb3, parsed);
    return vb3;
  }
  let m6 = vb3.matchOne("be");
  if (m6.found) {
    m6.prepend("not");
    return vb3;
  }
  if (hasCopula(vb3) === true) {
    return isWas(vb3, parsed);
  }
  m6 = vb3.matchOne("(will|had|have|has|did|does|do|#Modal)");
  if (m6.found) {
    m6.append("not");
    return vb3;
  }
  return vb3;
};
var toNegative_default = toNegative2;

// node_modules/compromise/src/3-three/verbs/api/api.js
var api18 = function(View2) {
  class Verbs extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Verbs";
    }
    parse(n5) {
      return this.getNth(n5).map(parse_default8);
    }
    json(opts2, n5) {
      let m6 = this.getNth(n5);
      let arr = m6.map((vb3) => {
        let json = vb3.toView().json(opts2)[0] || {};
        json.verb = toJSON_default2(vb3);
        return json;
      }, []);
      return arr;
    }
    subjects(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        return getSubject_default(vb3, parsed).subject;
      });
    }
    adverbs(n5) {
      return this.getNth(n5).map((vb3) => vb3.match("#Adverb"));
    }
    isSingular(n5) {
      return this.getNth(n5).filter((vb3) => {
        return getSubject_default(vb3).plural !== true;
      });
    }
    isPlural(n5) {
      return this.getNth(n5).filter((vb3) => {
        return getSubject_default(vb3).plural === true;
      });
    }
    isImperative(n5) {
      return this.getNth(n5).filter((vb3) => vb3.has("#Imperative"));
    }
    toInfinitive(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toInfinitive_default3(vb3, parsed, info.form);
      });
    }
    toPresentTense(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPresent_default2(vb3, parsed, info.form);
      });
    }
    toPastTense(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toPast_default2(vb3, parsed, info.form);
      });
    }
    toFutureTense(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toFuture_default2(vb3, parsed, info.form);
      });
    }
    toGerund(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toGerund_default(vb3, parsed, info.form);
      });
    }
    toPastParticiple(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.isInfinitive) {
          return vb3;
        }
        return toParticiple_default(vb3, parsed, info.form);
      });
    }
    conjugate(n5) {
      const { conjugate: conjugate2, toInfinitive: toInfinitive3 } = this.world.methods.two.transform.verb;
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        if (info.form === "imperative") {
          info.form = "simple-present";
        }
        let inf = parsed.root.text("normal");
        if (!parsed.root.has("#Infinitive")) {
          let tense = getTense2(parsed.root);
          inf = toInfinitive3(inf, vb3.model, tense) || inf;
        }
        return conjugate2(inf, vb3.model);
      }, []);
    }
    /** return only verbs with 'not'*/
    isNegative() {
      return this.if("#Negative");
    }
    /**  return only verbs without 'not'*/
    isPositive() {
      return this.ifNo("#Negative");
    }
    /** remove 'not' from these verbs */
    toPositive() {
      let m6 = this.match("do not #Verb");
      if (m6.found) {
        m6.remove("do not");
      }
      return this.remove("#Negative");
    }
    toNegative(n5) {
      return this.getNth(n5).map((vb3) => {
        let parsed = parse_default8(vb3);
        let info = grammar_default(vb3, parsed);
        return toNegative_default(vb3, parsed, info.form);
      });
    }
    // overloaded - keep Verb class
    update(pointer) {
      let m6 = new Verbs(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  Verbs.prototype.toPast = Verbs.prototype.toPastTense;
  Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;
  Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;
  View2.prototype.verbs = function(n5) {
    let vb3 = find_default6(this);
    vb3 = vb3.getNth(n5);
    return new Verbs(this.document, vb3.pointer);
  };
};
var api_default21 = api18;

// node_modules/compromise/src/3-three/verbs/plugin.js
var plugin_default29 = {
  api: api_default21
};

// node_modules/compromise/src/3-three/coreference/compute/lib.js
var findChained = function(want, s5) {
  let m6 = s5.match(want);
  if (m6.found) {
    let ref = m6.pronouns().refersTo();
    if (ref.found) {
      return ref;
    }
  }
  return s5.none();
};
var prevSentence = function(m6) {
  if (!m6.found) {
    return m6;
  }
  let [n5] = m6.fullPointer[0];
  if (n5 && n5 > 0) {
    return m6.update([[n5 - 1]]);
  }
  return m6.none();
};

// node_modules/compromise/src/3-three/coreference/compute/findPerson.js
var byGender = function(ppl, gender) {
  if (gender === "m") {
    return ppl.filter((m6) => !m6.presumedFemale().found);
  } else if (gender === "f") {
    return ppl.filter((m6) => !m6.presumedMale().found);
  }
  return ppl;
};
var getPerson = function(s5, gender) {
  let people = s5.people();
  people = byGender(people, gender);
  if (people.found) {
    return people.last();
  }
  people = s5.nouns("#Actor");
  if (people.found) {
    return people.last();
  }
  if (gender === "f") {
    return findChained("(she|her|hers)", s5);
  }
  if (gender === "m") {
    return findChained("(he|him|his)", s5);
  }
  return s5.none();
};
var findPerson_default = getPerson;

// node_modules/compromise/src/3-three/coreference/compute/findThey.js
var getThey = function(s5) {
  let nouns = s5.nouns();
  let things = nouns.isPlural().notIf("#Pronoun");
  if (things.found) {
    return things.last();
  }
  let chain = findChained("(they|their|theirs)", s5);
  if (chain.found) {
    return chain;
  }
  things = nouns.match("(somebody|nobody|everybody|anybody|someone|noone|everyone|anyone)");
  if (things.found) {
    return things.last();
  }
  return s5.none();
};
var findThey_default = getThey;

// node_modules/compromise/src/3-three/coreference/compute/index.js
var addReference = function(pron, m6) {
  if (m6 && m6.found) {
    let term = pron.docs[0][0];
    term.reference = m6.ptrs[0];
  }
};
var stepBack = function(m6, cb) {
  let s5 = m6.before();
  let res = cb(s5);
  if (res.found) {
    return res;
  }
  s5 = prevSentence(m6);
  res = cb(s5);
  if (res.found) {
    return res;
  }
  s5 = prevSentence(s5);
  res = cb(s5);
  if (res.found) {
    return res;
  }
  return m6.none();
};
var coreference = function(view) {
  let pronouns = view.pronouns().if("(he|him|his|she|her|hers|they|their|theirs|it|its)");
  pronouns.forEach((pron) => {
    let res = null;
    if (pron.has("(he|him|his)")) {
      res = stepBack(pron, (m6) => findPerson_default(m6, "m"));
    } else if (pron.has("(she|her|hers)")) {
      res = stepBack(pron, (m6) => findPerson_default(m6, "f"));
    } else if (pron.has("(they|their|theirs)")) {
      res = stepBack(pron, findThey_default);
    }
    if (res && res.found) {
      addReference(pron, res);
    }
  });
};
var compute_default12 = coreference;

// node_modules/compromise/src/3-three/coreference/api/pronouns.js
var api19 = function(View2) {
  class Pronouns extends View2 {
    constructor(document2, pointer, groups) {
      super(document2, pointer, groups);
      this.viewType = "Pronouns";
    }
    hasReference() {
      this.compute("coreference");
      return this.filter((m6) => {
        let term = m6.docs[0][0];
        return term.reference;
      });
    }
    // get the noun-phrase this pronoun refers to
    refersTo() {
      this.compute("coreference");
      return this.map((m6) => {
        if (!m6.found) {
          return m6.none();
        }
        let term = m6.docs[0][0];
        if (term.reference) {
          return m6.update([term.reference]);
        }
        return m6.none();
      });
    }
    // overloaded - keep Numbers class
    update(pointer) {
      let m6 = new Pronouns(this.document, pointer);
      m6._cache = this._cache;
      return m6;
    }
  }
  View2.prototype.pronouns = function(n5) {
    let m6 = this.match("#Pronoun");
    m6 = m6.getNth(n5);
    return new Pronouns(m6.document, m6.pointer);
  };
};
var pronouns_default = api19;

// node_modules/compromise/src/3-three/coreference/plugin.js
var plugin_default30 = {
  compute: { coreference: compute_default12 },
  api: pronouns_default
};

// node_modules/compromise/src/three.js
two_default.plugin(plugin_default19);
two_default.plugin(plugin_default20);
two_default.plugin(plugin_default21);
two_default.plugin(plugin_default30);
two_default.plugin(plugin_default22);
two_default.plugin(plugin_default23);
two_default.plugin(plugin_default24);
two_default.plugin(plugin_default25);
two_default.plugin(plugin_default26);
two_default.plugin(plugin_default27);
two_default.plugin(plugin_default28);
two_default.plugin(plugin_default29);
var three_default = two_default;

// corpus.json
var corpus_default = [
  "#Pronoun #Verb #Determiner #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Adjective #Adjective #Value #Pronoun",
  "#Noun #Verb #Determiner #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Determiner #Adjective #Value #Noun",
  "#Noun #Verb #Adjective #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Adjective #Adjective #Value #Noun",
  "#Pronoun #Verb #Adverb #Adjective #Value #Pronoun",
  "#Noun #Verb #Determiner #Adjective #Value #Noun",
  "#Pronoun #Verb #Determiner #Adjective  #Pronoun",
  "#Pronoun #Verb #Verb #Adjective #Value #Pronoun",
  "#Noun #Verb #Adjective #Adjective #Value #Noun",
  "#Noun #Verb #Adverb #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Adjective #Adjective  #Pronoun",
  "#Pronoun #Verb #Adverb #Adjective #Value #Noun",
  "#Pronoun #Verb #Determiner #Adjective #Value ",
  "#Noun #Verb #Determiner #Adjective  #Pronoun",
  "#Noun #Verb #Verb #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Determiner #Adjective  #Noun",
  "#Pronoun #Verb #Adjective #Adjective #Value ",
  "#Pronoun #Verb #Verb #Adjective #Value #Noun",
  "#Noun #Verb #Adjective #Adjective  #Pronoun",
  "#Noun #Verb #Adverb #Adjective #Value #Noun",
  "#Pronoun #Verb #Determiner  #Value #Pronoun",
  "#Pronoun #Verb #Adjective #Adjective  #Noun",
  "#Pronoun #Verb #Adverb #Adjective  #Pronoun",
  "#Noun #Verb #Determiner #Adjective #Value ",
  "#Pronoun #Verb  #Adjective #Value #Pronoun",
  "#Pronoun #Verb #Adjective  #Value #Pronoun",
  "#Noun #Verb #Determiner #Adjective  #Noun",
  "#Noun #Verb #Adjective #Adjective #Value ",
  "#Noun #Verb #Verb #Adjective #Value #Noun",
  "#Pronoun #Verb #Adverb #Adjective #Value ",
  "#Pronoun #Verb #Verb #Adjective  #Pronoun",
  "#Noun #Verb #Determiner  #Value #Pronoun",
  "#Noun #Verb #Adjective #Adjective  #Noun",
  "#Noun #Verb #Adverb #Adjective  #Pronoun",
  "#Pronoun #Verb #Determiner  #Value #Noun",
  "#Pronoun #Verb #Adverb #Adjective  #Noun",
  "#Noun #Verb  #Adjective #Value #Pronoun",
  "#Noun #Verb #Adjective  #Value #Pronoun",
  "#Pronoun #Verb  #Adjective #Value #Noun",
  "#Pronoun #Verb #Determiner #Adjective  ",
  "#Pronoun #Verb #Adjective  #Value #Noun",
  "#Pronoun #Verb #Adverb  #Value #Pronoun",
  "#Pronoun #Verb #Verb #Adjective #Value ",
  "#Noun #Verb #Adverb #Adjective #Value ",
  "#Noun #Verb #Verb #Adjective  #Pronoun",
  "#Pronoun #Verb #Adjective #Adjective  ",
  "#Pronoun #Verb #Verb #Adjective  #Noun",
  "#Noun #Verb #Determiner  #Value #Noun",
  "#Noun #Verb #Adverb #Adjective  #Noun",
  "#Pronoun #Verb #Determiner   #Pronoun",
  "#Pronoun #Verb #Verb  #Value #Pronoun",
  "#Noun #Verb  #Adjective #Value #Noun",
  "#Noun #Verb #Determiner #Adjective  ",
  "#Noun #Verb #Adjective  #Value #Noun",
  "#Noun #Verb #Adverb  #Value #Pronoun",
  "#Noun #Verb #Verb #Adjective #Value ",
  "#Pronoun #Verb  #Adjective  #Pronoun",
  "#Pronoun #Verb #Adjective   #Pronoun",
  "#Pronoun #Verb #Adverb  #Value #Noun",
  "#Noun #Verb #Adjective #Adjective  ",
  "#Noun #Verb #Verb #Adjective  #Noun",
  "#Pronoun #Verb #Determiner  #Value ",
  "#Pronoun #Verb #Adverb #Adjective  ",
  "#Noun #Verb #Determiner   #Pronoun",
  "#Noun #Verb #Verb  #Value #Pronoun",
  "#Pronoun #Verb  #Adjective #Value ",
  "#Pronoun #Verb #Determiner   #Noun",
  "#Pronoun #Verb #Adjective  #Value ",
  "#Pronoun #Verb #Verb  #Value #Noun",
  "#Noun #Verb  #Adjective  #Pronoun",
  "#Noun #Verb #Adjective   #Pronoun",
  "#Noun #Verb #Adverb  #Value #Noun",
  "#Pronoun #Verb  #Adjective  #Noun",
  "#Pronoun #Verb #Adjective   #Noun",
  "#Pronoun #Verb #Adverb   #Pronoun",
  "#Pronoun #Verb #Verb #Adjective  ",
  "#Noun #Verb #Determiner  #Value ",
  "#Noun #Verb #Adverb #Adjective  ",
  "#Pronoun #Verb   #Value #Pronoun",
  "#Noun #Verb  #Adjective #Value ",
  "#Noun #Verb #Determiner   #Noun",
  "#Noun #Verb #Adjective  #Value ",
  "#Noun #Verb #Verb  #Value #Noun",
  "#Pronoun #Verb #Adverb  #Value ",
  "#Pronoun #Verb #Verb   #Pronoun",
  "#Noun #Verb  #Adjective  #Noun",
  "#Noun #Verb #Adjective   #Noun",
  "#Noun #Verb #Adverb   #Pronoun",
  "#Noun #Verb #Verb #Adjective  ",
  "#Pronoun #Verb #Adverb   #Noun",
  "#Noun #Verb   #Value #Pronoun",
  "#Pronoun #Verb   #Value #Noun",
  "#Pronoun #Verb #Determiner   ",
  "#Pronoun #Verb #Verb  #Value ",
  "#Noun #Verb #Adverb  #Value ",
  "#Noun #Verb #Verb   #Pronoun",
  "#Pronoun #Verb  #Adjective  ",
  "#Pronoun #Verb #Adjective   ",
  "#Pronoun #Verb #Verb   #Noun",
  "#Noun #Verb #Adverb   #Noun",
  "#Noun #Verb   #Value #Noun",
  "#Noun #Verb #Determiner   ",
  "#Noun #Verb #Verb  #Value ",
  "#Pronoun #Verb    #Pronoun",
  "#Noun #Verb  #Adjective  ",
  "#Noun #Verb #Adjective   ",
  "#Noun #Verb #Verb   #Noun",
  "#Pronoun #Verb #Adverb   ",
  "#Pronoun #Verb   #Value ",
  "#Noun #Verb    #Pronoun",
  "#Pronoun #Verb    #Noun",
  "#Pronoun #Verb #Verb   ",
  "#Noun #Verb #Adverb   ",
  "#Noun #Verb   #Value ",
  "#Noun #Verb    #Noun",
  "#Noun #Verb #Verb   ",
  "#Pronoun #Verb    ",
  "#Noun #Verb    "
];

// main.ts
var import_codemirror = __toESM(require_codemirror());
var import_historica = __toESM(require_historica());

// src/ui/historicaSettingTab.ts
var import_obsidian = require("obsidian");
var HistoricaSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin5) {
    super(app, plugin5);
    this.plugin = plugin5;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.configManager.settings;
    new import_obsidian.Setting(containerEl).setName("Default Style").setDesc("Choose the default style for the timeline").addDropdown((dropdown) => {
      dropdown.addOption("1", "Style 1");
      dropdown.addOption("2", "Style 2");
      dropdown.setValue(settings.defaultStyle);
      dropdown.onChange(async (value) => {
        settings.defaultStyle = value;
        await this.plugin.configManager.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Show Summary Title").setDesc("Show short title in the timeline, turn it off if you think it is not smart enough, and this will make this plugin run at fastest speed").addToggle((toggle) => {
      toggle.setValue(settings.showUseFulInformation);
      toggle.onChange(async (value) => {
        settings.showUseFulInformation = value;
        await this.plugin.configManager.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Implicit date showing in the time entry").setDesc("Example, your current date as 2024/Mar/20,a string like '2 day ago' will be show explicit as '2024/Mar/18' if you turn this option off").addToggle((toggle) => {
      toggle.setValue(settings.showRelativeTime);
      toggle.onChange(async (value) => {
        settings.showRelativeTime = value;
        await this.plugin.configManager.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Smart theme").setDesc("Theme that dynamic change base on your current obsidian  theme, turn it off if you want to using classic theme of Historica - Legend Larva").addToggle((toggle) => {
      toggle.setValue(settings.usingSmartTheme);
      toggle.onChange(async (value) => {
        settings.usingSmartTheme = value;
        await this.plugin.configManager.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Language support").setDesc("Historica only support one language at the same time").addDropdown((dropdown) => {
      dropdown.addOption("en", "English (International)");
      dropdown.addOption("uk", "Ukrainian");
      dropdown.addOption("fr", "French");
      dropdown.addOption("de", "Deutsch");
      dropdown.addOption("ja", "Japanese");
      dropdown.addOption("nl", "Dutch");
      dropdown.addOption("ru", "Russian");
      dropdown.addOption("pt", "Portugues");
      dropdown.addOption("zh.hant", "Chinese (Traditional)");
      dropdown.setValue(settings.language);
      dropdown.onChange(async (value) => {
        settings.language = value;
        await this.plugin.configManager.saveSettings();
      });
    });
  }
};

// src/backgroundLogic/ConfigManager.ts
var ConfigManager = class {
  constructor(plugin5, defaultSettings) {
    this._plugin = plugin5;
    this._settings = defaultSettings;
  }
  get settings() {
    return this._settings;
  }
  set settings(value) {
    this._settings = value;
  }
  get plugin() {
    return this._plugin;
  }
  set plugin(value) {
    this._plugin = value;
  }
  async loadSettings() {
    this.plugin.configManager.settings = Object.assign({}, this._settings, await this.plugin.loadData());
  }
  async saveSettings() {
    await this.plugin.saveData(this.plugin.configManager.settings);
  }
  async writeLatestFileToData(file) {
    let settings = await this.plugin.loadData();
    if (!settings) {
      settings = {
        latestFile: file.path,
        showUseFulInformation: false,
        defaultStyle: "1",
        showRelativeTime: false,
        usingSmartTheme: true,
        language: "en"
      };
    }
    settings.latestFile = file.path;
    await this.plugin.saveData(settings);
  }
};

// src/backgroundLogic/HistoricaFileHelper.ts
var import_obsidian2 = require("obsidian");
var import_lodash = __toESM(require_lodash());
var HistoricaFileHelper = class {
  get plugin() {
    return this._plugin;
  }
  set plugin(value) {
    this._plugin = value;
  }
  constructor(plugin5) {
    this._plugin = plugin5;
  }
  async getCurrentFile() {
    let currentFile = this.plugin.app.workspace.getActiveFile();
    if (currentFile instanceof import_obsidian2.TFile) {
    } else {
      let data = await this.plugin.loadData();
      if (data.latestFile) {
        const currentFileAbstract = this.plugin.app.vault.getAbstractFileByPath(data.latestFile);
        if (currentFileAbstract instanceof import_obsidian2.TFile) {
          currentFile = currentFileAbstract;
        }
      }
    }
    if (!(0, import_lodash.isNull)(currentFile)) {
      return currentFile;
    } else {
      return new import_obsidian2.TFile();
    }
  }
};

// src/backgroundLogic/HistoricaDocumentProcesser.ts
var import_obsidian3 = require("obsidian");
var HistoricaDocumentProcesser = class {
  constructor() {
  }
  async parseUserTimeRangeQuery(historicaQueryInputArray, chrono) {
    let parseTimeArray = [];
    historicaQueryInputArray.map((timeInput) => {
      let start2 = null;
      let end2 = null;
      if (!timeInput.start && !timeInput.end) {
        new import_obsidian3.Notice("Your query is not valid, please check your query");
        return [];
      }
      if (timeInput.start) {
        const startParsingResult = chrono.parse(timeInput.start);
        if (startParsingResult) {
          start2 = {
            dateString: startParsingResult[0].date().toString(),
            unixTime: startParsingResult[0].date().getTime() / 1e3
          };
        }
      }
      if (timeInput.end) {
        const endParsingResult = chrono.parse(timeInput.end);
        if (endParsingResult) {
          end2 = {
            dateString: endParsingResult[0].date().toString(),
            unixTime: endParsingResult[0].date().getTime() / 1e3
          };
        }
      }
      parseTimeArray.push({
        start: start2,
        end: end2
      });
    });
    return parseTimeArray;
  }
  async GetTimelineDataFromDocumentArrayWithChrono(tokens, customChrono, compromiseNLP, userfulInformationPatternTag, isShowSummaryTitle, query, pintime) {
    let timelineData = [];
    let documents = [];
    tokens == null ? void 0 : tokens.forEach((token) => {
      if ("text" in token) {
        documents.push({
          raw: token.raw,
          text: token.text,
          type: token.type
        });
      }
    });
    documents == null ? void 0 : documents.forEach((doc) => {
      let parseResults;
      if (pintime) {
        const referenceTime = customChrono.parse(pintime);
        parseResults = customChrono.parse(doc.raw, referenceTime[0].start.date());
      } else {
        parseResults = customChrono.parse(doc.raw);
      }
      if (!parseResults || parseResults.length === 0) {
        return;
      }
      parseResults.forEach((parseResult) => {
        const [startData, endData] = this.extractDataToParseResult(parseResult, isShowSummaryTitle, userfulInformationPatternTag, compromiseNLP, doc.raw);
        if (startData) {
          timelineData.push(startData);
        }
        if (endData) {
          timelineData.push(endData);
        }
      });
    });
    timelineData.sort((a4, b2) => {
      return a4.unixTime - b2.unixTime;
    });
    let filterTimelineData = [];
    let parsedUserQueryArray = await this.parseUserTimeRangeQuery(query, customChrono);
    if (parsedUserQueryArray.length === 0) {
      return timelineData;
    }
    parsedUserQueryArray.map((parsedUserQuery) => {
      timelineData.map((timelineEntry) => {
        if (parsedUserQuery.start && parsedUserQuery.end) {
          if (timelineEntry.unixTime >= parsedUserQuery.start.unixTime && timelineEntry.unixTime <= parsedUserQuery.end.unixTime) {
            filterTimelineData.push(timelineEntry);
          }
        } else if (parsedUserQuery.start) {
          if (timelineEntry.unixTime >= parsedUserQuery.start.unixTime) {
            filterTimelineData.push(timelineEntry);
          }
        } else if (parsedUserQuery.end) {
          if (timelineEntry.unixTime <= parsedUserQuery.end.unixTime) {
            filterTimelineData.push(timelineEntry);
          }
        }
      });
    });
    filterTimelineData.sort((a4, b2) => {
      return a4.unixTime - b2.unixTime;
    });
    return filterTimelineData;
  }
  extractStringBaseOnTag(tags, compromiseNLP, text) {
    for (const tag2 of tags) {
      const result = compromiseNLP(text).match(tag2).json();
      if (result.length != 0) {
        for (const r3 of result) {
          if (r3.text.includes(".") || r3.text.includes(",")) {
            continue;
          }
          return r3.text;
        }
      }
    }
    return "";
  }
  extractDataToParseResult(parsingResult, isShowSummaryTitle, userfulInformationPatternTag, compromiseNLP, text) {
    let summaryTitle = "";
    let startData = null;
    let endData = null;
    if (parsingResult.start) {
      const start2 = parsingResult.start;
      const parseText = parsingResult.text;
      if (isShowSummaryTitle) {
        summaryTitle = this.extractStringBaseOnTag(userfulInformationPatternTag, compromiseNLP, text);
      } else {
        summaryTitle = "";
      }
      startData = {
        importantInformation: summaryTitle,
        stringThatParseAsDate: parseText,
        dateString: start2.date().toString(),
        dateStringCompact: start2.date().toDateString(),
        unixTime: start2.date().getTime() / 1e3,
        sentence: text.replace(parseText, `<historica-mark>${parseText}</historica-mark>`)
      };
    }
    if (parsingResult.end) {
      const end2 = parsingResult.end;
      const parseText = parsingResult.text;
      if (isShowSummaryTitle) {
        summaryTitle = this.extractStringBaseOnTag(userfulInformationPatternTag, compromiseNLP, text);
      } else {
        summaryTitle = "";
      }
      endData = {
        importantInformation: summaryTitle,
        stringThatParseAsDate: parseText,
        dateString: end2.date().toString(),
        dateStringCompact: end2.date().toDateString(),
        unixTime: end2.date().getTime() / 1e3,
        sentence: text.replace(parseText, `<historica-mark>${parseText}</historica-mark>`)
      };
    }
    return [startData, endData];
  }
  RecusiveGetToken(document2, tokens) {
    if ("type" in document2 && document2.type === "text") {
      tokens.push(document2);
    }
    if ("tokens" in document2 && document2.tokens) {
      document2.tokens.map((t5) => {
        this.RecusiveGetToken(t5, tokens);
      });
    }
    if ("rows" in document2 && document2.rows) {
      document2.rows.map((row) => {
        row.map((cell) => {
          this.RecusiveGetToken(cell, tokens);
        });
      });
    }
    if ("header" in document2 && document2.header) {
      document2.header.map((header) => {
        RecusiveGetToken(header, tokens);
      });
    }
    if ("items" in document2 && document2.items) {
      document2.items.map((item) => {
        this.RecusiveGetToken(item, tokens);
      });
    }
  }
};

// src/ui/SearchResultModal.ts
var import_obsidian4 = require("obsidian");
var HistoricaSearchResultModal = class extends import_obsidian4.Modal {
  constructor(app, query, thisPlugin, isUsingSmartTheme) {
    super(app);
    this.query = query;
    this.thisPlugin = thisPlugin;
    this.isUsingSmartTheme = isUsingSmartTheme;
  }
  async onOpen() {
    const { contentEl } = this;
    let historicaSearchResultModalEl;
    const historicaSearchResultModalClass = this.isUsingSmartTheme ? "historica-search-result-modal-smart-theme" : "historica-search-result-modal";
    const historicaSearchFileNameContainerClass = this.isUsingSmartTheme ? "historica-search-filename-container-smart-theme" : "historica-search-filename-container";
    const historicaSearchFileNameClass = this.isUsingSmartTheme ? "historica-search-filename-smart-theme" : "historica-search-filename";
    const historicaSearchResultContainerClass = this.isUsingSmartTheme ? "historica-search-result-container-smart-theme" : "historica-search-result-container";
    const historicaSearchResultElementClass = this.isUsingSmartTheme ? "historica-search-result-element-smart-theme" : "historica-search-result-element";
    historicaSearchResultModalEl = contentEl.createEl("div", {
      cls: historicaSearchResultModalClass
    });
    const searchFunction = (0, import_obsidian4.prepareSimpleSearch)(this.query);
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      let fileContent = await this.app.vault.read(file);
      const searchResult = searchFunction(fileContent);
      if (searchResult && searchResult.matches.length > 0) {
        let historicaSearchResultElementContainer;
        const historicaSearchFileNameContainer = historicaSearchResultModalEl.createEl("div", {
          cls: historicaSearchFileNameContainerClass
        });
        historicaSearchResultElementContainer = historicaSearchResultModalEl.createEl("div", {
          cls: historicaSearchResultContainerClass
        });
        historicaSearchFileNameContainer.createEl("h2", {
          text: file.name,
          cls: historicaSearchFileNameClass
        });
        let fileContentArray = this.createFileContentArray(searchResult, fileContent);
        fileContent = fileContentArray.join("");
        fileContent.split("\n").forEach((line, index4) => {
          if (line.includes("historica-mark")) {
            let historicaSearchResultElement;
            historicaSearchResultElement = historicaSearchResultElementContainer.createEl("div", {
              cls: historicaSearchResultElementClass
            });
            this.thisPlugin.historicaTimelineRenderer.formatSentencesWithMarkElement(line, historicaSearchResultElement, this.isUsingSmartTheme);
            historicaSearchResultElement.addEventListener(
              "click",
              async () => await this.HistoricaTimelineElementClickListener(this, file, line, index4)
            );
          }
        });
      }
    }
  }
  onClose() {
    super.onClose();
  }
  createFileContentArray(searchResult, fileContent) {
    let fileContentArray = [];
    for (let i5 = 0; i5 < searchResult.matches.length; i5++) {
      const start2 = searchResult.matches[i5][0];
      const end2 = searchResult.matches[i5][1];
      if (i5 === 0) {
        fileContentArray.push(fileContent.substring(0, start2));
        fileContentArray.push("<historica-mark>" + fileContent.substring(start2, end2) + "</historica-mark>");
      } else if (i5 === searchResult.matches.length - 1) {
        fileContentArray.push(fileContent.substring(searchResult.matches[i5 - 1][1], start2));
        fileContentArray.push("<historica-mark>" + fileContent.substring(start2, end2) + "</historica-mark>");
        fileContentArray.push(fileContent.substring(end2));
      } else {
        fileContentArray.push(fileContent.substring(searchResult.matches[i5 - 1][1], start2));
        fileContentArray.push("<historica-mark>" + fileContent.substring(start2, end2) + "</historica-mark>");
      }
    }
    return fileContentArray;
  }
  async HistoricaTimelineElementClickListener(thisModal, file, lineContent, index4) {
    thisModal.close();
    let leaf = thisModal.thisPlugin.app.workspace.getLeaf(false);
    const fileNeedToBeOpen = thisModal.thisPlugin.app.vault.getAbstractFileByPath(file.path);
    if (fileNeedToBeOpen instanceof import_obsidian4.TFile) {
      await leaf.openFile(fileNeedToBeOpen);
      await leaf.setViewState({
        type: "markdown",
        state: {
          active: true,
          line: index4
        },
        active: true
      });
      let view = leaf.view;
      view.editor.setCursor({
        line: index4,
        ch: 0
      });
      view.editor.setSelection({
        line: index4,
        ch: 0
      }, {
        line: index4,
        ch: lineContent.replace(/<historica-mark>/g, "").replace(/<\/historica-mark>/g, "").length
      });
      view.editor.focus();
      view.editor.scrollTo(0, index4);
    }
  }
};

// src/ui/TimelineActionModal.ts
var import_obsidian5 = require("obsidian");

// node_modules/html-to-image/es/util.js
function resolveUrl(url, baseUrl) {
  if (url.match(/^[a-z]+:\/\//i)) {
    return url;
  }
  if (url.match(/^\/\//)) {
    return window.location.protocol + url;
  }
  if (url.match(/^[a-z]+:/i)) {
    return url;
  }
  const doc = document.implementation.createHTMLDocument();
  const base = doc.createElement("base");
  const a4 = doc.createElement("a");
  doc.head.appendChild(base);
  doc.body.appendChild(a4);
  if (baseUrl) {
    base.href = baseUrl;
  }
  a4.href = url;
  return a4.href;
}
var uuid = (() => {
  let counter = 0;
  const random2 = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => {
    counter += 1;
    return `u${random2()}${counter}`;
  };
})();
function toArray4(arrayLike) {
  const arr = [];
  for (let i5 = 0, l4 = arrayLike.length; i5 < l4; i5++) {
    arr.push(arrayLike[i5]);
  }
  return arr;
}
function px(node2, styleProperty) {
  const win = node2.ownerDocument.defaultView || window;
  const val = win.getComputedStyle(node2).getPropertyValue(styleProperty);
  return val ? parseFloat(val.replace("px", "")) : 0;
}
function getNodeWidth(node2) {
  const leftBorder = px(node2, "border-left-width");
  const rightBorder = px(node2, "border-right-width");
  return node2.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node2) {
  const topBorder = px(node2, "border-top-width");
  const bottomBorder = px(node2, "border-bottom-width");
  return node2.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options2 = {}) {
  const width = options2.width || getNodeWidth(targetNode);
  const height = options2.height || getNodeHeight(targetNode);
  return { width, height };
}
function getPixelRatio() {
  let ratio;
  let FINAL_PROCESS;
  try {
    FINAL_PROCESS = process;
  } catch (e3) {
  }
  const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
  if (val) {
    ratio = parseInt(val, 10);
    if (Number.isNaN(ratio)) {
      ratio = 1;
    }
  }
  return ratio || window.devicePixelRatio || 1;
}
var canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
  if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
    if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvas.height) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    } else if (canvas.width > canvasDimensionLimit) {
      canvas.height *= canvasDimensionLimit / canvas.width;
      canvas.width = canvasDimensionLimit;
    } else {
      canvas.width *= canvasDimensionLimit / canvas.height;
      canvas.height = canvasDimensionLimit;
    }
  }
}
function canvasToBlob(canvas, options2 = {}) {
  if (canvas.toBlob) {
    return new Promise((resolve) => {
      canvas.toBlob(resolve, options2.type ? options2.type : "image/png", options2.quality ? options2.quality : 1);
    });
  }
  return new Promise((resolve) => {
    const binaryString = window.atob(canvas.toDataURL(options2.type ? options2.type : void 0, options2.quality ? options2.quality : void 0).split(",")[1]);
    const len = binaryString.length;
    const binaryArray = new Uint8Array(len);
    for (let i5 = 0; i5 < len; i5 += 1) {
      binaryArray[i5] = binaryString.charCodeAt(i5);
    }
    resolve(new Blob([binaryArray], {
      type: options2.type ? options2.type : "image/png"
    }));
  });
}
function createImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.decode = () => resolve(img);
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.crossOrigin = "anonymous";
    img.decoding = "async";
    img.src = url;
  });
}
async function svgToDataURL(svg) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html3) => `data:image/svg+xml;charset=utf-8,${html3}`);
}
async function nodeToDataURL(node2, width, height) {
  const xmlns = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(xmlns, "svg");
  const foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttribute("width", `${width}`);
  svg.setAttribute("height", `${height}`);
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node2);
  return svgToDataURL(svg);
}
var isInstanceOfElement = (node2, instance) => {
  if (node2 instanceof instance)
    return true;
  const nodePrototype = Object.getPrototypeOf(node2);
  if (nodePrototype === null)
    return false;
  return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
};

// node_modules/html-to-image/es/clone-pseudos.js
function formatCSSText(style) {
  const content = style.getPropertyValue("content");
  return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
}
function formatCSSProperties(style) {
  return toArray4(style).map((name) => {
    const value = style.getPropertyValue(name);
    const priority = style.getPropertyPriority(name);
    return `${name}: ${value}${priority ? " !important" : ""};`;
  }).join(" ");
}
function getPseudoElementStyle(className, pseudo, style) {
  const selector = `.${className}:${pseudo}`;
  const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);
  return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
  const style = window.getComputedStyle(nativeNode, pseudo);
  const content = style.getPropertyValue("content");
  if (content === "" || content === "none") {
    return;
  }
  const className = uuid();
  try {
    clonedNode.className = `${clonedNode.className} ${className}`;
  } catch (err) {
    return;
  }
  const styleElement = document.createElement("style");
  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
  clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
  clonePseudoElement(nativeNode, clonedNode, ":before");
  clonePseudoElement(nativeNode, clonedNode, ":after");
}

// node_modules/html-to-image/es/mimes.js
var WOFF = "application/font-woff";
var JPEG = "image/jpeg";
var mimes = {
  woff: WOFF,
  woff2: WOFF,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: JPEG,
  jpeg: JPEG,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function getExtension(url) {
  const match2 = /\.([^./]*?)$/g.exec(url);
  return match2 ? match2[1] : "";
}
function getMimeType(url) {
  const extension = getExtension(url).toLowerCase();
  return mimes[extension] || "";
}

// node_modules/html-to-image/es/dataurl.js
function getContentFromDataUrl(dataURL) {
  return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
  return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
  return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process2) {
  const res = await fetch(url, init);
  if (res.status === 404) {
    throw new Error(`Resource "${res.url}" not found`);
  }
  const blob = await res.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onloadend = () => {
      try {
        resolve(process2({ res, result: reader.result }));
      } catch (error) {
        reject(error);
      }
    };
    reader.readAsDataURL(blob);
  });
}
var cache2 = {};
function getCacheKey(url, contentType, includeQueryParams) {
  let key = url.replace(/\?.*/, "");
  if (includeQueryParams) {
    key = url;
  }
  if (/ttf|otf|eot|woff2?/i.test(key)) {
    key = key.replace(/.*\//, "");
  }
  return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options2) {
  const cacheKey = getCacheKey(resourceUrl, contentType, options2.includeQueryParams);
  if (cache2[cacheKey] != null) {
    return cache2[cacheKey];
  }
  if (options2.cacheBust) {
    resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + new Date().getTime();
  }
  let dataURL;
  try {
    const content = await fetchAsDataURL(resourceUrl, options2.fetchRequestInit, ({ res, result }) => {
      if (!contentType) {
        contentType = res.headers.get("Content-Type") || "";
      }
      return getContentFromDataUrl(result);
    });
    dataURL = makeDataUrl(content, contentType);
  } catch (error) {
    dataURL = options2.imagePlaceholder || "";
    let msg = `Failed to fetch resource: ${resourceUrl}`;
    if (error) {
      msg = typeof error === "string" ? error : error.message;
    }
    if (msg) {
      console.warn(msg);
    }
  }
  cache2[cacheKey] = dataURL;
  return dataURL;
}

// node_modules/html-to-image/es/clone-node.js
async function cloneCanvasElement(canvas) {
  const dataURL = canvas.toDataURL();
  if (dataURL === "data:,") {
    return canvas.cloneNode(false);
  }
  return createImage(dataURL);
}
async function cloneVideoElement(video, options2) {
  if (video.currentSrc) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = video.clientWidth;
    canvas.height = video.clientHeight;
    ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataURL2 = canvas.toDataURL();
    return createImage(dataURL2);
  }
  const poster = video.poster;
  const contentType = getMimeType(poster);
  const dataURL = await resourceToDataURL(poster, contentType, options2);
  return createImage(dataURL);
}
async function cloneIFrameElement(iframe) {
  var _a2;
  try {
    if ((_a2 = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body) {
      return await cloneNode(iframe.contentDocument.body, {}, true);
    }
  } catch (_b2) {
  }
  return iframe.cloneNode(false);
}
async function cloneSingleNode(node2, options2) {
  if (isInstanceOfElement(node2, HTMLCanvasElement)) {
    return cloneCanvasElement(node2);
  }
  if (isInstanceOfElement(node2, HTMLVideoElement)) {
    return cloneVideoElement(node2, options2);
  }
  if (isInstanceOfElement(node2, HTMLIFrameElement)) {
    return cloneIFrameElement(node2);
  }
  return node2.cloneNode(false);
}
var isSlotElement = (node2) => node2.tagName != null && node2.tagName.toUpperCase() === "SLOT";
async function cloneChildren(nativeNode, clonedNode, options2) {
  var _a2, _b2;
  let children = [];
  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
    children = toArray4(nativeNode.assignedNodes());
  } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a2 = nativeNode.contentDocument) === null || _a2 === void 0 ? void 0 : _a2.body)) {
    children = toArray4(nativeNode.contentDocument.body.childNodes);
  } else {
    children = toArray4(((_b2 = nativeNode.shadowRoot) !== null && _b2 !== void 0 ? _b2 : nativeNode).childNodes);
  }
  if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
    return clonedNode;
  }
  await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options2)).then((clonedChild) => {
    if (clonedChild) {
      clonedNode.appendChild(clonedChild);
    }
  }), Promise.resolve());
  return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode) {
  const targetStyle = clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    toArray4(sourceStyle).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name);
      if (name === "font-size" && value.endsWith("px")) {
        const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
        value = `${reducedFont}px`;
      }
      if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
        value = "block";
      }
      if (name === "d" && clonedNode.getAttribute("d")) {
        value = `path(${clonedNode.getAttribute("d")})`;
      }
      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
    });
  }
}
function cloneInputValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
    clonedNode.innerHTML = nativeNode.value;
  }
  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
    clonedNode.setAttribute("value", nativeNode.value);
  }
}
function cloneSelectValue(nativeNode, clonedNode) {
  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
    const clonedSelect = clonedNode;
    const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
    if (selectedOption) {
      selectedOption.setAttribute("selected", "");
    }
  }
}
function decorate(nativeNode, clonedNode) {
  if (isInstanceOfElement(clonedNode, Element)) {
    cloneCSSStyle(nativeNode, clonedNode);
    clonePseudoElements(nativeNode, clonedNode);
    cloneInputValue(nativeNode, clonedNode);
    cloneSelectValue(nativeNode, clonedNode);
  }
  return clonedNode;
}
async function ensureSVGSymbols(clone, options2) {
  const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
  if (uses.length === 0) {
    return clone;
  }
  const processedDefs = {};
  for (let i5 = 0; i5 < uses.length; i5++) {
    const use2 = uses[i5];
    const id = use2.getAttribute("xlink:href");
    if (id) {
      const exist = clone.querySelector(id);
      const definition = document.querySelector(id);
      if (!exist && definition && !processedDefs[id]) {
        processedDefs[id] = await cloneNode(definition, options2, true);
      }
    }
  }
  const nodes = Object.values(processedDefs);
  if (nodes.length) {
    const ns = "http://www.w3.org/1999/xhtml";
    const svg = document.createElementNS(ns, "svg");
    svg.setAttribute("xmlns", ns);
    svg.style.position = "absolute";
    svg.style.width = "0";
    svg.style.height = "0";
    svg.style.overflow = "hidden";
    svg.style.display = "none";
    const defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
    for (let i5 = 0; i5 < nodes.length; i5++) {
      defs.appendChild(nodes[i5]);
    }
    clone.appendChild(svg);
  }
  return clone;
}
async function cloneNode(node2, options2, isRoot) {
  if (!isRoot && options2.filter && !options2.filter(node2)) {
    return null;
  }
  return Promise.resolve(node2).then((clonedNode) => cloneSingleNode(clonedNode, options2)).then((clonedNode) => cloneChildren(node2, clonedNode, options2)).then((clonedNode) => decorate(node2, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options2));
}

// node_modules/html-to-image/es/embed-resources.js
var URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
var URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
var FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
  const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
}
function parseURLs(cssText) {
  const urls = [];
  cssText.replace(URL_REGEX, (raw, quotation, url) => {
    urls.push(url);
    return raw;
  });
  return urls.filter((url) => !isDataUrl(url));
}
async function embed(cssText, resourceURL, baseURL, options2, getContentFromUrl) {
  try {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    const contentType = getMimeType(resourceURL);
    let dataURL;
    if (getContentFromUrl) {
      const content = await getContentFromUrl(resolvedURL);
      dataURL = makeDataUrl(content, contentType);
    } else {
      dataURL = await resourceToDataURL(resolvedURL, contentType, options2);
    }
    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
  } catch (error) {
  }
  return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match2) => {
    while (true) {
      const [src, , format2] = URL_WITH_FORMAT_REGEX.exec(match2) || [];
      if (!format2) {
        return "";
      }
      if (format2 === preferredFontFormat) {
        return `src: ${src};`;
      }
    }
  });
}
function shouldEmbed(url) {
  return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options2) {
  if (!shouldEmbed(cssText)) {
    return cssText;
  }
  const filteredCSSText = filterPreferredFontFormat(cssText, options2);
  const urls = parseURLs(filteredCSSText);
  return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options2)), Promise.resolve(filteredCSSText));
}

// node_modules/html-to-image/es/embed-images.js
async function embedProp(propName, node2, options2) {
  var _a2;
  const propValue = (_a2 = node2.style) === null || _a2 === void 0 ? void 0 : _a2.getPropertyValue(propName);
  if (propValue) {
    const cssString = await embedResources(propValue, null, options2);
    node2.style.setProperty(propName, cssString, node2.style.getPropertyPriority(propName));
    return true;
  }
  return false;
}
async function embedBackground(clonedNode, options2) {
  if (!await embedProp("background", clonedNode, options2)) {
    await embedProp("background-image", clonedNode, options2);
  }
  if (!await embedProp("mask", clonedNode, options2)) {
    await embedProp("mask-image", clonedNode, options2);
  }
}
async function embedImageNode(clonedNode, options2) {
  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
  if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
    return;
  }
  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
  const dataURL = await resourceToDataURL(url, getMimeType(url), options2);
  await new Promise((resolve, reject) => {
    clonedNode.onload = resolve;
    clonedNode.onerror = reject;
    const image = clonedNode;
    if (image.decode) {
      image.decode = resolve;
    }
    if (image.loading === "lazy") {
      image.loading = "eager";
    }
    if (isImageElement) {
      clonedNode.srcset = "";
      clonedNode.src = dataURL;
    } else {
      clonedNode.href.baseVal = dataURL;
    }
  });
}
async function embedChildren(clonedNode, options2) {
  const children = toArray4(clonedNode.childNodes);
  const deferreds = children.map((child) => embedImages(child, options2));
  await Promise.all(deferreds).then(() => clonedNode);
}
async function embedImages(clonedNode, options2) {
  if (isInstanceOfElement(clonedNode, Element)) {
    await embedBackground(clonedNode, options2);
    await embedImageNode(clonedNode, options2);
    await embedChildren(clonedNode, options2);
  }
}

// node_modules/html-to-image/es/apply-style.js
function applyStyle(node2, options2) {
  const { style } = node2;
  if (options2.backgroundColor) {
    style.backgroundColor = options2.backgroundColor;
  }
  if (options2.width) {
    style.width = `${options2.width}px`;
  }
  if (options2.height) {
    style.height = `${options2.height}px`;
  }
  const manual = options2.style;
  if (manual != null) {
    Object.keys(manual).forEach((key) => {
      style[key] = manual[key];
    });
  }
  return node2;
}

// node_modules/html-to-image/es/embed-webfonts.js
var cssFetchCache = {};
async function fetchCSS(url) {
  let cache3 = cssFetchCache[url];
  if (cache3 != null) {
    return cache3;
  }
  const res = await fetch(url);
  const cssText = await res.text();
  cache3 = { url, cssText };
  cssFetchCache[url] = cache3;
  return cache3;
}
async function embedFonts(data, options2) {
  let cssText = data.cssText;
  const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
  const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
  const loadFonts = fontLocs.map(async (loc) => {
    let url = loc.replace(regexUrl, "$1");
    if (!url.startsWith("https://")) {
      url = new URL(url, data.url).href;
    }
    return fetchAsDataURL(url, options2.fetchRequestInit, ({ result }) => {
      cssText = cssText.replace(loc, `url(${result})`);
      return [loc, result];
    });
  });
  return Promise.all(loadFonts).then(() => cssText);
}
function parseCSS(source) {
  if (source == null) {
    return [];
  }
  const result = [];
  const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
  let cssText = source.replace(commentsRegex, "");
  const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  while (true) {
    const matches3 = keyframesRegex.exec(cssText);
    if (matches3 === null) {
      break;
    }
    result.push(matches3[0]);
  }
  cssText = cssText.replace(keyframesRegex, "");
  const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
  const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
  const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
  while (true) {
    let matches3 = importRegex.exec(cssText);
    if (matches3 === null) {
      matches3 = unifiedRegex.exec(cssText);
      if (matches3 === null) {
        break;
      } else {
        importRegex.lastIndex = unifiedRegex.lastIndex;
      }
    } else {
      unifiedRegex.lastIndex = importRegex.lastIndex;
    }
    result.push(matches3[0]);
  }
  return result;
}
async function getCSSRules(styleSheets, options2) {
  const ret = [];
  const deferreds = [];
  styleSheets.forEach((sheet) => {
    if ("cssRules" in sheet) {
      try {
        toArray4(sheet.cssRules || []).forEach((item, index4) => {
          if (item.type === CSSRule.IMPORT_RULE) {
            let importIndex = index4 + 1;
            const url = item.href;
            const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options2)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              try {
                sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
              } catch (error) {
                console.error("Error inserting rule from remote css", {
                  rule,
                  error
                });
              }
            })).catch((e3) => {
              console.error("Error loading remote css", e3.toString());
            });
            deferreds.push(deferred);
          }
        });
      } catch (e3) {
        const inline2 = styleSheets.find((a4) => a4.href == null) || document.styleSheets[0];
        if (sheet.href != null) {
          deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options2)).then((cssText) => parseCSS(cssText).forEach((rule) => {
            inline2.insertRule(rule, sheet.cssRules.length);
          })).catch((err) => {
            console.error("Error loading remote stylesheet", err);
          }));
        }
        console.error("Error inlining remote css file", e3);
      }
    }
  });
  return Promise.all(deferreds).then(() => {
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray4(sheet.cssRules || []).forEach((item) => {
            ret.push(item);
          });
        } catch (e3) {
          console.error(`Error while reading CSS rules from ${sheet.href}`, e3);
        }
      }
    });
    return ret;
  });
}
function getWebFontRules(cssRules) {
  return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
}
async function parseWebFontRules(node2, options2) {
  if (node2.ownerDocument == null) {
    throw new Error("Provided element is not within a Document");
  }
  const styleSheets = toArray4(node2.ownerDocument.styleSheets);
  const cssRules = await getCSSRules(styleSheets, options2);
  return getWebFontRules(cssRules);
}
async function getWebFontCSS(node2, options2) {
  const rules2 = await parseWebFontRules(node2, options2);
  const cssTexts = await Promise.all(rules2.map((rule) => {
    const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
    return embedResources(rule.cssText, baseUrl, options2);
  }));
  return cssTexts.join("\n");
}
async function embedWebFonts(clonedNode, options2) {
  const cssText = options2.fontEmbedCSS != null ? options2.fontEmbedCSS : options2.skipFonts ? null : await getWebFontCSS(clonedNode, options2);
  if (cssText) {
    const styleNode = document.createElement("style");
    const sytleContent = document.createTextNode(cssText);
    styleNode.appendChild(sytleContent);
    if (clonedNode.firstChild) {
      clonedNode.insertBefore(styleNode, clonedNode.firstChild);
    } else {
      clonedNode.appendChild(styleNode);
    }
  }
}

// node_modules/html-to-image/es/index.js
async function toSvg(node2, options2 = {}) {
  const { width, height } = getImageSize(node2, options2);
  const clonedNode = await cloneNode(node2, options2, true);
  await embedWebFonts(clonedNode, options2);
  await embedImages(clonedNode, options2);
  applyStyle(clonedNode, options2);
  const datauri = await nodeToDataURL(clonedNode, width, height);
  return datauri;
}
async function toCanvas(node2, options2 = {}) {
  const { width, height } = getImageSize(node2, options2);
  const svg = await toSvg(node2, options2);
  const img = await createImage(svg);
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  const ratio = options2.pixelRatio || getPixelRatio();
  const canvasWidth = options2.canvasWidth || width;
  const canvasHeight = options2.canvasHeight || height;
  canvas.width = canvasWidth * ratio;
  canvas.height = canvasHeight * ratio;
  if (!options2.skipAutoScale) {
    checkCanvasDimensions(canvas);
  }
  canvas.style.width = `${canvasWidth}`;
  canvas.style.height = `${canvasHeight}`;
  if (options2.backgroundColor) {
    context.fillStyle = options2.backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);
  }
  context.drawImage(img, 0, 0, canvas.width, canvas.height);
  return canvas;
}
async function toPng(node2, options2 = {}) {
  const canvas = await toCanvas(node2, options2);
  return canvas.toDataURL();
}
async function toBlob(node2, options2 = {}) {
  const canvas = await toCanvas(node2, options2);
  const blob = await canvasToBlob(canvas);
  return blob;
}

// src/ui/TimelineActionModal.ts
var import_json_2_csv = __toESM(require_converter());
var TimelineActionModal = class extends import_obsidian5.Modal {
  constructor(app, targetEl, thisPlugin, timelineData, isUsingSMartTheme) {
    super(app);
    this.targetEl = targetEl;
    this.thisPlugin = thisPlugin;
    this.timelineData = timelineData;
    this.isUsingSmartTheme = isUsingSMartTheme;
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    const historicaTimelineActionModalClass = this.isUsingSmartTheme ? "historica-timeline-action-modal-smart-theme" : "historica-timeline-action-modal";
    const actionModalEl = contentEl.createEl("div", {
      cls: historicaTimelineActionModalClass
    });
    const actionButtonClass = this.isUsingSmartTheme ? "historica-timeline-action-button-smart-theme" : "historica-timeline-action-button";
    actionModalEl.createEl("div", {
      text: "Export as image (clipboard)",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const blob = await toBlob(this.targetEl);
      if (blob) {
        const item = new ClipboardItem({ [blob.type]: blob });
        await navigator.clipboard.write([item]);
      }
      new import_obsidian5.Notice("Successfully copied to clipboard");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Export as image (PNG)",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const image = await this.thisPlugin.historicaExportHelper.convertHTMLToImageData(this.targetEl);
      const link2 = document.createElement("a");
      link2.href = image;
      link2.download = "historica-timeline.png";
      link2.click();
      new import_obsidian5.Notice("Successfully download image");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Export as pdf",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const imageData = await this.thisPlugin.historicaExportHelper.convertHTMLToImageData(this.targetEl);
      const image = new Image();
      image.src = imageData;
      const pdf = await this.thisPlugin.historicaExportHelper.convertImageToPdf(imageData);
      pdf.save("historica-timeline.pdf");
      new import_obsidian5.Notice("Successfully download pdf");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Export as json",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const data = JSON.stringify(this.timelineData, null, 4);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link2 = document.createElement("a");
      link2.href = url;
      link2.download = "historica-timeline.json";
      link2.click();
      URL.revokeObjectURL(url);
      new import_obsidian5.Notice("Successfully download json");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Export as csv",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const csv = await (0, import_json_2_csv.json2csv)(this.timelineData);
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const link2 = document.createElement("a");
      link2.href = url;
      link2.download = "historica-timeline.csv";
      link2.click();
      URL.revokeObjectURL(url);
      new import_obsidian5.Notice("Successfully download csv");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Copy as json",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const data = JSON.stringify(this.timelineData, null, 4);
      await navigator.clipboard.writeText(data);
      new import_obsidian5.Notice("Successfully copied to clipboard");
      this.close();
    });
    actionModalEl.createEl("div", {
      text: "Copy as csv",
      cls: actionButtonClass
    }).addEventListener("click", async () => {
      const csv = (0, import_json_2_csv.json2csv)(this.timelineData);
      await navigator.clipboard.writeText(csv);
      new import_obsidian5.Notice("Successfully copied to clipboard");
      this.close();
    });
  }
  onClose() {
    super.onClose();
  }
};

// src/ui/HistoricaTimelineRenderer.ts
var import_obsidian6 = require("obsidian");
var HistoricaTimelineRenderer = class {
  get plugin() {
    return this._plugin;
  }
  set plugin(value) {
    this._plugin = value;
  }
  constructor(plugin5) {
    this._plugin = plugin5;
  }
  async renderTimelineEntry(timelineData, blockConfig, el) {
    if (blockConfig.style === 1) {
      const historicaEntryClass = blockConfig.smart_theme ? "historica-entry-1-smart-theme group" : "historica-entry-1 group";
      const historicaVerticalLineClass = blockConfig.smart_theme ? "historica-vertical-line-1-smart-theme" : "historica-vertical-line-1";
      const historicaTimeClass = blockConfig.smart_theme ? "historica-time-1-smart-theme" : "historica-time-1";
      const historicaTitleClass = blockConfig.smart_theme ? "historica-title-1-smart-theme" : "historica-title-1";
      const historicaContentClass = blockConfig.smart_theme ? "historica-content-1-smart-theme" : "historica-content-1";
      const historicaContainerClass = blockConfig.smart_theme ? "historica-container-1-smart-theme" : "historica-container-1";
      const timelineEl = el.createEl("div", {
        cls: historicaContainerClass
      });
      timelineEl.addEventListener("contextmenu", async (e3) => {
        e3.preventDefault();
        new TimelineActionModal(
          this.plugin.app,
          timelineEl,
          this.plugin,
          timelineData,
          blockConfig.smart_theme
        ).open();
      });
      timelineData.map((entry) => {
        const timelineEntryEl = timelineEl.createEl("div", {
          cls: historicaEntryClass
        });
        const verticalLine = timelineEntryEl.createEl("div", { cls: historicaVerticalLineClass });
        console.log(entry.dateStringCompact);
        if (blockConfig.implicit_time) {
          verticalLine.createEl("time", { cls: historicaTimeClass, text: entry.stringThatParseAsDate });
        } else {
          verticalLine.createEl("time", { cls: historicaTimeClass, text: entry.dateStringCompact });
        }
        verticalLine.createEl("div", { cls: historicaTitleClass, text: entry.importantInformation });
        const historicaContent = timelineEntryEl.createEl("div", { cls: historicaContentClass });
        historicaContent.addEventListener("click", async () => {
          new HistoricaSearchResultModal(this.plugin.app, entry.stringThatParseAsDate, this.plugin, blockConfig.smart_theme).open();
        });
        this.formatSentencesWithMarkElement(entry.sentence, historicaContent, blockConfig.smart_theme);
      });
    } else if (blockConfig.style === 2) {
      let historicaCardTimeClass, historicaCardClass, historicaCardContainerClass, historicaCardTitleClass, historicaContainerClass, historicaTimelineIconClass, historicaTimelineItemClass, historicaCardContentClass;
      if (blockConfig.smart_theme) {
        historicaContainerClass = "historica-container-2-smart-theme";
        historicaTimelineItemClass = "historica-item-2-smart-theme group";
        historicaTimelineIconClass = "historica-icon-2-smart-theme";
        historicaCardContainerClass = "historica-card-container-2-smart-theme";
        historicaCardClass = "historica-card-2-smart-theme";
        historicaCardTitleClass = "historica-card-title-2-smart-theme";
        historicaCardTimeClass = "historica-card-time-2-smart-theme";
        historicaCardContentClass = "historica-card-content-2-smart-theme";
      } else {
        historicaContainerClass = "historica-container-2";
        historicaTimelineItemClass = "historica-item-2 group";
        historicaTimelineIconClass = "historica-icon-2";
        historicaCardContainerClass = "historica-card-container-2";
        historicaCardClass = "historica-card-2";
        historicaCardTitleClass = "historica-card-title-2";
        historicaCardTimeClass = "historica-card-time-2";
        historicaCardContentClass = "historica-card-content-2";
      }
      const timelineContainer = el.createEl("div", {
        cls: historicaContainerClass
      });
      timelineContainer.addEventListener("contextmenu", async (e3) => {
        e3.preventDefault();
        new TimelineActionModal(
          this.plugin.app,
          timelineContainer,
          this.plugin,
          timelineData,
          blockConfig.smart_theme
        ).open();
      });
      timelineData.map((entry) => {
        const timelineItem = timelineContainer.createEl("div", {
          cls: historicaTimelineItemClass
        });
        const timelineIcon = timelineItem.createEl("div", {
          cls: historicaTimelineIconClass
        });
        const timelineCardContainer = timelineItem.createEl("div", {
          cls: historicaCardContainerClass
        });
        (0, import_obsidian6.setIcon)(timelineIcon, "shell");
        const timelineCard = timelineCardContainer.createEl("div", {
          cls: historicaCardClass
        });
        timelineCard.createEl("div", {
          cls: historicaCardTitleClass,
          text: entry.importantInformation
        });
        if (blockConfig.implicit_time) {
          timelineCard.createEl("div", {
            cls: historicaCardTimeClass,
            text: entry.stringThatParseAsDate
          });
        } else {
          timelineCard.createEl("div", {
            cls: historicaCardTimeClass,
            text: entry.dateStringCompact
          });
        }
        const timelineCardContent = timelineCardContainer.createEl("div", {
          cls: historicaCardContentClass
        });
        this.formatSentencesWithMarkElement(entry.sentence, timelineCardContent, blockConfig.smart_theme);
        timelineCardContent.addEventListener("click", async () => {
          new HistoricaSearchResultModal(this.plugin.app, entry.stringThatParseAsDate, this.plugin, blockConfig.smart_theme).open();
        });
      });
    }
  }
  formatSentencesWithMarkElement(sen, el, isUsingSmartTheme) {
    const regex = /(<historica-mark>.*<\/historica-mark>)/g;
    const parts = sen.split(regex);
    const historicaMarkClass = isUsingSmartTheme ? "historica-mark-smart-theme" : "historica-mark";
    for (let i5 = 0; i5 < parts.length; i5++) {
      if (regex.test(parts[i5])) {
        el.createEl("historica-mark", {
          cls: historicaMarkClass,
          text: parts[i5].replace(/<historica-mark>/g, "").replace(/<\/historica-mark>/g, "")
        });
      } else {
        el.createEl("span", {
          text: parts[i5]
        });
      }
    }
  }
};

// src/backgroundLogic/HistoricaUserBlockProcesser.ts
var import_obsidian7 = require("obsidian");
var import_lodash3 = __toESM(require_lodash());

// node_modules/chrono-node/dist/esm/locales/en/index.js
var en_exports = {};
__export(en_exports, {
  Chrono: () => Chrono,
  GB: () => GB,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual,
  configuration: () => configuration,
  parse: () => parse7,
  parseDate: () => parseDate,
  strict: () => strict
});

// node_modules/chrono-node/dist/esm/results.js
var import_quarterOfYear = __toESM(require_quarterOfYear(), 1);
var import_dayjs2 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/types.js
var Meridiem;
(function(Meridiem2) {
  Meridiem2[Meridiem2["AM"] = 0] = "AM";
  Meridiem2[Meridiem2["PM"] = 1] = "PM";
})(Meridiem || (Meridiem = {}));
var Weekday;
(function(Weekday2) {
  Weekday2[Weekday2["SUNDAY"] = 0] = "SUNDAY";
  Weekday2[Weekday2["MONDAY"] = 1] = "MONDAY";
  Weekday2[Weekday2["TUESDAY"] = 2] = "TUESDAY";
  Weekday2[Weekday2["WEDNESDAY"] = 3] = "WEDNESDAY";
  Weekday2[Weekday2["THURSDAY"] = 4] = "THURSDAY";
  Weekday2[Weekday2["FRIDAY"] = 5] = "FRIDAY";
  Weekday2[Weekday2["SATURDAY"] = 6] = "SATURDAY";
})(Weekday || (Weekday = {}));
var Month;
(function(Month2) {
  Month2[Month2["JANUARY"] = 1] = "JANUARY";
  Month2[Month2["FEBRUARY"] = 2] = "FEBRUARY";
  Month2[Month2["MARCH"] = 3] = "MARCH";
  Month2[Month2["APRIL"] = 4] = "APRIL";
  Month2[Month2["MAY"] = 5] = "MAY";
  Month2[Month2["JUNE"] = 6] = "JUNE";
  Month2[Month2["JULY"] = 7] = "JULY";
  Month2[Month2["AUGUST"] = 8] = "AUGUST";
  Month2[Month2["SEPTEMBER"] = 9] = "SEPTEMBER";
  Month2[Month2["OCTOBER"] = 10] = "OCTOBER";
  Month2[Month2["NOVEMBER"] = 11] = "NOVEMBER";
  Month2[Month2["DECEMBER"] = 12] = "DECEMBER";
})(Month || (Month = {}));

// node_modules/chrono-node/dist/esm/utils/dayjs.js
function assignTheNextDay(component, targetDayJs) {
  targetDayJs = targetDayJs.add(1, "day");
  assignSimilarDate(component, targetDayJs);
  implySimilarTime(component, targetDayJs);
}
function implyTheNextDay(component, targetDayJs) {
  targetDayJs = targetDayJs.add(1, "day");
  implySimilarDate(component, targetDayJs);
  implySimilarTime(component, targetDayJs);
}
function assignSimilarDate(component, targetDayJs) {
  component.assign("day", targetDayJs.date());
  component.assign("month", targetDayJs.month() + 1);
  component.assign("year", targetDayJs.year());
}
function assignSimilarTime(component, targetDayJs) {
  component.assign("hour", targetDayJs.hour());
  component.assign("minute", targetDayJs.minute());
  component.assign("second", targetDayJs.second());
  component.assign("millisecond", targetDayJs.millisecond());
  if (component.get("hour") < 12) {
    component.assign("meridiem", Meridiem.AM);
  } else {
    component.assign("meridiem", Meridiem.PM);
  }
}
function implySimilarDate(component, targetDayJs) {
  component.imply("day", targetDayJs.date());
  component.imply("month", targetDayJs.month() + 1);
  component.imply("year", targetDayJs.year());
}
function implySimilarTime(component, targetDayJs) {
  component.imply("hour", targetDayJs.hour());
  component.imply("minute", targetDayJs.minute());
  component.imply("second", targetDayJs.second());
  component.imply("millisecond", targetDayJs.millisecond());
}

// node_modules/chrono-node/dist/esm/timezone.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var TIMEZONE_ABBR_MAP = {
  ACDT: 630,
  ACST: 570,
  ADT: -180,
  AEDT: 660,
  AEST: 600,
  AFT: 270,
  AKDT: -480,
  AKST: -540,
  ALMT: 360,
  AMST: -180,
  AMT: -240,
  ANAST: 720,
  ANAT: 720,
  AQTT: 300,
  ART: -180,
  AST: -240,
  AWDT: 540,
  AWST: 480,
  AZOST: 0,
  AZOT: -60,
  AZST: 300,
  AZT: 240,
  BNT: 480,
  BOT: -240,
  BRST: -120,
  BRT: -180,
  BST: 60,
  BTT: 360,
  CAST: 480,
  CAT: 120,
  CCT: 390,
  CDT: -300,
  CEST: 120,
  CET: {
    timezoneOffsetDuringDst: 2 * 60,
    timezoneOffsetNonDst: 60,
    dstStart: (year3) => getLastWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2),
    dstEnd: (year3) => getLastWeekdayOfMonth(year3, Month.OCTOBER, Weekday.SUNDAY, 3)
  },
  CHADT: 825,
  CHAST: 765,
  CKT: -600,
  CLST: -180,
  CLT: -240,
  COT: -300,
  CST: -360,
  CT: {
    timezoneOffsetDuringDst: -5 * 60,
    timezoneOffsetNonDst: -6 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  CVT: -60,
  CXT: 420,
  ChST: 600,
  DAVT: 420,
  EASST: -300,
  EAST: -360,
  EAT: 180,
  ECT: -300,
  EDT: -240,
  EEST: 180,
  EET: 120,
  EGST: 0,
  EGT: -60,
  EST: -300,
  ET: {
    timezoneOffsetDuringDst: -4 * 60,
    timezoneOffsetNonDst: -5 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  FJST: 780,
  FJT: 720,
  FKST: -180,
  FKT: -240,
  FNT: -120,
  GALT: -360,
  GAMT: -540,
  GET: 240,
  GFT: -180,
  GILT: 720,
  GMT: 0,
  GST: 240,
  GYT: -240,
  HAA: -180,
  HAC: -300,
  HADT: -540,
  HAE: -240,
  HAP: -420,
  HAR: -360,
  HAST: -600,
  HAT: -90,
  HAY: -480,
  HKT: 480,
  HLV: -210,
  HNA: -240,
  HNC: -360,
  HNE: -300,
  HNP: -480,
  HNR: -420,
  HNT: -150,
  HNY: -540,
  HOVT: 420,
  ICT: 420,
  IDT: 180,
  IOT: 360,
  IRDT: 270,
  IRKST: 540,
  IRKT: 540,
  IRST: 210,
  IST: 330,
  JST: 540,
  KGT: 360,
  KRAST: 480,
  KRAT: 480,
  KST: 540,
  KUYT: 240,
  LHDT: 660,
  LHST: 630,
  LINT: 840,
  MAGST: 720,
  MAGT: 720,
  MART: -510,
  MAWT: 300,
  MDT: -360,
  MESZ: 120,
  MEZ: 60,
  MHT: 720,
  MMT: 390,
  MSD: 240,
  MSK: 180,
  MST: -420,
  MT: {
    timezoneOffsetDuringDst: -6 * 60,
    timezoneOffsetNonDst: -7 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  MUT: 240,
  MVT: 300,
  MYT: 480,
  NCT: 660,
  NDT: -90,
  NFT: 690,
  NOVST: 420,
  NOVT: 360,
  NPT: 345,
  NST: -150,
  NUT: -660,
  NZDT: 780,
  NZST: 720,
  OMSST: 420,
  OMST: 420,
  PDT: -420,
  PET: -300,
  PETST: 720,
  PETT: 720,
  PGT: 600,
  PHOT: 780,
  PHT: 480,
  PKT: 300,
  PMDT: -120,
  PMST: -180,
  PONT: 660,
  PST: -480,
  PT: {
    timezoneOffsetDuringDst: -7 * 60,
    timezoneOffsetNonDst: -8 * 60,
    dstStart: (year3) => getNthWeekdayOfMonth(year3, Month.MARCH, Weekday.SUNDAY, 2, 2),
    dstEnd: (year3) => getNthWeekdayOfMonth(year3, Month.NOVEMBER, Weekday.SUNDAY, 1, 2)
  },
  PWT: 540,
  PYST: -180,
  PYT: -240,
  RET: 240,
  SAMT: 240,
  SAST: 120,
  SBT: 660,
  SCT: 240,
  SGT: 480,
  SRT: -180,
  SST: -660,
  TAHT: -600,
  TFT: 300,
  TJT: 300,
  TKT: 780,
  TLT: 540,
  TMT: 300,
  TVT: 720,
  ULAT: 480,
  UTC: 0,
  UYST: -120,
  UYT: -180,
  UZT: 300,
  VET: -210,
  VLAST: 660,
  VLAT: 660,
  VUT: 660,
  WAST: 120,
  WAT: 60,
  WEST: 60,
  WESZ: 60,
  WET: 0,
  WEZ: 0,
  WFT: 720,
  WGST: -120,
  WGT: -180,
  WIB: 420,
  WIT: 540,
  WITA: 480,
  WST: 780,
  WT: 0,
  YAKST: 600,
  YAKT: 600,
  YAPT: 600,
  YEKST: 360,
  YEKT: 360
};
function getNthWeekdayOfMonth(year3, month2, weekday, n5, hour = 0) {
  let dayOfMonth = 0;
  let i5 = 0;
  while (i5 < n5) {
    dayOfMonth++;
    const date = new Date(year3, month2 - 1, dayOfMonth);
    if (date.getDay() === weekday)
      i5++;
  }
  return new Date(year3, month2 - 1, dayOfMonth, hour);
}
function getLastWeekdayOfMonth(year3, month2, weekday, hour = 0) {
  const oneIndexedWeekday = weekday === 0 ? 7 : weekday;
  const date = new Date(year3, month2 - 1 + 1, 1, 12);
  const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();
  let dayDiff;
  if (firstWeekdayNextMonth === oneIndexedWeekday)
    dayDiff = 7;
  else if (firstWeekdayNextMonth < oneIndexedWeekday)
    dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;
  else
    dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;
  date.setDate(date.getDate() - dayDiff);
  return new Date(year3, month2 - 1, date.getDate(), hour);
}
function toTimezoneOffset(timezoneInput, date, timezoneOverrides = {}) {
  var _a2;
  if (timezoneInput == null) {
    return null;
  }
  if (typeof timezoneInput === "number") {
    return timezoneInput;
  }
  const matchedTimezone = (_a2 = timezoneOverrides[timezoneInput]) != null ? _a2 : TIMEZONE_ABBR_MAP[timezoneInput];
  if (matchedTimezone == null) {
    return null;
  }
  if (typeof matchedTimezone == "number") {
    return matchedTimezone;
  }
  if (date == null) {
    return null;
  }
  if ((0, import_dayjs.default)(date).isAfter(matchedTimezone.dstStart(date.getFullYear())) && !(0, import_dayjs.default)(date).isAfter(matchedTimezone.dstEnd(date.getFullYear()))) {
    return matchedTimezone.timezoneOffsetDuringDst;
  }
  return matchedTimezone.timezoneOffsetNonDst;
}

// node_modules/chrono-node/dist/esm/results.js
import_dayjs2.default.extend(import_quarterOfYear.default);
var ReferenceWithTimezone = class {
  constructor(input) {
    var _a2;
    input = input != null ? input : new Date();
    if (input instanceof Date) {
      this.instant = input;
    } else {
      this.instant = (_a2 = input.instant) != null ? _a2 : new Date();
      this.timezoneOffset = toTimezoneOffset(input.timezone, this.instant);
    }
  }
  getDateWithAdjustedTimezone() {
    return new Date(this.instant.getTime() + this.getSystemTimezoneAdjustmentMinute(this.instant) * 6e4);
  }
  getSystemTimezoneAdjustmentMinute(date, overrideTimezoneOffset) {
    var _a2;
    if (!date || date.getTime() < 0) {
      date = new Date();
    }
    const currentTimezoneOffset = -date.getTimezoneOffset();
    const targetTimezoneOffset = (_a2 = overrideTimezoneOffset != null ? overrideTimezoneOffset : this.timezoneOffset) != null ? _a2 : currentTimezoneOffset;
    return currentTimezoneOffset - targetTimezoneOffset;
  }
};
var ParsingComponents = class {
  constructor(reference, knownComponents) {
    this._tags = /* @__PURE__ */ new Set();
    this.reference = reference;
    this.knownValues = {};
    this.impliedValues = {};
    if (knownComponents) {
      for (const key in knownComponents) {
        this.knownValues[key] = knownComponents[key];
      }
    }
    const refDayJs = (0, import_dayjs2.default)(reference.instant);
    this.imply("day", refDayJs.date());
    this.imply("month", refDayJs.month() + 1);
    this.imply("year", refDayJs.year());
    this.imply("hour", 12);
    this.imply("minute", 0);
    this.imply("second", 0);
    this.imply("millisecond", 0);
  }
  get(component) {
    if (component in this.knownValues) {
      return this.knownValues[component];
    }
    if (component in this.impliedValues) {
      return this.impliedValues[component];
    }
    return null;
  }
  isCertain(component) {
    return component in this.knownValues;
  }
  getCertainComponents() {
    return Object.keys(this.knownValues);
  }
  imply(component, value) {
    if (component in this.knownValues) {
      return this;
    }
    this.impliedValues[component] = value;
    return this;
  }
  assign(component, value) {
    this.knownValues[component] = value;
    delete this.impliedValues[component];
    return this;
  }
  delete(component) {
    delete this.knownValues[component];
    delete this.impliedValues[component];
  }
  clone() {
    const component = new ParsingComponents(this.reference);
    component.knownValues = {};
    component.impliedValues = {};
    for (const key in this.knownValues) {
      component.knownValues[key] = this.knownValues[key];
    }
    for (const key in this.impliedValues) {
      component.impliedValues[key] = this.impliedValues[key];
    }
    return component;
  }
  isOnlyDate() {
    return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second");
  }
  isOnlyTime() {
    return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
  }
  isOnlyWeekdayComponent() {
    return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month");
  }
  isDateWithUnknownYear() {
    return this.isCertain("month") && !this.isCertain("year");
  }
  isValidDate() {
    const date = this.dateWithoutTimezoneAdjustment();
    if (date.getFullYear() !== this.get("year"))
      return false;
    if (date.getMonth() !== this.get("month") - 1)
      return false;
    if (date.getDate() !== this.get("day"))
      return false;
    if (this.get("hour") != null && date.getHours() != this.get("hour"))
      return false;
    if (this.get("minute") != null && date.getMinutes() != this.get("minute"))
      return false;
    return true;
  }
  toString() {
    return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`;
  }
  dayjs() {
    return (0, import_dayjs2.default)(this.date());
  }
  date() {
    const date = this.dateWithoutTimezoneAdjustment();
    const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get("timezoneOffset"));
    return new Date(date.getTime() + timezoneAdjustment * 6e4);
  }
  addTag(tag2) {
    this._tags.add(tag2);
    return this;
  }
  addTags(tags) {
    for (const tag2 of tags) {
      this._tags.add(tag2);
    }
    return this;
  }
  tags() {
    return new Set(this._tags);
  }
  dateWithoutTimezoneAdjustment() {
    const date = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond"));
    date.setFullYear(this.get("year"));
    return date;
  }
  static createRelativeFromReference(reference, fragments) {
    let date = (0, import_dayjs2.default)(reference.instant);
    for (const key in fragments) {
      date = date.add(fragments[key], key);
    }
    const components = new ParsingComponents(reference);
    if (fragments["hour"] || fragments["minute"] || fragments["second"]) {
      assignSimilarTime(components, date);
      assignSimilarDate(components, date);
      if (reference.timezoneOffset !== null) {
        components.assign("timezoneOffset", -reference.instant.getTimezoneOffset());
      }
    } else {
      implySimilarTime(components, date);
      if (reference.timezoneOffset !== null) {
        components.imply("timezoneOffset", -reference.instant.getTimezoneOffset());
      }
      if (fragments["d"]) {
        components.assign("day", date.date());
        components.assign("month", date.month() + 1);
        components.assign("year", date.year());
      } else {
        if (fragments["week"]) {
          components.imply("weekday", date.day());
        }
        components.imply("day", date.date());
        if (fragments["month"]) {
          components.assign("month", date.month() + 1);
          components.assign("year", date.year());
        } else {
          components.imply("month", date.month() + 1);
          if (fragments["year"]) {
            components.assign("year", date.year());
          } else {
            components.imply("year", date.year());
          }
        }
      }
    }
    return components;
  }
};
var ParsingResult = class {
  constructor(reference, index4, text, start2, end2) {
    this.reference = reference;
    this.refDate = reference.instant;
    this.index = index4;
    this.text = text;
    this.start = start2 || new ParsingComponents(reference);
    this.end = end2;
  }
  clone() {
    const result = new ParsingResult(this.reference, this.index, this.text);
    result.start = this.start ? this.start.clone() : null;
    result.end = this.end ? this.end.clone() : null;
    return result;
  }
  date() {
    return this.start.date();
  }
  tags() {
    const combinedTags = new Set(this.start.tags());
    if (this.end) {
      for (const tag2 of this.end.tags()) {
        combinedTags.add(tag2);
      }
    }
    return combinedTags;
  }
  toString() {
    const tags = Array.from(this.tags()).sort();
    return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;
  }
};

// node_modules/chrono-node/dist/esm/utils/pattern.js
function repeatedTimeunitPattern(prefix5, singleTimeunitPattern, connectorPattern = "\\s{0,5},?\\s{0,5}") {
  const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\((?!\?)/g, "(?:");
  return `${prefix5}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;
}
function extractTerms(dictionary) {
  let keys;
  if (dictionary instanceof Array) {
    keys = [...dictionary];
  } else if (dictionary instanceof Map) {
    keys = Array.from(dictionary.keys());
  } else {
    keys = Object.keys(dictionary);
  }
  return keys;
}
function matchAnyPattern(dictionary) {
  const joinedTerms = extractTerms(dictionary).sort((a4, b2) => b2.length - a4.length).join("|").replace(/\./g, "\\.");
  return `(?:${joinedTerms})`;
}

// node_modules/chrono-node/dist/esm/calculation/years.js
var import_dayjs4 = __toESM(require_dayjs_min(), 1);
function findMostLikelyADYear(yearNumber) {
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
function findYearClosestToRef(refDate, day, month2) {
  const refMoment = (0, import_dayjs4.default)(refDate);
  let dateMoment = refMoment;
  dateMoment = dateMoment.month(month2 - 1);
  dateMoment = dateMoment.date(day);
  dateMoment = dateMoment.year(refMoment.year());
  const nextYear = dateMoment.add(1, "y");
  const lastYear = dateMoment.add(-1, "y");
  if (Math.abs(nextYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
    dateMoment = nextYear;
  } else if (Math.abs(lastYear.diff(refMoment)) < Math.abs(dateMoment.diff(refMoment))) {
    dateMoment = lastYear;
  }
  return dateMoment.year();
}

// node_modules/chrono-node/dist/esm/locales/en/constants.js
var WEEKDAY_DICTIONARY = {
  sunday: 0,
  sun: 0,
  "sun.": 0,
  monday: 1,
  mon: 1,
  "mon.": 1,
  tuesday: 2,
  tue: 2,
  "tue.": 2,
  wednesday: 3,
  wed: 3,
  "wed.": 3,
  thursday: 4,
  thurs: 4,
  "thurs.": 4,
  thur: 4,
  "thur.": 4,
  thu: 4,
  "thu.": 4,
  friday: 5,
  fri: 5,
  "fri.": 5,
  saturday: 6,
  sat: 6,
  "sat.": 6
};
var FULL_MONTH_NAME_DICTIONARY = {
  january: 1,
  february: 2,
  march: 3,
  april: 4,
  may: 5,
  june: 6,
  july: 7,
  august: 8,
  september: 9,
  october: 10,
  november: 11,
  december: 12
};
var MONTH_DICTIONARY = {
  ...FULL_MONTH_NAME_DICTIONARY,
  jan: 1,
  "jan.": 1,
  feb: 2,
  "feb.": 2,
  mar: 3,
  "mar.": 3,
  apr: 4,
  "apr.": 4,
  jun: 6,
  "jun.": 6,
  jul: 7,
  "jul.": 7,
  aug: 8,
  "aug.": 8,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oct: 10,
  "oct.": 10,
  nov: 11,
  "nov.": 11,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10,
  eleven: 11,
  twelve: 12
};
var ORDINAL_WORD_DICTIONARY = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
  sixth: 6,
  seventh: 7,
  eighth: 8,
  ninth: 9,
  tenth: 10,
  eleventh: 11,
  twelfth: 12,
  thirteenth: 13,
  fourteenth: 14,
  fifteenth: 15,
  sixteenth: 16,
  seventeenth: 17,
  eighteenth: 18,
  nineteenth: 19,
  twentieth: 20,
  "twenty first": 21,
  "twenty-first": 21,
  "twenty second": 22,
  "twenty-second": 22,
  "twenty third": 23,
  "twenty-third": 23,
  "twenty fourth": 24,
  "twenty-fourth": 24,
  "twenty fifth": 25,
  "twenty-fifth": 25,
  "twenty sixth": 26,
  "twenty-sixth": 26,
  "twenty seventh": 27,
  "twenty-seventh": 27,
  "twenty eighth": 28,
  "twenty-eighth": 28,
  "twenty ninth": 29,
  "twenty-ninth": 29,
  "thirtieth": 30,
  "thirty first": 31,
  "thirty-first": 31
};
var TIME_UNIT_DICTIONARY_NO_ABBR = {
  second: "second",
  seconds: "second",
  minute: "minute",
  minutes: "minute",
  hour: "hour",
  hours: "hour",
  day: "d",
  days: "d",
  week: "week",
  weeks: "week",
  month: "month",
  months: "month",
  quarter: "quarter",
  quarters: "quarter",
  year: "year",
  years: "year"
};
var TIME_UNIT_DICTIONARY = {
  s: "second",
  sec: "second",
  second: "second",
  seconds: "second",
  m: "minute",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minutes: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  hour: "hour",
  hours: "hour",
  d: "d",
  day: "d",
  days: "d",
  w: "w",
  week: "week",
  weeks: "week",
  mo: "month",
  mon: "month",
  mos: "month",
  month: "month",
  months: "month",
  qtr: "quarter",
  quarter: "quarter",
  quarters: "quarter",
  y: "year",
  yr: "year",
  year: "year",
  years: "year",
  ...TIME_UNIT_DICTIONARY_NO_ABBR
};
var NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`;
function parseNumberPattern(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY[num];
  } else if (num === "a" || num === "an" || num == "the") {
    return 1;
  } else if (num.match(/few/)) {
    return 3;
  } else if (num.match(/half/)) {
    return 0.5;
  } else if (num.match(/couple/)) {
    return 2;
  } else if (num.match(/several/)) {
    return 7;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;
function parseOrdinalNumberPattern(match2) {
  let num = match2.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY[num];
  }
  num = num.replace(/(?:st|nd|rd|th)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;
function parseYear(match2) {
  if (/BE/i.test(match2)) {
    match2 = match2.replace(/BE/i, "");
    return parseInt(match2) - 543;
  }
  if (/BCE?/i.test(match2)) {
    match2 = match2.replace(/BCE?/i, "");
    return -parseInt(match2);
  }
  if (/(AD|CE)/i.test(match2)) {
    match2 = match2.replace(/(AD|CE)/i, "");
    return parseInt(match2);
  }
  const rawYearNumber = parseInt(match2);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;
var SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, "i");
var SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY_NO_ABBR)})`;
var TIME_UNIT_CONNECTOR_PATTERN = `\\s{0,5},?(?:\\s*and)?\\s{0,5}`;
var TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
var TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\s{0,3})?`, SINGLE_TIME_UNIT_NO_ABBR_PATTERN, TIME_UNIT_CONNECTOR_PATTERN);
function parseTimeUnits(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  while (match2) {
    collectDateTimeFragment(fragments, match2);
    remainingText = remainingText.substring(match2[0].length).trim();
    match2 = SINGLE_TIME_UNIT_REGEX.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment(fragments, match2) {
  const num = parseNumberPattern(match2[1]);
  const unit = TIME_UNIT_DICTIONARY[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/common/parsers/AbstractParserWithWordBoundary.js
var AbstractParserWithWordBoundaryChecking = class {
  constructor() {
    this.cachedInnerPattern = null;
    this.cachedPattern = null;
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return this.innerPattern(context) !== currentInnerPattern;
  }
  patternLeftBoundary() {
    return `(\\W|^)`;
  }
  pattern(context) {
    if (this.cachedInnerPattern) {
      if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {
        return this.cachedPattern;
      }
    }
    this.cachedInnerPattern = this.innerPattern(context);
    this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags);
    return this.cachedPattern;
  }
  extract(context, match2) {
    var _a2;
    const header = (_a2 = match2[1]) != null ? _a2 : "";
    match2.index = match2.index + header.length;
    match2[0] = match2[0].substring(header.length);
    for (let i5 = 2; i5 < match2.length; i5++) {
      match2[i5 - 1] = match2[i5];
    }
    return this.innerExtract(context, match2);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitWithinFormatParser.js
var PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_WITH_PREFIX_STRICT = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern(context) {
    if (this.strictMode) {
      return PATTERN_WITH_PREFIX_STRICT;
    }
    return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;
  }
  innerExtract(context, match2) {
    if (match2[0].match(/^for\s*the\s*\w+/)) {
      return null;
    }
    const timeUnits = parseTimeUnits(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameLittleEndianParser.js
var PATTERN = new RegExp(`(?:on\\s{0,3})?(${ORDINAL_NUMBER_PATTERN})(?:\\s{0,3}(?:to|\\-|\\\u2013|until|through|till)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY)})(?:(?:-|/|,?\\s{0,3})(${YEAR_PATTERN}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP = 1;
var DATE_TO_GROUP = 2;
var MONTH_NAME_GROUP = 3;
var YEAR_GROUP = 4;
var ENMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY[match2[MONTH_NAME_GROUP].toLowerCase()];
    const day = parseOrdinalNumberPattern(match2[DATE_GROUP]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP]) {
      const yearNumber = parseYear(match2[YEAR_GROUP]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP]) {
      const endDate = parseOrdinalNumberPattern(match2[DATE_TO_GROUP]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameMiddleEndianParser.js
var PATTERN2 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY)})(?:-|/|\\s*,?\\s*)(${ORDINAL_NUMBER_PATTERN})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${ORDINAL_NUMBER_PATTERN})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${YEAR_PATTERN}))?(?=\\W|$)(?!\\:\\d)`, "i");
var MONTH_NAME_GROUP2 = 1;
var DATE_GROUP2 = 2;
var DATE_TO_GROUP2 = 3;
var YEAR_GROUP2 = 4;
var ENMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(shouldSkipYearLikeDate) {
    super();
    this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;
  }
  innerPattern() {
    return PATTERN2;
  }
  innerExtract(context, match2) {
    const month2 = MONTH_DICTIONARY[match2[MONTH_NAME_GROUP2].toLowerCase()];
    const day = parseOrdinalNumberPattern(match2[DATE_GROUP2]);
    if (day > 31) {
      return null;
    }
    if (this.shouldSkipYearLikeDate) {
      if (!match2[DATE_TO_GROUP2] && !match2[YEAR_GROUP2] && match2[DATE_GROUP2].match(/^2[0-5]$/)) {
        return null;
      }
    }
    const components = context.createParsingComponents({
      day,
      month: month2
    }).addTag("parser/ENMonthNameMiddleEndianParser");
    if (match2[YEAR_GROUP2]) {
      const year3 = parseYear(match2[YEAR_GROUP2]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      components.imply("year", year3);
    }
    if (!match2[DATE_TO_GROUP2]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern(match2[DATE_TO_GROUP2]);
    const result = context.createParsingResult(match2.index, match2[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENMonthNameParser.js
var PATTERN3 = new RegExp(`((?:in)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var PREFIX_GROUP = 1;
var MONTH_NAME_GROUP3 = 2;
var YEAR_GROUP3 = 3;
var ENMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN3;
  }
  innerExtract(context, match2) {
    const monthName = match2[MONTH_NAME_GROUP3].toLowerCase();
    if (match2[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match2.index + (match2[PREFIX_GROUP] || "").length, match2.index + match2[0].length);
    result.start.imply("day", 1);
    result.start.addTag("parser/ENMonthNameParser");
    const month2 = MONTH_DICTIONARY[monthName];
    result.start.assign("month", month2);
    if (match2[YEAR_GROUP3]) {
      const year3 = parseYear(match2[YEAR_GROUP3]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month2);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualYearMonthDayParser.js
var PATTERN4 = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP = 1;
var MONTH_NAME_GROUP4 = 2;
var MONTH_NUMBER_GROUP = 3;
var DATE_NUMBER_GROUP = 4;
var ENCasualYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN4;
  }
  innerExtract(context, match2) {
    const month2 = match2[MONTH_NUMBER_GROUP] ? parseInt(match2[MONTH_NUMBER_GROUP]) : MONTH_DICTIONARY[match2[MONTH_NAME_GROUP4].toLowerCase()];
    if (month2 < 1 || month2 > 12) {
      return null;
    }
    const year3 = parseInt(match2[YEAR_NUMBER_GROUP]);
    const day = parseInt(match2[DATE_NUMBER_GROUP]);
    return {
      day,
      month: month2,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENSlashMonthFormatParser.js
var PATTERN5 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP = 1;
var YEAR_GROUP4 = 2;
var ENSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN5;
  }
  innerExtract(context, match2) {
    const year3 = parseInt(match2[YEAR_GROUP4]);
    const month2 = parseInt(match2[MONTH_GROUP]);
    return context.createParsingComponents().imply("day", 1).assign("month", month2).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/AbstractTimeExpressionParser.js
function primaryTimePattern(leftBoundary, primaryPrefix, primarySuffix, flags) {
  return new RegExp(`${leftBoundary}${primaryPrefix}(\\d{1,4})(?:(?:\\.|:|\uFF1A)(\\d{1,2})(?:(?::|\uFF1A)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${primarySuffix}`, flags);
}
function followingTimePatten(followingPhase, followingSuffix) {
  return new RegExp(`^(${followingPhase})(\\d{1,4})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:(?:\\.|\\:|\\\uFF1A)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${followingSuffix}`, "i");
}
var HOUR_GROUP = 2;
var MINUTE_GROUP = 3;
var SECOND_GROUP = 4;
var MILLI_SECOND_GROUP = 5;
var AM_PM_HOUR_GROUP = 6;
var AbstractTimeExpressionParser = class {
  constructor(strictMode = false) {
    this.cachedPrimaryPrefix = null;
    this.cachedPrimarySuffix = null;
    this.cachedPrimaryTimePattern = null;
    this.cachedFollowingPhase = null;
    this.cachedFollowingSuffix = null;
    this.cachedFollowingTimePatten = null;
    this.strictMode = strictMode;
  }
  patternFlags() {
    return "i";
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|\\b)`;
  }
  primarySuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  followingSuffix() {
    return `(?!/)(?=\\W|$)`;
  }
  pattern(context) {
    return this.getPrimaryTimePatternThroughCache();
  }
  extract(context, match2) {
    const startComponents = this.extractPrimaryTimeComponents(context, match2);
    if (!startComponents) {
      match2.index += match2[0].length;
      return null;
    }
    const index4 = match2.index + match2[1].length;
    const text = match2[0].substring(match2[1].length);
    const result = context.createParsingResult(index4, text, startComponents);
    match2.index += match2[0].length;
    const remainingText = context.text.substring(match2.index);
    const followingPattern = this.getFollowingTimePatternThroughCache();
    const followingMatch = followingPattern.exec(remainingText);
    if (text.match(/^\d{3,4}/) && followingMatch && followingMatch[0].match(/^\s*([+-])\s*\d{2,4}$/)) {
      return null;
    }
    if (!followingMatch || followingMatch[0].match(/^\s*([+-])\s*\d{3,4}$/)) {
      return this.checkAndReturnWithoutFollowingPattern(result);
    }
    result.end = this.extractFollowingTimeComponents(context, followingMatch, result);
    if (result.end) {
      result.text += followingMatch[0];
    }
    return this.checkAndReturnWithFollowingPattern(result);
  }
  extractPrimaryTimeComponents(context, match2, strict11 = false) {
    const components = context.createParsingComponents();
    let minute = 0;
    let meridiem = null;
    let hour = parseInt(match2[HOUR_GROUP]);
    if (hour > 100) {
      if (this.strictMode || match2[MINUTE_GROUP] != null) {
        return null;
      }
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (hour > 24) {
      return null;
    }
    if (match2[MINUTE_GROUP] != null) {
      if (match2[MINUTE_GROUP].length == 1 && !match2[AM_PM_HOUR_GROUP]) {
        return null;
      }
      minute = parseInt(match2[MINUTE_GROUP]);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 12) {
      meridiem = Meridiem.PM;
    }
    if (match2[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12)
        return null;
      const ampm = match2[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem !== null) {
      components.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        components.imply("meridiem", Meridiem.AM);
      } else {
        components.imply("meridiem", Meridiem.PM);
      }
    }
    if (match2[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match2[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match2[SECOND_GROUP] != null) {
      const second = parseInt(match2[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    return components;
  }
  extractFollowingTimeComponents(context, match2, result) {
    const components = context.createParsingComponents();
    if (match2[MILLI_SECOND_GROUP] != null) {
      const millisecond = parseInt(match2[MILLI_SECOND_GROUP].substring(0, 3));
      if (millisecond >= 1e3)
        return null;
      components.assign("millisecond", millisecond);
    }
    if (match2[SECOND_GROUP] != null) {
      const second = parseInt(match2[SECOND_GROUP]);
      if (second >= 60)
        return null;
      components.assign("second", second);
    }
    let hour = parseInt(match2[HOUR_GROUP]);
    let minute = 0;
    let meridiem = -1;
    if (match2[MINUTE_GROUP] != null) {
      minute = parseInt(match2[MINUTE_GROUP]);
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match2[AM_PM_HOUR_GROUP] != null) {
      if (hour > 12) {
        return null;
      }
      const ampm = match2[AM_PM_HOUR_GROUP][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
          if (!components.isCertain("day")) {
            components.imply("day", components.get("day") + 1);
          }
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == Meridiem.AM) {
          result.start.imply("meridiem", Meridiem.AM);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", Meridiem.PM);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    }
    components.assign("hour", hour);
    components.assign("minute", minute);
    if (meridiem >= 0) {
      components.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("hour") > 12;
      if (startAtPM) {
        if (result.start.get("hour") - 12 > hour) {
          components.imply("meridiem", Meridiem.AM);
        } else if (hour <= 12) {
          components.assign("hour", hour + 12);
          components.assign("meridiem", Meridiem.PM);
        }
      } else if (hour > 12) {
        components.imply("meridiem", Meridiem.PM);
      } else if (hour <= 12) {
        components.imply("meridiem", Meridiem.AM);
      }
    }
    if (components.date().getTime() < result.start.date().getTime()) {
      components.imply("day", components.get("day") + 1);
    }
    return components;
  }
  checkAndReturnWithoutFollowingPattern(result) {
    if (result.text.match(/^\d$/)) {
      return null;
    }
    if (result.text.match(/^\d\d\d+$/)) {
      return null;
    }
    if (result.text.match(/\d[apAP]$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)$/);
    if (endingWithNumbers) {
      const endingNumbers = endingWithNumbers[1];
      if (this.strictMode) {
        return null;
      }
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      if (endingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  checkAndReturnWithFollowingPattern(result) {
    if (result.text.match(/^\d+-\d+$/)) {
      return null;
    }
    const endingWithNumbers = result.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/);
    if (endingWithNumbers) {
      if (this.strictMode) {
        return null;
      }
      const startingNumbers = endingWithNumbers[1];
      const endingNumbers = endingWithNumbers[2];
      if (endingNumbers.includes(".") && !endingNumbers.match(/\d(\.\d{2})+$/)) {
        return null;
      }
      const endingNumberVal = parseInt(endingNumbers);
      const startingNumberVal = parseInt(startingNumbers);
      if (endingNumberVal > 24 || startingNumberVal > 24) {
        return null;
      }
    }
    return result;
  }
  getPrimaryTimePatternThroughCache() {
    const primaryPrefix = this.primaryPrefix();
    const primarySuffix = this.primarySuffix();
    if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {
      return this.cachedPrimaryTimePattern;
    }
    this.cachedPrimaryTimePattern = primaryTimePattern(this.primaryPatternLeftBoundary(), primaryPrefix, primarySuffix, this.patternFlags());
    this.cachedPrimaryPrefix = primaryPrefix;
    this.cachedPrimarySuffix = primarySuffix;
    return this.cachedPrimaryTimePattern;
  }
  getFollowingTimePatternThroughCache() {
    const followingPhase = this.followingPhase();
    const followingSuffix = this.followingSuffix();
    if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {
      return this.cachedFollowingTimePatten;
    }
    this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);
    this.cachedFollowingPhase = followingPhase;
    this.cachedFollowingSuffix = followingSuffix;
    return this.cachedFollowingTimePatten;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeExpressionParser.js
var ENTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  followingPhase() {
    return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|to|until|through|till|\\?)\\s*";
  }
  primaryPrefix() {
    return "(?:(?:at|from)\\s*)??";
  }
  primarySuffix() {
    return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match2) {
    const components = super.extractPrimaryTimeComponents(context, match2);
    if (!components) {
      return components;
    }
    if (match2[0].endsWith("night")) {
      const hour = components.get("hour");
      if (hour >= 6 && hour < 12) {
        components.assign("hour", components.get("hour") + 12);
        components.assign("meridiem", Meridiem.PM);
      } else if (hour < 6) {
        components.assign("meridiem", Meridiem.AM);
      }
    }
    if (match2[0].endsWith("afternoon")) {
      components.assign("meridiem", Meridiem.PM);
      const hour = components.get("hour");
      if (hour >= 0 && hour <= 6) {
        components.assign("hour", components.get("hour") + 12);
      }
    }
    if (match2[0].endsWith("morning")) {
      components.assign("meridiem", Meridiem.AM);
      const hour = components.get("hour");
      if (hour < 12) {
        components.assign("hour", components.get("hour"));
      }
    }
    return components.addTag("parser/ENTimeExpressionParser");
  }
};

// node_modules/chrono-node/dist/esm/utils/timeunits.js
function reverseTimeUnits(timeUnits) {
  const reversed = {};
  for (const key in timeUnits) {
    reversed[key] = -timeUnits[key];
  }
  return reversed;
}
function addImpliedTimeUnits(components, timeUnits) {
  const output = components.clone();
  let date = components.dayjs();
  for (const key in timeUnits) {
    date = date.add(timeUnits[key], key);
  }
  if ("day" in timeUnits || "d" in timeUnits || "week" in timeUnits || "month" in timeUnits || "year" in timeUnits) {
    output.imply("day", date.date());
    output.imply("month", date.month() + 1);
    output.imply("year", date.year());
  }
  if ("second" in timeUnits || "minute" in timeUnits || "hour" in timeUnits) {
    output.imply("second", date.second());
    output.imply("minute", date.minute());
    output.imply("hour", date.hour());
  }
  return output;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitAgoFormatParser.js
var PATTERN6 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i");
var ENTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN : PATTERN6;
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits(match2[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitLaterFormatParser.js
var PATTERN7 = new RegExp(`(${TIME_UNITS_PATTERN})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i");
var STRICT_PATTERN2 = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i");
var GROUP_NUM_TIMEUNITS = 1;
var ENTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN2 : PATTERN7;
  }
  innerExtract(context, match2) {
    const fragments = parseTimeUnits(match2[GROUP_NUM_TIMEUNITS]);
    return ParsingComponents.createRelativeFromReference(context.reference, fragments);
  }
};

// node_modules/chrono-node/dist/esm/common/abstractRefiners.js
var Filter = class {
  refine(context, results) {
    return results.filter((r3) => this.isValid(context, r3));
  }
};
var MergingRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const mergedResults = [];
    let curResult = results[0];
    let nextResult = null;
    for (let i5 = 1; i5 < results.length; i5++) {
      nextResult = results[i5];
      const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);
      if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {
        mergedResults.push(curResult);
        curResult = nextResult;
      } else {
        const left = curResult;
        const right = nextResult;
        const mergedResult = this.mergeResults(textBetween, left, right, context);
        context.debug(() => {
          console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);
        });
        curResult = mergedResult;
      }
    }
    if (curResult != null) {
      mergedResults.push(curResult);
    }
    return mergedResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateRangeRefiner.js
var AbstractMergeDateRangeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, fromResult, toResult) {
    if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {
      toResult.start.getCertainComponents().forEach((key) => {
        if (!fromResult.start.isCertain(key)) {
          fromResult.start.imply(key, toResult.start.get(key));
        }
      });
      fromResult.start.getCertainComponents().forEach((key) => {
        if (!toResult.start.isCertain(key)) {
          toResult.start.imply(key, fromResult.start.get(key));
        }
      });
    }
    if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
      let fromMoment = fromResult.start.dayjs();
      let toMoment = toResult.start.dayjs();
      if (toResult.start.isOnlyWeekdayComponent() && toMoment.add(7, "days").isAfter(fromMoment)) {
        toMoment = toMoment.add(7, "days");
        toResult.start.imply("day", toMoment.date());
        toResult.start.imply("month", toMoment.month() + 1);
        toResult.start.imply("year", toMoment.year());
      } else if (fromResult.start.isOnlyWeekdayComponent() && fromMoment.add(-7, "days").isBefore(toMoment)) {
        fromMoment = fromMoment.add(-7, "days");
        fromResult.start.imply("day", fromMoment.date());
        fromResult.start.imply("month", fromMoment.month() + 1);
        fromResult.start.imply("year", fromMoment.year());
      } else if (toResult.start.isDateWithUnknownYear() && toMoment.add(1, "years").isAfter(fromMoment)) {
        toMoment = toMoment.add(1, "years");
        toResult.start.imply("year", toMoment.year());
      } else if (fromResult.start.isDateWithUnknownYear() && fromMoment.add(-1, "years").isBefore(toMoment)) {
        fromMoment = fromMoment.add(-1, "years");
        fromResult.start.imply("year", fromMoment.year());
      } else {
        [toResult, fromResult] = [fromResult, toResult];
      }
    }
    const result = fromResult.clone();
    result.start = fromResult.start;
    result.end = toResult.start;
    result.index = Math.min(fromResult.index, toResult.index);
    if (fromResult.index < toResult.index) {
      result.text = fromResult.text + textBetween + toResult.text;
    } else {
      result.text = toResult.text + textBetween + fromResult.text;
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateRangeRefiner.js
var ENMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(to|-|–|until|through|till)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/calculation/mergingCalculation.js
function mergeDateTimeResult(dateResult, timeResult) {
  const result = dateResult.clone();
  const beginDate = dateResult.start;
  const beginTime = timeResult.start;
  result.start = mergeDateTimeComponent(beginDate, beginTime);
  if (dateResult.end != null || timeResult.end != null) {
    const endDate = dateResult.end == null ? dateResult.start : dateResult.end;
    const endTime = timeResult.end == null ? timeResult.start : timeResult.end;
    const endDateTime = mergeDateTimeComponent(endDate, endTime);
    if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {
      const nextDayJs = endDateTime.dayjs().add(1, "day");
      if (endDateTime.isCertain("day")) {
        assignSimilarDate(endDateTime, nextDayJs);
      } else {
        implySimilarDate(endDateTime, nextDayJs);
      }
    }
    result.end = endDateTime;
  }
  return result;
}
function mergeDateTimeComponent(dateComponent, timeComponent) {
  const dateTimeComponent = dateComponent.clone();
  if (timeComponent.isCertain("hour")) {
    dateTimeComponent.assign("hour", timeComponent.get("hour"));
    dateTimeComponent.assign("minute", timeComponent.get("minute"));
    if (timeComponent.isCertain("second")) {
      dateTimeComponent.assign("second", timeComponent.get("second"));
      if (timeComponent.isCertain("millisecond")) {
        dateTimeComponent.assign("millisecond", timeComponent.get("millisecond"));
      } else {
        dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
      }
    } else {
      dateTimeComponent.imply("second", timeComponent.get("second"));
      dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
    }
  } else {
    dateTimeComponent.imply("hour", timeComponent.get("hour"));
    dateTimeComponent.imply("minute", timeComponent.get("minute"));
    dateTimeComponent.imply("second", timeComponent.get("second"));
    dateTimeComponent.imply("millisecond", timeComponent.get("millisecond"));
  }
  if (timeComponent.isCertain("timezoneOffset")) {
    dateTimeComponent.assign("timezoneOffset", timeComponent.get("timezoneOffset"));
  }
  if (timeComponent.isCertain("meridiem")) {
    dateTimeComponent.assign("meridiem", timeComponent.get("meridiem"));
  } else if (timeComponent.get("meridiem") != null && dateTimeComponent.get("meridiem") == null) {
    dateTimeComponent.imply("meridiem", timeComponent.get("meridiem"));
  }
  if (dateTimeComponent.get("meridiem") == Meridiem.PM && dateTimeComponent.get("hour") < 12) {
    if (timeComponent.isCertain("hour")) {
      dateTimeComponent.assign("hour", dateTimeComponent.get("hour") + 12);
    } else {
      dateTimeComponent.imply("hour", dateTimeComponent.get("hour") + 12);
    }
  }
  dateTimeComponent.addTags(dateComponent.tags());
  dateTimeComponent.addTags(timeComponent.tags());
  return dateTimeComponent;
}

// node_modules/chrono-node/dist/esm/common/refiners/AbstractMergeDateTimeRefiner.js
var AbstractMergeDateTimeRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    return (currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime() || nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime()) && textBetween.match(this.patternBetween()) != null;
  }
  mergeResults(textBetween, currentResult, nextResult) {
    const result = currentResult.start.isOnlyDate() ? mergeDateTimeResult(currentResult, nextResult) : mergeDateTimeResult(nextResult, currentResult);
    result.index = currentResult.index;
    result.text = currentResult.text + textBetween + nextResult.text;
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeDateTimeRefiner.js
var ENMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneAbbrRefiner.js
var TIMEZONE_NAME_PATTERN = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i");
var ExtractTimezoneAbbrRefiner = class {
  constructor(timezoneOverrides) {
    this.timezoneOverrides = timezoneOverrides;
  }
  refine(context, results) {
    var _a2;
    const timezoneOverrides = (_a2 = context.option.timezones) != null ? _a2 : {};
    results.forEach((result) => {
      var _a3, _b2;
      const suffix = context.text.substring(result.index + result.text.length);
      const match2 = TIMEZONE_NAME_PATTERN.exec(suffix);
      if (!match2) {
        return;
      }
      const timezoneAbbr = match2[1].toUpperCase();
      const refDate = (_b2 = (_a3 = result.start.date()) != null ? _a3 : result.refDate) != null ? _b2 : new Date();
      const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };
      const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);
      if (extractedTimezoneOffset == null) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`);
      });
      const currentTimezoneOffset = result.start.get("timezoneOffset");
      if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {
        if (result.start.isCertain("timezoneOffset")) {
          return;
        }
        if (timezoneAbbr != match2[1]) {
          return;
        }
      }
      if (result.start.isOnlyDate()) {
        if (timezoneAbbr != match2[1]) {
          return;
        }
      }
      result.text += match2[0];
      if (!result.start.isCertain("timezoneOffset")) {
        result.start.assign("timezoneOffset", extractedTimezoneOffset);
      }
      if (result.end != null && !result.end.isCertain("timezoneOffset")) {
        result.end.assign("timezoneOffset", extractedTimezoneOffset);
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ExtractTimezoneOffsetRefiner.js
var TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i");
var TIMEZONE_OFFSET_SIGN_GROUP = 1;
var TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;
var TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;
var ExtractTimezoneOffsetRefiner = class {
  refine(context, results) {
    results.forEach(function(result) {
      if (result.start.isCertain("timezoneOffset")) {
        return;
      }
      const suffix = context.text.substring(result.index + result.text.length);
      const match2 = TIMEZONE_OFFSET_PATTERN.exec(suffix);
      if (!match2) {
        return;
      }
      context.debug(() => {
        console.log(`Extracting timezone: '${match2[0]}' into : ${result}`);
      });
      const hourOffset = parseInt(match2[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);
      const minuteOffset = parseInt(match2[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || "0");
      let timezoneOffset = hourOffset * 60 + minuteOffset;
      if (timezoneOffset > 14 * 60) {
        return;
      }
      if (match2[TIMEZONE_OFFSET_SIGN_GROUP] === "-") {
        timezoneOffset = -timezoneOffset;
      }
      if (result.end != null) {
        result.end.assign("timezoneOffset", timezoneOffset);
      }
      result.start.assign("timezoneOffset", timezoneOffset);
      result.text += match2[0];
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/OverlapRemovalRefiner.js
var OverlapRemovalRefiner = class {
  refine(context, results) {
    if (results.length < 2) {
      return results;
    }
    const filteredResults = [];
    let prevResult = results[0];
    for (let i5 = 1; i5 < results.length; i5++) {
      const result = results[i5];
      if (result.index >= prevResult.index + prevResult.text.length) {
        filteredResults.push(prevResult);
        prevResult = result;
        continue;
      }
      let kept = null;
      let removed = null;
      if (result.text.length > prevResult.text.length) {
        kept = result;
        removed = prevResult;
      } else {
        kept = prevResult;
        removed = result;
      }
      context.debug(() => {
        console.log(`${this.constructor.name} remove ${removed} by ${kept}`);
      });
      prevResult = kept;
    }
    if (prevResult != null) {
      filteredResults.push(prevResult);
    }
    return filteredResults;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/ForwardDateRefiner.js
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
var ForwardDateRefiner = class {
  refine(context, results) {
    if (!context.option.forwardDate) {
      return results;
    }
    results.forEach(function(result) {
      let refMoment = (0, import_dayjs6.default)(context.refDate);
      if (result.start.isOnlyTime() && refMoment.isAfter(result.start.dayjs())) {
        refMoment = refMoment.add(1, "day");
        implySimilarDate(result.start, refMoment);
        if (result.end && result.end.isOnlyTime()) {
          implySimilarDate(result.end, refMoment);
          if (result.start.dayjs().isAfter(result.end.dayjs())) {
            refMoment = refMoment.add(1, "day");
            implySimilarDate(result.end, refMoment);
          }
        }
      }
      if (result.start.isOnlyWeekdayComponent() && refMoment.isAfter(result.start.dayjs())) {
        if (refMoment.day() >= result.start.get("weekday")) {
          refMoment = refMoment.day(result.start.get("weekday") + 7);
        } else {
          refMoment = refMoment.day(result.start.get("weekday"));
        }
        result.start.imply("day", refMoment.date());
        result.start.imply("month", refMoment.month() + 1);
        result.start.imply("year", refMoment.year());
        context.debug(() => {
          console.log(`Forward weekly adjusted for ${result} (${result.start})`);
        });
        if (result.end && result.end.isOnlyWeekdayComponent()) {
          if (refMoment.day() > result.end.get("weekday")) {
            refMoment = refMoment.day(result.end.get("weekday") + 7);
          } else {
            refMoment = refMoment.day(result.end.get("weekday"));
          }
          result.end.imply("day", refMoment.date());
          result.end.imply("month", refMoment.month() + 1);
          result.end.imply("year", refMoment.year());
          context.debug(() => {
            console.log(`Forward weekly adjusted for ${result} (${result.end})`);
          });
        }
      }
      if (result.start.isDateWithUnknownYear() && refMoment.isAfter(result.start.dayjs())) {
        for (let i5 = 0; i5 < 3 && refMoment.isAfter(result.start.dayjs()); i5++) {
          result.start.imply("year", result.start.get("year") + 1);
          context.debug(() => {
            console.log(`Forward yearly adjusted for ${result} (${result.start})`);
          });
          if (result.end && !result.end.isCertain("year")) {
            result.end.imply("year", result.end.get("year") + 1);
            context.debug(() => {
              console.log(`Forward yearly adjusted for ${result} (${result.end})`);
            });
          }
        }
      }
    });
    return results;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/UnlikelyFormatFilter.js
var UnlikelyFormatFilter = class extends Filter {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  isValid(context, result) {
    if (result.text.replace(" ", "").match(/^\d*(\.\d*)?$/)) {
      context.debug(() => {
        console.log(`Removing unlikely result '${result.text}'`);
      });
      return false;
    }
    if (!result.start.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.start})`);
      });
      return false;
    }
    if (result.end && !result.end.isValidDate()) {
      context.debug(() => {
        console.log(`Removing invalid result: ${result} (${result.end})`);
      });
      return false;
    }
    if (this.strictMode) {
      return this.isStrictModeValid(context, result);
    }
    return true;
  }
  isStrictModeValid(context, result) {
    if (result.start.isOnlyWeekdayComponent()) {
      context.debug(() => {
        console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);
      });
      return false;
    }
    if (result.start.isOnlyTime() && (!result.start.isCertain("hour") || !result.start.isCertain("minute"))) {
      context.debug(() => {
        console.log(`(Strict) Removing uncertain time component: ${result} (${result.end})`);
      });
      return false;
    }
    return true;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/ISOFormatParser.js
var PATTERN8 = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(?:Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i");
var YEAR_NUMBER_GROUP2 = 1;
var MONTH_NUMBER_GROUP2 = 2;
var DATE_NUMBER_GROUP2 = 3;
var HOUR_NUMBER_GROUP = 4;
var MINUTE_NUMBER_GROUP = 5;
var SECOND_NUMBER_GROUP = 6;
var MILLISECOND_NUMBER_GROUP = 7;
var TZD_HOUR_OFFSET_GROUP = 8;
var TZD_MINUTE_OFFSET_GROUP = 9;
var ISOFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN8;
  }
  innerExtract(context, match2) {
    const components = {};
    components["year"] = parseInt(match2[YEAR_NUMBER_GROUP2]);
    components["month"] = parseInt(match2[MONTH_NUMBER_GROUP2]);
    components["day"] = parseInt(match2[DATE_NUMBER_GROUP2]);
    if (match2[HOUR_NUMBER_GROUP] != null) {
      components["hour"] = parseInt(match2[HOUR_NUMBER_GROUP]);
      components["minute"] = parseInt(match2[MINUTE_NUMBER_GROUP]);
      if (match2[SECOND_NUMBER_GROUP] != null) {
        components["second"] = parseInt(match2[SECOND_NUMBER_GROUP]);
      }
      if (match2[MILLISECOND_NUMBER_GROUP] != null) {
        components["millisecond"] = parseInt(match2[MILLISECOND_NUMBER_GROUP]);
      }
      if (match2[TZD_HOUR_OFFSET_GROUP] == null) {
        components["timezoneOffset"] = 0;
      } else {
        const hourOffset = parseInt(match2[TZD_HOUR_OFFSET_GROUP]);
        let minuteOffset = 0;
        if (match2[TZD_MINUTE_OFFSET_GROUP] != null) {
          minuteOffset = parseInt(match2[TZD_MINUTE_OFFSET_GROUP]);
        }
        let offset2 = hourOffset * 60;
        if (offset2 < 0) {
          offset2 -= minuteOffset;
        } else {
          offset2 += minuteOffset;
        }
        components["timezoneOffset"] = offset2;
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/common/refiners/MergeWeekdayComponentRefiner.js
var MergeWeekdayComponentRefiner = class extends MergingRefiner {
  mergeResults(textBetween, currentResult, nextResult) {
    const newResult = nextResult.clone();
    newResult.index = currentResult.index;
    newResult.text = currentResult.text + textBetween + newResult.text;
    newResult.start.assign("weekday", currentResult.start.get("weekday"));
    if (newResult.end) {
      newResult.end.assign("weekday", currentResult.start.get("weekday"));
    }
    return newResult;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    const weekdayThenNormalDate = currentResult.start.isOnlyWeekdayComponent() && !currentResult.start.isCertain("hour") && nextResult.start.isCertain("day");
    return weekdayThenNormalDate && textBetween.match(/^,?\s*$/) != null;
  }
};

// node_modules/chrono-node/dist/esm/configurations.js
function includeCommonConfiguration(configuration2, strictMode = false) {
  configuration2.parsers.unshift(new ISOFormatParser());
  configuration2.refiners.unshift(new MergeWeekdayComponentRefiner());
  configuration2.refiners.unshift(new ExtractTimezoneOffsetRefiner());
  configuration2.refiners.unshift(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ExtractTimezoneAbbrRefiner());
  configuration2.refiners.push(new OverlapRemovalRefiner());
  configuration2.refiners.push(new ForwardDateRefiner());
  configuration2.refiners.push(new UnlikelyFormatFilter(strictMode));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
var import_dayjs10 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/common/casualReferences.js
var import_dayjs8 = __toESM(require_dayjs_min(), 1);
function now(reference) {
  const targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  assignSimilarTime(component, targetDate);
  if (reference.timezoneOffset !== null) {
    component.assign("timezoneOffset", targetDate.utcOffset());
  }
  component.addTag("casualReference/now");
  return component;
}
function today(reference) {
  const targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  implySimilarTime(component, targetDate);
  component.addTag("casualReference/today");
  return component;
}
function yesterday(reference) {
  return theDayBefore(reference, 1).addTag("casualReference/yesterday");
}
function theDayBefore(reference, numDay) {
  return theDayAfter(reference, -numDay);
}
function tomorrow(reference) {
  return theDayAfter(reference, 1).addTag("casualReference/tomorrow");
}
function theDayAfter(reference, nDays) {
  let targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  targetDate = targetDate.add(nDays, "day");
  assignSimilarDate(component, targetDate);
  implySimilarTime(component, targetDate);
  return component;
}
function tonight(reference, implyHour = 22) {
  const targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/tonight");
  return component;
}
function lastNight(reference, implyHour = 0) {
  let targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  if (targetDate.hour() < 6) {
    targetDate = targetDate.add(-1, "day");
  }
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  return component;
}
function evening(reference, implyHour = 20) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.addTag("casualReference/evening");
  return component;
}
function yesterdayEvening(reference, implyHour = 20) {
  let targetDate = (0, import_dayjs8.default)(reference.instant);
  const component = new ParsingComponents(reference, {});
  targetDate = targetDate.add(-1, "day");
  assignSimilarDate(component, targetDate);
  component.imply("hour", implyHour);
  component.imply("meridiem", Meridiem.PM);
  component.addTag("casualReference/yesterday");
  component.addTag("casualReference/evening");
  return component;
}
function midnight(reference) {
  const component = new ParsingComponents(reference, {});
  const targetDate = (0, import_dayjs8.default)(reference.instant);
  if (targetDate.hour() > 2) {
    implyTheNextDay(component, targetDate);
  }
  component.assign("hour", 0);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/midnight");
  return component;
}
function morning(reference, implyHour = 6) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/morning");
  return component;
}
function afternoon(reference, implyHour = 15) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.PM);
  component.imply("hour", implyHour);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/afternoon");
  return component;
}
function noon(reference) {
  const component = new ParsingComponents(reference, {});
  component.imply("meridiem", Meridiem.AM);
  component.imply("hour", 12);
  component.imply("minute", 0);
  component.imply("second", 0);
  component.imply("millisecond", 0);
  component.addTag("casualReference/noon");
  return component;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualDateParser.js
var PATTERN9 = /(now|today|tonight|tomorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i;
var ENCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN9;
  }
  innerExtract(context, match2) {
    let targetDate = (0, import_dayjs10.default)(context.refDate);
    const lowerText = match2[0].toLowerCase();
    let component = context.createParsingComponents();
    switch (lowerText) {
      case "now":
        component = now(context.reference);
        break;
      case "today":
        component = today(context.reference);
        break;
      case "yesterday":
        component = yesterday(context.reference);
        break;
      case "tomorrow":
      case "tmr":
      case "tmrw":
        component = tomorrow(context.reference);
        break;
      case "tonight":
        component = tonight(context.reference);
        break;
      default:
        if (lowerText.match(/last\s*night/)) {
          if (targetDate.hour() > 6) {
            targetDate = targetDate.add(-1, "day");
          }
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    component.addTag("parser/ENCasualDateParser");
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENCasualTimeParser.js
var PATTERN10 = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i;
var ENCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN10;
  }
  innerExtract(context, match2) {
    let component = null;
    switch (match2[1].toLowerCase()) {
      case "afternoon":
        component = afternoon(context.reference);
        break;
      case "evening":
      case "night":
        component = evening(context.reference);
        break;
      case "midnight":
        component = midnight(context.reference);
        break;
      case "morning":
        component = morning(context.reference);
        break;
      case "noon":
      case "midday":
        component = noon(context.reference);
        break;
    }
    if (component) {
      component.addTag("parser/ENCasualTimeParser");
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/common/calculation/weekdays.js
function createParsingComponentsAtWeekday(reference, weekday, modifier) {
  const refDate = reference.getDateWithAdjustedTimezone();
  const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);
  let components = new ParsingComponents(reference);
  components = addImpliedTimeUnits(components, { "day": daysToWeekday });
  components.assign("weekday", weekday);
  return components;
}
function getDaysToWeekday(refDate, weekday, modifier) {
  const refWeekday = refDate.getDay();
  switch (modifier) {
    case "this":
      return getDaysForwardToWeekday(refDate, weekday);
    case "last":
      return getBackwardDaysToWeekday(refDate, weekday);
    case "next":
      if (refWeekday == Weekday.SUNDAY) {
        return weekday == Weekday.SUNDAY ? 7 : weekday;
      }
      if (refWeekday == Weekday.SATURDAY) {
        if (weekday == Weekday.SATURDAY)
          return 7;
        if (weekday == Weekday.SUNDAY)
          return 8;
        return 1 + weekday;
      }
      if (weekday < refWeekday && weekday != Weekday.SUNDAY) {
        return getDaysForwardToWeekday(refDate, weekday);
      } else {
        return getDaysForwardToWeekday(refDate, weekday) + 7;
      }
  }
  return getDaysToWeekdayClosest(refDate, weekday);
}
function getDaysToWeekdayClosest(refDate, weekday) {
  const backward = getBackwardDaysToWeekday(refDate, weekday);
  const forward = getDaysForwardToWeekday(refDate, weekday);
  return forward < -backward ? forward : backward;
}
function getDaysForwardToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let forwardCount = weekday - refWeekday;
  if (forwardCount < 0) {
    forwardCount += 7;
  }
  return forwardCount;
}
function getBackwardDaysToWeekday(refDate, weekday) {
  const refWeekday = refDate.getDay();
  let backwardCount = weekday - refWeekday;
  if (backwardCount >= 0) {
    backwardCount -= 7;
  }
  return backwardCount;
}

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENWeekdayParser.js
var PATTERN11 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i");
var PREFIX_GROUP2 = 1;
var WEEKDAY_GROUP = 2;
var POSTFIX_GROUP = 3;
var ENWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN11;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY[dayOfWeek];
    const prefix5 = match2[PREFIX_GROUP2];
    const postfix = match2[POSTFIX_GROUP];
    let modifierWord = prefix5 || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "last" || modifierWord == "past") {
      modifier = "last";
    } else if (modifierWord == "next") {
      modifier = "next";
    } else if (modifierWord == "this") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENRelativeDateFormatParser.js
var import_dayjs12 = __toESM(require_dayjs_min(), 1);
var PATTERN12 = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP = 1;
var RELATIVE_WORD_GROUP = 2;
var ENRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN12;
  }
  innerExtract(context, match2) {
    const modifier = match2[MODIFIER_WORD_GROUP].toLowerCase();
    const unitWord = match2[RELATIVE_WORD_GROUP].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY[unitWord];
    if (modifier == "next" || modifier.startsWith("after")) {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "last" || modifier == "past") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs12.default)(context.reference.instant);
    if (unitWord.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (unitWord.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (unitWord.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/common/parsers/SlashDateFormatParser.js
var PATTERN13 = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i");
var OPENING_GROUP = 1;
var ENDING_GROUP = 5;
var FIRST_NUMBERS_GROUP = 2;
var SECOND_NUMBERS_GROUP = 3;
var YEAR_GROUP5 = 4;
var SlashDateFormatParser = class {
  constructor(littleEndian) {
    this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;
    this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;
  }
  pattern() {
    return PATTERN13;
  }
  extract(context, match2) {
    if (match2[OPENING_GROUP].length == 0 && match2.index > 0 && match2.index < context.text.length) {
      const previousChar = context.text[match2.index - 1];
      if (previousChar >= "0" && previousChar <= "9") {
        return;
      }
    }
    const index4 = match2.index + match2[OPENING_GROUP].length;
    const text = match2[0].substr(match2[OPENING_GROUP].length, match2[0].length - match2[OPENING_GROUP].length - match2[ENDING_GROUP].length);
    if (text.match(/^\d\.\d$/) || text.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/)) {
      return;
    }
    if (!match2[YEAR_GROUP5] && match2[0].indexOf("/") < 0) {
      return;
    }
    const result = context.createParsingResult(index4, text);
    let month2 = parseInt(match2[this.groupNumberMonth]);
    let day = parseInt(match2[this.groupNumberDay]);
    if (month2 < 1 || month2 > 12) {
      if (month2 > 12) {
        if (day >= 1 && day <= 12 && month2 <= 31) {
          [day, month2] = [month2, day];
        } else {
          return null;
        }
      }
    }
    if (day < 1 || day > 31) {
      return null;
    }
    result.start.assign("day", day);
    result.start.assign("month", month2);
    if (match2[YEAR_GROUP5]) {
      const rawYearNumber = parseInt(match2[YEAR_GROUP5]);
      const year3 = findMostLikelyADYear(rawYearNumber);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.js
var PATTERN14 = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_PATTERN})(?=\\W|$)`, "i");
var PATTERN_NO_ABBR = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\W|$)`, "i");
var ENTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(allowAbbreviations = true) {
    super();
    this.allowAbbreviations = allowAbbreviations;
  }
  innerPattern() {
    return this.allowAbbreviations ? PATTERN14 : PATTERN_NO_ABBR;
  }
  innerExtract(context, match2) {
    const prefix5 = match2[1].toLowerCase();
    let timeUnits = parseTimeUnits(match2[2]);
    switch (prefix5) {
      case "last":
      case "past":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeAfterDateRefiner.js
function IsPositiveFollowingReference(result) {
  return result.text.match(/^[+-]/i) != null;
}
function IsNegativeFollowingReference(result) {
  return result.text.match(/^-/i) != null;
}
var ENMergeRelativeAfterDateRefiner = class extends MergingRefiner {
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(/^\s*$/i)) {
      return false;
    }
    return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);
  }
  mergeResults(textBetween, currentResult, nextResult, context) {
    let timeUnits = parseTimeUnits(nextResult.text);
    if (IsNegativeFollowingReference(nextResult)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    const components = ParsingComponents.createRelativeFromReference(new ReferenceWithTimezone(currentResult.start.date()), timeUnits);
    return new ParsingResult(currentResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.js
function hasImpliedEarlierReferenceDate(result) {
  return result.text.match(/\s+(before|from)$/i) != null;
}
function hasImpliedLaterReferenceDate(result) {
  return result.text.match(/\s+(after|since)$/i) != null;
}
var ENMergeRelativeFollowByDateRefiner = class extends MergingRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
  shouldMergeResults(textBetween, currentResult, nextResult) {
    if (!textBetween.match(this.patternBetween())) {
      return false;
    }
    if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {
      return false;
    }
    return !!nextResult.start.get("day") && !!nextResult.start.get("month") && !!nextResult.start.get("year");
  }
  mergeResults(textBetween, currentResult, nextResult) {
    let timeUnits = parseTimeUnits(currentResult.text);
    if (hasImpliedEarlierReferenceDate(currentResult)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    const components = ParsingComponents.createRelativeFromReference(new ReferenceWithTimezone(nextResult.start.date()), timeUnits);
    return new ParsingResult(nextResult.reference, currentResult.index, `${currentResult.text}${textBetween}${nextResult.text}`, components);
  }
};

// node_modules/chrono-node/dist/esm/locales/en/configuration.js
var ENDefaultConfiguration = class {
  createCasualConfiguration(littleEndian = false) {
    const option = this.createConfiguration(false, littleEndian);
    option.parsers.push(new ENCasualDateParser());
    option.parsers.push(new ENCasualTimeParser());
    option.parsers.push(new ENMonthNameParser());
    option.parsers.push(new ENRelativeDateFormatParser());
    option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());
    return option;
  }
  createConfiguration(strictMode = true, littleEndian = false) {
    const options2 = includeCommonConfiguration({
      parsers: [
        new SlashDateFormatParser(littleEndian),
        new ENTimeUnitWithinFormatParser(strictMode),
        new ENMonthNameLittleEndianParser(),
        new ENMonthNameMiddleEndianParser(littleEndian),
        new ENWeekdayParser(),
        new ENCasualYearMonthDayParser(),
        new ENSlashMonthFormatParser(),
        new ENTimeExpressionParser(strictMode),
        new ENTimeUnitAgoFormatParser(strictMode),
        new ENTimeUnitLaterFormatParser(strictMode)
      ],
      refiners: [new ENMergeDateTimeRefiner()]
    }, strictMode);
    options2.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());
    options2.refiners.unshift(new ENMergeRelativeAfterDateRefiner());
    options2.refiners.unshift(new OverlapRemovalRefiner());
    options2.refiners.push(new ENMergeDateTimeRefiner());
    options2.refiners.push(new ENMergeDateRangeRefiner());
    return options2;
  }
};

// node_modules/chrono-node/dist/esm/chrono.js
var Chrono = class {
  constructor(configuration2) {
    this.defaultConfig = new ENDefaultConfiguration();
    configuration2 = configuration2 || this.defaultConfig.createCasualConfiguration();
    this.parsers = [...configuration2.parsers];
    this.refiners = [...configuration2.refiners];
  }
  clone() {
    return new Chrono({
      parsers: [...this.parsers],
      refiners: [...this.refiners]
    });
  }
  parseDate(text, referenceDate, option) {
    const results = this.parse(text, referenceDate, option);
    return results.length > 0 ? results[0].start.date() : null;
  }
  parse(text, referenceDate, option) {
    const context = new ParsingContext(text, referenceDate, option);
    let results = [];
    this.parsers.forEach((parser2) => {
      const parsedResults = Chrono.executeParser(context, parser2);
      results = results.concat(parsedResults);
    });
    results.sort((a4, b2) => {
      return a4.index - b2.index;
    });
    this.refiners.forEach(function(refiner) {
      results = refiner.refine(context, results);
    });
    return results;
  }
  static executeParser(context, parser2) {
    const results = [];
    const pattern = parser2.pattern(context);
    const originalText = context.text;
    let remainingText = context.text;
    let match2 = pattern.exec(remainingText);
    while (match2) {
      const index4 = match2.index + originalText.length - remainingText.length;
      match2.index = index4;
      const result = parser2.extract(context, match2);
      if (!result) {
        remainingText = originalText.substring(match2.index + 1);
        match2 = pattern.exec(remainingText);
        continue;
      }
      let parsedResult = null;
      if (result instanceof ParsingResult) {
        parsedResult = result;
      } else if (result instanceof ParsingComponents) {
        parsedResult = context.createParsingResult(match2.index, match2[0]);
        parsedResult.start = result;
      } else {
        parsedResult = context.createParsingResult(match2.index, match2[0], result);
      }
      const parsedIndex = parsedResult.index;
      const parsedText = parsedResult.text;
      context.debug(() => console.log(`${parser2.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`));
      results.push(parsedResult);
      remainingText = originalText.substring(parsedIndex + parsedText.length);
      match2 = pattern.exec(remainingText);
    }
    return results;
  }
};
var ParsingContext = class {
  constructor(text, refDate, option) {
    this.text = text;
    this.reference = new ReferenceWithTimezone(refDate);
    this.option = option != null ? option : {};
    this.refDate = this.reference.instant;
  }
  createParsingComponents(components) {
    if (components instanceof ParsingComponents) {
      return components;
    }
    return new ParsingComponents(this.reference, components);
  }
  createParsingResult(index4, textOrEndIndex, startComponents, endComponents) {
    const text = typeof textOrEndIndex === "string" ? textOrEndIndex : this.text.substring(index4, textOrEndIndex);
    const start2 = startComponents ? this.createParsingComponents(startComponents) : null;
    const end2 = endComponents ? this.createParsingComponents(endComponents) : null;
    return new ParsingResult(this.reference, index4, text, start2, end2);
  }
  debug(block2) {
    if (this.option.debug) {
      if (this.option.debug instanceof Function) {
        this.option.debug(block2);
      } else {
        const handler = this.option.debug;
        handler.debug(block2);
      }
    }
  }
};

// node_modules/chrono-node/dist/esm/locales/en/index.js
var configuration = new ENDefaultConfiguration();
var casual = new Chrono(configuration.createCasualConfiguration(false));
var strict = new Chrono(configuration.createConfiguration(true, false));
var GB = new Chrono(configuration.createCasualConfiguration(true));
function parse7(text, ref, option) {
  return casual.parse(text, ref, option);
}
function parseDate(text, ref, option) {
  return casual.parseDate(text, ref, option);
}

// node_modules/chrono-node/dist/esm/locales/de/index.js
var de_exports = {};
__export(de_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual2,
  createCasualConfiguration: () => createCasualConfiguration,
  createConfiguration: () => createConfiguration,
  parse: () => parse8,
  parseDate: () => parseDate2,
  strict: () => strict2
});

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeExpressionParser.js
var DETimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:um|von)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|bis)\\s*";
  }
  extractPrimaryTimeComponents(context, match2) {
    if (match2[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match2);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/constants.js
var WEEKDAY_DICTIONARY2 = {
  "sonntag": 0,
  "so": 0,
  "montag": 1,
  "mo": 1,
  "dienstag": 2,
  "di": 2,
  "mittwoch": 3,
  "mi": 3,
  "donnerstag": 4,
  "do": 4,
  "freitag": 5,
  "fr": 5,
  "samstag": 6,
  "sa": 6
};
var MONTH_DICTIONARY2 = {
  "januar": 1,
  "j\xE4nner": 1,
  "janner": 1,
  "jan": 1,
  "jan.": 1,
  "februar": 2,
  "feber": 2,
  "feb": 2,
  "feb.": 2,
  "m\xE4rz": 3,
  "maerz": 3,
  "m\xE4r": 3,
  "m\xE4r.": 3,
  "mrz": 3,
  "mrz.": 3,
  "april": 4,
  "apr": 4,
  "apr.": 4,
  "mai": 5,
  "juni": 6,
  "jun": 6,
  "jun.": 6,
  "juli": 7,
  "jul": 7,
  "jul.": 7,
  "august": 8,
  "aug": 8,
  "aug.": 8,
  "september": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "oktober": 10,
  "okt": 10,
  "okt.": 10,
  "november": 11,
  "nov": 11,
  "nov.": 11,
  "dezember": 12,
  "dez": 12,
  "dez.": 12
};
var INTEGER_WORD_DICTIONARY2 = {
  "eins": 1,
  "eine": 1,
  "einem": 1,
  "einen": 1,
  "einer": 1,
  "zwei": 2,
  "drei": 3,
  "vier": 4,
  "f\xFCnf": 5,
  "fuenf": 5,
  "sechs": 6,
  "sieben": 7,
  "acht": 8,
  "neun": 9,
  "zehn": 10,
  "elf": 11,
  "zw\xF6lf": 12,
  "zwoelf": 12
};
var TIME_UNIT_DICTIONARY2 = {
  sek: "second",
  sekunde: "second",
  sekunden: "second",
  min: "minute",
  minute: "minute",
  minuten: "minute",
  h: "hour",
  std: "hour",
  stunde: "hour",
  stunden: "hour",
  tag: "d",
  tage: "d",
  tagen: "d",
  woche: "week",
  wochen: "week",
  monat: "month",
  monate: "month",
  monaten: "month",
  monats: "month",
  quartal: "quarter",
  quartals: "quarter",
  quartale: "quarter",
  quartalen: "quarter",
  a: "year",
  j: "year",
  jr: "year",
  jahr: "year",
  jahre: "year",
  jahren: "year",
  jahres: "year"
};
var NUMBER_PATTERN2 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY2)}|[0-9]+|[0-9]+\\.[0-9]+|halb?|halbe?|einigen?|wenigen?|mehreren?)`;
function parseNumberPattern2(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY2[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY2[num];
  } else if (num === "ein" || num === "einer" || num === "einem" || num === "einen" || num === "eine") {
    return 1;
  } else if (num.match(/wenigen/)) {
    return 2;
  } else if (num.match(/halb/) || num.match(/halben/)) {
    return 0.5;
  } else if (num.match(/einigen/)) {
    return 3;
  } else if (num.match(/mehreren/)) {
    return 7;
  }
  return parseFloat(num);
}
var YEAR_PATTERN2 = `(?:[0-9]{1,4}(?:\\s*[vn]\\.?\\s*(?:C(?:hr)?|(?:u\\.?|d\\.?(?:\\s*g\\.?)?)?\\s*Z)\\.?|\\s*(?:u\\.?|d\\.?(?:\\s*g\\.)?)\\s*Z\\.?)?)`;
function parseYear2(match2) {
  if (/v/i.test(match2)) {
    return -parseInt(match2.replace(/[^0-9]+/gi, ""));
  }
  if (/n/i.test(match2)) {
    return parseInt(match2.replace(/[^0-9]+/gi, ""));
  }
  if (/z/i.test(match2)) {
    return parseInt(match2.replace(/[^0-9]+/gi, ""));
  }
  const rawYearNumber = parseInt(match2);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN2 = `(${NUMBER_PATTERN2})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX2 = new RegExp(SINGLE_TIME_UNIT_PATTERN2, "i");
var TIME_UNITS_PATTERN2 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN2);
function parseTimeUnits2(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  while (match2) {
    collectDateTimeFragment2(fragments, match2);
    remainingText = remainingText.substring(match2[0].length);
    match2 = SINGLE_TIME_UNIT_REGEX2.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment2(fragments, match2) {
  const num = parseNumberPattern2(match2[1]);
  const unit = TIME_UNIT_DICTIONARY2[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEWeekdayParser.js
var PATTERN15 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:a[mn]\\s*?)?(?:(diese[mn]|letzte[mn]|n(?:\xE4|ae)chste[mn])\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY2)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(diese|letzte|n(?:\xE4|ae)chste)\\s*woche)?(?=\\W|$)`, "i");
var PREFIX_GROUP3 = 1;
var SUFFIX_GROUP = 3;
var WEEKDAY_GROUP2 = 2;
var DEWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN15;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP2].toLowerCase();
    const offset2 = WEEKDAY_DICTIONARY2[dayOfWeek];
    const prefix5 = match2[PREFIX_GROUP3];
    const postfix = match2[SUFFIX_GROUP];
    let modifierWord = prefix5 || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord.match(/letzte/)) {
      modifier = "last";
    } else if (modifierWord.match(/chste/)) {
      modifier = "next";
    } else if (modifierWord.match(/diese/)) {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, offset2, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DESpecificTimeExpressionParser.js
var FIRST_REG_PATTERN = new RegExp("(^|\\s|T)(?:(?:um|von)\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|bis(?:\\s+um)?|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s)?)?(?:\\s*Uhr)?(?:\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\s+der\\s+Nacht))?(?=\\W|$)", "i");
var HOUR_GROUP2 = 2;
var MINUTE_GROUP2 = 3;
var SECOND_GROUP2 = 4;
var AM_PM_HOUR_GROUP2 = 5;
var DESpecificTimeExpressionParser = class {
  pattern(context) {
    return FIRST_REG_PATTERN;
  }
  extract(context, match2) {
    const result = context.createParsingResult(match2.index + match2[1].length, match2[0].substring(match2[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match2.index += match2[0].length;
      return null;
    }
    result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match2);
    if (!result.start) {
      match2.index += match2[0].length;
      return null;
    }
    const remainingText = context.text.substring(match2.index + match2[0].length);
    const secondMatch = SECOND_REG_PATTERN.exec(remainingText);
    if (secondMatch) {
      result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match2) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match2[HOUR_GROUP2]);
    if (match2[MINUTE_GROUP2] != null) {
      minute = parseInt(match2[MINUTE_GROUP2]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match2[AM_PM_HOUR_GROUP2] != null) {
      if (hour > 12)
        return null;
      const ampm = match2[AM_PM_HOUR_GROUP2].toLowerCase();
      if (ampm.match(/morgen|vormittag/)) {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm.match(/nachmittag|abend/)) {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
      if (ampm.match(/nacht/)) {
        if (hour == 12) {
          meridiem = Meridiem.AM;
          hour = 0;
        } else if (hour < 6) {
          meridiem = Meridiem.AM;
        } else {
          meridiem = Meridiem.PM;
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match2[SECOND_GROUP2] != null) {
      const second = parseInt(match2[SECOND_GROUP2]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateRangeRefiner.js
var DEMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(bis(?:\s*(?:am|zum))?|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/refiners/DEMergeDateTimeRefiner.js
var DEMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualDateParser.js
var import_dayjs15 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualTimeParser.js
var import_dayjs13 = __toESM(require_dayjs_min(), 1);
var DECasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(diesen)?\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const targetDate = (0, import_dayjs13.default)(context.refDate);
    const timeKeywordPattern = match2[2].toLowerCase();
    const component = context.createParsingComponents();
    implySimilarTime(component, targetDate);
    return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);
  }
  static extractTimeComponents(component, timeKeywordPattern) {
    switch (timeKeywordPattern) {
      case "morgen":
        component.imply("hour", 6);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "vormittag":
        component.imply("hour", 9);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "mittag":
      case "mittags":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "nachmittag":
        component.imply("hour", 15);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "abend":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "nacht":
        component.imply("hour", 22);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "mitternacht":
        if (component.get("hour") > 1) {
          component = addImpliedTimeUnits(component, { "day": 1 });
        }
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DECasualDateParser.js
var PATTERN16 = new RegExp(`(jetzt|heute|morgen|\xFCbermorgen|uebermorgen|gestern|vorgestern|letzte\\s*nacht)(?:\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?(?=\\W|$)`, "i");
var DATE_GROUP3 = 1;
var TIME_GROUP = 2;
var DECasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return PATTERN16;
  }
  innerExtract(context, match2) {
    let targetDate = (0, import_dayjs15.default)(context.refDate);
    const dateKeyword = (match2[DATE_GROUP3] || "").toLowerCase();
    const timeKeyword = (match2[TIME_GROUP] || "").toLowerCase();
    let component = context.createParsingComponents();
    switch (dateKeyword) {
      case "jetzt":
        component = now(context.reference);
        break;
      case "heute":
        component = today(context.reference);
        break;
      case "morgen":
        assignTheNextDay(component, targetDate);
        break;
      case "\xFCbermorgen":
      case "uebermorgen":
        targetDate = targetDate.add(1, "day");
        assignTheNextDay(component, targetDate);
        break;
      case "gestern":
        targetDate = targetDate.add(-1, "day");
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      case "vorgestern":
        targetDate = targetDate.add(-2, "day");
        assignSimilarDate(component, targetDate);
        implySimilarTime(component, targetDate);
        break;
      default:
        if (dateKeyword.match(/letzte\s*nacht/)) {
          if (targetDate.hour() > 6) {
            targetDate = targetDate.add(-1, "day");
          }
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
        break;
    }
    if (timeKeyword) {
      component = DECasualTimeParser.extractTimeComponents(component, timeKeyword);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DEMonthNameLittleEndianParser.js
var PATTERN17 = new RegExp(`(?:am\\s*?)?(?:den\\s*?)?([0-9]{1,2})\\.(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\\u2013|\\s)\\s*([0-9]{1,2})\\.?)?\\s*(${matchAnyPattern(MONTH_DICTIONARY2)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN2}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP4 = 1;
var DATE_TO_GROUP3 = 2;
var MONTH_NAME_GROUP5 = 3;
var YEAR_GROUP6 = 4;
var DEMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN17;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY2[match2[MONTH_NAME_GROUP5].toLowerCase()];
    const day = parseInt(match2[DATE_GROUP4]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP4].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP6]) {
      const yearNumber = parseYear2(match2[YEAR_GROUP6]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP3]) {
      const endDate = parseInt(match2[DATE_TO_GROUP3]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitRelativeFormatParser.js
var DETimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:\\s*((?:n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\s*)?(${NUMBER_PATTERN2})?(?:\\s*(n\xE4chste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY2)})`, "i");
  }
  innerExtract(context, match2) {
    const num = match2[2] ? parseNumberPattern2(match2[2]) : 1;
    const unit = TIME_UNIT_DICTIONARY2[match2[4].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match2[1] || match2[3] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/parsers/DETimeUnitWithinFormatParser.js
var DETimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:in|f\xFCr|w\xE4hrend)\\s*(${TIME_UNITS_PATTERN2})(?=\\W|$)`, "i");
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits2(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/de/index.js
var casual2 = new Chrono(createCasualConfiguration());
var strict2 = new Chrono(createConfiguration(true));
function parse8(text, ref, option) {
  return casual2.parse(text, ref, option);
}
function parseDate2(text, ref, option) {
  return casual2.parseDate(text, ref, option);
}
function createCasualConfiguration(littleEndian = true) {
  const option = createConfiguration(false, littleEndian);
  option.parsers.unshift(new DECasualTimeParser());
  option.parsers.unshift(new DECasualDateParser());
  option.parsers.unshift(new DETimeUnitAgoFormatParser());
  return option;
}
function createConfiguration(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(littleEndian),
      new DETimeExpressionParser(),
      new DESpecificTimeExpressionParser(),
      new DEMonthNameLittleEndianParser(),
      new DEWeekdayParser(),
      new DETimeUnitWithinFormatParser()
    ],
    refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var fr_exports = {};
__export(fr_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual3,
  createCasualConfiguration: () => createCasualConfiguration2,
  createConfiguration: () => createConfiguration2,
  parse: () => parse9,
  parseDate: () => parseDate3,
  strict: () => strict3
});

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualDateParser.js
var import_dayjs17 = __toESM(require_dayjs_min(), 1);
var FRCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(maintenant|aujourd'hui|demain|hier|cette\s*nuit|la\s*veille)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    let targetDate = (0, import_dayjs17.default)(context.refDate);
    const lowerText = match2[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "maintenant":
        return now(context.reference);
      case "aujourd'hui":
        return today(context.reference);
      case "hier":
        return yesterday(context.reference);
      case "demain":
        return tomorrow(context.reference);
      default:
        if (lowerText.match(/cette\s*nuit/)) {
          assignSimilarDate(component, targetDate);
          component.imply("hour", 22);
          component.imply("meridiem", Meridiem.PM);
        } else if (lowerText.match(/la\s*veille/)) {
          targetDate = targetDate.add(-1, "day");
          assignSimilarDate(component, targetDate);
          component.imply("hour", 0);
        }
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRCasualTimeParser.js
var FRCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(cet?)?\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const suffixLower = match2[2].toLowerCase();
    const component = context.createParsingComponents();
    switch (suffixLower) {
      case "apr\xE8s-midi":
      case "aprem":
        component.imply("hour", 14);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "soir":
        component.imply("hour", 18);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.PM);
        break;
      case "matin":
        component.imply("hour", 8);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "a midi":
        component.imply("hour", 12);
        component.imply("minute", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
      case "\xE0 minuit":
        component.imply("hour", 0);
        component.imply("meridiem", Meridiem.AM);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeExpressionParser.js
var FRTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:[\xE0a])\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*";
  }
  extractPrimaryTimeComponents(context, match2) {
    if (match2[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match2);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateTimeRefiner.js
var FRMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(T|\xE0|a|au|vers|de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/refiners/FRMergeDateRangeRefiner.js
var FRMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(à|a|au|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/constants.js
var WEEKDAY_DICTIONARY3 = {
  "dimanche": 0,
  "dim": 0,
  "lundi": 1,
  "lun": 1,
  "mardi": 2,
  "mar": 2,
  "mercredi": 3,
  "mer": 3,
  "jeudi": 4,
  "jeu": 4,
  "vendredi": 5,
  "ven": 5,
  "samedi": 6,
  "sam": 6
};
var MONTH_DICTIONARY3 = {
  "janvier": 1,
  "jan": 1,
  "jan.": 1,
  "f\xE9vrier": 2,
  "f\xE9v": 2,
  "f\xE9v.": 2,
  "fevrier": 2,
  "fev": 2,
  "fev.": 2,
  "mars": 3,
  "mar": 3,
  "mar.": 3,
  "avril": 4,
  "avr": 4,
  "avr.": 4,
  "mai": 5,
  "juin": 6,
  "jun": 6,
  "juillet": 7,
  "juil": 7,
  "jul": 7,
  "jul.": 7,
  "ao\xFBt": 8,
  "aout": 8,
  "septembre": 9,
  "sep": 9,
  "sep.": 9,
  "sept": 9,
  "sept.": 9,
  "octobre": 10,
  "oct": 10,
  "oct.": 10,
  "novembre": 11,
  "nov": 11,
  "nov.": 11,
  "d\xE9cembre": 12,
  "decembre": 12,
  "dec": 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY3 = {
  "un": 1,
  "deux": 2,
  "trois": 3,
  "quatre": 4,
  "cinq": 5,
  "six": 6,
  "sept": 7,
  "huit": 8,
  "neuf": 9,
  "dix": 10,
  "onze": 11,
  "douze": 12,
  "treize": 13
};
var TIME_UNIT_DICTIONARY3 = {
  "sec": "second",
  "seconde": "second",
  "secondes": "second",
  "min": "minute",
  "mins": "minute",
  "minute": "minute",
  "minutes": "minute",
  "h": "hour",
  "hr": "hour",
  "hrs": "hour",
  "heure": "hour",
  "heures": "hour",
  "jour": "d",
  "jours": "d",
  "semaine": "week",
  "semaines": "week",
  "mois": "month",
  "trimestre": "quarter",
  "trimestres": "quarter",
  "ans": "year",
  "ann\xE9e": "year",
  "ann\xE9es": "year"
};
var NUMBER_PATTERN3 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY3)}|[0-9]+|[0-9]+\\.[0-9]+|une?\\b|quelques?|demi-?)`;
function parseNumberPattern3(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY3[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY3[num];
  } else if (num === "une" || num === "un") {
    return 1;
  } else if (num.match(/quelques?/)) {
    return 3;
  } else if (num.match(/demi-?/)) {
    return 0.5;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN2 = `(?:[0-9]{1,2}(?:er)?)`;
function parseOrdinalNumberPattern2(match2) {
  let num = match2.toLowerCase();
  num = num.replace(/(?:er)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN3 = `(?:[1-9][0-9]{0,3}\\s*(?:AC|AD|p\\.\\s*C(?:hr?)?\\.\\s*n\\.)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear3(match2) {
  if (/AC/i.test(match2)) {
    match2 = match2.replace(/BC/i, "");
    return -parseInt(match2);
  }
  if (/AD/i.test(match2) || /C/i.test(match2)) {
    match2 = match2.replace(/[^\d]+/i, "");
    return parseInt(match2);
  }
  let yearNumber = parseInt(match2);
  if (yearNumber < 100) {
    if (yearNumber > 50) {
      yearNumber = yearNumber + 1900;
    } else {
      yearNumber = yearNumber + 2e3;
    }
  }
  return yearNumber;
}
var SINGLE_TIME_UNIT_PATTERN3 = `(${NUMBER_PATTERN3})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX3 = new RegExp(SINGLE_TIME_UNIT_PATTERN3, "i");
var TIME_UNITS_PATTERN3 = repeatedTimeunitPattern("", SINGLE_TIME_UNIT_PATTERN3);
function parseTimeUnits3(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  while (match2) {
    collectDateTimeFragment3(fragments, match2);
    remainingText = remainingText.substring(match2[0].length);
    match2 = SINGLE_TIME_UNIT_REGEX3.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment3(fragments, match2) {
  const num = parseNumberPattern3(match2[1]);
  const unit = TIME_UNIT_DICTIONARY3[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRWeekdayParser.js
var PATTERN18 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(?:ce)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY3)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(dernier|prochain)\\s*)?(?=\\W|\\d|$)`, "i");
var WEEKDAY_GROUP3 = 1;
var POSTFIX_GROUP2 = 2;
var FRWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN18;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP3].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY3[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    let suffix = match2[POSTFIX_GROUP2];
    suffix = suffix || "";
    suffix = suffix.toLowerCase();
    let modifier = null;
    if (suffix == "dernier") {
      modifier = "last";
    } else if (suffix == "prochain") {
      modifier = "next";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRSpecificTimeExpressionParser.js
var FIRST_REG_PATTERN2 = new RegExp("(^|\\s|T)(?:(?:[\xE0a])\\s*)?(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var SECOND_REG_PATTERN2 = new RegExp("^\\s*(\\-|\\\u2013|\\~|\\\u301C|[\xE0a]|\\?)\\s*(\\d{1,2})(?:h|:)?(?:(\\d{1,2})(?:m|:)?)?(?:(\\d{1,2})(?:s|:)?)?(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?(?=\\W|$)", "i");
var HOUR_GROUP3 = 2;
var MINUTE_GROUP3 = 3;
var SECOND_GROUP3 = 4;
var AM_PM_HOUR_GROUP3 = 5;
var FRSpecificTimeExpressionParser = class {
  pattern(context) {
    return FIRST_REG_PATTERN2;
  }
  extract(context, match2) {
    const result = context.createParsingResult(match2.index + match2[1].length, match2[0].substring(match2[1].length));
    if (result.text.match(/^\d{4}$/)) {
      match2.index += match2[0].length;
      return null;
    }
    result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match2);
    if (!result.start) {
      match2.index += match2[0].length;
      return null;
    }
    const remainingText = context.text.substring(match2.index + match2[0].length);
    const secondMatch = SECOND_REG_PATTERN2.exec(remainingText);
    if (secondMatch) {
      result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);
      if (result.end) {
        result.text += secondMatch[0];
      }
    }
    return result;
  }
  static extractTimeComponent(extractingComponents, match2) {
    let hour = 0;
    let minute = 0;
    let meridiem = null;
    hour = parseInt(match2[HOUR_GROUP3]);
    if (match2[MINUTE_GROUP3] != null) {
      minute = parseInt(match2[MINUTE_GROUP3]);
    }
    if (minute >= 60 || hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = Meridiem.PM;
    }
    if (match2[AM_PM_HOUR_GROUP3] != null) {
      if (hour > 12)
        return null;
      const ampm = match2[AM_PM_HOUR_GROUP3][0].toLowerCase();
      if (ampm == "a") {
        meridiem = Meridiem.AM;
        if (hour == 12) {
          hour = 0;
        }
      }
      if (ampm == "p") {
        meridiem = Meridiem.PM;
        if (hour != 12) {
          hour += 12;
        }
      }
    }
    extractingComponents.assign("hour", hour);
    extractingComponents.assign("minute", minute);
    if (meridiem !== null) {
      extractingComponents.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        extractingComponents.imply("meridiem", Meridiem.AM);
      } else {
        extractingComponents.imply("meridiem", Meridiem.PM);
      }
    }
    if (match2[SECOND_GROUP3] != null) {
      const second = parseInt(match2[SECOND_GROUP3]);
      if (second >= 60)
        return null;
      extractingComponents.assign("second", second);
    }
    return extractingComponents;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRMonthNameLittleEndianParser.js
var PATTERN19 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN2})(?:\\s*(?:au|\\-|\\\u2013|jusqu'au?|\\s)\\s*(${ORDINAL_NUMBER_PATTERN2}))?(?:-|/|\\s*(?:de)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY3)})(?:(?:-|/|,?\\s*)(${YEAR_PATTERN3}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var DATE_GROUP5 = 1;
var DATE_TO_GROUP4 = 2;
var MONTH_NAME_GROUP6 = 3;
var YEAR_GROUP7 = 4;
var FRMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN19;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY3[match2[MONTH_NAME_GROUP6].toLowerCase()];
    const day = parseOrdinalNumberPattern2(match2[DATE_GROUP5]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP5].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP7]) {
      const yearNumber = parseYear3(match2[YEAR_GROUP7]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP4]) {
      const endDate = parseOrdinalNumberPattern2(match2[DATE_TO_GROUP4]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitAgoFormatParser.js
var FRTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`il y a\\s*(${TIME_UNITS_PATTERN3})(?=(?:\\W|$))`, "i");
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits3(match2[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitWithinFormatParser.js
var FRTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:dans|en|pour|pendant|de)\\s*(${TIME_UNITS_PATTERN3})(?=\\W|$)`, "i");
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits3(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/parsers/FRTimeUnitRelativeFormatParser.js
var FRTimeUnitAgoFormatParser2 = class extends AbstractParserWithWordBoundaryChecking {
  constructor() {
    super();
  }
  innerPattern() {
    return new RegExp(`(?:les?|la|l'|du|des?)\\s*(${NUMBER_PATTERN3})?(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY3)})(?:\\s*(prochaine?s?|derni[e\xE8]re?s?|pass[\xE9e]e?s?|pr[\xE9e]c[\xE9e]dents?|suivante?s?))?`, "i");
  }
  innerExtract(context, match2) {
    const num = match2[1] ? parseNumberPattern3(match2[1]) : 1;
    const unit = TIME_UNIT_DICTIONARY3[match2[3].toLowerCase()];
    let timeUnits = {};
    timeUnits[unit] = num;
    let modifier = match2[2] || match2[4] || "";
    modifier = modifier.toLowerCase();
    if (!modifier) {
      return;
    }
    if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {
      timeUnits = reverseTimeUnits(timeUnits);
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/fr/index.js
var casual3 = new Chrono(createCasualConfiguration2());
var strict3 = new Chrono(createConfiguration2(true));
function parse9(text, ref, option) {
  return casual3.parse(text, ref, option);
}
function parseDate3(text, ref, option) {
  return casual3.parseDate(text, ref, option);
}
function createCasualConfiguration2(littleEndian = true) {
  const option = createConfiguration2(false, littleEndian);
  option.parsers.unshift(new FRCasualDateParser());
  option.parsers.unshift(new FRCasualTimeParser());
  option.parsers.unshift(new FRTimeUnitAgoFormatParser2());
  return option;
}
function createConfiguration2(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new FRMonthNameLittleEndianParser(),
      new FRTimeExpressionParser(),
      new FRSpecificTimeExpressionParser(),
      new FRTimeUnitAgoFormatParser(),
      new FRTimeUnitWithinFormatParser(),
      new FRWeekdayParser()
    ],
    refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var ja_exports = {};
__export(ja_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual4,
  createCasualConfiguration: () => createCasualConfiguration3,
  createConfiguration: () => createConfiguration3,
  parse: () => parse10,
  parseDate: () => parseDate4,
  strict: () => strict4
});

// node_modules/chrono-node/dist/esm/locales/ja/constants.js
function toHankaku(text) {
  return String(text).replace(/\u2019/g, "'").replace(/\u201D/g, '"').replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
}
function alphaNum(token) {
  return String.fromCharCode(token.charCodeAt(0) - 65248);
}

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPStandardParser.js
var import_dayjs19 = __toESM(require_dayjs_min(), 1);
var PATTERN20 = /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
var SPECIAL_YEAR_GROUP = 1;
var TYPICAL_YEAR_GROUP = 2;
var ERA_GROUP = 3;
var YEAR_NUMBER_GROUP3 = 4;
var MONTH_GROUP2 = 5;
var DAY_GROUP = 6;
var JPStandardParser = class {
  pattern() {
    return PATTERN20;
  }
  extract(context, match2) {
    const month2 = parseInt(toHankaku(match2[MONTH_GROUP2]));
    const day = parseInt(toHankaku(match2[DAY_GROUP]));
    const components = context.createParsingComponents({
      day,
      month: month2
    });
    if (match2[SPECIAL_YEAR_GROUP] && match2[SPECIAL_YEAR_GROUP].match("\u540C|\u4ECA|\u672C")) {
      const moment = (0, import_dayjs19.default)(context.refDate);
      components.assign("year", moment.year());
    }
    if (match2[TYPICAL_YEAR_GROUP]) {
      const yearNumText = match2[YEAR_NUMBER_GROUP3];
      let year3 = yearNumText == "\u5143" ? 1 : parseInt(toHankaku(yearNumText));
      if (match2[ERA_GROUP] == "\u4EE4\u548C") {
        year3 += 2018;
      } else if (match2[ERA_GROUP] == "\u5E73\u6210") {
        year3 += 1988;
      } else if (match2[ERA_GROUP] == "\u662D\u548C") {
        year3 += 1925;
      }
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/refiners/JPMergeDateRangeRefiner.js
var JPMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(から|ー|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/parsers/JPCasualDateParser.js
var import_dayjs20 = __toESM(require_dayjs_min(), 1);
var PATTERN21 = /今日|きょう|当日|とうじつ|昨日|きのう|明日|あした|今夜|こんや|今夕|こんゆう|今晩|こんばん|今朝|けさ/i;
function normalizeTextToKanji(text) {
  switch (text) {
    case "\u304D\u3087\u3046":
      return "\u4ECA\u65E5";
    case "\u3068\u3046\u3058\u3064":
      return "\u5F53\u65E5";
    case "\u304D\u306E\u3046":
      return "\u6628\u65E5";
    case "\u3042\u3057\u305F":
      return "\u660E\u65E5";
    case "\u3053\u3093\u3084":
      return "\u4ECA\u591C";
    case "\u3053\u3093\u3086\u3046":
      return "\u4ECA\u5915";
    case "\u3053\u3093\u3070\u3093":
      return "\u4ECA\u6669";
    case "\u3051\u3055":
      return "\u4ECA\u671D";
    default:
      return text;
  }
}
var JPCasualDateParser = class {
  pattern() {
    return PATTERN21;
  }
  extract(context, match2) {
    const text = normalizeTextToKanji(match2[0]);
    const date = (0, import_dayjs20.default)(context.refDate);
    const components = context.createParsingComponents();
    switch (text) {
      case "\u6628\u65E5":
        return yesterday(context.reference);
      case "\u660E\u65E5":
        return tomorrow(context.reference);
      case "\u4ECA\u65E5":
      case "\u5F53\u65E5":
        return today(context.reference);
    }
    if (text == "\u4ECA\u591C" || text == "\u4ECA\u5915" || text == "\u4ECA\u6669") {
      components.imply("hour", 22);
      components.assign("meridiem", Meridiem.PM);
    } else if (text.match("\u4ECA\u671D")) {
      components.imply("hour", 6);
      components.assign("meridiem", Meridiem.AM);
    }
    components.assign("day", date.date());
    components.assign("month", date.month() + 1);
    components.assign("year", date.year());
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ja/index.js
var casual4 = new Chrono(createCasualConfiguration3());
var strict4 = new Chrono(createConfiguration3());
function parse10(text, ref, option) {
  return casual4.parse(text, ref, option);
}
function parseDate4(text, ref, option) {
  return casual4.parseDate(text, ref, option);
}
function createCasualConfiguration3() {
  const option = createConfiguration3();
  option.parsers.unshift(new JPCasualDateParser());
  return option;
}
function createConfiguration3() {
  return {
    parsers: [new JPStandardParser()],
    refiners: [new JPMergeDateRangeRefiner()]
  };
}

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var pt_exports = {};
__export(pt_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual5,
  createCasualConfiguration: () => createCasualConfiguration4,
  createConfiguration: () => createConfiguration4,
  parse: () => parse11,
  parseDate: () => parseDate5,
  strict: () => strict5
});

// node_modules/chrono-node/dist/esm/locales/pt/constants.js
var WEEKDAY_DICTIONARY4 = {
  "domingo": 0,
  "dom": 0,
  "segunda": 1,
  "segunda-feira": 1,
  "seg": 1,
  "ter\xE7a": 2,
  "ter\xE7a-feira": 2,
  "ter": 2,
  "quarta": 3,
  "quarta-feira": 3,
  "qua": 3,
  "quinta": 4,
  "quinta-feira": 4,
  "qui": 4,
  "sexta": 5,
  "sexta-feira": 5,
  "sex": 5,
  "s\xE1bado": 6,
  "sabado": 6,
  "sab": 6
};
var MONTH_DICTIONARY4 = {
  "janeiro": 1,
  "jan": 1,
  "jan.": 1,
  "fevereiro": 2,
  "fev": 2,
  "fev.": 2,
  "mar\xE7o": 3,
  "mar": 3,
  "mar.": 3,
  "abril": 4,
  "abr": 4,
  "abr.": 4,
  "maio": 5,
  "mai": 5,
  "mai.": 5,
  "junho": 6,
  "jun": 6,
  "jun.": 6,
  "julho": 7,
  "jul": 7,
  "jul.": 7,
  "agosto": 8,
  "ago": 8,
  "ago.": 8,
  "setembro": 9,
  "set": 9,
  "set.": 9,
  "outubro": 10,
  "out": 10,
  "out.": 10,
  "novembro": 11,
  "nov": 11,
  "nov.": 11,
  "dezembro": 12,
  "dez": 12,
  "dez.": 12
};
var YEAR_PATTERN4 = "[0-9]{1,4}(?![^\\s]\\d)(?:\\s*[a|d]\\.?\\s*c\\.?|\\s*a\\.?\\s*d\\.?)?";
function parseYear4(match2) {
  if (match2.match(/^[0-9]{1,4}$/)) {
    let yearNumber = parseInt(match2);
    if (yearNumber < 100) {
      if (yearNumber > 50) {
        yearNumber = yearNumber + 1900;
      } else {
        yearNumber = yearNumber + 2e3;
      }
    }
    return yearNumber;
  }
  if (match2.match(/a\.?\s*c\.?/i)) {
    match2 = match2.replace(/a\.?\s*c\.?/i, "");
    return -parseInt(match2);
  }
  return parseInt(match2);
}

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTWeekdayParser.js
var PATTERN22 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:(este|esta|passado|pr[o\xF3]ximo)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY4)})(?:\\s*(?:\\,|\\)|\\\uFF09))?(?:\\s*(este|esta|passado|pr[\xF3o]ximo)\\s*semana)?(?=\\W|\\d|$)`, "i");
var PREFIX_GROUP4 = 1;
var WEEKDAY_GROUP4 = 2;
var POSTFIX_GROUP3 = 3;
var PTWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN22;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP4].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY4[dayOfWeek];
    if (weekday === void 0) {
      return null;
    }
    const prefix5 = match2[PREFIX_GROUP4];
    const postfix = match2[POSTFIX_GROUP3];
    let norm = prefix5 || postfix || "";
    norm = norm.toLowerCase();
    let modifier = null;
    if (norm == "passado") {
      modifier = "this";
    } else if (norm == "pr\xF3ximo" || norm == "proximo") {
      modifier = "next";
    } else if (norm == "este") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTTimeExpressionParser.js
var PTTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:ao?|\xE0s?|das|da|de|do)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|a(?:o)?|\\?)\\s*";
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateTimeRefiner.js
var PTMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(?:,|\xE0)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/refiners/PTMergeDateRangeRefiner.js
var PTMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(?:-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTMonthNameLittleEndianParser.js
var PATTERN23 = new RegExp(`([0-9]{1,2})(?:\xBA|\xAA|\xB0)?(?:\\s*(?:desde|de|\\-|\\\u2013|ao?|\\s)\\s*([0-9]{1,2})(?:\xBA|\xAA|\xB0)?)?\\s*(?:de)?\\s*(?:-|/|\\s*(?:de|,)?\\s*)(${matchAnyPattern(MONTH_DICTIONARY4)})(?:\\s*(?:de|,)?\\s*(${YEAR_PATTERN4}))?(?=\\W|$)`, "i");
var DATE_GROUP6 = 1;
var DATE_TO_GROUP5 = 2;
var MONTH_NAME_GROUP7 = 3;
var YEAR_GROUP8 = 4;
var PTMonthNameLittleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN23;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY4[match2[MONTH_NAME_GROUP7].toLowerCase()];
    const day = parseInt(match2[DATE_GROUP6]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP6].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP8]) {
      const yearNumber = parseYear4(match2[YEAR_GROUP8]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP5]) {
      const endDate = parseInt(match2[DATE_TO_GROUP5]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualDateParser.js
var PTCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(agora|hoje|amanha|amanhã|ontem)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const lowerText = match2[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "agora":
        return now(context.reference);
      case "hoje":
        return today(context.reference);
      case "amanha":
      case "amanh\xE3":
        return tomorrow(context.reference);
      case "ontem":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/parsers/PTCasualTimeParser.js
var import_dayjs22 = __toESM(require_dayjs_min(), 1);
var PTCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(?:esta\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const targetDate = (0, import_dayjs22.default)(context.refDate);
    const component = context.createParsingComponents();
    switch (match2[1].toLowerCase()) {
      case "tarde":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "noite":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 22);
        break;
      case "manha":
      case "manh\xE3":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "meia-noite":
        assignTheNextDay(component, targetDate);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "meio-dia":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/pt/index.js
var casual5 = new Chrono(createCasualConfiguration4());
var strict5 = new Chrono(createConfiguration4(true));
function parse11(text, ref, option) {
  return casual5.parse(text, ref, option);
}
function parseDate5(text, ref, option) {
  return casual5.parseDate(text, ref, option);
}
function createCasualConfiguration4(littleEndian = true) {
  const option = createConfiguration4(false, littleEndian);
  option.parsers.push(new PTCasualDateParser());
  option.parsers.push(new PTCasualTimeParser());
  return option;
}
function createConfiguration4(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new PTWeekdayParser(),
      new PTTimeExpressionParser(),
      new PTMonthNameLittleEndianParser()
    ],
    refiners: [new PTMergeDateTimeRefiner(), new PTMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var nl_exports = {};
__export(nl_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual6,
  createCasualConfiguration: () => createCasualConfiguration5,
  createConfiguration: () => createConfiguration5,
  parse: () => parse12,
  parseDate: () => parseDate6,
  strict: () => strict6
});

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateRangeRefiner.js
var NLMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(tot|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/refiners/NLMergeDateTimeRefiner.js
var NLMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp("^\\s*(om|na|voor|in de|,|-)?\\s*$");
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateParser.js
var NLCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(nu|vandaag|morgen|morgend|gisteren)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const lowerText = match2[0].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "nu":
        return now(context.reference);
      case "vandaag":
        return today(context.reference);
      case "morgen":
      case "morgend":
        return tomorrow(context.reference);
      case "gisteren":
        return yesterday(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualTimeParser.js
var import_dayjs23 = __toESM(require_dayjs_min(), 1);
var DAY_GROUP2 = 1;
var MOMENT_GROUP = 2;
var NLCasualTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return /(deze)?\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const targetDate = (0, import_dayjs23.default)(context.refDate);
    const component = context.createParsingComponents();
    if (match2[DAY_GROUP2] === "deze") {
      component.assign("day", context.refDate.getDate());
      component.assign("month", context.refDate.getMonth() + 1);
      component.assign("year", context.refDate.getFullYear());
    }
    switch (match2[MOMENT_GROUP].toLowerCase()) {
      case "namiddag":
      case "'s namiddags":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
      case "'s avonds'":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
      case "middernacht":
        assignTheNextDay(component, targetDate);
        component.imply("hour", 0);
        component.imply("minute", 0);
        component.imply("second", 0);
        break;
      case "ochtend":
      case "'s ochtends":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
      case "'s middags":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/constants.js
var WEEKDAY_DICTIONARY5 = {
  zondag: 0,
  zon: 0,
  "zon.": 0,
  zo: 0,
  "zo.": 0,
  maandag: 1,
  ma: 1,
  "ma.": 1,
  dinsdag: 2,
  din: 2,
  "din.": 2,
  di: 2,
  "di.": 2,
  woensdag: 3,
  woe: 3,
  "woe.": 3,
  wo: 3,
  "wo.": 3,
  donderdag: 4,
  dond: 4,
  "dond.": 4,
  do: 4,
  "do.": 4,
  vrijdag: 5,
  vrij: 5,
  "vrij.": 5,
  vr: 5,
  "vr.": 5,
  zaterdag: 6,
  zat: 6,
  "zat.": 6,
  "za": 6,
  "za.": 6
};
var MONTH_DICTIONARY5 = {
  januari: 1,
  jan: 1,
  "jan.": 1,
  februari: 2,
  feb: 2,
  "feb.": 2,
  maart: 3,
  mar: 3,
  "mar.": 3,
  mrt: 3,
  "mrt.": 3,
  april: 4,
  apr: 4,
  "apr.": 4,
  mei: 5,
  juni: 6,
  jun: 6,
  "jun.": 6,
  juli: 7,
  jul: 7,
  "jul.": 7,
  augustus: 8,
  aug: 8,
  "aug.": 8,
  september: 9,
  sep: 9,
  "sep.": 9,
  sept: 9,
  "sept.": 9,
  oktober: 10,
  okt: 10,
  "okt.": 10,
  november: 11,
  nov: 11,
  "nov.": 11,
  december: 12,
  dec: 12,
  "dec.": 12
};
var INTEGER_WORD_DICTIONARY4 = {
  een: 1,
  twee: 2,
  drie: 3,
  vier: 4,
  vijf: 5,
  zes: 6,
  zeven: 7,
  acht: 8,
  negen: 9,
  tien: 10,
  elf: 11,
  twaalf: 12
};
var ORDINAL_WORD_DICTIONARY2 = {
  eerste: 1,
  tweede: 2,
  derde: 3,
  vierde: 4,
  vijfde: 5,
  zesde: 6,
  zevende: 7,
  achtste: 8,
  negende: 9,
  tiende: 10,
  elfde: 11,
  twaalfde: 12,
  dertiende: 13,
  veertiende: 14,
  vijftiende: 15,
  zestiende: 16,
  zeventiende: 17,
  achttiende: 18,
  negentiende: 19,
  twintigste: 20,
  "eenentwintigste": 21,
  "twee\xEBntwintigste": 22,
  "drieentwintigste": 23,
  "vierentwintigste": 24,
  "vijfentwintigste": 25,
  "zesentwintigste": 26,
  "zevenentwintigste": 27,
  "achtentwintig": 28,
  "negenentwintig": 29,
  "dertigste": 30,
  "eenendertigste": 31
};
var TIME_UNIT_DICTIONARY4 = {
  sec: "second",
  second: "second",
  seconden: "second",
  min: "minute",
  mins: "minute",
  minute: "minute",
  minuut: "minute",
  minuten: "minute",
  minuutje: "minute",
  h: "hour",
  hr: "hour",
  hrs: "hour",
  uur: "hour",
  u: "hour",
  uren: "hour",
  dag: "d",
  dagen: "d",
  week: "week",
  weken: "week",
  maand: "month",
  maanden: "month",
  jaar: "year",
  jr: "year",
  jaren: "year"
};
var NUMBER_PATTERN4 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY4)}|[0-9]+|[0-9]+[\\.,][0-9]+|halve?|half|paar)`;
function parseNumberPattern4(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY4[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY4[num];
  } else if (num === "paar") {
    return 2;
  } else if (num === "half" || num.match(/halve?/)) {
    return 0.5;
  }
  return parseFloat(num.replace(",", "."));
}
var ORDINAL_NUMBER_PATTERN3 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY2)}|[0-9]{1,2}(?:ste|de)?)`;
function parseOrdinalNumberPattern3(match2) {
  let num = match2.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY2[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY2[num];
  }
  num = num.replace(/(?:ste|de)$/i, "");
  return parseInt(num);
}
var YEAR_PATTERN5 = `(?:[1-9][0-9]{0,3}\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;
function parseYear5(match2) {
  if (/voor Christus/i.test(match2)) {
    match2 = match2.replace(/voor Christus/i, "");
    return -parseInt(match2);
  }
  if (/na Christus/i.test(match2)) {
    match2 = match2.replace(/na Christus/i, "");
    return parseInt(match2);
  }
  const rawYearNumber = parseInt(match2);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN4 = `(${NUMBER_PATTERN4})\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})\\s{0,5}`;
var SINGLE_TIME_UNIT_REGEX4 = new RegExp(SINGLE_TIME_UNIT_PATTERN4, "i");
var TIME_UNITS_PATTERN4 = repeatedTimeunitPattern(`(?:(?:binnen|in)\\s*)?`, SINGLE_TIME_UNIT_PATTERN4);
function parseTimeUnits4(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  while (match2) {
    collectDateTimeFragment4(fragments, match2);
    remainingText = remainingText.substring(match2[0].length);
    match2 = SINGLE_TIME_UNIT_REGEX4.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment4(fragments, match2) {
  const num = parseNumberPattern4(match2[1]);
  const unit = TIME_UNIT_DICTIONARY4[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitWithinFormatParser.js
var NLTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp(`(?:binnen|in|binnen de|voor)\\s*(` + TIME_UNITS_PATTERN4 + `)(?=\\W|$)`, "i");
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits4(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLWeekdayParser.js
var PATTERN24 = new RegExp(`(?:(?:\\,|\\(|\\\uFF08)\\s*)?(?:op\\s*?)?(?:(deze|vorige|volgende)\\s*(?:week\\s*)?)?(${matchAnyPattern(WEEKDAY_DICTIONARY5)})(?=\\W|$)`, "i");
var PREFIX_GROUP5 = 1;
var WEEKDAY_GROUP5 = 2;
var POSTFIX_GROUP4 = 3;
var NLWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN24;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP5].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY5[dayOfWeek];
    const prefix5 = match2[PREFIX_GROUP5];
    const postfix = match2[POSTFIX_GROUP4];
    let modifierWord = prefix5 || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "vorige") {
      modifier = "last";
    } else if (modifierWord == "volgende") {
      modifier = "next";
    } else if (modifierWord == "deze") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameMiddleEndianParser.js
var PATTERN25 = new RegExp(`(?:on\\s*?)?(${ORDINAL_NUMBER_PATTERN3})(?:\\s*(?:tot|\\-|\\\u2013|until|through|till|\\s)\\s*(${ORDINAL_NUMBER_PATTERN3}))?(?:-|/|\\s*(?:of)?\\s*)(` + matchAnyPattern(MONTH_DICTIONARY5) + `)(?:(?:-|/|,?\\s*)(${YEAR_PATTERN5}(?![^\\s]\\d)))?(?=\\W|$)`, "i");
var MONTH_NAME_GROUP8 = 3;
var DATE_GROUP7 = 1;
var DATE_TO_GROUP6 = 2;
var YEAR_GROUP9 = 4;
var NLMonthNameMiddleEndianParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN25;
  }
  innerExtract(context, match2) {
    const month2 = MONTH_DICTIONARY5[match2[MONTH_NAME_GROUP8].toLowerCase()];
    const day = parseOrdinalNumberPattern3(match2[DATE_GROUP7]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP7].length;
      return null;
    }
    const components = context.createParsingComponents({
      day,
      month: month2
    });
    if (match2[YEAR_GROUP9]) {
      const year3 = parseYear5(match2[YEAR_GROUP9]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      components.imply("year", year3);
    }
    if (!match2[DATE_TO_GROUP6]) {
      return components;
    }
    const endDate = parseOrdinalNumberPattern3(match2[DATE_TO_GROUP6]);
    const result = context.createParsingResult(match2.index, match2[0]);
    result.start = components;
    result.end = components.clone();
    result.end.assign("day", endDate);
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLMonthNameParser.js
var PATTERN26 = new RegExp(`(${matchAnyPattern(MONTH_DICTIONARY5)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN5})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i");
var MONTH_NAME_GROUP9 = 1;
var YEAR_GROUP10 = 2;
var NLMonthNameParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN26;
  }
  innerExtract(context, match2) {
    const components = context.createParsingComponents();
    components.imply("day", 1);
    const monthName = match2[MONTH_NAME_GROUP9];
    const month2 = MONTH_DICTIONARY5[monthName.toLowerCase()];
    components.assign("month", month2);
    if (match2[YEAR_GROUP10]) {
      const year3 = parseYear5(match2[YEAR_GROUP10]);
      components.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month2);
      components.imply("year", year3);
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLSlashMonthFormatParser.js
var PATTERN27 = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i");
var MONTH_GROUP3 = 1;
var YEAR_GROUP11 = 2;
var NLSlashMonthFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN27;
  }
  innerExtract(context, match2) {
    const year3 = parseInt(match2[YEAR_GROUP11]);
    const month2 = parseInt(match2[MONTH_GROUP3]);
    return context.createParsingComponents().imply("day", 1).assign("month", month2).assign("year", year3);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeExpressionParser.js
var NLTimeExpressionParser = class extends AbstractTimeExpressionParser {
  primaryPrefix() {
    return "(?:(?:om)\\s*)?";
  }
  followingPhase() {
    return "\\s*(?:\\-|\\\u2013|\\~|\\\u301C|om|\\?)\\s*";
  }
  primarySuffix() {
    return "(?:\\s*(?:uur))?(?!/)(?=\\W|$)";
  }
  extractPrimaryTimeComponents(context, match2) {
    if (match2[0].match(/^\s*\d{4}\s*$/)) {
      return null;
    }
    return super.extractPrimaryTimeComponents(context, match2);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualYearMonthDayParser.js
var PATTERN28 = new RegExp(`([0-9]{4})[\\.\\/\\s](?:(${matchAnyPattern(MONTH_DICTIONARY5)})|([0-9]{1,2}))[\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i");
var YEAR_NUMBER_GROUP4 = 1;
var MONTH_NAME_GROUP10 = 2;
var MONTH_NUMBER_GROUP3 = 3;
var DATE_NUMBER_GROUP3 = 4;
var NLCasualYearMonthDayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN28;
  }
  innerExtract(context, match2) {
    const month2 = match2[MONTH_NUMBER_GROUP3] ? parseInt(match2[MONTH_NUMBER_GROUP3]) : MONTH_DICTIONARY5[match2[MONTH_NAME_GROUP10].toLowerCase()];
    if (month2 < 1 || month2 > 12) {
      return null;
    }
    const year3 = parseInt(match2[YEAR_NUMBER_GROUP4]);
    const day = parseInt(match2[DATE_NUMBER_GROUP3]);
    return {
      day,
      month: month2,
      year: year3
    };
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLCasualDateTimeParser.js
var import_dayjs26 = __toESM(require_dayjs_min(), 1);
var DATE_GROUP8 = 1;
var TIME_OF_DAY_GROUP = 2;
var NLCasualDateTimeParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\W|$)/i;
  }
  innerExtract(context, match2) {
    const dateText = match2[DATE_GROUP8].toLowerCase();
    const timeText = match2[TIME_OF_DAY_GROUP].toLowerCase();
    const component = context.createParsingComponents();
    const targetDate = (0, import_dayjs26.default)(context.refDate);
    switch (dateText) {
      case "gisteren":
        assignSimilarDate(component, targetDate.add(-1, "day"));
        break;
      case "van":
        assignSimilarDate(component, targetDate);
        break;
      case "morgen":
        assignTheNextDay(component, targetDate);
        break;
    }
    switch (timeText) {
      case "ochtend":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 6);
        break;
      case "middag":
        component.imply("meridiem", Meridiem.AM);
        component.imply("hour", 12);
        break;
      case "namiddag":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 15);
        break;
      case "avond":
        component.imply("meridiem", Meridiem.PM);
        component.imply("hour", 20);
        break;
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.js
var PATTERN29 = new RegExp(`(dit|deze|vorig|afgelopen|(?:aan)?komend|over|\\+|-)e?\\s*(${TIME_UNITS_PATTERN4})(?=\\W|$)`, "i");
var PREFIX_WORD_GROUP = 1;
var TIME_UNIT_WORD_GROUP = 2;
var NLTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN29;
  }
  innerExtract(context, match2) {
    const prefix5 = match2[PREFIX_WORD_GROUP].toLowerCase();
    let timeUnits = parseTimeUnits4(match2[TIME_UNIT_WORD_GROUP]);
    switch (prefix5) {
      case "vorig":
      case "afgelopen":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLRelativeDateFormatParser.js
var import_dayjs27 = __toESM(require_dayjs_min(), 1);
var PATTERN30 = new RegExp(`(dit|deze|(?:aan)?komend|volgend|afgelopen|vorig)e?\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY4)})(?=\\s*)(?=\\W|$)`, "i");
var MODIFIER_WORD_GROUP2 = 1;
var RELATIVE_WORD_GROUP2 = 2;
var NLRelativeDateFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN30;
  }
  innerExtract(context, match2) {
    const modifier = match2[MODIFIER_WORD_GROUP2].toLowerCase();
    const unitWord = match2[RELATIVE_WORD_GROUP2].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY4[unitWord];
    if (modifier == "volgend" || modifier == "komend" || modifier == "aankomend") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "afgelopen" || modifier == "vorig") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs27.default)(context.reference.instant);
    if (unitWord.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (unitWord.match(/maand/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (unitWord.match(/jaar/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitAgoFormatParser.js
var PATTERN31 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(?:geleden|voor|eerder)(?=(?:\\W|$))", "i");
var STRICT_PATTERN3 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")geleden(?=(?:\\W|$))", "i");
var NLTimeUnitAgoFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN3 : PATTERN31;
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits4(match2[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/parsers/NLTimeUnitLaterFormatParser.js
var PATTERN32 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|na|vanaf nu|voortaan|vooruit|uit)(?=(?:\\W|$))", "i");
var STRICT_PATTERN4 = new RegExp("(" + TIME_UNITS_PATTERN4 + ")(later|vanaf nu)(?=(?:\\W|$))", "i");
var GROUP_NUM_TIMEUNITS2 = 1;
var NLTimeUnitLaterFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  constructor(strictMode) {
    super();
    this.strictMode = strictMode;
  }
  innerPattern() {
    return this.strictMode ? STRICT_PATTERN4 : PATTERN32;
  }
  innerExtract(context, match2) {
    const fragments = parseTimeUnits4(match2[GROUP_NUM_TIMEUNITS2]);
    return ParsingComponents.createRelativeFromReference(context.reference, fragments);
  }
};

// node_modules/chrono-node/dist/esm/locales/nl/index.js
var casual6 = new Chrono(createCasualConfiguration5());
var strict6 = new Chrono(createConfiguration5(true));
function parse12(text, ref, option) {
  return casual6.parse(text, ref, option);
}
function parseDate6(text, ref, option) {
  return casual6.parseDate(text, ref, option);
}
function createCasualConfiguration5(littleEndian = true) {
  const option = createConfiguration5(false, littleEndian);
  option.parsers.unshift(new NLCasualDateParser());
  option.parsers.unshift(new NLCasualTimeParser());
  option.parsers.unshift(new NLCasualDateTimeParser());
  option.parsers.unshift(new NLMonthNameParser());
  option.parsers.unshift(new NLRelativeDateFormatParser());
  option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration5(strictMode = true, littleEndian = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(littleEndian),
      new NLTimeUnitWithinFormatParser(),
      new NLMonthNameMiddleEndianParser(),
      new NLMonthNameParser(),
      new NLWeekdayParser(),
      new NLCasualYearMonthDayParser(),
      new NLSlashMonthFormatParser(),
      new NLTimeExpressionParser(strictMode),
      new NLTimeUnitAgoFormatParser(strictMode),
      new NLTimeUnitLaterFormatParser(strictMode)
    ],
    refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/zh/index.js
var zh_exports = {};
__export(zh_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual7,
  createCasualConfiguration: () => createCasualConfiguration6,
  createConfiguration: () => createConfiguration6,
  hans: () => hans_exports,
  hant: () => hant,
  parse: () => parse13,
  parseDate: () => parseDate7,
  strict: () => strict7
});

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantCasualDateParser.js
var import_dayjs28 = __toESM(require_dayjs_min(), 1);
var NOW_GROUP = 1;
var DAY_GROUP_1 = 2;
var TIME_GROUP_1 = 3;
var TIME_GROUP_2 = 4;
var DAY_GROUP_3 = 5;
var TIME_GROUP_3 = 6;
var ZHHantCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(\u800C\u5BB6|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
  }
  innerExtract(context, match2) {
    const index4 = match2.index;
    const result = context.createParsingResult(index4, match2[0]);
    const refMoment = (0, import_dayjs28.default)(context.refDate);
    let startMoment = refMoment;
    if (match2[NOW_GROUP]) {
      result.start.imply("hour", refMoment.hour());
      result.start.imply("minute", refMoment.minute());
      result.start.imply("second", refMoment.second());
      result.start.imply("millisecond", refMoment.millisecond());
    } else if (match2[DAY_GROUP_1]) {
      const day1 = match2[DAY_GROUP_1];
      const time1 = match2[TIME_GROUP_1];
      if (day1 == "\u660E" || day1 == "\u807D") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "\u5F8C") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "\u5927\u5F8C") {
        startMoment = startMoment.add(3, "day");
      }
      if (time1 == "\u65E9" || time1 == "\u671D") {
        result.start.imply("hour", 6);
      } else if (time1 == "\u665A") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match2[TIME_GROUP_2]) {
      const timeString2 = match2[TIME_GROUP_2];
      const time2 = timeString2[0];
      if (time2 == "\u65E9" || time2 == "\u671D" || time2 == "\u4E0A") {
        result.start.imply("hour", 6);
      } else if (time2 == "\u4E0B" || time2 == "\u664F") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u4E2D") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u591C" || time2 == "\u665A") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u51CC") {
        result.start.imply("hour", 0);
      }
    } else if (match2[DAY_GROUP_3]) {
      const day3 = match2[DAY_GROUP_3];
      if (day3 == "\u660E" || day3 == "\u807D") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "\u5F8C") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "\u5927\u5F8C") {
        startMoment = startMoment.add(3, "day");
      }
      const timeString3 = match2[TIME_GROUP_3];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "\u65E9" || time3 == "\u671D" || time3 == "\u4E0A") {
          result.start.imply("hour", 6);
        } else if (time3 == "\u4E0B" || time3 == "\u664F") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u4E2D") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u591C" || time3 == "\u665A") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u51CC") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", startMoment.date());
    result.start.assign("month", startMoment.month() + 1);
    result.start.assign("year", startMoment.year());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDateParser.js
var import_dayjs29 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/zh/hant/constants.js
var NUMBER = {
  "\u96F6": 0,
  "\u4E00": 1,
  "\u4E8C": 2,
  "\u5169": 2,
  "\u4E09": 3,
  "\u56DB": 4,
  "\u4E94": 5,
  "\u516D": 6,
  "\u4E03": 7,
  "\u516B": 8,
  "\u4E5D": 9,
  "\u5341": 10,
  "\u5EFF": 20,
  "\u5345": 30
};
var WEEKDAY_OFFSET = {
  "\u5929": 0,
  "\u65E5": 0,
  "\u4E00": 1,
  "\u4E8C": 2,
  "\u4E09": 3,
  "\u56DB": 4,
  "\u4E94": 5,
  "\u516D": 6
};
function zhStringToNumber(text) {
  let number = 0;
  for (let i5 = 0; i5 < text.length; i5++) {
    const char = text[i5];
    if (char === "\u5341") {
      number = number === 0 ? NUMBER[char] : number * NUMBER[char];
    } else {
      number += NUMBER[char];
    }
  }
  return number;
}
function zhStringToYear(text) {
  let string = "";
  for (let i5 = 0; i5 < text.length; i5++) {
    const char = text[i5];
    string = string + NUMBER[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDateParser.js
var YEAR_GROUP12 = 1;
var MONTH_GROUP4 = 2;
var DAY_GROUP3 = 3;
var ZHHantDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER).join("") + "]{4}|[" + Object.keys(NUMBER).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(NUMBER).join("") + "]{1,2})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER).join("") + "]{1,2})?(?:\\s*)(?:\u65E5|\u865F)?");
  }
  innerExtract(context, match2) {
    const startMoment = (0, import_dayjs29.default)(context.refDate);
    const result = context.createParsingResult(match2.index, match2[0]);
    let month2 = parseInt(match2[MONTH_GROUP4]);
    if (isNaN(month2))
      month2 = zhStringToNumber(match2[MONTH_GROUP4]);
    result.start.assign("month", month2);
    if (match2[DAY_GROUP3]) {
      let day = parseInt(match2[DAY_GROUP3]);
      if (isNaN(day))
        day = zhStringToNumber(match2[DAY_GROUP3]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", startMoment.date());
    }
    if (match2[YEAR_GROUP12]) {
      let year3 = parseInt(match2[YEAR_GROUP12]);
      if (isNaN(year3))
        year3 = zhStringToYear(match2[YEAR_GROUP12]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.js
var import_dayjs30 = __toESM(require_dayjs_min(), 1);
var PATTERN33 = new RegExp("(\\d+|[" + Object.keys(NUMBER).join("") + "]+|\u534A|\u5E7E)(?:\\s*)(?:\u500B)?(\u79D2(?:\u9418)?|\u5206\u9418|\u5C0F\u6642|\u9418|\u65E5|\u5929|\u661F\u671F|\u79AE\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u904E)?\u5F8C|(?:\u4E4B)?\u5167)", "i");
var NUMBER_GROUP = 1;
var UNIT_GROUP = 2;
var ZHHantDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN33;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    let number = parseInt(match2[NUMBER_GROUP]);
    if (isNaN(number)) {
      number = zhStringToNumber(match2[NUMBER_GROUP]);
    }
    if (isNaN(number)) {
      const string = match2[NUMBER_GROUP];
      if (string === "\u5E7E") {
        number = 3;
      } else if (string === "\u534A") {
        number = 0.5;
      } else {
        return null;
      }
    }
    let date = (0, import_dayjs30.default)(context.refDate);
    const unit = match2[UNIT_GROUP];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[日天星禮月年]/)) {
      if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
        date = date.add(number, "d");
      } else if (unitAbbr == "\u661F" || unitAbbr == "\u79AE") {
        date = date.add(number * 7, "d");
      } else if (unitAbbr == "\u6708") {
        date = date.add(number, "month");
      } else if (unitAbbr == "\u5E74") {
        date = date.add(number, "year");
      }
      result.start.assign("year", date.year());
      result.start.assign("month", date.month() + 1);
      result.start.assign("day", date.date());
      return result;
    }
    if (unitAbbr == "\u79D2") {
      date = date.add(number, "second");
    } else if (unitAbbr == "\u5206") {
      date = date.add(number, "minute");
    } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u9418") {
      date = date.add(number, "hour");
    }
    result.start.imply("year", date.year());
    result.start.imply("month", date.month() + 1);
    result.start.imply("day", date.date());
    result.start.assign("hour", date.hour());
    result.start.assign("minute", date.minute());
    result.start.assign("second", date.second());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.js
var import_dayjs31 = __toESM(require_dayjs_min(), 1);
var PATTERN34 = new RegExp("(?<prefix>\u4E0A|\u4ECA|\u4E0B|\u9019|\u5462)(?:\u500B)?(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")");
var ZHHantRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN34;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const dayOfWeek = match2.groups.weekday;
    const offset2 = WEEKDAY_OFFSET[dayOfWeek];
    if (offset2 === void 0)
      return null;
    let modifier = null;
    const prefix5 = match2.groups.prefix;
    if (prefix5 == "\u4E0A") {
      modifier = "last";
    } else if (prefix5 == "\u4E0B") {
      modifier = "next";
    } else if (prefix5 == "\u4ECA" || prefix5 == "\u9019" || prefix5 == "\u5462") {
      modifier = "this";
    }
    let startMoment = (0, import_dayjs31.default)(context.refDate);
    let startMomentFixed = false;
    const refOffset = startMoment.day();
    if (modifier == "last" || modifier == "past") {
      startMoment = startMoment.day(offset2 - 7);
      startMomentFixed = true;
    } else if (modifier == "next") {
      startMoment = startMoment.day(offset2 + 7);
      startMomentFixed = true;
    } else if (modifier == "this") {
      startMoment = startMoment.day(offset2);
    } else {
      if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        startMoment = startMoment.day(offset2 - 7);
      } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        startMoment = startMoment.day(offset2 + 7);
      } else {
        startMoment = startMoment.day(offset2);
      }
    }
    result.start.assign("weekday", offset2);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantTimeExpressionParser.js
var import_dayjs32 = __toESM(require_dayjs_min(), 1);
var FIRST_REG_PATTERN3 = new RegExp("(?:\u7531|\u5F9E|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN3 = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u5F8C|\u5927\u5F8C|\u807D|\u6628|\u5C0B|\u7434)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348|\u665D)|\u671D(?:\u65E9)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348|\u665D)|\u664F(?:\u665D)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(NUMBER).join("") + "]+)(?:\\s*)(?:\u9EDE|\u6642|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_12 = 1;
var ZH_AM_PM_HOUR_GROUP_1 = 2;
var ZH_AM_PM_HOUR_GROUP_2 = 3;
var DAY_GROUP_32 = 4;
var ZH_AM_PM_HOUR_GROUP_3 = 5;
var HOUR_GROUP4 = 6;
var MINUTE_GROUP4 = 7;
var SECOND_GROUP4 = 8;
var AM_PM_HOUR_GROUP4 = 9;
var ZHHantTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN3;
  }
  innerExtract(context, match2) {
    if (match2.index > 0 && context.text[match2.index - 1].match(/\w/)) {
      return null;
    }
    const refMoment = (0, import_dayjs32.default)(context.refDate);
    const result = context.createParsingResult(match2.index, match2[0]);
    let startMoment = refMoment.clone();
    if (match2[DAY_GROUP_12]) {
      var day1 = match2[DAY_GROUP_12];
      if (day1 == "\u660E" || day1 == "\u807D") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "\u5F8C") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "\u5927\u5F8C") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else if (match2[DAY_GROUP_32]) {
      var day3 = match2[DAY_GROUP_32];
      if (day3 == "\u660E" || day3 == "\u807D") {
        startMoment = startMoment.add(1, "day");
      } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "\u5F8C") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "\u5927\u5F8C") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match2[SECOND_GROUP4]) {
      var second = parseInt(match2[SECOND_GROUP4]);
      if (isNaN(second)) {
        second = zhStringToNumber(match2[SECOND_GROUP4]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match2[HOUR_GROUP4]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(match2[HOUR_GROUP4]);
    }
    if (match2[MINUTE_GROUP4]) {
      if (match2[MINUTE_GROUP4] == "\u534A") {
        minute = 30;
      } else if (match2[MINUTE_GROUP4] == "\u6B63" || match2[MINUTE_GROUP4] == "\u6574") {
        minute = 0;
      } else {
        minute = parseInt(match2[MINUTE_GROUP4]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(match2[MINUTE_GROUP4]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match2[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      var ampm = match2[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_1]) {
      var zhAMPMString1 = match2[ZH_AM_PM_HOUR_GROUP_1];
      var zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_2]) {
      var zhAMPMString2 = match2[ZH_AM_PM_HOUR_GROUP_2];
      var zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_3]) {
      var zhAMPMString3 = match2[ZH_AM_PM_HOUR_GROUP_3];
      var zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    match2 = SECOND_REG_PATTERN3.exec(context.text.substring(result.index + result.text.length));
    if (!match2) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    let endMoment = startMoment.clone();
    result.end = context.createParsingComponents();
    if (match2[DAY_GROUP_12]) {
      var day1 = match2[DAY_GROUP_12];
      if (day1 == "\u660E" || day1 == "\u807D") {
        if (refMoment.hour() > 1) {
          endMoment = endMoment.add(1, "day");
        }
      } else if (day1 == "\u6628" || day1 == "\u5C0B" || day1 == "\u7434") {
        endMoment = endMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        endMoment = endMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        endMoment = endMoment.add(-3, "day");
      } else if (day1 == "\u5F8C") {
        endMoment = endMoment.add(2, "day");
      } else if (day1 == "\u5927\u5F8C") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else if (match2[DAY_GROUP_32]) {
      var day3 = match2[DAY_GROUP_32];
      if (day3 == "\u660E" || day3 == "\u807D") {
        endMoment = endMoment.add(1, "day");
      } else if (day3 == "\u6628" || day3 == "\u5C0B" || day3 == "\u7434") {
        endMoment = endMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        endMoment = endMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        endMoment = endMoment.add(-3, "day");
      } else if (day3 == "\u5F8C") {
        endMoment = endMoment.add(2, "day");
      } else if (day3 == "\u5927\u5F8C") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else {
      result.end.imply("day", endMoment.date());
      result.end.imply("month", endMoment.month() + 1);
      result.end.imply("year", endMoment.year());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (match2[SECOND_GROUP4]) {
      var second = parseInt(match2[SECOND_GROUP4]);
      if (isNaN(second)) {
        second = zhStringToNumber(match2[SECOND_GROUP4]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(match2[HOUR_GROUP4]);
    if (isNaN(hour)) {
      hour = zhStringToNumber(match2[HOUR_GROUP4]);
    }
    if (match2[MINUTE_GROUP4]) {
      if (match2[MINUTE_GROUP4] == "\u534A") {
        minute = 30;
      } else if (match2[MINUTE_GROUP4] == "\u6B63" || match2[MINUTE_GROUP4] == "\u6574") {
        minute = 0;
      } else {
        minute = parseInt(match2[MINUTE_GROUP4]);
        if (isNaN(minute)) {
          minute = zhStringToNumber(match2[MINUTE_GROUP4]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match2[AM_PM_HOUR_GROUP4]) {
      if (hour > 12)
        return null;
      var ampm = match2[AM_PM_HOUR_GROUP4][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_1]) {
      var zhAMPMString1 = match2[ZH_AM_PM_HOUR_GROUP_1];
      var zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "\u671D" || zhAMPM1 == "\u65E9") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_2]) {
      var zhAMPMString2 = match2[ZH_AM_PM_HOUR_GROUP_2];
      var zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u671D" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u664F" || zhAMPM2 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_3]) {
      var zhAMPMString3 = match2[ZH_AM_PM_HOUR_GROUP_3];
      var zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u671D" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u664F" || zhAMPM3 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + match2[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/parsers/ZHHantWeekdayParser.js
var import_dayjs33 = __toESM(require_dayjs_min(), 1);
var PATTERN35 = new RegExp("(?:\u661F\u671F|\u79AE\u62DC|\u9031)(?<weekday>" + Object.keys(WEEKDAY_OFFSET).join("|") + ")");
var ZHHantWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN35;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const dayOfWeek = match2.groups.weekday;
    const offset2 = WEEKDAY_OFFSET[dayOfWeek];
    if (offset2 === void 0)
      return null;
    let startMoment = (0, import_dayjs33.default)(context.refDate);
    const startMomentFixed = false;
    const refOffset = startMoment.day();
    if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
      startMoment = startMoment.day(offset2 - 7);
    } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
      startMoment = startMoment.day(offset2 + 7);
    } else {
      startMoment = startMoment.day(offset2);
    }
    result.start.assign("weekday", offset2);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.js
var ZHHantMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(至|到|\-|\~|～|－|ー)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.js
var ZHHantMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hant/index.js
var hant = new Chrono(createCasualConfiguration6());
var casual7 = new Chrono(createCasualConfiguration6());
var strict7 = new Chrono(createConfiguration6());
function parse13(text, ref, option) {
  return casual7.parse(text, ref, option);
}
function parseDate7(text, ref, option) {
  return casual7.parseDate(text, ref, option);
}
function createCasualConfiguration6() {
  const option = createConfiguration6();
  option.parsers.unshift(new ZHHantCasualDateParser());
  return option;
}
function createConfiguration6() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHantDateParser(),
      new ZHHantRelationWeekdayParser(),
      new ZHHantWeekdayParser(),
      new ZHHantTimeExpressionParser(),
      new ZHHantDeadlineFormatParser()
    ],
    refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans_exports = {};
__export(hans_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual8,
  createCasualConfiguration: () => createCasualConfiguration7,
  createConfiguration: () => createConfiguration7,
  hans: () => hans,
  parse: () => parse14,
  parseDate: () => parseDate8,
  strict: () => strict8
});

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansCasualDateParser.js
var import_dayjs34 = __toESM(require_dayjs_min(), 1);
var NOW_GROUP2 = 1;
var DAY_GROUP_13 = 2;
var TIME_GROUP_12 = 3;
var TIME_GROUP_22 = 4;
var DAY_GROUP_33 = 5;
var TIME_GROUP_32 = 6;
var ZHHansCasualDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern(context) {
    return new RegExp("(\u73B0\u5728|\u7ACB(?:\u523B|\u5373)|\u5373\u523B)|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s|,|\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?", "i");
  }
  innerExtract(context, match2) {
    const index4 = match2.index;
    const result = context.createParsingResult(index4, match2[0]);
    const refMoment = (0, import_dayjs34.default)(context.refDate);
    let startMoment = refMoment;
    if (match2[NOW_GROUP2]) {
      result.start.imply("hour", refMoment.hour());
      result.start.imply("minute", refMoment.minute());
      result.start.imply("second", refMoment.second());
      result.start.imply("millisecond", refMoment.millisecond());
    } else if (match2[DAY_GROUP_13]) {
      const day1 = match2[DAY_GROUP_13];
      const time1 = match2[TIME_GROUP_12];
      if (day1 == "\u660E") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "\u6628") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "\u540E") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "\u5927\u540E") {
        startMoment = startMoment.add(3, "day");
      }
      if (time1 == "\u65E9") {
        result.start.imply("hour", 6);
      } else if (time1 == "\u665A") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      }
    } else if (match2[TIME_GROUP_22]) {
      const timeString2 = match2[TIME_GROUP_22];
      const time2 = timeString2[0];
      if (time2 == "\u65E9" || time2 == "\u4E0A") {
        result.start.imply("hour", 6);
      } else if (time2 == "\u4E0B") {
        result.start.imply("hour", 15);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u4E2D") {
        result.start.imply("hour", 12);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u591C" || time2 == "\u665A") {
        result.start.imply("hour", 22);
        result.start.imply("meridiem", 1);
      } else if (time2 == "\u51CC") {
        result.start.imply("hour", 0);
      }
    } else if (match2[DAY_GROUP_33]) {
      const day3 = match2[DAY_GROUP_33];
      if (day3 == "\u660E") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day3 == "\u6628") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "\u540E") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "\u5927\u540E") {
        startMoment = startMoment.add(3, "day");
      }
      const timeString3 = match2[TIME_GROUP_32];
      if (timeString3) {
        const time3 = timeString3[0];
        if (time3 == "\u65E9" || time3 == "\u4E0A") {
          result.start.imply("hour", 6);
        } else if (time3 == "\u4E0B") {
          result.start.imply("hour", 15);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u4E2D") {
          result.start.imply("hour", 12);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u591C" || time3 == "\u665A") {
          result.start.imply("hour", 22);
          result.start.imply("meridiem", 1);
        } else if (time3 == "\u51CC") {
          result.start.imply("hour", 0);
        }
      }
    }
    result.start.assign("day", startMoment.date());
    result.start.assign("month", startMoment.month() + 1);
    result.start.assign("year", startMoment.year());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDateParser.js
var import_dayjs35 = __toESM(require_dayjs_min(), 1);

// node_modules/chrono-node/dist/esm/locales/zh/hans/constants.js
var NUMBER2 = {
  "\u96F6": 0,
  "\u3007": 0,
  "\u4E00": 1,
  "\u4E8C": 2,
  "\u4E24": 2,
  "\u4E09": 3,
  "\u56DB": 4,
  "\u4E94": 5,
  "\u516D": 6,
  "\u4E03": 7,
  "\u516B": 8,
  "\u4E5D": 9,
  "\u5341": 10
};
var WEEKDAY_OFFSET2 = {
  "\u5929": 0,
  "\u65E5": 0,
  "\u4E00": 1,
  "\u4E8C": 2,
  "\u4E09": 3,
  "\u56DB": 4,
  "\u4E94": 5,
  "\u516D": 6
};
function zhStringToNumber2(text) {
  let number = 0;
  for (let i5 = 0; i5 < text.length; i5++) {
    const char = text[i5];
    if (char === "\u5341") {
      number = number === 0 ? NUMBER2[char] : number * NUMBER2[char];
    } else {
      number += NUMBER2[char];
    }
  }
  return number;
}
function zhStringToYear2(text) {
  let string = "";
  for (let i5 = 0; i5 < text.length; i5++) {
    const char = text[i5];
    string = string + NUMBER2[char];
  }
  return parseInt(string);
}

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDateParser.js
var YEAR_GROUP13 = 1;
var MONTH_GROUP5 = 2;
var DAY_GROUP4 = 3;
var ZHHansDateParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return new RegExp("(\\d{2,4}|[" + Object.keys(NUMBER2).join("") + "]{4}|[" + Object.keys(NUMBER2).join("") + "]{2})?(?:\\s*)(?:\u5E74)?(?:[\\s|,|\uFF0C]*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})(?:\\s*)(?:\u6708)(?:\\s*)(\\d{1,2}|[" + Object.keys(NUMBER2).join("") + "]{1,3})?(?:\\s*)(?:\u65E5|\u53F7)?");
  }
  innerExtract(context, match2) {
    const startMoment = (0, import_dayjs35.default)(context.refDate);
    const result = context.createParsingResult(match2.index, match2[0]);
    let month2 = parseInt(match2[MONTH_GROUP5]);
    if (isNaN(month2))
      month2 = zhStringToNumber2(match2[MONTH_GROUP5]);
    result.start.assign("month", month2);
    if (match2[DAY_GROUP4]) {
      let day = parseInt(match2[DAY_GROUP4]);
      if (isNaN(day))
        day = zhStringToNumber2(match2[DAY_GROUP4]);
      result.start.assign("day", day);
    } else {
      result.start.imply("day", startMoment.date());
    }
    if (match2[YEAR_GROUP13]) {
      let year3 = parseInt(match2[YEAR_GROUP13]);
      if (isNaN(year3))
        year3 = zhStringToYear2(match2[YEAR_GROUP13]);
      result.start.assign("year", year3);
    } else {
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.js
var import_dayjs36 = __toESM(require_dayjs_min(), 1);
var PATTERN36 = new RegExp("(\\d+|[" + Object.keys(NUMBER2).join("") + "]+|\u534A|\u51E0)(?:\\s*)(?:\u4E2A)?(\u79D2(?:\u949F)?|\u5206\u949F|\u5C0F\u65F6|\u949F|\u65E5|\u5929|\u661F\u671F|\u793C\u62DC|\u6708|\u5E74)(?:(?:\u4E4B|\u8FC7)?\u540E|(?:\u4E4B)?\u5185)", "i");
var NUMBER_GROUP2 = 1;
var UNIT_GROUP2 = 2;
var ZHHansDeadlineFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN36;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    let number = parseInt(match2[NUMBER_GROUP2]);
    if (isNaN(number)) {
      number = zhStringToNumber2(match2[NUMBER_GROUP2]);
    }
    if (isNaN(number)) {
      const string = match2[NUMBER_GROUP2];
      if (string === "\u51E0") {
        number = 3;
      } else if (string === "\u534A") {
        number = 0.5;
      } else {
        return null;
      }
    }
    let date = (0, import_dayjs36.default)(context.refDate);
    const unit = match2[UNIT_GROUP2];
    const unitAbbr = unit[0];
    if (unitAbbr.match(/[日天星礼月年]/)) {
      if (unitAbbr == "\u65E5" || unitAbbr == "\u5929") {
        date = date.add(number, "d");
      } else if (unitAbbr == "\u661F" || unitAbbr == "\u793C") {
        date = date.add(number * 7, "d");
      } else if (unitAbbr == "\u6708") {
        date = date.add(number, "month");
      } else if (unitAbbr == "\u5E74") {
        date = date.add(number, "year");
      }
      result.start.assign("year", date.year());
      result.start.assign("month", date.month() + 1);
      result.start.assign("day", date.date());
      return result;
    }
    if (unitAbbr == "\u79D2") {
      date = date.add(number, "second");
    } else if (unitAbbr == "\u5206") {
      date = date.add(number, "minute");
    } else if (unitAbbr == "\u5C0F" || unitAbbr == "\u949F") {
      date = date.add(number, "hour");
    }
    result.start.imply("year", date.year());
    result.start.imply("month", date.month() + 1);
    result.start.imply("day", date.date());
    result.start.assign("hour", date.hour());
    result.start.assign("minute", date.minute());
    result.start.assign("second", date.second());
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.js
var import_dayjs37 = __toESM(require_dayjs_min(), 1);
var PATTERN37 = new RegExp("(?<prefix>\u4E0A|\u4E0B|\u8FD9)(?:\u4E2A)?(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansRelationWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN37;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const dayOfWeek = match2.groups.weekday;
    const offset2 = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset2 === void 0)
      return null;
    let modifier = null;
    const prefix5 = match2.groups.prefix;
    if (prefix5 == "\u4E0A") {
      modifier = "last";
    } else if (prefix5 == "\u4E0B") {
      modifier = "next";
    } else if (prefix5 == "\u8FD9") {
      modifier = "this";
    }
    let startMoment = (0, import_dayjs37.default)(context.refDate);
    let startMomentFixed = false;
    const refOffset = startMoment.day();
    if (modifier == "last" || modifier == "past") {
      startMoment = startMoment.day(offset2 - 7);
      startMomentFixed = true;
    } else if (modifier == "next") {
      startMoment = startMoment.day(offset2 + 7);
      startMomentFixed = true;
    } else if (modifier == "this") {
      startMoment = startMoment.day(offset2);
    } else {
      if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        startMoment = startMoment.day(offset2 - 7);
      } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
        startMoment = startMoment.day(offset2 + 7);
      } else {
        startMoment = startMoment.day(offset2);
      }
    }
    result.start.assign("weekday", offset2);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansTimeExpressionParser.js
var import_dayjs38 = __toESM(require_dayjs_min(), 1);
var FIRST_REG_PATTERN4 = new RegExp("(?:\u4ECE|\u81EA)?(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var SECOND_REG_PATTERN4 = new RegExp("(?:^\\s*(?:\u5230|\u81F3|\\-|\\\u2013|\\~|\\\u301C)\\s*)(?:(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(\u65E9|\u671D|\u665A)|(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668))|(\u4ECA|\u660E|\u524D|\u5927\u524D|\u540E|\u5927\u540E|\u6628)(?:\u65E5|\u5929)(?:[\\s,\uFF0C]*)(?:(\u4E0A(?:\u5348)|\u65E9(?:\u4E0A)|\u4E0B(?:\u5348)|\u665A(?:\u4E0A)|\u591C(?:\u665A)?|\u4E2D(?:\u5348)|\u51CC(?:\u6668)))?)?(?:[\\s,\uFF0C]*)(?:(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)(?:\\s*)(?:\u70B9|\u65F6|:|\uFF1A)(?:\\s*)(\\d+|\u534A|\u6B63|\u6574|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:\u5206|:|\uFF1A)?(?:\\s*)(\\d+|[" + Object.keys(NUMBER2).join("") + "]+)?(?:\\s*)(?:\u79D2)?)(?:\\s*(A.M.|P.M.|AM?|PM?))?", "i");
var DAY_GROUP_14 = 1;
var ZH_AM_PM_HOUR_GROUP_12 = 2;
var ZH_AM_PM_HOUR_GROUP_22 = 3;
var DAY_GROUP_34 = 4;
var ZH_AM_PM_HOUR_GROUP_32 = 5;
var HOUR_GROUP5 = 6;
var MINUTE_GROUP5 = 7;
var SECOND_GROUP5 = 8;
var AM_PM_HOUR_GROUP5 = 9;
var ZHHansTimeExpressionParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return FIRST_REG_PATTERN4;
  }
  innerExtract(context, match2) {
    if (match2.index > 0 && context.text[match2.index - 1].match(/\w/)) {
      return null;
    }
    const refMoment = (0, import_dayjs38.default)(context.refDate);
    const result = context.createParsingResult(match2.index, match2[0]);
    let startMoment = refMoment.clone();
    if (match2[DAY_GROUP_14]) {
      const day1 = match2[DAY_GROUP_14];
      if (day1 == "\u660E") {
        if (refMoment.hour() > 1) {
          startMoment = startMoment.add(1, "day");
        }
      } else if (day1 == "\u6628") {
        startMoment = startMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day1 == "\u540E") {
        startMoment = startMoment.add(2, "day");
      } else if (day1 == "\u5927\u540E") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else if (match2[DAY_GROUP_34]) {
      const day3 = match2[DAY_GROUP_34];
      if (day3 == "\u660E") {
        startMoment = startMoment.add(1, "day");
      } else if (day3 == "\u6628") {
        startMoment = startMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        startMoment = startMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        startMoment = startMoment.add(-3, "day");
      } else if (day3 == "\u540E") {
        startMoment = startMoment.add(2, "day");
      } else if (day3 == "\u5927\u540E") {
        startMoment = startMoment.add(3, "day");
      }
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    let hour = 0;
    let minute = 0;
    let meridiem = -1;
    if (match2[SECOND_GROUP5]) {
      let second = parseInt(match2[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber2(match2[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.start.assign("second", second);
    }
    hour = parseInt(match2[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(match2[HOUR_GROUP5]);
    }
    if (match2[MINUTE_GROUP5]) {
      if (match2[MINUTE_GROUP5] == "\u534A") {
        minute = 30;
      } else if (match2[MINUTE_GROUP5] == "\u6B63" || match2[MINUTE_GROUP5] == "\u6574") {
        minute = 0;
      } else {
        minute = parseInt(match2[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(match2[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match2[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      const ampm = match2[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_12]) {
      const zhAMPMString1 = match2[ZH_AM_PM_HOUR_GROUP_12];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "\u65E9") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_22]) {
      const zhAMPMString2 = match2[ZH_AM_PM_HOUR_GROUP_22];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_32]) {
      const zhAMPMString3 = match2[ZH_AM_PM_HOUR_GROUP_32];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.start.assign("hour", hour);
    result.start.assign("minute", minute);
    if (meridiem >= 0) {
      result.start.assign("meridiem", meridiem);
    } else {
      if (hour < 12) {
        result.start.imply("meridiem", 0);
      } else {
        result.start.imply("meridiem", 1);
      }
    }
    match2 = SECOND_REG_PATTERN4.exec(context.text.substring(result.index + result.text.length));
    if (!match2) {
      if (result.text.match(/^\d+$/)) {
        return null;
      }
      return result;
    }
    let endMoment = startMoment.clone();
    result.end = context.createParsingComponents();
    if (match2[DAY_GROUP_14]) {
      const day1 = match2[DAY_GROUP_14];
      if (day1 == "\u660E") {
        if (refMoment.hour() > 1) {
          endMoment = endMoment.add(1, "day");
        }
      } else if (day1 == "\u6628") {
        endMoment = endMoment.add(-1, "day");
      } else if (day1 == "\u524D") {
        endMoment = endMoment.add(-2, "day");
      } else if (day1 == "\u5927\u524D") {
        endMoment = endMoment.add(-3, "day");
      } else if (day1 == "\u540E") {
        endMoment = endMoment.add(2, "day");
      } else if (day1 == "\u5927\u540E") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else if (match2[DAY_GROUP_34]) {
      const day3 = match2[DAY_GROUP_34];
      if (day3 == "\u660E") {
        endMoment = endMoment.add(1, "day");
      } else if (day3 == "\u6628") {
        endMoment = endMoment.add(-1, "day");
      } else if (day3 == "\u524D") {
        endMoment = endMoment.add(-2, "day");
      } else if (day3 == "\u5927\u524D") {
        endMoment = endMoment.add(-3, "day");
      } else if (day3 == "\u540E") {
        endMoment = endMoment.add(2, "day");
      } else if (day3 == "\u5927\u540E") {
        endMoment = endMoment.add(3, "day");
      }
      result.end.assign("day", endMoment.date());
      result.end.assign("month", endMoment.month() + 1);
      result.end.assign("year", endMoment.year());
    } else {
      result.end.imply("day", endMoment.date());
      result.end.imply("month", endMoment.month() + 1);
      result.end.imply("year", endMoment.year());
    }
    hour = 0;
    minute = 0;
    meridiem = -1;
    if (match2[SECOND_GROUP5]) {
      let second = parseInt(match2[SECOND_GROUP5]);
      if (isNaN(second)) {
        second = zhStringToNumber2(match2[SECOND_GROUP5]);
      }
      if (second >= 60)
        return null;
      result.end.assign("second", second);
    }
    hour = parseInt(match2[HOUR_GROUP5]);
    if (isNaN(hour)) {
      hour = zhStringToNumber2(match2[HOUR_GROUP5]);
    }
    if (match2[MINUTE_GROUP5]) {
      if (match2[MINUTE_GROUP5] == "\u534A") {
        minute = 30;
      } else if (match2[MINUTE_GROUP5] == "\u6B63" || match2[MINUTE_GROUP5] == "\u6574") {
        minute = 0;
      } else {
        minute = parseInt(match2[MINUTE_GROUP5]);
        if (isNaN(minute)) {
          minute = zhStringToNumber2(match2[MINUTE_GROUP5]);
        }
      }
    } else if (hour > 100) {
      minute = hour % 100;
      hour = Math.floor(hour / 100);
    }
    if (minute >= 60) {
      return null;
    }
    if (hour > 24) {
      return null;
    }
    if (hour >= 12) {
      meridiem = 1;
    }
    if (match2[AM_PM_HOUR_GROUP5]) {
      if (hour > 12)
        return null;
      const ampm = match2[AM_PM_HOUR_GROUP5][0].toLowerCase();
      if (ampm == "a") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      }
      if (ampm == "p") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
      if (!result.start.isCertain("meridiem")) {
        if (meridiem == 0) {
          result.start.imply("meridiem", 0);
          if (result.start.get("hour") == 12) {
            result.start.assign("hour", 0);
          }
        } else {
          result.start.imply("meridiem", 1);
          if (result.start.get("hour") != 12) {
            result.start.assign("hour", result.start.get("hour") + 12);
          }
        }
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_12]) {
      const zhAMPMString1 = match2[ZH_AM_PM_HOUR_GROUP_12];
      const zhAMPM1 = zhAMPMString1[0];
      if (zhAMPM1 == "\u65E9") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM1 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_22]) {
      const zhAMPMString2 = match2[ZH_AM_PM_HOUR_GROUP_22];
      const zhAMPM2 = zhAMPMString2[0];
      if (zhAMPM2 == "\u4E0A" || zhAMPM2 == "\u65E9" || zhAMPM2 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM2 == "\u4E0B" || zhAMPM2 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    } else if (match2[ZH_AM_PM_HOUR_GROUP_32]) {
      const zhAMPMString3 = match2[ZH_AM_PM_HOUR_GROUP_32];
      const zhAMPM3 = zhAMPMString3[0];
      if (zhAMPM3 == "\u4E0A" || zhAMPM3 == "\u65E9" || zhAMPM3 == "\u51CC") {
        meridiem = 0;
        if (hour == 12)
          hour = 0;
      } else if (zhAMPM3 == "\u4E0B" || zhAMPM3 == "\u665A") {
        meridiem = 1;
        if (hour != 12)
          hour += 12;
      }
    }
    result.text = result.text + match2[0];
    result.end.assign("hour", hour);
    result.end.assign("minute", minute);
    if (meridiem >= 0) {
      result.end.assign("meridiem", meridiem);
    } else {
      const startAtPM = result.start.isCertain("meridiem") && result.start.get("meridiem") == 1;
      if (startAtPM && result.start.get("hour") > hour) {
        result.end.imply("meridiem", 0);
      } else if (hour > 12) {
        result.end.imply("meridiem", 1);
      }
    }
    if (result.end.date().getTime() < result.start.date().getTime()) {
      result.end.imply("day", result.end.get("day") + 1);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/parsers/ZHHansWeekdayParser.js
var import_dayjs39 = __toESM(require_dayjs_min(), 1);
var PATTERN38 = new RegExp("(?:\u661F\u671F|\u793C\u62DC|\u5468)(?<weekday>" + Object.keys(WEEKDAY_OFFSET2).join("|") + ")");
var ZHHansWeekdayParser = class extends AbstractParserWithWordBoundaryChecking {
  innerPattern() {
    return PATTERN38;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const dayOfWeek = match2.groups.weekday;
    const offset2 = WEEKDAY_OFFSET2[dayOfWeek];
    if (offset2 === void 0)
      return null;
    let startMoment = (0, import_dayjs39.default)(context.refDate);
    const startMomentFixed = false;
    const refOffset = startMoment.day();
    if (Math.abs(offset2 - 7 - refOffset) < Math.abs(offset2 - refOffset)) {
      startMoment = startMoment.day(offset2 - 7);
    } else if (Math.abs(offset2 + 7 - refOffset) < Math.abs(offset2 - refOffset)) {
      startMoment = startMoment.day(offset2 + 7);
    } else {
      startMoment = startMoment.day(offset2);
    }
    result.start.assign("weekday", offset2);
    if (startMomentFixed) {
      result.start.assign("day", startMoment.date());
      result.start.assign("month", startMoment.month() + 1);
      result.start.assign("year", startMoment.year());
    } else {
      result.start.imply("day", startMoment.date());
      result.start.imply("month", startMoment.month() + 1);
      result.start.imply("year", startMoment.year());
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.js
var ZHHansMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(至|到|-|~|～|－|ー)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.js
var ZHHansMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return /^\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/zh/hans/index.js
var hans = new Chrono(createCasualConfiguration7());
var casual8 = new Chrono(createCasualConfiguration7());
var strict8 = new Chrono(createConfiguration7());
function parse14(text, ref, option) {
  return casual8.parse(text, ref, option);
}
function parseDate8(text, ref, option) {
  return casual8.parseDate(text, ref, option);
}
function createCasualConfiguration7() {
  const option = createConfiguration7();
  option.parsers.unshift(new ZHHansCasualDateParser());
  return option;
}
function createConfiguration7() {
  const configuration2 = includeCommonConfiguration({
    parsers: [
      new ZHHansDateParser(),
      new ZHHansRelationWeekdayParser(),
      new ZHHansWeekdayParser(),
      new ZHHansTimeExpressionParser(),
      new ZHHansDeadlineFormatParser()
    ],
    refiners: [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()]
  });
  configuration2.refiners = configuration2.refiners.filter((refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner));
  return configuration2;
}

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var ru_exports = {};
__export(ru_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual9,
  createCasualConfiguration: () => createCasualConfiguration8,
  createConfiguration: () => createConfiguration8,
  parse: () => parse15,
  parseDate: () => parseDate9,
  strict: () => strict9
});

// node_modules/chrono-node/dist/esm/locales/ru/constants.js
var REGEX_PARTS = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY6 = {
  \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435: 0,
  \u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u044F: 0,
  \u0432\u0441\u043A: 0,
  "\u0432\u0441\u043A.": 0,
  \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A: 1,
  \u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A\u0430: 1,
  \u043F\u043D: 1,
  "\u043F\u043D.": 1,
  \u0432\u0442\u043E\u0440\u043D\u0438\u043A: 2,
  \u0432\u0442\u043E\u0440\u043D\u0438\u043A\u0430: 2,
  \u0432\u0442: 2,
  "\u0432\u0442.": 2,
  \u0441\u0440\u0435\u0434\u0430: 3,
  \u0441\u0440\u0435\u0434\u044B: 3,
  \u0441\u0440\u0435\u0434\u0443: 3,
  \u0441\u0440: 3,
  "\u0441\u0440.": 3,
  \u0447\u0435\u0442\u0432\u0435\u0440\u0433: 4,
  \u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430: 4,
  \u0447\u0442: 4,
  "\u0447\u0442.": 4,
  \u043F\u044F\u0442\u043D\u0438\u0446\u0430: 5,
  \u043F\u044F\u0442\u043D\u0438\u0446\u0443: 5,
  \u043F\u044F\u0442\u043D\u0438\u0446\u044B: 5,
  \u043F\u0442: 5,
  "\u043F\u0442.": 5,
  \u0441\u0443\u0431\u0431\u043E\u0442\u0430: 6,
  \u0441\u0443\u0431\u0431\u043E\u0442\u0443: 6,
  \u0441\u0443\u0431\u0431\u043E\u0442\u044B: 6,
  \u0441\u0431: 6,
  "\u0441\u0431.": 6
};
var FULL_MONTH_NAME_DICTIONARY2 = {
  \u044F\u043D\u0432\u0430\u0440\u044C: 1,
  \u044F\u043D\u0432\u0430\u0440\u044F: 1,
  \u044F\u043D\u0432\u0430\u0440\u0435: 1,
  \u0444\u0435\u0432\u0440\u0430\u043B\u044C: 2,
  \u0444\u0435\u0432\u0440\u0430\u043B\u044F: 2,
  \u0444\u0435\u0432\u0440\u0430\u043B\u0435: 2,
  \u043C\u0430\u0440\u0442: 3,
  \u043C\u0430\u0440\u0442\u0430: 3,
  \u043C\u0430\u0440\u0442\u0435: 3,
  \u0430\u043F\u0440\u0435\u043B\u044C: 4,
  \u0430\u043F\u0440\u0435\u043B\u044F: 4,
  \u0430\u043F\u0440\u0435\u043B\u0435: 4,
  \u043C\u0430\u0439: 5,
  \u043C\u0430\u044F: 5,
  \u043C\u0430\u0435: 5,
  \u0438\u044E\u043D\u044C: 6,
  \u0438\u044E\u043D\u044F: 6,
  \u0438\u044E\u043D\u0435: 6,
  \u0438\u044E\u043B\u044C: 7,
  \u0438\u044E\u043B\u044F: 7,
  \u0438\u044E\u043B\u0435: 7,
  \u0430\u0432\u0433\u0443\u0441\u0442: 8,
  \u0430\u0432\u0433\u0443\u0441\u0442\u0430: 8,
  \u0430\u0432\u0433\u0443\u0441\u0442\u0435: 8,
  \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044C: 9,
  \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F: 9,
  \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u0435: 9,
  \u043E\u043A\u0442\u044F\u0431\u0440\u044C: 10,
  \u043E\u043A\u0442\u044F\u0431\u0440\u044F: 10,
  \u043E\u043A\u0442\u044F\u0431\u0440\u0435: 10,
  \u043D\u043E\u044F\u0431\u0440\u044C: 11,
  \u043D\u043E\u044F\u0431\u0440\u044F: 11,
  \u043D\u043E\u044F\u0431\u0440\u0435: 11,
  \u0434\u0435\u043A\u0430\u0431\u0440\u044C: 12,
  \u0434\u0435\u043A\u0430\u0431\u0440\u044F: 12,
  \u0434\u0435\u043A\u0430\u0431\u0440\u0435: 12
};
var MONTH_DICTIONARY6 = {
  ...FULL_MONTH_NAME_DICTIONARY2,
  \u044F\u043D\u0432: 1,
  "\u044F\u043D\u0432.": 1,
  \u0444\u0435\u0432: 2,
  "\u0444\u0435\u0432.": 2,
  \u043C\u0430\u0440: 3,
  "\u043C\u0430\u0440.": 3,
  \u0430\u043F\u0440: 4,
  "\u0430\u043F\u0440.": 4,
  \u0430\u0432\u0433: 8,
  "\u0430\u0432\u0433.": 8,
  \u0441\u0435\u043D: 9,
  "\u0441\u0435\u043D.": 9,
  \u043E\u043A\u0442: 10,
  "\u043E\u043A\u0442.": 10,
  \u043D\u043E\u044F: 11,
  "\u043D\u043E\u044F.": 11,
  \u0434\u0435\u043A: 12,
  "\u0434\u0435\u043A.": 12
};
var INTEGER_WORD_DICTIONARY5 = {
  \u043E\u0434\u0438\u043D: 1,
  \u043E\u0434\u043D\u0430: 1,
  \u043E\u0434\u043D\u043E\u0439: 1,
  \u043E\u0434\u043D\u0443: 1,
  \u0434\u0432\u0435: 2,
  \u0434\u0432\u0430: 2,
  \u0434\u0432\u0443\u0445: 2,
  \u0442\u0440\u0438: 3,
  \u0442\u0440\u0435\u0445: 3,
  \u0442\u0440\u0451\u0445: 3,
  \u0447\u0435\u0442\u044B\u0440\u0435: 4,
  \u0447\u0435\u0442\u044B\u0440\u0435\u0445: 4,
  \u0447\u0435\u0442\u044B\u0440\u0451\u0445: 4,
  \u043F\u044F\u0442\u044C: 5,
  \u043F\u044F\u0442\u0438: 5,
  \u0448\u0435\u0441\u0442\u044C: 6,
  \u0448\u0435\u0441\u0442\u0438: 6,
  \u0441\u0435\u043C\u044C: 7,
  \u0441\u0435\u043C\u0438: 7,
  \u0432\u043E\u0441\u0435\u043C\u044C: 8,
  \u0432\u043E\u0441\u044C\u043C\u0438: 8,
  \u0434\u0435\u0432\u044F\u0442\u044C: 9,
  \u0434\u0435\u0432\u044F\u0442\u0438: 9,
  \u0434\u0435\u0441\u044F\u0442\u044C: 10,
  \u0434\u0435\u0441\u044F\u0442\u0438: 10,
  \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 11,
  \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 11,
  \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u044C: 12,
  \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u0438: 12
};
var ORDINAL_WORD_DICTIONARY3 = {
  \u043F\u0435\u0440\u0432\u043E\u0435: 1,
  \u043F\u0435\u0440\u0432\u043E\u0433\u043E: 1,
  \u0432\u0442\u043E\u0440\u043E\u0435: 2,
  \u0432\u0442\u043E\u0440\u043E\u0433\u043E: 2,
  \u0442\u0440\u0435\u0442\u044C\u0435: 3,
  \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E: 3,
  \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435: 4,
  \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E: 4,
  \u043F\u044F\u0442\u043E\u0435: 5,
  \u043F\u044F\u0442\u043E\u0433\u043E: 5,
  \u0448\u0435\u0441\u0442\u043E\u0435: 6,
  \u0448\u0435\u0441\u0442\u043E\u0433\u043E: 6,
  \u0441\u0435\u0434\u044C\u043C\u043E\u0435: 7,
  \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E: 7,
  \u0432\u043E\u0441\u044C\u043C\u043E\u0435: 8,
  \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E: 8,
  \u0434\u0435\u0432\u044F\u0442\u043E\u0435: 9,
  \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E: 9,
  \u0434\u0435\u0441\u044F\u0442\u043E\u0435: 10,
  \u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E: 10,
  \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 11,
  \u043E\u0434\u0438\u043D\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 11,
  \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 12,
  \u0434\u0432\u0435\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 12,
  \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 13,
  \u0442\u0440\u0438\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 13,
  \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 14,
  \u0447\u0435\u0442\u044B\u0440\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 14,
  \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 15,
  \u043F\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 15,
  \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 16,
  \u0448\u0435\u0441\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 16,
  \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 17,
  \u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 17,
  \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 18,
  \u0432\u043E\u0441\u0435\u043C\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 18,
  \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 19,
  \u0434\u0435\u0432\u044F\u0442\u043D\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 19,
  \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0435: 20,
  \u0434\u0432\u0430\u0434\u0446\u0430\u0442\u043E\u0433\u043E: 20,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 21,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 21,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0435": 22,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u0442\u043E\u0440\u043E\u0433\u043E": 22,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435": 23,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u0435\u0433\u043E": 23,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0435": 24,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0435": 25,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u043F\u044F\u0442\u043E\u0433\u043E": 25,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0435": 26,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0448\u0435\u0441\u0442\u043E\u0433\u043E": 26,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0435": 27,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0441\u0435\u0434\u044C\u043C\u043E\u0433\u043E": 27,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0435": 28,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0435": 29,
  "\u0434\u0432\u0430\u0434\u0446\u0430\u0442\u044C \u0434\u0435\u0432\u044F\u0442\u043E\u0433\u043E": 29,
  "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0435": 30,
  "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u043E\u0433\u043E": 30,
  "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0435": 31,
  "\u0442\u0440\u0438\u0434\u0446\u0430\u0442\u044C \u043F\u0435\u0440\u0432\u043E\u0433\u043E": 31
};
var TIME_UNIT_DICTIONARY5 = {
  \u0441\u0435\u043A: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u044B: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0430: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u0435\u043A: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
  \u043C\u0438\u043D: "minute",
  \u043C\u0438\u043D\u0443\u0442\u0430: "minute",
  \u043C\u0438\u043D\u0443\u0442: "minute",
  \u043C\u0438\u043D\u0443\u0442\u044B: "minute",
  \u043C\u0438\u043D\u0443\u0442\u0443: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043E\u043A: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043A\u0438: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043A\u0443: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043E\u0447\u0435\u043A: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043E\u0447\u043A\u0438: "minute",
  \u043C\u0438\u043D\u0443\u0442\u043E\u0447\u043A\u0443: "minute",
  \u0447\u0430\u0441: "hour",
  \u0447\u0430\u0441\u043E\u0432: "hour",
  \u0447\u0430\u0441\u0430: "hour",
  \u0447\u0430\u0441\u0443: "hour",
  \u0447\u0430\u0441\u0438\u043A\u043E\u0432: "hour",
  \u0447\u0430\u0441\u0438\u043A\u0430: "hour",
  \u0447\u0430\u0441\u0438\u043A\u0435: "hour",
  \u0447\u0430\u0441\u0438\u043A: "hour",
  \u0434\u0435\u043D\u044C: "d",
  \u0434\u043D\u044F: "d",
  \u0434\u043D\u0435\u0439: "d",
  \u0441\u0443\u0442\u043E\u043A: "d",
  \u0441\u0443\u0442\u043A\u0438: "d",
  \u043D\u0435\u0434\u0435\u043B\u044F: "week",
  \u043D\u0435\u0434\u0435\u043B\u0435: "week",
  \u043D\u0435\u0434\u0435\u043B\u0438: "week",
  \u043D\u0435\u0434\u0435\u043B\u044E: "week",
  \u043D\u0435\u0434\u0435\u043B\u044C: "week",
  \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0435: "week",
  \u043D\u0435\u0434\u0435\u043B\u044C\u043A\u0438: "week",
  \u043D\u0435\u0434\u0435\u043B\u0435\u043A: "week",
  \u043C\u0435\u0441\u044F\u0446: "month",
  \u043C\u0435\u0441\u044F\u0446\u0435: "month",
  \u043C\u0435\u0441\u044F\u0446\u0435\u0432: "month",
  \u043C\u0435\u0441\u044F\u0446\u0430: "month",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0435: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u043E\u0432: "quarter",
  \u0433\u043E\u0434: "year",
  \u0433\u043E\u0434\u0430: "year",
  \u0433\u043E\u0434\u0443: "year",
  \u0433\u043E\u0434\u043E\u0432: "year",
  \u043B\u0435\u0442: "year",
  \u0433\u043E\u0434\u0438\u043A: "year",
  \u0433\u043E\u0434\u0438\u043A\u0430: "year",
  \u0433\u043E\u0434\u0438\u043A\u043E\u0432: "year"
};
var NUMBER_PATTERN5 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY5)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u043E\u043B|\u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E|\u043F\u0430\u0440(?:\u044B|\u0443)|\\s{0,3})`;
function parseNumberPattern5(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY5[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY5[num];
  }
  if (num.match(/несколько/)) {
    return 3;
  } else if (num.match(/пол/)) {
    return 0.5;
  } else if (num.match(/пар/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN4 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY3)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435|\u043E\u0435)?)`;
function parseOrdinalNumberPattern4(match2) {
  const num = match2.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY3[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY3[num];
  }
  return parseInt(num);
}
var year = "(?:\\s+(?:\u0433\u043E\u0434\u0443|\u0433\u043E\u0434\u0430|\u0433\u043E\u0434|\u0433|\u0433.))?";
var YEAR_PATTERN6 = `(?:[1-9][0-9]{0,3}${year}\\s*(?:\u043D.\u044D.|\u0434\u043E \u043D.\u044D.|\u043D. \u044D.|\u0434\u043E \u043D. \u044D.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;
function parseYear6(match2) {
  if (/(год|года|г|г.)/i.test(match2)) {
    match2 = match2.replace(/(год|года|г|г.)/i, "");
  }
  if (/(до н.э.|до н. э.)/i.test(match2)) {
    match2 = match2.replace(/(до н.э.|до н. э.)/i, "");
    return -parseInt(match2);
  }
  if (/(н. э.|н.э.)/i.test(match2)) {
    match2 = match2.replace(/(н. э.|н.э.)/i, "");
    return parseInt(match2);
  }
  const rawYearNumber = parseInt(match2);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN5 = `(${NUMBER_PATTERN5})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
var SINGLE_TIME_UNIT_REGEX5 = new RegExp(SINGLE_TIME_UNIT_PATTERN5, "i");
var TIME_UNITS_PATTERN5 = repeatedTimeunitPattern(`(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN5);
function parseTimeUnits5(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  while (match2) {
    collectDateTimeFragment5(fragments, match2);
    remainingText = remainingText.substring(match2[0].length).trim();
    match2 = SINGLE_TIME_UNIT_REGEX5.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment5(fragments, match2) {
  const num = parseNumberPattern5(match2[1]);
  const unit = TIME_UNIT_DICTIONARY5[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitWithinFormatParser.js
var PATTERN39 = `(?:(?:\u043E\u043A\u043E\u043B\u043E|\u043F\u0440\u0438\u043C\u0435\u0440\u043D\u043E)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN5})${REGEX_PARTS.rightBoundary}`;
var RUTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN39, REGEX_PARTS.flags) : new RegExp(`(?:\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0435|\u0432 \u0442\u0435\u0447\u0435\u043D\u0438\u0438)\\s*${PATTERN39}`, REGEX_PARTS.flags);
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits5(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking = class extends AbstractParserWithLeftBoundaryChecking {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameLittleEndianParser.js
var DATE_GROUP9 = 1;
var DATE_TO_GROUP7 = 2;
var MONTH_NAME_GROUP11 = 3;
var YEAR_GROUP14 = 4;
var RUMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:\u0441)?\\s*(${ORDINAL_NUMBER_PATTERN4})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN4}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY6)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN6}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY6[match2[MONTH_NAME_GROUP11].toLowerCase()];
    const day = parseOrdinalNumberPattern4(match2[DATE_GROUP9]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP9].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP14]) {
      const yearNumber = parseYear6(match2[YEAR_GROUP14]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.refDate, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP7]) {
      const endDate = parseOrdinalNumberPattern4(match2[DATE_TO_GROUP7]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUMonthNameParser.js
var MONTH_NAME_GROUP12 = 2;
var YEAR_GROUP15 = 3;
var RUMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `((?:\u0432)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY6)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN6})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match2) {
    const monthName = match2[MONTH_NAME_GROUP12].toLowerCase();
    if (match2[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY2[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match2.index, match2.index + match2[0].length);
    result.start.imply("day", 1);
    const month2 = MONTH_DICTIONARY6[monthName];
    result.start.assign("month", month2);
    if (match2[YEAR_GROUP15]) {
      const year3 = parseYear6(match2[YEAR_GROUP15]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.refDate, 1, month2);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeExpressionParser.js
var RUTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0438|\u043F\u043E|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:\u0432|\u0441)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:\u0443\u0442\u0440\u0430|\u0432\u0435\u0447\u0435\u0440\u0430|\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F))?(?!\\/)${REGEX_PARTS.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match2) {
    const components = super.extractPrimaryTimeComponents(context, match2);
    if (components) {
      if (match2[0].endsWith("\u0432\u0435\u0447\u0435\u0440\u0430")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match2[0].endsWith("\u043F\u043E\u0441\u043B\u0435 \u043F\u043E\u043B\u0443\u0434\u043D\u044F")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match2[0].endsWith("\u0443\u0442\u0440\u0430")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitAgoFormatParser.js
var RUTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN5})\\s{0,5}\u043D\u0430\u0437\u0430\u0434(?=(?:\\W|$))`;
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits5(match2[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateRangeRefiner.js
var RUMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(и до|и по|до|по|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/refiners/RUMergeDateTimeRefiner.js
var RUMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|\u0432|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualDateParser.js
var RUCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:\u0441|\u0441\u043E)?\\s*(\u0441\u0435\u0433\u043E\u0434\u043D\u044F|\u0432\u0447\u0435\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0441\u043B\u0435\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430)`;
  }
  innerExtract(context, match2) {
    const lowerText = match2[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "\u0441\u0435\u0433\u043E\u0434\u043D\u044F":
        return today(context.reference);
      case "\u0432\u0447\u0435\u0440\u0430":
        return yesterday(context.reference);
      case "\u0437\u0430\u0432\u0442\u0440\u0430":
        return tomorrow(context.reference);
      case "\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
        return theDayAfter(context.reference, 2);
      case "\u043F\u043E\u0441\u043B\u0435\u043F\u043E\u0441\u043B\u0435\u0437\u0430\u0432\u0442\u0440\u0430":
        return theDayAfter(context.reference, 3);
      case "\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
        return theDayBefore(context.reference, 2);
      case "\u043F\u043E\u0437\u0430\u043F\u043E\u0437\u0430\u0432\u0447\u0435\u0440\u0430":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUCasualTimeParser.js
var import_dayjs41 = __toESM(require_dayjs_min(), 1);
var RUCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(\u0441\u0435\u0439\u0447\u0430\u0441|\u043F\u0440\u043E\u0448\u043B\u044B\u043C\\s*\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u043F\u0440\u043E\u0448\u043B\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u0441\u0435\u0433\u043E\u0434\u043D\u044F\\s*\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u043E\u0439\\s*\u043D\u043E\u0447\u044C\u044E|\u043D\u043E\u0447\u044C\u044E|\u044D\u0442\u0438\u043C \u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u043E\u043C|\u0443\u0442\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u0434\u0435\u043D\u044C|\u0432\u0435\u0447\u0435\u0440\u043E\u043C|\u0432\u0435\u0447\u0435\u0440\u0430|\u0432\\s*\u043F\u043E\u043B\u043D\u043E\u0447\u044C)`;
  }
  innerExtract(context, match2) {
    let targetDate = (0, import_dayjs41.default)(context.refDate);
    const lowerText = match2[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "\u0441\u0435\u0439\u0447\u0430\u0441") {
      return now(context.reference);
    }
    if (lowerText === "\u0432\u0435\u0447\u0435\u0440\u043E\u043C" || lowerText === "\u0432\u0435\u0447\u0435\u0440\u0430") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("\u0443\u0442\u0440\u043E\u043C") || lowerText.endsWith("\u0443\u0442\u0440\u0430")) {
      return morning(context.reference);
    }
    if (lowerText.match(/в\s*полдень/)) {
      return noon(context.reference);
    }
    if (lowerText.match(/прошлой\s*ночью/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/прошлым\s*вечером/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/следующей\s*ночью/)) {
      const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
      targetDate = targetDate.add(daysToAdd, "day");
      assignSimilarDate(component, targetDate);
      component.imply("hour", 0);
    }
    if (lowerText.match(/в\s*полночь/) || lowerText.endsWith("\u043D\u043E\u0447\u044C\u044E")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUWeekdayParser.js
var PREFIX_GROUP6 = 1;
var WEEKDAY_GROUP6 = 2;
var POSTFIX_GROUP5 = 3;
var RUWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:(\u044D\u0442\u0443|\u044D\u0442\u043E\u0442|\u043F\u0440\u043E\u0448\u043B\u044B\u0439|\u043F\u0440\u043E\u0448\u043B\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY6)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*\u043D\u0430\\s*(\u044D\u0442\u043E\u0439|\u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439)\\s*\u043D\u0435\u0434\u0435\u043B\u0435)?`;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP6].toLowerCase();
    const weekday = WEEKDAY_DICTIONARY6[dayOfWeek];
    const prefix5 = match2[PREFIX_GROUP6];
    const postfix = match2[POSTFIX_GROUP5];
    let modifierWord = prefix5 || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLowerCase();
    let modifier = null;
    if (modifierWord == "\u043F\u0440\u043E\u0448\u043B\u044B\u0439" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u0443\u044E" || modifierWord == "\u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
      modifier = "last";
    } else if (modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0443\u044E" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifierWord == "\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0433\u043E") {
      modifier = "next";
    } else if (modifierWord == "\u044D\u0442\u043E\u0442" || modifierWord == "\u044D\u0442\u0443" || modifierWord == "\u044D\u0442\u043E\u0439") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RURelativeDateFormatParser.js
var import_dayjs42 = __toESM(require_dayjs_min(), 1);
var MODIFIER_WORD_GROUP3 = 1;
var RELATIVE_WORD_GROUP3 = 2;
var RURelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439|\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439|\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C|\u043D\u0430 \u044D\u0442\u043E\u0439|\u0432 \u044D\u0442\u043E\u043C)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY5)})`;
  }
  innerExtract(context, match2) {
    const modifier = match2[MODIFIER_WORD_GROUP3].toLowerCase();
    const unitWord = match2[RELATIVE_WORD_GROUP3].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY5[unitWord];
    if (modifier == "\u043D\u0430 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439" || modifier == "\u0432 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u043C") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "\u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C" || modifier == "\u043D\u0430 \u043F\u0440\u043E\u0448\u043B\u043E\u0439") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs42.default)(context.reference.instant);
    if (timeunit.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (timeunit.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (timeunit.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.js
var RUTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking {
  innerPatternString(context) {
    return `(\u044D\u0442\u0438|\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435|\u043F\u0440\u043E\u0448\u043B\u044B\u0435|\u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0435|\u043F\u043E\u0441\u043B\u0435|\u0441\u043F\u0443\u0441\u0442\u044F|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${TIME_UNITS_PATTERN5})`;
  }
  innerExtract(context, match2) {
    const prefix5 = match2[1].toLowerCase();
    let timeUnits = parseTimeUnits5(match2[2]);
    switch (prefix5) {
      case "\u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\u0435":
      case "\u043F\u0440\u043E\u0448\u043B\u044B\u0435":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/ru/index.js
var casual9 = new Chrono(createCasualConfiguration8());
var strict9 = new Chrono(createConfiguration8(true));
function parse15(text, ref, option) {
  return casual9.parse(text, ref, option);
}
function parseDate9(text, ref, option) {
  return casual9.parseDate(text, ref, option);
}
function createCasualConfiguration8() {
  const option = createConfiguration8(false);
  option.parsers.unshift(new RUCasualDateParser());
  option.parsers.unshift(new RUCasualTimeParser());
  option.parsers.unshift(new RUMonthNameParser());
  option.parsers.unshift(new RURelativeDateFormatParser());
  option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration8(strictMode = true) {
  return includeCommonConfiguration({
    parsers: [
      new SlashDateFormatParser(true),
      new RUTimeUnitWithinFormatParser(),
      new RUMonthNameLittleEndianParser(),
      new RUWeekdayParser(),
      new RUTimeExpressionParser(strictMode),
      new RUTimeUnitAgoFormatParser()
    ],
    refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()]
  }, strictMode);
}

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var uk_exports = {};
__export(uk_exports, {
  Chrono: () => Chrono,
  Meridiem: () => Meridiem,
  ParsingComponents: () => ParsingComponents,
  ParsingResult: () => ParsingResult,
  ReferenceWithTimezone: () => ReferenceWithTimezone,
  Weekday: () => Weekday,
  casual: () => casual10,
  createCasualConfiguration: () => createCasualConfiguration9,
  createConfiguration: () => createConfiguration9,
  parse: () => parse16,
  parseDate: () => parseDate10,
  strict: () => strict10
});

// node_modules/chrono-node/dist/esm/locales/uk/constants.js
var REGEX_PARTS2 = {
  leftBoundary: "([^\\p{L}\\p{N}_]|^)",
  rightBoundary: "(?=[^\\p{L}\\p{N}_]|$)",
  flags: "iu"
};
var WEEKDAY_DICTIONARY7 = {
  "\u043D\u0435\u0434\u0456\u043B\u044F": 0,
  "\u043D\u0435\u0434\u0456\u043B\u0456": 0,
  "\u043D\u0435\u0434\u0456\u043B\u044E": 0,
  "\u043D\u0434": 0,
  "\u043D\u0434.": 0,
  "\u043F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A": 1,
  "\u043F\u043E\u043D\u0435\u0434\u0456\u043B\u043A\u0430": 1,
  "\u043F\u043D": 1,
  "\u043F\u043D.": 1,
  "\u0432\u0456\u0432\u0442\u043E\u0440\u043E\u043A": 2,
  "\u0432\u0456\u0432\u0442\u043E\u0440\u043A\u0430": 2,
  "\u0432\u0442": 2,
  "\u0432\u0442.": 2,
  "\u0441\u0435\u0440\u0435\u0434\u0430": 3,
  "\u0441\u0435\u0440\u0435\u0434\u0438": 3,
  "\u0441\u0435\u0440\u0435\u0434\u0443": 3,
  "\u0441\u0440": 3,
  "\u0441\u0440.": 3,
  "\u0447\u0435\u0442\u0432\u0435\u0440": 4,
  "\u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430": 4,
  "\u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0443": 4,
  "\u0447\u0442": 4,
  "\u0447\u0442.": 4,
  "\u043F'\u044F\u0442\u043D\u0438\u0446\u044F": 5,
  "\u043F'\u044F\u0442\u043D\u0438\u0446\u0456": 5,
  "\u043F'\u044F\u0442\u043D\u0438\u0446\u044E": 5,
  "\u043F\u0442": 5,
  "\u043F\u0442.": 5,
  "\u0441\u0443\u0431\u043E\u0442\u0430": 6,
  "\u0441\u0443\u0431\u043E\u0442\u0438": 6,
  "\u0441\u0443\u0431\u043E\u0442\u0443": 6,
  "\u0441\u0431": 6,
  "\u0441\u0431.": 6
};
var FULL_MONTH_NAME_DICTIONARY3 = {
  "\u0441\u0456\u0447\u0435\u043D\u044C": 1,
  "\u0441\u0456\u0447\u043D\u044F": 1,
  "\u0441\u0456\u0447\u043D\u0456": 1,
  "\u043B\u044E\u0442\u0438\u0439": 2,
  "\u043B\u044E\u0442\u043E\u0433\u043E": 2,
  "\u043B\u044E\u0442\u043E\u043C\u0443": 2,
  "\u0431\u0435\u0440\u0435\u0437\u0435\u043D\u044C": 3,
  "\u0431\u0435\u0440\u0435\u0437\u043D\u044F": 3,
  "\u0431\u0435\u0440\u0435\u0437\u043D\u0456": 3,
  "\u043A\u0432\u0456\u0442\u0435\u043D\u044C": 4,
  "\u043A\u0432\u0456\u0442\u043D\u044F": 4,
  "\u043A\u0432\u0456\u0442\u043D\u0456": 4,
  "\u0442\u0440\u0430\u0432\u0435\u043D\u044C": 5,
  "\u0442\u0440\u0430\u0432\u043D\u044F": 5,
  "\u0442\u0440\u0430\u0432\u043D\u0456": 5,
  "\u0447\u0435\u0440\u0432\u0435\u043D\u044C": 6,
  "\u0447\u0435\u0440\u0432\u043D\u044F": 6,
  "\u0447\u0435\u0440\u0432\u043D\u0456": 6,
  "\u043B\u0438\u043F\u0435\u043D\u044C": 7,
  "\u043B\u0438\u043F\u043D\u044F": 7,
  "\u043B\u0438\u043F\u043D\u0456": 7,
  "\u0441\u0435\u0440\u043F\u0435\u043D\u044C": 8,
  "\u0441\u0435\u0440\u043F\u043D\u044F": 8,
  "\u0441\u0435\u0440\u043F\u043D\u0456": 8,
  "\u0432\u0435\u0440\u0435\u0441\u0435\u043D\u044C": 9,
  "\u0432\u0435\u0440\u0435\u0441\u043D\u044F": 9,
  "\u0432\u0435\u0440\u0435\u0441\u043D\u0456": 9,
  "\u0436\u043E\u0432\u0442\u0435\u043D\u044C": 10,
  "\u0436\u043E\u0432\u0442\u043D\u044F": 10,
  "\u0436\u043E\u0432\u0442\u043D\u0456": 10,
  "\u043B\u0438\u0441\u0442\u043E\u043F\u0430\u0434": 11,
  "\u043B\u0438\u0441\u0442\u043E\u043F\u0430\u0434\u0430": 11,
  "\u043B\u0438\u0441\u0442\u043E\u043F\u0430\u0434\u0443": 11,
  "\u0433\u0440\u0443\u0434\u0435\u043D\u044C": 12,
  "\u0433\u0440\u0443\u0434\u043D\u044F": 12,
  "\u0433\u0440\u0443\u0434\u043D\u0456": 12
};
var MONTH_DICTIONARY7 = {
  ...FULL_MONTH_NAME_DICTIONARY3,
  "\u0441\u0456\u0447": 1,
  "\u0441\u0456\u0447.": 1,
  "\u043B\u044E\u0442": 2,
  "\u043B\u044E\u0442.": 2,
  "\u0431\u0435\u0440": 3,
  "\u0431\u0435\u0440.": 3,
  "\u043A\u0432\u0456\u0442": 4,
  "\u043A\u0432\u0456\u0442.": 4,
  "\u0442\u0440\u0430\u0432": 5,
  "\u0442\u0440\u0430\u0432.": 5,
  "\u0447\u0435\u0440\u0432": 6,
  "\u0447\u0435\u0440\u0432.": 6,
  "\u043B\u0438\u043F": 7,
  "\u043B\u0438\u043F.": 7,
  "\u0441\u0435\u0440\u043F": 8,
  "\u0441\u0435\u0440\u043F.": 8,
  "\u0441\u0435\u0440": 8,
  "c\u0435\u0440.": 8,
  "\u0432\u0435\u0440": 9,
  "\u0432\u0435\u0440.": 9,
  "\u0432\u0435\u0440\u0435\u0441": 9,
  "\u0432\u0435\u0440\u0435\u0441.": 9,
  "\u0436\u043E\u0432\u0442": 10,
  "\u0436\u043E\u0432\u0442.": 10,
  "\u043B\u0438\u0441\u0442\u043E\u043F": 11,
  "\u043B\u0438\u0441\u0442\u043E\u043F.": 11,
  "\u0433\u0440\u0443\u0434": 12,
  "\u0433\u0440\u0443\u0434.": 12
};
var INTEGER_WORD_DICTIONARY6 = {
  "\u043E\u0434\u0438\u043D": 1,
  "\u043E\u0434\u043D\u0430": 1,
  "\u043E\u0434\u043D\u043E\u0457": 1,
  "\u043E\u0434\u043D\u0443": 1,
  "\u0434\u0432\u0456": 2,
  "\u0434\u0432\u0430": 2,
  "\u0434\u0432\u043E\u0445": 2,
  "\u0442\u0440\u0438": 3,
  "\u0442\u0440\u044C\u043E\u0445": 3,
  "\u0447\u043E\u0442\u0438\u0440\u0438": 4,
  "\u0447\u043E\u0442\u0438\u0440\u044C\u043E\u0445": 4,
  "\u043F'\u044F\u0442\u044C": 5,
  "\u043F'\u044F\u0442\u0438": 5,
  "\u0448\u0456\u0441\u0442\u044C": 6,
  "\u0448\u0435\u0441\u0442\u0438": 6,
  "\u0441\u0456\u043C": 7,
  "\u0441\u0435\u043C\u0438": 7,
  "\u0432\u0456\u0441\u0456\u043C": 8,
  "\u0432\u043E\u0441\u044C\u043C\u0438": 8,
  "\u0434\u0435\u0432'\u044F\u0442\u044C": 9,
  "\u0434\u0435\u0432'\u044F\u0442\u0438": 9,
  "\u0434\u0435\u0441\u044F\u0442\u044C": 10,
  "\u0434\u0435\u0441\u044F\u0442\u0438": 10,
  "\u043E\u0434\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u044C": 11,
  "\u043E\u0434\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u0438": 11,
  "\u0434\u0432\u0430\u043D\u0430\u0434\u0446\u044F\u0442\u044C": 12,
  "\u0434\u0432\u0430\u043D\u0430\u0434\u0446\u044F\u0442\u0438": 12
};
var ORDINAL_WORD_DICTIONARY4 = {
  "\u043F\u0435\u0440\u0448\u0435": 1,
  "\u043F\u0435\u0440\u0448\u043E\u0433\u043E": 1,
  "\u0434\u0440\u0443\u0433\u0435": 2,
  "\u0434\u0440\u0443\u0433\u043E\u0433\u043E": 2,
  "\u0442\u0440\u0435\u0442\u0454": 3,
  "\u0442\u0440\u0435\u0442\u044C\u043E\u0433\u043E": 3,
  "\u0447\u0435\u0442\u0432\u0435\u0440\u0442\u0435": 4,
  "\u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 4,
  "\u043F'\u044F\u0442\u0435": 5,
  "\u043F'\u044F\u0442\u043E\u0433\u043E": 5,
  "\u0448\u043E\u0441\u0442\u0435": 6,
  "\u0448\u043E\u0441\u0442\u043E\u0433\u043E": 6,
  "\u0441\u044C\u043E\u043C\u0435": 7,
  "\u0441\u044C\u043E\u043C\u043E\u0433\u043E": 7,
  "\u0432\u043E\u0441\u044C\u043C\u0435": 8,
  "\u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 8,
  "\u0434\u0435\u0432'\u044F\u0442\u0435": 9,
  "\u0434\u0435\u0432'\u044F\u0442\u043E\u0433\u043E": 9,
  "\u0434\u0435\u0441\u044F\u0442\u0435": 10,
  "\u0434\u0435\u0441\u044F\u0442\u043E\u0433\u043E": 10,
  "\u043E\u0434\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 11,
  "\u043E\u0434\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 11,
  "\u0434\u0432\u0430\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 12,
  "\u0434\u0432\u0430\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 12,
  "\u0442\u0440\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 13,
  "\u0442\u0440\u0438\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 13,
  "\u0447\u043E\u0442\u0438\u0440\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 14,
  "\u0447\u043E\u0442\u0438\u043D\u0440\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 14,
  "\u043F'\u044F\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 15,
  "\u043F'\u044F\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 15,
  "\u0448\u0456\u0441\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 16,
  "\u0448\u0456\u0441\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 16,
  "\u0441\u0456\u043C\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 17,
  "\u0441\u0456\u043C\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 17,
  "\u0432\u0456\u0441\u0456\u043C\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 18,
  "\u0432\u0456\u0441\u0456\u043C\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 18,
  "\u0434\u0435\u0432'\u044F\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u0435": 19,
  "\u0434\u0435\u0432'\u044F\u0442\u043D\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 19,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u0435": 20,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 20,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u043F\u0435\u0440\u0448\u0435": 21,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u043F\u0435\u0440\u0448\u043E\u0433\u043E": 21,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0434\u0440\u0443\u0433\u0435": 22,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0434\u0440\u0443\u0433\u043E\u0433\u043E": 22,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0442\u0440\u0435\u0442\u0454": 23,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0442\u0440\u0435\u0442\u044C\u043E\u0433\u043E": 23,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u0435": 24,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0447\u0435\u0442\u0432\u0435\u0440\u0442\u043E\u0433\u043E": 24,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u043F'\u044F\u0442\u0435": 25,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u043F'\u044F\u0442\u043E\u0433\u043E": 25,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0448\u043E\u0441\u0442\u0435": 26,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0448\u043E\u0441\u0442\u043E\u0433\u043E": 26,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0441\u044C\u043E\u043C\u0435": 27,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0441\u044C\u043E\u043C\u043E\u0433\u043E": 27,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u0435": 28,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0432\u043E\u0441\u044C\u043C\u043E\u0433\u043E": 28,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0434\u0435\u0432'\u044F\u0442\u0435": 29,
  "\u0434\u0432\u0430\u0434\u0446\u044F\u0442\u044C \u0434\u0435\u0432'\u044F\u0442\u043E\u0433\u043E": 29,
  "\u0442\u0440\u0438\u0434\u0446\u044F\u0442\u0435": 30,
  "\u0442\u0440\u0438\u0434\u0446\u044F\u0442\u043E\u0433\u043E": 30,
  "\u0442\u0440\u0438\u0434\u0446\u044F\u0442\u044C \u043F\u0435\u0440\u0448\u0435": 31,
  "\u0442\u0440\u0438\u0434\u0446\u044F\u0442\u044C \u043F\u0435\u0440\u0448\u043E\u0433\u043E": 31
};
var TIME_UNIT_DICTIONARY6 = {
  \u0441\u0435\u043A: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u0430: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u0438: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u0443: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043E\u043A: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0438: "second",
  \u0441\u0435\u043A\u0443\u043D\u0434\u043E\u0447\u043A\u0443: "second",
  \u0445\u0432: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u0430: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u0438: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u0443: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043E\u043A: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043A\u0438: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043A\u0443: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043E\u0447\u043E\u043A: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043E\u0447\u043A\u0438: "minute",
  \u0445\u0432\u0438\u043B\u0438\u043D\u043E\u0447\u043A\u0443: "minute",
  \u0433\u043E\u0434: "hour",
  \u0433\u043E\u0434\u0438\u043D\u0430: "hour",
  \u0433\u043E\u0434\u0438\u043D: "hour",
  \u0433\u043E\u0434\u0438\u043D\u0438: "hour",
  \u0433\u043E\u0434\u0438\u043D\u0443: "hour",
  \u0433\u043E\u0434\u0438\u043D\u043A\u0430: "hour",
  \u0433\u043E\u0434\u0438\u043D\u043E\u043A: "hour",
  \u0433\u043E\u0434\u0438\u043D\u043A\u0438: "hour",
  \u0433\u043E\u0434\u0438\u043D\u043A\u0443: "hour",
  \u0434\u0435\u043D\u044C: "d",
  \u0434\u043D\u044F: "d",
  \u0434\u043D\u0456\u0432: "d",
  \u0434\u043D\u0456: "d",
  \u0434\u043E\u0431\u0430: "d",
  \u0434\u043E\u0431\u0443: "d",
  \u0442\u0438\u0436\u0434\u0435\u043D\u044C: "week",
  \u0442\u0438\u0436\u043D\u044E: "week",
  \u0442\u0438\u0436\u043D\u044F: "week",
  \u0442\u0438\u0436\u043D\u0456: "week",
  \u0442\u0438\u0436\u043D\u0456\u0432: "week",
  \u043C\u0456\u0441\u044F\u0446\u044C: "month",
  \u043C\u0456\u0441\u044F\u0446\u0456\u0432: "month",
  \u043C\u0456\u0441\u044F\u0446\u0456: "month",
  \u043C\u0456\u0441\u044F\u0446\u044F: "month",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0443: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0430: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0456\u0432: "quarter",
  \u043A\u0432\u0430\u0440\u0442\u0430\u043B\u0456: "quarter",
  \u0440\u0456\u043A: "year",
  \u0440\u043E\u043A\u0443: "year",
  \u0440\u043E\u0446\u0456: "year",
  \u0440\u043E\u043A\u0456\u0432: "year",
  \u0440\u043E\u043A\u0438: "year"
};
var NUMBER_PATTERN6 = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY6)}|[0-9]+|[0-9]+\\.[0-9]+|\u043F\u0456\u0432|\u0434\u0435\u043A\u0456\u043B\u044C\u043A\u0430|\u043F\u0430\u0440(?:\u0443)|\\s{0,3})`;
function parseNumberPattern6(match2) {
  const num = match2.toLowerCase();
  if (INTEGER_WORD_DICTIONARY6[num] !== void 0) {
    return INTEGER_WORD_DICTIONARY6[num];
  }
  if (num.match(/декілька/)) {
    return 2;
  } else if (num.match(/пів/)) {
    return 0.5;
  } else if (num.match(/пар/)) {
    return 2;
  } else if (num === "") {
    return 1;
  }
  return parseFloat(num);
}
var ORDINAL_NUMBER_PATTERN5 = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY4)}|[0-9]{1,2}(?:\u0433\u043E|\u043E\u0433\u043E|\u0435)?)`;
function parseOrdinalNumberPattern5(match2) {
  const num = match2.toLowerCase();
  if (ORDINAL_WORD_DICTIONARY4[num] !== void 0) {
    return ORDINAL_WORD_DICTIONARY4[num];
  }
  return parseInt(num);
}
var year2 = "(?:\\s+(?:\u0440\u043E\u043A\u0443|\u0440\u0456\u043A|\u0440|\u0440.))?";
var YEAR_PATTERN7 = `(?:[1-9][0-9]{0,3}${year2}\\s*(?:\u043D.\u0435.|\u0434\u043E \u043D.\u0435.|\u043D. \u0435.|\u0434\u043E \u043D. \u0435.)|[1-2][0-9]{3}${year2}|[5-9][0-9]${year2})`;
function parseYearPattern(match2) {
  if (/(рік|року|р|р.)/i.test(match2)) {
    match2 = match2.replace(/(рік|року|р|р.)/i, "");
  }
  if (/(до н.е.|до н. е.)/i.test(match2)) {
    match2 = match2.replace(/(до н.е.|до н. е.)/i, "");
    return -parseInt(match2);
  }
  if (/(н. е.|н.е.)/i.test(match2)) {
    match2 = match2.replace(/(н. е.|н.е.)/i, "");
    return parseInt(match2);
  }
  const rawYearNumber = parseInt(match2);
  return findMostLikelyADYear(rawYearNumber);
}
var SINGLE_TIME_UNIT_PATTERN6 = `(${NUMBER_PATTERN6})\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY6)})`;
var SINGLE_TIME_UNIT_REGEX6 = new RegExp(SINGLE_TIME_UNIT_PATTERN6, "i");
var TIME_UNITS_PATTERN6 = repeatedTimeunitPattern(`(?:(?:\u0431\u043B\u0438\u0437\u044C\u043A\u043E|\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u043D\u043E)\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN6);
function parseTimeUnits6(timeunitText) {
  const fragments = {};
  let remainingText = timeunitText;
  let match2 = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  while (match2) {
    collectDateTimeFragment6(fragments, match2);
    remainingText = remainingText.substring(match2[0].length).trim();
    match2 = SINGLE_TIME_UNIT_REGEX6.exec(remainingText);
  }
  return fragments;
}
function collectDateTimeFragment6(fragments, match2) {
  const num = parseNumberPattern6(match2[1]);
  const unit = TIME_UNIT_DICTIONARY6[match2[2].toLowerCase()];
  fragments[unit] = num;
}

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitWithinFormatParser.js
var PATTERN40 = `(?:(?:\u043F\u0440\u0438\u0431\u043B\u0438\u0437\u043D\u043E|\u043E\u0440\u0456\u0454\u043D\u0442\u043E\u0432\u043D\u043E)\\s*(?:~\\s*)?)?(${TIME_UNITS_PATTERN6})${REGEX_PARTS2.rightBoundary}`;
var UKTimeUnitWithinFormatParser = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return context.option.forwardDate ? new RegExp(PATTERN40, "i") : new RegExp(`(?:\u043F\u0440\u043E\u0442\u044F\u0433\u043E\u043C|\u043D\u0430 \u043F\u0440\u043E\u0442\u044F\u0437\u0456|\u043F\u0440\u043E\u0442\u044F\u0433\u043E\u043C|\u0443\u043F\u0440\u043E\u0434\u043E\u0432\u0436|\u0432\u043F\u0440\u043E\u0434\u043E\u0432\u0436)\\s*${PATTERN40}`, REGEX_PARTS2.flags);
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits6(match2[1]);
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/AbstractParserWithWordBoundaryChecking.js
var AbstractParserWithLeftBoundaryChecking2 = class extends AbstractParserWithWordBoundaryChecking {
  patternLeftBoundary() {
    return REGEX_PARTS2.leftBoundary;
  }
  innerPattern(context) {
    return new RegExp(this.innerPatternString(context), REGEX_PARTS2.flags);
  }
  innerPatternHasChange(context, currentInnerPattern) {
    return false;
  }
};
var AbstractParserWithLeftRightBoundaryChecking2 = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPattern(context) {
    return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS2.rightBoundary}`, REGEX_PARTS2.flags);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameLittleEndianParser.js
var DATE_GROUP10 = 1;
var DATE_TO_GROUP8 = 2;
var MONTH_NAME_GROUP13 = 3;
var YEAR_GROUP16 = 4;
var UKMonthNameLittleEndianParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:\u0437|\u0456\u0437)?\\s*(${ORDINAL_NUMBER_PATTERN5})(?:\\s{0,3}(?:\u043F\u043E|-|\u2013|\u0434\u043E)?\\s{0,3}(${ORDINAL_NUMBER_PATTERN5}))?(?:-|\\/|\\s{0,3}(?:of)?\\s{0,3})(${matchAnyPattern(MONTH_DICTIONARY7)})(?:(?:-|\\/|,?\\s{0,3})(${YEAR_PATTERN7}(?![^\\s]\\d)))?`;
  }
  innerExtract(context, match2) {
    const result = context.createParsingResult(match2.index, match2[0]);
    const month2 = MONTH_DICTIONARY7[match2[MONTH_NAME_GROUP13].toLowerCase()];
    const day = parseOrdinalNumberPattern5(match2[DATE_GROUP10]);
    if (day > 31) {
      match2.index = match2.index + match2[DATE_GROUP10].length;
      return null;
    }
    result.start.assign("month", month2);
    result.start.assign("day", day);
    if (match2[YEAR_GROUP16]) {
      const yearNumber = parseYearPattern(match2[YEAR_GROUP16]);
      result.start.assign("year", yearNumber);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, day, month2);
      result.start.imply("year", year3);
    }
    if (match2[DATE_TO_GROUP8]) {
      const endDate = parseOrdinalNumberPattern5(match2[DATE_TO_GROUP8]);
      result.end = result.start.clone();
      result.end.assign("day", endDate);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKMonthNameParser.js
var MONTH_NAME_GROUP14 = 2;
var YEAR_GROUP17 = 3;
var UkMonthNameParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `((?:\u0432|\u0443)\\s*)?(${matchAnyPattern(MONTH_DICTIONARY7)})\\s*(?:[,-]?\\s*(${YEAR_PATTERN7})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`;
  }
  innerExtract(context, match2) {
    const monthName = match2[MONTH_NAME_GROUP14].toLowerCase();
    if (match2[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY3[monthName]) {
      return null;
    }
    const result = context.createParsingResult(match2.index, match2.index + match2[0].length);
    result.start.imply("day", 1);
    const month2 = MONTH_DICTIONARY7[monthName];
    result.start.assign("month", month2);
    if (match2[YEAR_GROUP17]) {
      const year3 = parseYearPattern(match2[YEAR_GROUP17]);
      result.start.assign("year", year3);
    } else {
      const year3 = findYearClosestToRef(context.reference.instant, 1, month2);
      result.start.imply("year", year3);
    }
    return result;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeExpressionParser.js
var UKTimeExpressionParser = class extends AbstractTimeExpressionParser {
  constructor(strictMode) {
    super(strictMode);
  }
  patternFlags() {
    return REGEX_PARTS2.flags;
  }
  primaryPatternLeftBoundary() {
    return `(^|\\s|T|(?:[^\\p{L}\\p{N}_]))`;
  }
  followingPhase() {
    return `\\s*(?:\\-|\\\u2013|\\~|\\\u301C|\u0434\u043E|\u0456|\u043F\u043E|\\?)\\s*`;
  }
  primaryPrefix() {
    return `(?:(?:\u0432|\u0443|\u043E|\u043E\u0431|\u0437|\u0456\u0437|\u0432\u0456\u0434)\\s*)??`;
  }
  primarySuffix() {
    return `(?:\\s*(?:\u0440\u0430\u043D\u043A\u0443|\u0432\u0435\u0447\u043E\u0440\u0430|\u043F\u043E \u043E\u0431\u0456\u0434\u0456|\u043F\u0456\u0441\u043B\u044F \u043E\u0431\u0456\u0434\u0443))?(?!\\/)${REGEX_PARTS2.rightBoundary}`;
  }
  extractPrimaryTimeComponents(context, match2) {
    const components = super.extractPrimaryTimeComponents(context, match2);
    if (components) {
      if (match2[0].endsWith("\u0432\u0435\u0447\u043E\u0440\u0430")) {
        const hour = components.get("hour");
        if (hour >= 6 && hour < 12) {
          components.assign("hour", components.get("hour") + 12);
          components.assign("meridiem", Meridiem.PM);
        } else if (hour < 6) {
          components.assign("meridiem", Meridiem.AM);
        }
      }
      if (match2[0].endsWith("\u043F\u043E \u043E\u0431\u0456\u0434\u0456") || match2[0].endsWith("\u043F\u0456\u0441\u043B\u044F \u043E\u0431\u0456\u0434\u0443")) {
        components.assign("meridiem", Meridiem.PM);
        const hour = components.get("hour");
        if (hour >= 0 && hour <= 6) {
          components.assign("hour", components.get("hour") + 12);
        }
      }
      if (match2[0].endsWith("\u0440\u0430\u043D\u043A\u0443")) {
        components.assign("meridiem", Meridiem.AM);
        const hour = components.get("hour");
        if (hour < 12) {
          components.assign("hour", components.get("hour"));
        }
      }
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitAgoFormatParser.js
var UKTimeUnitAgoFormatParser = class extends AbstractParserWithLeftBoundaryChecking2 {
  innerPatternString(context) {
    return `(${TIME_UNITS_PATTERN6})\\s{0,5}\u0442\u043E\u043C\u0443(?=(?:\\W|$))`;
  }
  innerExtract(context, match2) {
    const timeUnits = parseTimeUnits6(match2[1]);
    const outputTimeUnits = reverseTimeUnits(timeUnits);
    return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateRangeRefiner.js
var UKMergeDateRangeRefiner = class extends AbstractMergeDateRangeRefiner {
  patternBetween() {
    return /^\s*(і до|і по|до|по|-)\s*$/i;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/refiners/UKMergeDateTimeRefiner.js
var UKMergeDateTimeRefiner = class extends AbstractMergeDateTimeRefiner {
  patternBetween() {
    return new RegExp(`^\\s*(T|\u0432|\u0443|\u043E|,|-)?\\s*$`);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualDateParser.js
var UKCasualDateParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:\u0437|\u0456\u0437|\u0432\u0456\u0434)?\\s*(\u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456|\u0432\u0447\u043E\u0440\u0430|\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u0456\u0441\u043B\u044F\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u0456\u0441\u043B\u044F\u043F\u0456\u0441\u043B\u044F\u0437\u0430\u0432\u0442\u0440\u0430|\u043F\u043E\u0437\u0430\u043F\u043E\u0437\u0430\u0432\u0447\u043E\u0440\u0430|\u043F\u043E\u0437\u0430\u0432\u0447\u043E\u0440\u0430)`;
  }
  innerExtract(context, match2) {
    const lowerText = match2[1].toLowerCase();
    const component = context.createParsingComponents();
    switch (lowerText) {
      case "\u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456":
        return today(context.reference);
      case "\u0432\u0447\u043E\u0440\u0430":
        return yesterday(context.reference);
      case "\u0437\u0430\u0432\u0442\u0440\u0430":
        return tomorrow(context.reference);
      case "\u043F\u0456\u0441\u043B\u044F\u0437\u0430\u0432\u0442\u0440\u0430":
        return theDayAfter(context.reference, 2);
      case "\u043F\u0456\u0441\u043B\u044F\u043F\u0456\u0441\u043B\u044F\u0437\u0430\u0432\u0442\u0440\u0430":
        return theDayAfter(context.reference, 3);
      case "\u043F\u043E\u0437\u0430\u0432\u0447\u043E\u0440\u0430":
        return theDayBefore(context.reference, 2);
      case "\u043F\u043E\u0437\u0430\u043F\u043E\u0437\u0430\u0432\u0447\u043E\u0440\u0430":
        return theDayBefore(context.reference, 3);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKCasualTimeParser.js
var import_dayjs44 = __toESM(require_dayjs_min(), 1);
var UKCasualTimeParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(\u0437\u0430\u0440\u0430\u0437|\u043C\u0438\u043D\u0443\u043B\u043E\u0433\u043E\\s*\u0432\u0435\u0447\u043E\u0440\u0430|\u043C\u0438\u043D\u0443\u043B\u043E\u0457\\s*\u043D\u043E\u0447\u0456|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u0457\\s*\u043D\u043E\u0447\u0456|\u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456\\s*\u0432\u043D\u043E\u0447\u0456|\u0446\u0456\u0454\u0457\\s*\u043D\u043E\u0447\u0456|\u0446\u044C\u043E\u0433\u043E \u0440\u0430\u043D\u043A\u0443|\u0432\u0440\u0430\u043D\u0446\u0456|\u0440\u0430\u043D\u043A\u0443|\u0437\u0440\u0430\u043D\u043A\u0443|\u043E\u043F\u0456\u0432\u0434\u043D\u0456|\u0432\u0432\u0435\u0447\u0435\u0440\u0456|\u0432\u0435\u0447\u043E\u0440\u0430|\u043E\u043F\u0456\u0432\u043D\u043E\u0447\u0456|\u0432\u043D\u043E\u0447\u0456)`;
  }
  innerExtract(context, match2) {
    let targetDate = (0, import_dayjs44.default)(context.reference.instant);
    const lowerText = match2[0].toLowerCase();
    const component = context.createParsingComponents();
    if (lowerText === "\u0437\u0430\u0440\u0430\u0437") {
      return now(context.reference);
    }
    if (lowerText === "\u0432\u0432\u0435\u0447\u0435\u0440\u0456" || lowerText === "\u0432\u0435\u0447\u043E\u0440\u0430") {
      return evening(context.reference);
    }
    if (lowerText.endsWith("\u0432\u0440\u0430\u043D\u0446\u0456") || lowerText.endsWith("\u0440\u0430\u043D\u043A\u0443") || lowerText.endsWith("\u0437\u0440\u0430\u043D\u043A\u0443")) {
      return morning(context.reference);
    }
    if (lowerText.endsWith("\u043E\u043F\u0456\u0432\u0434\u043D\u0456")) {
      return noon(context.reference);
    }
    if (lowerText.match(/минулої\s*ночі/)) {
      return lastNight(context.reference);
    }
    if (lowerText.match(/минулого\s*вечора/)) {
      return yesterdayEvening(context.reference);
    }
    if (lowerText.match(/наступної\s*ночі/)) {
      const daysToAdd = targetDate.hour() < 22 ? 1 : 2;
      targetDate = targetDate.add(daysToAdd, "day");
      assignSimilarDate(component, targetDate);
      component.imply("hour", 1);
    }
    if (lowerText.match(/цієї\s*ночі/)) {
      return midnight(context.reference);
    }
    if (lowerText.endsWith("\u043E\u043F\u0456\u0432\u043D\u043E\u0447\u0456") || lowerText.endsWith("\u0432\u043D\u043E\u0447\u0456")) {
      return midnight(context.reference);
    }
    return component;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKWeekdayParser.js
var PREFIX_GROUP7 = 1;
var WEEKDAY_GROUP7 = 2;
var POSTFIX_GROUP6 = 3;
var UKWeekdayParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(?:(?:,|\\(|\uFF08)\\s*)?(?:\u0432\\s*?)?(?:\u0443\\s*?)?(?:(\u0446\u0435\u0439|\u043C\u0438\u043D\u0443\u043B\u043E\u0433\u043E|\u043C\u0438\u043D\u0443\u043B\u0438\u0439|\u043F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u0456\u0439|\u043F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u044C\u043E\u0433\u043E|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u0433\u043E|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u0438\u0439|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443)\\s*)?(${matchAnyPattern(WEEKDAY_DICTIONARY7)})(?:\\s*(?:,|\\)|\uFF09))?(?:\\s*(\u043D\u0430|\u0443|\u0432)\\s*(\u0446\u044C\u043E\u043C\u0443|\u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443)\\s*\u0442\u0438\u0436\u043D\u0456)?`;
  }
  innerExtract(context, match2) {
    const dayOfWeek = match2[WEEKDAY_GROUP7].toLocaleLowerCase();
    const weekday = WEEKDAY_DICTIONARY7[dayOfWeek];
    const prefix5 = match2[PREFIX_GROUP7];
    const postfix = match2[POSTFIX_GROUP6];
    let modifierWord = prefix5 || postfix;
    modifierWord = modifierWord || "";
    modifierWord = modifierWord.toLocaleLowerCase();
    let modifier = null;
    if (modifierWord == "\u043C\u0438\u043D\u0443\u043B\u043E\u0433\u043E" || modifierWord == "\u043C\u0438\u043D\u0443\u043B\u0438\u0439" || modifierWord == "\u043F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u0456\u0439" || modifierWord == "\u043F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u044C\u043E\u0433\u043E") {
      modifier = "last";
    } else if (modifierWord == "\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u0433\u043E" || modifierWord == "\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u0438\u0439") {
      modifier = "next";
    } else if (modifierWord == "\u0446\u0435\u0439" || modifierWord == "\u0446\u044C\u043E\u0433\u043E" || modifierWord == "\u0446\u044C\u043E\u043C\u0443") {
      modifier = "this";
    }
    return createParsingComponentsAtWeekday(context.reference, weekday, modifier);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKRelativeDateFormatParser.js
var import_dayjs45 = __toESM(require_dayjs_min(), 1);
var MODIFIER_WORD_GROUP4 = 1;
var RELATIVE_WORD_GROUP4 = 2;
var UKRelativeDateFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(\u0432 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443|\u0443 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443|\u043D\u0430 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443|\u043C\u0438\u043D\u0443\u043B\u043E\u0433\u043E|\u043D\u0430 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443|\u0432 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443|\u0443 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u0433\u043E|\u043D\u0430 \u0446\u044C\u043E\u043C\u0443|\u0432 \u0446\u044C\u043E\u043C\u0443|\u0443 \u0446\u044C\u043E\u043C\u0443|\u0446\u044C\u043E\u0433\u043E)\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY6)})(?=\\s*)`;
  }
  innerExtract(context, match2) {
    const modifier = match2[MODIFIER_WORD_GROUP4].toLowerCase();
    const unitWord = match2[RELATIVE_WORD_GROUP4].toLowerCase();
    const timeunit = TIME_UNIT_DICTIONARY6[unitWord];
    if (modifier == "\u043D\u0430 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443" || modifier == "\u0432 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443" || modifier == "\u0443 \u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u043C\u0443" || modifier == "\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u043E\u0433\u043E") {
      const timeUnits = {};
      timeUnits[timeunit] = 1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    if (modifier == "\u043D\u0430 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443" || modifier == "\u0432 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443" || modifier == "\u0443 \u043C\u0438\u043D\u0443\u043B\u043E\u043C\u0443" || modifier == "\u043C\u0438\u043D\u0443\u043B\u043E\u0433\u043E") {
      const timeUnits = {};
      timeUnits[timeunit] = -1;
      return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
    }
    const components = context.createParsingComponents();
    let date = (0, import_dayjs45.default)(context.reference.instant);
    if (timeunit.match(/week/i)) {
      date = date.add(-date.get("d"), "d");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.imply("year", date.year());
    } else if (timeunit.match(/month/i)) {
      date = date.add(-date.date() + 1, "d");
      components.imply("day", date.date());
      components.assign("year", date.year());
      components.assign("month", date.month() + 1);
    } else if (timeunit.match(/year/i)) {
      date = date.add(-date.date() + 1, "d");
      date = date.add(-date.month(), "month");
      components.imply("day", date.date());
      components.imply("month", date.month() + 1);
      components.assign("year", date.year());
    }
    return components;
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/parsers/UKTimeUnitCasualRelativeFormatParser.js
var UKTimeUnitCasualRelativeFormatParser = class extends AbstractParserWithLeftRightBoundaryChecking2 {
  innerPatternString(context) {
    return `(\u0446\u0456|\u043E\u0441\u0442\u0430\u043D\u043D\u0456|\u043C\u0438\u043D\u0443\u043B\u0456|\u043C\u0430\u0439\u0431\u0443\u0442\u043D\u0456|\u043D\u0430\u0441\u0442\u0443\u043F\u043D\u0456|\u043F\u0456\u0441\u043B\u044F|\u0447\u0435\u0440\u0435\u0437|\\+|-)\\s*(${TIME_UNITS_PATTERN6})`;
  }
  innerExtract(context, match2) {
    const prefix5 = match2[1].toLowerCase();
    let timeUnits = parseTimeUnits6(match2[3]);
    switch (prefix5) {
      case "\u043E\u0441\u0442\u0430\u043D\u043D\u0456":
      case "\u043C\u0438\u043D\u0443\u043B\u0456":
      case "-":
        timeUnits = reverseTimeUnits(timeUnits);
        break;
    }
    return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);
  }
};

// node_modules/chrono-node/dist/esm/locales/uk/index.js
var casual10 = new Chrono(createCasualConfiguration9());
var strict10 = new Chrono(createConfiguration9(true));
function createCasualConfiguration9() {
  const option = createConfiguration9(false);
  option.parsers.unshift(new UKCasualDateParser());
  option.parsers.unshift(new UKCasualTimeParser());
  option.parsers.unshift(new UkMonthNameParser());
  option.parsers.unshift(new UKRelativeDateFormatParser());
  option.parsers.unshift(new UKTimeUnitCasualRelativeFormatParser());
  return option;
}
function createConfiguration9(strictMode) {
  return includeCommonConfiguration({
    parsers: [
      new ISOFormatParser(),
      new SlashDateFormatParser(true),
      new UKTimeUnitWithinFormatParser(),
      new UKMonthNameLittleEndianParser(),
      new UKWeekdayParser(),
      new UKTimeExpressionParser(strictMode),
      new UKTimeUnitAgoFormatParser()
    ],
    refiners: [new UKMergeDateTimeRefiner(), new UKMergeDateRangeRefiner()]
  }, strictMode);
}
function parse16(text, ref, option) {
  return casual10.parse(text, ref, option);
}
function parseDate10(text, ref, option) {
  return casual10.parseDate(text, ref, option);
}

// src/backgroundLogic/HistoricaChrono.ts
var import_lodash2 = __toESM(require_lodash());
var HistoricaSupportLanguages = [
  "en",
  "ja",
  "fr",
  "de",
  "nl",
  "ru",
  "uk",
  "pt",
  "zh.hant"
];
var BCEpattern = [
  /\b(\d{4})\s+B\.?C\.?E?\.?\b/i,
  /\b(\d{4})\s+Before\s+\w{1,2}\s+Christ\b/i,
  /\b(\d{4})\s+Before\s+\w{1,2}\s+Common\s+Era\b/i,
  /\bB\.?C\.?E?\.?:?\s+(\d{4})\b/i,
  /\bBefore\s+\w{1,2}\s+Christ\s+(\d{4})\b/i,
  /\bBefore\s+\w{1,2}\s+Common\s+Era\s+(\d{4})\b/i
];
var ADpattern = [
  /\b(\d{4})\s+A\.?D\.?E?\.?\b/i,
  /\b(\d{4})\s+Anno\s+Domini\b/i,
  /\bA\.?D\.?E?\.?:?\s+(\d{4})\b/i,
  /\bAnno\s+Domini\s+(\d{4})\b/i
];
var HistoricaChrono = class {
  get customChrono() {
    return this._customChrono;
  }
  set customChrono(value) {
    this._customChrono = value;
  }
  async setupCustomChrono(userLang) {
    if (userLang === "en") {
      this.customChrono = en_exports.casual.clone();
    } else if (userLang === "de") {
      this.customChrono = de_exports.casual.clone();
    } else if (userLang === "fr") {
      this.customChrono = fr_exports.casual.clone();
    } else if (userLang === "ja") {
      this.customChrono = ja_exports.casual.clone();
    } else if (userLang === "nl") {
      this.customChrono = nl_exports.casual.clone();
    } else if (userLang === "ru") {
      this.customChrono = ru_exports.casual.clone();
    } else if (userLang === "uk") {
      this.customChrono = uk_exports.casual.clone();
    } else if (userLang === "pt") {
      this.customChrono = pt_exports.casual.clone();
    } else if (userLang === "zh.hant") {
      this.customChrono = zh_exports.hant.clone();
    }
    if (userLang === "en") {
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(in|at|on|from|to|year)\s+(\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: 1,
            month: 1,
            year: (0, import_lodash2.parseInt)(match2[2])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(\d{4})[\/,-](\d{1,2})[\/,-](\d{1,2})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: (0, import_lodash2.parseInt)(match2[3]),
            month: (0, import_lodash2.parseInt)(match2[2]),
            year: (0, import_lodash2.parseInt)(match2[1])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(\d{1,2})[\/,-](\d{1,2})[\/,-](\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: (0, import_lodash2.parseInt)(match2[2]),
            month: (0, import_lodash2.parseInt)(match2[1]),
            year: (0, import_lodash2.parseInt)(match2[3])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: (0, import_lodash2.parseInt)(match2[1]),
            month: new Date(Date.parse(match2[2] + " 1, 2000")).getMonth() + 1,
            year: (0, import_lodash2.parseInt)(match2[3])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2})\s+(\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: (0, import_lodash2.parseInt)(match2[2]),
            month: new Date(Date.parse(match2[1] + " 1, 2000")).getMonth() + 1,
            year: (0, import_lodash2.parseInt)(match2[3])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(\d{4})[\/,-](\d{1,2})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: 1,
            month: (0, import_lodash2.parseInt)(match2[2]),
            year: (0, import_lodash2.parseInt)(match2[1])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(\d{1,2})[\/,-](\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: 1,
            month: (0, import_lodash2.parseInt)(match2[1]),
            year: (0, import_lodash2.parseInt)(match2[2])
          };
        }
      });
      this.customChrono.parsers.push({
        pattern: () => {
          return /\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})\b/i;
        },
        extract: (_context, match2) => {
          return {
            day: 1,
            month: new Date(Date.parse(match2[1] + " 1, 2000")).getMonth() + 1,
            year: (0, import_lodash2.parseInt)(match2[2])
          };
        }
      });
      BCEpattern.forEach((pattern) => {
        this.customChrono.parsers.push({
          pattern: () => {
            return pattern;
          },
          extract: (_context, match2) => {
            return {
              year: -(0, import_lodash2.parseInt)(match2[1])
            };
          }
        });
      });
      ADpattern.forEach((pattern) => {
        this.customChrono.parsers.push({
          pattern: () => {
            return pattern;
          },
          extract: (_context, match2) => {
            return {
              year: (0, import_lodash2.parseInt)(match2[1])
            };
          }
        });
      });
    }
    return this.customChrono;
  }
};

// src/backgroundLogic/HistoricaUserBlockProcesser.ts
var HistoricaUserBlockProcesser = class {
  get plugin() {
    return this._plugin;
  }
  set plugin(value) {
    this._plugin = value;
  }
  constructor(plugin5) {
    this._plugin = plugin5;
  }
  async verifyBlockConfig(blockConfig) {
    if (!blockConfig.language || !HistoricaSupportLanguages.includes(blockConfig.language)) {
      blockConfig.language = this.plugin.configManager.settings.language;
    }
    if (![1, 2].includes(blockConfig.style) || !blockConfig.style) {
      blockConfig.style = (0, import_lodash3.parseInt)(this.plugin.configManager.settings.defaultStyle);
    }
    if ((0, import_lodash3.isUndefined)(blockConfig.include_files)) {
      blockConfig.include_files = [];
    }
    let query = [];
    if (blockConfig.query === void 0) {
      query = [];
    } else if (Object.keys(blockConfig.query).length === 0) {
      query = [];
    } else if (Object.keys(blockConfig.query).length >= 0) {
      const keys = Object.keys(blockConfig.query);
      keys.map((key) => {
        if (!blockConfig.query[key].start && !typeof blockConfig.query[key].start === "string") {
          new import_obsidian7.Notice(`Your query is not valid, please check your query at ${key}`);
        }
        if (blockConfig.query[key].end && !typeof blockConfig.query[key].start === "string") {
          new import_obsidian7.Notice(`Your query is not valid, please check your query at ${key}`);
        }
        query.push({
          // @ts-ignore
          start: blockConfig.query[key].start,
          // @ts-ignore
          end: blockConfig.query[key].end
        });
      });
    } else if (!Array.isArray(blockConfig.query)) {
      query = [blockConfig.query];
    } else if (Array.isArray(blockConfig.query) && blockConfig.query[0].start) {
      query = blockConfig.query;
    } else {
      query = [];
      new import_obsidian7.Notice("Your query is not valid, please check your query");
    }
    blockConfig.query = query;
    if ((0, import_lodash3.isUndefined)(blockConfig.pin_time) || blockConfig.pin_time && blockConfig.pin_time.trim() === "") {
      blockConfig.pin_time = null;
    }
    if (![true, false].includes(blockConfig.smart_theme)) {
      blockConfig.smart_theme = this.plugin.configManager.settings.usingSmartTheme;
    }
    if (![true, false].includes(blockConfig.implicit_time)) {
      blockConfig.implicit_time = this.plugin.configManager.settings.showRelativeTime;
    }
    return blockConfig;
  }
};

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$1(html3, encode) {
  if (encode) {
    if (escapeTest.test(html3)) {
      return html3.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html3)) {
      return html3.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html3;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape2(html3) {
  return html3.replace(unescapeTest, (_4, n5) => {
    n5 = n5.toLowerCase();
    if (n5 === "colon")
      return ":";
    if (n5.charAt(0) === "#") {
      return n5.charAt(1) === "x" ? String.fromCharCode(parseInt(n5.substring(2), 16)) : String.fromCharCode(+n5.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  let source = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      let valSource = typeof val === "string" ? val : val.source;
      valSource = valSource.replace(caret, "$1");
      source = source.replace(name, valSource);
      return obj;
    },
    getRegex: () => {
      return new RegExp(source, opt);
    }
  };
  return obj;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e3) {
    return null;
  }
  return href;
}
var noopTest = { exec: () => null };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match2, offset2, str) => {
    let escaped = false;
    let curr = offset2;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i5 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i5 < cells.length; i5++) {
    cells[i5] = cells[i5].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c5, invert) {
  const l4 = str.length;
  if (l4 === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l4) {
    const currChar = str.charAt(l4 - suffLen - 1);
    if (currChar === c5 && !invert) {
      suffLen++;
    } else if (currChar !== c5 && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l4 - suffLen);
}
function findClosingBracket(str, b2) {
  if (str.indexOf(b2[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i5 = 0; i5 < str.length; i5++) {
    if (str[i5] === "\\") {
      i5++;
    } else if (str[i5] === b2[0]) {
      level++;
    } else if (str[i5] === b2[1]) {
      level--;
      if (level < 0) {
        return i5;
      }
    }
  }
  return -1;
}
function outputLink(cap, link2, raw, lexer2) {
  const href = link2.href;
  const title = link2.title ? escape$1(link2.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$1(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node2) => {
    const matchIndentInNode = node2.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node2;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node2.slice(indentToCode.length);
    }
    return node2;
  }).join("\n");
}
var _Tokenizer = class {
  // set by the lexer
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "rules");
    // set by the lexer
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list5 = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t5) => " ".repeat(3 * t5.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list5.loose) {
          if (endsWithBlankLine) {
            list5.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list5.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list5.raw += raw;
      }
      list5.items[list5.items.length - 1].raw = raw.trimEnd();
      list5.items[list5.items.length - 1].text = itemContents.trimEnd();
      list5.raw = list5.raw.trimEnd();
      for (let i5 = 0; i5 < list5.items.length; i5++) {
        this.lexer.state.top = false;
        list5.items[i5].tokens = this.lexer.blockTokens(list5.items[i5].text, []);
        if (!list5.loose) {
          const spacers = list5.items[i5].tokens.filter((t5) => t5.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t5) => /\n.*\n/.test(t5.raw));
          list5.loose = hasMultipleLineBreaks;
        }
      }
      if (list5.loose) {
        for (let i5 = 0; i5 < list5.items.length; i5++) {
          list5.items[i5].loose = true;
        }
      }
      return list5;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (!cap) {
      return;
    }
    if (!/[:|]/.test(cap[2])) {
      return;
    }
    const headers = splitCells(cap[1]);
    const aligns = cap[2].replace(/^\||\| *$/g, "").split("|");
    const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : [];
    const item = {
      type: "table",
      raw: cap[0],
      header: [],
      align: [],
      rows: []
    };
    if (headers.length !== aligns.length) {
      return;
    }
    for (const align of aligns) {
      if (/^ *-+: *$/.test(align)) {
        item.align.push("right");
      } else if (/^ *:-+: *$/.test(align)) {
        item.align.push("center");
      } else if (/^ *:-+ *$/.test(align)) {
        item.align.push("left");
      } else {
        item.align.push(null);
      }
    }
    for (const header of headers) {
      item.header.push({
        text: header,
        tokens: this.lexer.inline(header)
      });
    }
    for (const row of rows) {
      item.rows.push(splitCells(row, item.header.length).map((cell) => {
        return {
          text: cell,
          tokens: this.lexer.inline(cell)
        };
      }));
    }
    return item;
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$1(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start2 + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link2) {
          href = link2[1];
          title = link2[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
        title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      const linkString = (cap[2] || cap[1]).replace(/\s+/g, " ");
      const link2 = links[linkString.toLowerCase()];
      if (!link2) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link2, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match2 = this.rules.inline.emStrongLDelim.exec(src);
    if (!match2)
      return;
    if (match2[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match2[1] || match2[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match2[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match2 = endReg.exec(maskedSrc)) != null) {
        rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match2[3] || match2[4]) {
          delimTotal += rLength;
          continue;
        } else if (match2[5] || match2[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match2[0]][0].length;
        const raw = src.slice(0, lLength + match2.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape$1(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape$1(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    var _a2, _b2;
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape$1(cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = (_b2 = (_a2 = this.rules.inline._backpedal.exec(cap[0])) == null ? void 0 : _a2[0]) != null ? _b2 : "";
        } while (prevCapZero !== cap[0]);
        text = escape$1(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = cap[0];
      } else {
        text = escape$1(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var newline = /^(?: *(?:\n|$))+/;
var blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
var fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var bullet = /(?:[*+-]|\d{1,9}[.)])/;
var lheading = edit(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, bullet).getRegex();
var _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var blockText = /^[^\n]+/;
var _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
var def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var list4 = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
var _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var html2 = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
var blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html: html2,
  lheading,
  list: list4,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
};
var gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
var blockGfm = {
  ...blockNormal,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
};
var blockPedantic = {
  ...blockNormal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
};
var escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var br = /^( {2,}|\\)\n(?!\s*$)/;
var inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var _punctuation = "\\p{P}\\p{S}";
var punctuation = edit(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, _punctuation).getRegex();
var blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
var emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimAst = edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, _punctuation).getRegex();
var emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, _punctuation).getRegex();
var anyPunctuation = edit(/\\([punct])/, "gu").replace(/punct/g, _punctuation).getRegex();
var autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
var tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
var link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
var nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
var reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
var inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
};
var inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
};
var inlineGfm = {
  ...inlineNormal,
  escape: edit(escape).replace("])", "~|])").getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
var inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
};
var inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
};
var _Lexer = class {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules2 = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules2.block = block.pedantic;
      rules2.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules2.block = block.gfm;
      if (this.options.breaks) {
        rules2.inline = inline.breaks;
      } else {
        rules2.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules2;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new _Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    for (let i5 = 0; i5 < this.inlineQueue.length; i5++) {
      const next = this.inlineQueue[i5];
      this.inlineTokens(next.src, next.tokens);
    }
    this.inlineQueue = [];
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_4, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match2;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match2 = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  code(code, infostring, escaped) {
    var _a2;
    const lang = (_a2 = (infostring || "").match(/^\S*/)) == null ? void 0 : _a2[0];
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape$1(lang) + '">' + (escaped ? code : escape$1(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html3, block2) {
    return html3;
  }
  heading(text, level, raw) {
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start2) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text, task, checked) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag2 = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out2 = '<a href="' + href + '"';
    if (title) {
      out2 += ' title="' + title + '"';
    }
    out2 += ">" + text + "</a>";
    return out2;
  }
  image(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out2 = `<img src="${href}" alt="${text}"`;
    if (title) {
      out2 += ` title="${title}"`;
    }
    out2 += ">";
    return out2;
  }
  text(text) {
    return text;
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new _Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out2 = "";
    for (let i5 = 0; i5 < tokens.length; i5++) {
      const token = tokens[i5];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out2 += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out2 += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out2 += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out2 += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j3 = 0; j3 < tableToken.header.length; j3++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j3].tokens), { header: true, align: tableToken.align[j3] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j3 = 0; j3 < tableToken.rows.length; j3++) {
            const row = tableToken.rows[j3];
            cell = "";
            for (let k3 = 0; k3 < row.length; k3++) {
              cell += this.renderer.tablecell(this.parseInline(row[k3].tokens), { header: false, align: tableToken.align[k3] });
            }
            body += this.renderer.tablerow(cell);
          }
          out2 += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out2 += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start2 = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j3 = 0; j3 < listToken.items.length; j3++) {
            const item = listToken.items[j3];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox + " "
                  });
                }
              } else {
                itemBody += checkbox + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out2 += this.renderer.list(body, ordered, start2);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out2 += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out2 += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i5 + 1 < tokens.length && tokens[i5 + 1].type === "text") {
            textToken = tokens[++i5];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out2 += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out2;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out2 = "";
    for (let i5 = 0; i5 < tokens.length; i5++) {
      const token = tokens[i5];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out2 += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out2 += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out2 += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out2 += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token;
          out2 += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out2 += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token;
          out2 += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out2 += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out2 += renderer.br();
          break;
        }
        case "del": {
          const delToken = token;
          out2 += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token;
          out2 += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out2;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html3) {
    return html3;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(tokens) {
    return tokens;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
]));
var _parseMarkdown, parseMarkdown_fn, _onError, onError_fn;
var Marked = class {
  constructor(...args) {
    __privateAdd(this, _parseMarkdown);
    __privateAdd(this, _onError);
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
    __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    var _a2, _b2;
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if ((_b2 = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b2[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              const tokens2 = genericToken[childTokens].flat(Infinity);
              values = values.concat(this.walkTokens(tokens2, callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts2 = { ...pack };
      opts2.async = this.defaults.async || opts2.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts2.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          if (!(prop in renderer)) {
            throw new Error(`renderer '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const rendererProp = prop;
          const rendererFunc = pack.renderer[rendererProp];
          const prevRenderer = renderer[rendererProp];
          renderer[rendererProp] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts2.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          if (!(prop in tokenizer)) {
            throw new Error(`tokenizer '${prop}' does not exist`);
          }
          if (["options", "rules", "lexer"].includes(prop)) {
            continue;
          }
          const tokenizerProp = prop;
          const tokenizerFunc = pack.tokenizer[tokenizerProp];
          const prevTokenizer = tokenizer[tokenizerProp];
          tokenizer[tokenizerProp] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts2.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks2 = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          if (!(prop in hooks2)) {
            throw new Error(`hook '${prop}' does not exist`);
          }
          if (prop === "options") {
            continue;
          }
          const hooksProp = prop;
          const hooksFunc = pack.hooks[hooksProp];
          const prevHook = hooks2[hooksProp];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks2[hooksProp] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks2, arg)).then((ret2) => {
                  return prevHook.call(hooks2, ret2);
                });
              }
              const ret = hooksFunc.call(hooks2, arg);
              return prevHook.call(hooks2, ret);
            };
          } else {
            hooks2[hooksProp] = (...args2) => {
              let ret = hooksFunc.apply(hooks2, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks2, args2);
              }
              return ret;
            };
          }
        }
        opts2.hooks = hooks2;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts2.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts2 };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 != null ? options2 : this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 != null ? options2 : this.defaults);
  }
};
_parseMarkdown = new WeakSet();
parseMarkdown_fn = function(lexer2, parser2) {
  return (src, options2) => {
    const origOpt = { ...options2 };
    const opt = { ...this.defaults, ...origOpt };
    if (this.defaults.async === true && origOpt.async === false) {
      if (!opt.silent) {
        console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
      }
      opt.async = true;
    }
    const throwError = __privateMethod(this, _onError, onError_fn).call(this, !!opt.silent, !!opt.async);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html3) => opt.hooks ? opt.hooks.postprocess(html3) : html3).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      let tokens = lexer2(src, opt);
      if (opt.hooks) {
        tokens = opt.hooks.processAllTokens(tokens);
      }
      if (opt.walkTokens) {
        this.walkTokens(tokens, opt.walkTokens);
      }
      let html3 = parser2(tokens, opt);
      if (opt.hooks) {
        html3 = opt.hooks.postprocess(html3);
      }
      return html3;
    } catch (e3) {
      return throwError(e3);
    }
  };
};
_onError = new WeakSet();
onError_fn = function(silent, async) {
  return (e3) => {
    e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape$1(e3.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e3);
    }
    throw e3;
  };
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/backgroundLogic/HistoricaDocumentFileParser.ts
var HistoricaDocumentFileParser = class {
  get documentProcesser() {
    return this._documentProcesser;
  }
  set documentProcesser(value) {
    this._documentProcesser = value;
  }
  get plugin() {
    return this._plugin;
  }
  set plugin(value) {
    this._plugin = value;
  }
  constructor(plugin5, documentProcesser) {
    this._plugin = plugin5;
    this._documentProcesser = documentProcesser;
  }
  async parseTFileAndUpdateDocuments(file, documents) {
    if (!file) {
      return;
    }
    const fileContent = await this.plugin.app.vault.read(file);
    const lexerResult = marked.lexer(fileContent);
    lexerResult.map((token) => {
      this.documentProcesser.RecusiveGetToken(token, documents);
    });
  }
};

// node_modules/jspdf/dist/jspdf.es.min.js
init_typeof();

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start2) {
  var b2 = new u16(31);
  for (var i5 = 0; i5 < 31; ++i5) {
    b2[i5] = start2 += 1 << eb[i5 - 1];
  }
  var r3 = new u32(b2[30]);
  for (var i5 = 1; i5 < 30; ++i5) {
    for (var j3 = b2[i5]; j3 < b2[i5 + 1]; ++j3) {
      r3[j3] = j3 - b2[i5] << 5 | i5;
    }
  }
  return [b2, r3];
};
var _a = freb(fleb, 2);
var fl = _a[0];
var revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b[0];
var revfd = _b[1];
var rev = new u16(32768);
for (i5 = 0; i5 < 32768; ++i5) {
  x2 = (i5 & 43690) >>> 1 | (i5 & 21845) << 1;
  x2 = (x2 & 52428) >>> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >>> 4 | (x2 & 3855) << 4;
  rev[i5] = ((x2 & 65280) >>> 8 | (x2 & 255) << 8) >>> 1;
}
var x2;
var i5;
var hMap = function(cd, mb, r3) {
  var s5 = cd.length;
  var i5 = 0;
  var l4 = new u16(mb);
  for (; i5 < s5; ++i5)
    ++l4[cd[i5] - 1];
  var le2 = new u16(mb);
  for (i5 = 0; i5 < mb; ++i5) {
    le2[i5] = le2[i5 - 1] + l4[i5 - 1] << 1;
  }
  var co;
  if (r3) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i5 = 0; i5 < s5; ++i5) {
      if (cd[i5]) {
        var sv = i5 << 4 | cd[i5];
        var r_1 = mb - cd[i5];
        var v4 = le2[cd[i5] - 1]++ << r_1;
        for (var m6 = v4 | (1 << r_1) - 1; v4 <= m6; ++v4) {
          co[rev[v4] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s5);
    for (i5 = 0; i5 < s5; ++i5)
      co[i5] = rev[le2[cd[i5] - 1]++] >>> 15 - cd[i5];
  }
  return co;
};
var flt = new u8(288);
for (i5 = 0; i5 < 144; ++i5)
  flt[i5] = 8;
var i5;
for (i5 = 144; i5 < 256; ++i5)
  flt[i5] = 9;
var i5;
for (i5 = 256; i5 < 280; ++i5)
  flt[i5] = 7;
var i5;
for (i5 = 280; i5 < 288; ++i5)
  flt[i5] = 8;
var i5;
var fdt = new u8(32);
for (i5 = 0; i5 < 32; ++i5)
  fdt[i5] = 5;
var i5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max3 = function(a4) {
  var m6 = a4[0];
  for (var i5 = 1; i5 < a4.length; ++i5) {
    if (a4[i5] > m6)
      m6 = a4[i5];
  }
  return m6;
};
var bits = function(d3, p7, m6) {
  var o4 = p7 / 8 >> 0;
  return (d3[o4] | d3[o4 + 1] << 8) >>> (p7 & 7) & m6;
};
var bits16 = function(d3, p7) {
  var o4 = p7 / 8 >> 0;
  return (d3[o4] | d3[o4 + 1] << 8 | d3[o4 + 2] << 16) >>> (p7 & 7);
};
var shft = function(p7) {
  return (p7 / 8 >> 0) + (p7 & 7 && 1);
};
var slc = function(v4, s5, e3) {
  if (s5 == null || s5 < 0)
    s5 = 0;
  if (e3 == null || e3 > v4.length)
    e3 = v4.length;
  var n5 = new (v4 instanceof u16 ? u16 : v4 instanceof u32 ? u32 : u8)(e3 - s5);
  n5.set(v4.subarray(s5, e3));
  return n5;
};
var inflt = function(dat, buf, st2) {
  var sl = dat.length;
  var noBuf = !buf || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l5) {
    var bl = buf.length;
    if (l5 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l5));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s5 = shft(pos) + 4, l4 = dat[s5 - 4] | dat[s5 - 3] << 8, t5 = s5 + l4;
        if (t5 > sl) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l4);
        buf.set(dat.subarray(s5, t5), bt2);
        st2.b = bt2 += l4, st2.p = pos = t5 * 8;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i5 = 0; i5 < hcLen; ++i5) {
          clt[clim[i5]] = bits(dat, pos + i5 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max3(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i5 = 0; i5 < tl; ) {
          var r3 = clm[bits(dat, pos, clbmsk)];
          pos += r3 & 15;
          var s5 = r3 >>> 4;
          if (s5 < 16) {
            ldt[i5++] = s5;
          } else {
            var c5 = 0, n5 = 0;
            if (s5 == 16)
              n5 = 3 + bits(dat, pos, 3), pos += 2, c5 = ldt[i5 - 1];
            else if (s5 == 17)
              n5 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s5 == 18)
              n5 = 11 + bits(dat, pos, 127), pos += 7;
            while (n5--)
              ldt[i5++] = c5;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max3(lt2);
        dbt = max3(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c5 = lm[bits16(dat, pos) & lms], sym = c5 >>> 4;
      pos += c5 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c5)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i5 = sym - 257, b2 = fleb[i5];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i5];
          pos += b2;
        }
        var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >>> 4;
        if (!d3)
          throw "invalid distance";
        pos += d3 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end2 = bt2 + add;
        for (; bt2 < end2; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end2;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var wbits = function(d3, p7, v4) {
  v4 <<= p7 & 7;
  var o4 = p7 / 8 >> 0;
  d3[o4] |= v4;
  d3[o4 + 1] |= v4 >>> 8;
};
var wbits16 = function(d3, p7, v4) {
  v4 <<= p7 & 7;
  var o4 = p7 / 8 >> 0;
  d3[o4] |= v4;
  d3[o4 + 1] |= v4 >>> 8;
  d3[o4 + 2] |= v4 >>> 16;
};
var hTree = function(d3, mb) {
  var t5 = [];
  for (var i5 = 0; i5 < d3.length; ++i5) {
    if (d3[i5])
      t5.push({ s: i5, f: d3[i5] });
  }
  var s5 = t5.length;
  var t22 = t5.slice();
  if (!s5)
    return [new u8(0), 0];
  if (s5 == 1) {
    var v4 = new u8(t5[0].s + 1);
    v4[t5[0].s] = 1;
    return [v4, 1];
  }
  t5.sort(function(a4, b2) {
    return a4.f - b2.f;
  });
  t5.push({ s: -1, f: 25001 });
  var l4 = t5[0], r3 = t5[1], i0 = 0, i1 = 1, i22 = 2;
  t5[0] = { s: -1, f: l4.f + r3.f, l: l4, r: r3 };
  while (i1 != s5 - 1) {
    l4 = t5[t5[i0].f < t5[i22].f ? i0++ : i22++];
    r3 = t5[i0 != i1 && t5[i0].f < t5[i22].f ? i0++ : i22++];
    t5[i1++] = { s: -1, f: l4.f + r3.f, l: l4, r: r3 };
  }
  var maxSym = t22[0].s;
  for (var i5 = 1; i5 < s5; ++i5) {
    if (t22[i5].s > maxSym)
      maxSym = t22[i5].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t5[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i5 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a4, b2) {
      return tr[b2.s] - tr[a4.s] || a4.f - b2.f;
    });
    for (; i5 < s5; ++i5) {
      var i2_1 = t22[i5].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i5].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i5;
    }
    for (; i5 >= 0 && dt2; --i5) {
      var i2_3 = t22[i5].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function(n5, l4, d3) {
  return n5.s == -1 ? Math.max(ln(n5.l, l4, d3 + 1), ln(n5.r, l4, d3 + 1)) : l4[n5.s] = d3;
};
var lc = function(c5) {
  var s5 = c5.length;
  while (s5 && !c5[--s5])
    ;
  var cl = new u16(++s5);
  var cli2 = 0, cln = c5[0], cls = 1;
  var w2 = function(v4) {
    cl[cli2++] = v4;
  };
  for (var i5 = 1; i5 <= s5; ++i5) {
    if (c5[i5] == cln && i5 != s5)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c5[i5];
    }
  }
  return [cl.subarray(0, cli2), s5];
};
var clen = function(cf, cl) {
  var l4 = 0;
  for (var i5 = 0; i5 < cl.length; ++i5)
    l4 += cf[i5] * cl[i5];
  return l4;
};
var wfblk = function(out2, pos, dat) {
  var s5 = dat.length;
  var o4 = shft(pos + 2);
  out2[o4] = s5 & 255;
  out2[o4 + 1] = s5 >>> 8;
  out2[o4 + 2] = out2[o4] ^ 255;
  out2[o4 + 3] = out2[o4 + 1] ^ 255;
  for (var i5 = 0; i5 < s5; ++i5)
    out2[o4 + i5 + 4] = dat[i5];
  return (o4 + 4 + s5) * 8;
};
var wblk = function(dat, out2, final, syms, lf, df, eb, li, bs, bl, p7) {
  wbits(out2, p7++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i5 = 0; i5 < lclt.length; ++i5)
    lcfreq[lclt[i5] & 31]++;
  for (var i5 = 0; i5 < lcdt.length; ++i5)
    lcfreq[lcdt[i5] & 31]++;
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out2, p7, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out2, p7, 1 + (dtlen < ftlen)), p7 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out2, p7, nlc - 257);
    wbits(out2, p7 + 5, ndc - 1);
    wbits(out2, p7 + 10, nlcc - 4);
    p7 += 14;
    for (var i5 = 0; i5 < nlcc; ++i5)
      wbits(out2, p7 + 3 * i5, lct[clim[i5]]);
    p7 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i5 = 0; i5 < clct.length; ++i5) {
        var len = clct[i5] & 31;
        wbits(out2, p7, llm[len]), p7 += lct[len];
        if (len > 15)
          wbits(out2, p7, clct[i5] >>> 5 & 127), p7 += clct[i5] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i5 = 0; i5 < li; ++i5) {
    if (syms[i5] > 255) {
      var len = syms[i5] >>> 18 & 31;
      wbits16(out2, p7, lm[len + 257]), p7 += ll[len + 257];
      if (len > 7)
        wbits(out2, p7, syms[i5] >>> 23 & 31), p7 += fleb[len];
      var dst = syms[i5] & 31;
      wbits16(out2, p7, dm[dst]), p7 += dl[dst];
      if (dst > 3)
        wbits16(out2, p7, syms[i5] >>> 5 & 8191), p7 += fdeb[dst];
    } else {
      wbits16(out2, p7, lm[syms[i5]]), p7 += ll[syms[i5]];
    }
  }
  wbits16(out2, p7, lm[256]);
  return p7 + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s5 = dat.length;
  var o4 = new u8(pre + s5 + 5 * (1 + Math.floor(s5 / 7e3)) + post);
  var w2 = o4.subarray(pre, o4.length - post);
  var pos = 0;
  if (!lvl || s5 < 8) {
    for (var i5 = 0; i5 <= s5; i5 += 65535) {
      var e3 = i5 + 65535;
      if (e3 < s5) {
        pos = wfblk(w2, pos, dat.subarray(i5, e3));
      } else {
        w2[i5] = lst;
        pos = wfblk(w2, pos, dat.subarray(i5, s5));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n5 = opt >>> 13, c5 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i6) {
      return (dat[i6] ^ dat[i6 + 1] << bs1_1 ^ dat[i6 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i5 = 0, li = 0, wi = 0, bs = 0;
    for (; i5 < s5; ++i5) {
      var hv = hsh(i5);
      var imod = i5 & 32767;
      var pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i5) {
        var rem = s5 - i5;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i5 - bs, pos);
          li = lc_1 = eb = 0, bs = i5;
          for (var j3 = 0; j3 < 286; ++j3)
            lf[j3] = 0;
          for (var j3 = 0; j3 < 30; ++j3)
            df[j3] = 0;
        }
        var l4 = 2, d3 = 0, ch_1 = c5, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i5 - dif)) {
          var maxn = Math.min(n5, rem) - 1;
          var maxd = Math.min(32767, i5);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i5 + l4] == dat[i5 + l4 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i5 + nl] == dat[i5 + nl - dif]; ++nl)
                ;
              if (nl > l4) {
                l4 = nl, d3 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j3 = 0; j3 < mmd; ++j3) {
                  var ti = i5 - dif + j3 + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d3) {
          syms[li++] = 268435456 | revfl[l4] << 18 | revfd[d3];
          var lin = revfl[l4] & 31, din = revfd[d3] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i5 + l4;
          ++lc_1;
        } else {
          syms[li++] = dat[i5];
          ++lf[dat[i5]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i5 - bs, pos);
    if (!lst)
      pos = wfblk(w2, pos, et);
  }
  return slc(o4, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a4 = 1, b2 = 0;
  return {
    p: function(d3) {
      var n5 = a4, m6 = b2;
      var l4 = d3.length;
      for (var i5 = 0; i5 != l4; ) {
        var e3 = Math.min(i5 + 5552, l4);
        for (; i5 < e3; ++i5)
          n5 += d3[i5], m6 += n5;
        n5 %= 65521, m6 %= 65521;
      }
      a4 = n5, b2 = m6;
    },
    d: function() {
      return (a4 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a4 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st2);
};
var wbytes = function(d3, b2, v4) {
  for (; v4; ++b2)
    d3[b2] = v4, v4 >>>= 8;
};
var zlh = function(c5, o4) {
  var lv = o4.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c5[0] = 120, c5[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d3) {
  if ((d3[0] & 15) != 8 || d3[0] >>> 4 > 7 || (d3[0] << 8 | d3[1]) % 31)
    throw "invalid zlib data";
  if (d3[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data, opts2) {
  if (opts2 === void 0) {
    opts2 = {};
  }
  var a4 = adler();
  a4.p(data);
  var d3 = dopt(data, opts2, 2, 4);
  return zlh(d3, opts2), wbytes(d3, d3.length - 4, a4.d()), d3;
}
function unzlibSync(data, out2) {
  return inflt((zlv(data), data.subarray(2, -4)), out2);
}

// node_modules/jspdf/dist/jspdf.es.min.js
var n4 = function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i4() {
  n4.console && "function" == typeof n4.console.log && n4.console.log.apply(n4.console, arguments);
}
var a3 = { log: i4, warn: function(t5) {
  n4.console && ("function" == typeof n4.console.warn ? n4.console.warn.apply(n4.console, arguments) : i4.call(null, arguments));
}, error: function(t5) {
  n4.console && ("function" == typeof n4.console.error ? n4.console.error.apply(n4.console, arguments) : i4(t5));
} };
function o3(t5, e3, r3) {
  var n5 = new XMLHttpRequest();
  n5.open("GET", t5), n5.responseType = "blob", n5.onload = function() {
    l3(n5.response, e3, r3);
  }, n5.onerror = function() {
    a3.error("could not download file");
  }, n5.send();
}
function s4(t5) {
  var e3 = new XMLHttpRequest();
  e3.open("HEAD", t5, false);
  try {
    e3.send();
  } catch (t6) {
  }
  return e3.status >= 200 && e3.status <= 299;
}
function c4(t5) {
  try {
    t5.dispatchEvent(new MouseEvent("click"));
  } catch (r3) {
    var e3 = document.createEvent("MouseEvents");
    e3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t5.dispatchEvent(e3);
  }
}
var u3;
var h3;
var l3 = n4.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== n4 ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t5, e3, r3) {
  var i5 = n4.URL || n4.webkitURL, a4 = document.createElement("a");
  e3 = e3 || t5.name || "download", a4.download = e3, a4.rel = "noopener", "string" == typeof t5 ? (a4.href = t5, a4.origin !== location.origin ? s4(a4.href) ? o3(t5, e3, r3) : c4(a4, a4.target = "_blank") : c4(a4)) : (a4.href = i5.createObjectURL(t5), setTimeout(function() {
    i5.revokeObjectURL(a4.href);
  }, 4e4), setTimeout(function() {
    c4(a4);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e3, r3, n5) {
  if (r3 = r3 || e3.name || "download", "string" == typeof e3)
    if (s4(e3))
      o3(e3, r3, n5);
    else {
      var i5 = document.createElement("a");
      i5.href = e3, i5.target = "_blank", setTimeout(function() {
        c4(i5);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e4, r4) {
      return void 0 === r4 ? r4 = { autoBom: false } : "object" !== _typeof(r4) && (a3.warn("Deprecated: Expected third argument to be a object"), r4 = { autoBom: !r4 }), r4.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e4.type) ? new Blob([String.fromCharCode(65279), e4], { type: e4.type }) : e4;
    }(e3, n5), r3);
} : function(e3, r3, i5, a4) {
  if ((a4 = a4 || open("", "_blank")) && (a4.document.title = a4.document.body.innerText = "downloading..."), "string" == typeof e3)
    return o3(e3, r3, i5);
  var s5 = "application/octet-stream" === e3.type, c5 = /constructor/i.test(n4.HTMLElement) || n4.safari, u4 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u4 || s5 && c5) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
    var h4 = new FileReader();
    h4.onloadend = function() {
      var t5 = h4.result;
      t5 = u4 ? t5 : t5.replace(/^data:[^;]*;/, "data:attachment/file;"), a4 ? a4.location.href = t5 : location = t5, a4 = null;
    }, h4.readAsDataURL(e3);
  } else {
    var l4 = n4.URL || n4.webkitURL, f5 = l4.createObjectURL(e3);
    a4 ? a4.location = f5 : location.href = f5, a4 = null, setTimeout(function() {
      l4.revokeObjectURL(f5);
    }, 4e4);
  }
});
function f4(t5) {
  var e3;
  t5 = t5 || "", this.ok = false, "#" == t5.charAt(0) && (t5 = t5.substr(1, 6));
  t5 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t5 = (t5 = t5.replace(/ /g, "")).toLowerCase()] || t5;
  for (var r3 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t6) {
    return [parseInt(t6[1]), parseInt(t6[2]), parseInt(t6[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t6) {
    return [parseInt(t6[1], 16), parseInt(t6[2], 16), parseInt(t6[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t6) {
    return [parseInt(t6[1] + t6[1], 16), parseInt(t6[2] + t6[2], 16), parseInt(t6[3] + t6[3], 16)];
  } }], n5 = 0; n5 < r3.length; n5++) {
    var i5 = r3[n5].re, a4 = r3[n5].process, o4 = i5.exec(t5);
    o4 && (e3 = a4(o4), this.r = e3[0], this.g = e3[1], this.b = e3[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t6 = this.r.toString(16), e4 = this.g.toString(16), r4 = this.b.toString(16);
    return 1 == t6.length && (t6 = "0" + t6), 1 == e4.length && (e4 = "0" + e4), 1 == r4.length && (r4 = "0" + r4), "#" + t6 + e4 + r4;
  };
}
function d2(t5, e3) {
  var r3 = t5[0], n5 = t5[1], i5 = t5[2], a4 = t5[3];
  r3 = g4(r3, n5, i5, a4, e3[0], 7, -680876936), a4 = g4(a4, r3, n5, i5, e3[1], 12, -389564586), i5 = g4(i5, a4, r3, n5, e3[2], 17, 606105819), n5 = g4(n5, i5, a4, r3, e3[3], 22, -1044525330), r3 = g4(r3, n5, i5, a4, e3[4], 7, -176418897), a4 = g4(a4, r3, n5, i5, e3[5], 12, 1200080426), i5 = g4(i5, a4, r3, n5, e3[6], 17, -1473231341), n5 = g4(n5, i5, a4, r3, e3[7], 22, -45705983), r3 = g4(r3, n5, i5, a4, e3[8], 7, 1770035416), a4 = g4(a4, r3, n5, i5, e3[9], 12, -1958414417), i5 = g4(i5, a4, r3, n5, e3[10], 17, -42063), n5 = g4(n5, i5, a4, r3, e3[11], 22, -1990404162), r3 = g4(r3, n5, i5, a4, e3[12], 7, 1804603682), a4 = g4(a4, r3, n5, i5, e3[13], 12, -40341101), i5 = g4(i5, a4, r3, n5, e3[14], 17, -1502002290), r3 = m5(r3, n5 = g4(n5, i5, a4, r3, e3[15], 22, 1236535329), i5, a4, e3[1], 5, -165796510), a4 = m5(a4, r3, n5, i5, e3[6], 9, -1069501632), i5 = m5(i5, a4, r3, n5, e3[11], 14, 643717713), n5 = m5(n5, i5, a4, r3, e3[0], 20, -373897302), r3 = m5(r3, n5, i5, a4, e3[5], 5, -701558691), a4 = m5(a4, r3, n5, i5, e3[10], 9, 38016083), i5 = m5(i5, a4, r3, n5, e3[15], 14, -660478335), n5 = m5(n5, i5, a4, r3, e3[4], 20, -405537848), r3 = m5(r3, n5, i5, a4, e3[9], 5, 568446438), a4 = m5(a4, r3, n5, i5, e3[14], 9, -1019803690), i5 = m5(i5, a4, r3, n5, e3[3], 14, -187363961), n5 = m5(n5, i5, a4, r3, e3[8], 20, 1163531501), r3 = m5(r3, n5, i5, a4, e3[13], 5, -1444681467), a4 = m5(a4, r3, n5, i5, e3[2], 9, -51403784), i5 = m5(i5, a4, r3, n5, e3[7], 14, 1735328473), r3 = v3(r3, n5 = m5(n5, i5, a4, r3, e3[12], 20, -1926607734), i5, a4, e3[5], 4, -378558), a4 = v3(a4, r3, n5, i5, e3[8], 11, -2022574463), i5 = v3(i5, a4, r3, n5, e3[11], 16, 1839030562), n5 = v3(n5, i5, a4, r3, e3[14], 23, -35309556), r3 = v3(r3, n5, i5, a4, e3[1], 4, -1530992060), a4 = v3(a4, r3, n5, i5, e3[4], 11, 1272893353), i5 = v3(i5, a4, r3, n5, e3[7], 16, -155497632), n5 = v3(n5, i5, a4, r3, e3[10], 23, -1094730640), r3 = v3(r3, n5, i5, a4, e3[13], 4, 681279174), a4 = v3(a4, r3, n5, i5, e3[0], 11, -358537222), i5 = v3(i5, a4, r3, n5, e3[3], 16, -722521979), n5 = v3(n5, i5, a4, r3, e3[6], 23, 76029189), r3 = v3(r3, n5, i5, a4, e3[9], 4, -640364487), a4 = v3(a4, r3, n5, i5, e3[12], 11, -421815835), i5 = v3(i5, a4, r3, n5, e3[15], 16, 530742520), r3 = b(r3, n5 = v3(n5, i5, a4, r3, e3[2], 23, -995338651), i5, a4, e3[0], 6, -198630844), a4 = b(a4, r3, n5, i5, e3[7], 10, 1126891415), i5 = b(i5, a4, r3, n5, e3[14], 15, -1416354905), n5 = b(n5, i5, a4, r3, e3[5], 21, -57434055), r3 = b(r3, n5, i5, a4, e3[12], 6, 1700485571), a4 = b(a4, r3, n5, i5, e3[3], 10, -1894986606), i5 = b(i5, a4, r3, n5, e3[10], 15, -1051523), n5 = b(n5, i5, a4, r3, e3[1], 21, -2054922799), r3 = b(r3, n5, i5, a4, e3[8], 6, 1873313359), a4 = b(a4, r3, n5, i5, e3[15], 10, -30611744), i5 = b(i5, a4, r3, n5, e3[6], 15, -1560198380), n5 = b(n5, i5, a4, r3, e3[13], 21, 1309151649), r3 = b(r3, n5, i5, a4, e3[4], 6, -145523070), a4 = b(a4, r3, n5, i5, e3[11], 10, -1120210379), i5 = b(i5, a4, r3, n5, e3[2], 15, 718787259), n5 = b(n5, i5, a4, r3, e3[9], 21, -343485551), t5[0] = _3(r3, t5[0]), t5[1] = _3(n5, t5[1]), t5[2] = _3(i5, t5[2]), t5[3] = _3(a4, t5[3]);
}
function p6(t5, e3, r3, n5, i5, a4) {
  return e3 = _3(_3(e3, t5), _3(n5, a4)), _3(e3 << i5 | e3 >>> 32 - i5, r3);
}
function g4(t5, e3, r3, n5, i5, a4, o4) {
  return p6(e3 & r3 | ~e3 & n5, t5, e3, i5, a4, o4);
}
function m5(t5, e3, r3, n5, i5, a4, o4) {
  return p6(e3 & n5 | r3 & ~n5, t5, e3, i5, a4, o4);
}
function v3(t5, e3, r3, n5, i5, a4, o4) {
  return p6(e3 ^ r3 ^ n5, t5, e3, i5, a4, o4);
}
function b(t5, e3, r3, n5, i5, a4, o4) {
  return p6(r3 ^ (e3 | ~n5), t5, e3, i5, a4, o4);
}
function y2(t5) {
  var e3, r3 = t5.length, n5 = [1732584193, -271733879, -1732584194, 271733878];
  for (e3 = 64; e3 <= t5.length; e3 += 64)
    d2(n5, w(t5.substring(e3 - 64, e3)));
  t5 = t5.substring(e3 - 64);
  var i5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e3 = 0; e3 < t5.length; e3++)
    i5[e3 >> 2] |= t5.charCodeAt(e3) << (e3 % 4 << 3);
  if (i5[e3 >> 2] |= 128 << (e3 % 4 << 3), e3 > 55)
    for (d2(n5, i5), e3 = 0; e3 < 16; e3++)
      i5[e3] = 0;
  return i5[14] = 8 * r3, d2(n5, i5), n5;
}
function w(t5) {
  var e3, r3 = [];
  for (e3 = 0; e3 < 64; e3 += 4)
    r3[e3 >> 2] = t5.charCodeAt(e3) + (t5.charCodeAt(e3 + 1) << 8) + (t5.charCodeAt(e3 + 2) << 16) + (t5.charCodeAt(e3 + 3) << 24);
  return r3;
}
u3 = n4.atob.bind(n4), h3 = n4.btoa.bind(n4);
var N2 = "0123456789abcdef".split("");
function L(t5) {
  for (var e3 = "", r3 = 0; r3 < 4; r3++)
    e3 += N2[t5 >> 8 * r3 + 4 & 15] + N2[t5 >> 8 * r3 & 15];
  return e3;
}
function A(t5) {
  return String.fromCharCode((255 & t5) >> 0, (65280 & t5) >> 8, (16711680 & t5) >> 16, (4278190080 & t5) >> 24);
}
function x(t5) {
  return y2(t5).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t5) {
  for (var e3 = 0; e3 < t5.length; e3++)
    t5[e3] = L(t5[e3]);
  return t5.join("");
}(y2("hello"));
function _3(t5, e3) {
  if (S) {
    var r3 = (65535 & t5) + (65535 & e3);
    return (t5 >> 16) + (e3 >> 16) + (r3 >> 16) << 16 | 65535 & r3;
  }
  return t5 + e3 & 4294967295;
}
function P(t5, e3) {
  var r3, n5, i5, a4;
  if (t5 !== r3) {
    for (var o4 = (i5 = t5, a4 = 1 + (256 / t5.length >> 0), new Array(a4 + 1).join(i5)), s5 = [], c5 = 0; c5 < 256; c5++)
      s5[c5] = c5;
    var u4 = 0;
    for (c5 = 0; c5 < 256; c5++) {
      var h4 = s5[c5];
      u4 = (u4 + h4 + o4.charCodeAt(c5)) % 256, s5[c5] = s5[u4], s5[u4] = h4;
    }
    r3 = t5, n5 = s5;
  } else
    s5 = n5;
  var l4 = e3.length, f5 = 0, d3 = 0, p7 = "";
  for (c5 = 0; c5 < l4; c5++)
    d3 = (d3 + (h4 = s5[f5 = (f5 + 1) % 256])) % 256, s5[f5] = s5[d3], s5[d3] = h4, o4 = s5[(s5[f5] + s5[d3]) % 256], p7 += String.fromCharCode(e3.charCodeAt(c5) ^ o4);
  return p7;
}
var k2 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t5, e3, r3, n5) {
  this.v = 1, this.r = 2;
  var i5 = 192;
  t5.forEach(function(t6) {
    if (void 0 !== k2.perm)
      throw new Error("Invalid permission: " + t6);
    i5 += k2[t6];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a4 = (e3 + this.padding).substr(0, 32), o4 = (r3 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a4, o4), this.P = -(1 + (255 ^ i5)), this.encryptionKey = x(a4 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n5)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t5) {
  if (/[^\u0000-\u00ff]/.test(t5))
    throw new Error("Invalid PDF Name Object: " + t5 + ", Only accept ASCII characters.");
  for (var e3 = "", r3 = t5.length, n5 = 0; n5 < r3; n5++) {
    var i5 = t5.charCodeAt(n5);
    if (i5 < 33 || 35 === i5 || 37 === i5 || 40 === i5 || 41 === i5 || 47 === i5 || 60 === i5 || 62 === i5 || 91 === i5 || 93 === i5 || 123 === i5 || 125 === i5 || i5 > 126)
      e3 += "#" + ("0" + i5.toString(16)).slice(-2);
    else
      e3 += t5[n5];
  }
  return e3;
}
function C(e3) {
  if ("object" !== _typeof(e3))
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r3 = {};
  this.subscribe = function(t5, e4, n5) {
    if (n5 = n5 || false, "string" != typeof t5 || "function" != typeof e4 || "boolean" != typeof n5)
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r3.hasOwnProperty(t5) || (r3[t5] = {});
    var i5 = Math.random().toString(35);
    return r3[t5][i5] = [e4, !!n5], i5;
  }, this.unsubscribe = function(t5) {
    for (var e4 in r3)
      if (r3[e4][t5])
        return delete r3[e4][t5], 0 === Object.keys(r3[e4]).length && delete r3[e4], true;
    return false;
  }, this.publish = function(t5) {
    if (r3.hasOwnProperty(t5)) {
      var i5 = Array.prototype.slice.call(arguments, 1), o4 = [];
      for (var s5 in r3[t5]) {
        var c5 = r3[t5][s5];
        try {
          c5[0].apply(e3, i5);
        } catch (t6) {
          n4.console && a3.error("jsPDF PubSub Error", t6.message, t6);
        }
        c5[1] && o4.push(s5);
      }
      o4.length && o4.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r3;
  };
}
function j2(t5) {
  if (!(this instanceof j2))
    return new j2(t5);
  var e3 = "opacity,stroke-opacity".split(",");
  for (var r3 in t5)
    t5.hasOwnProperty(r3) && e3.indexOf(r3) >= 0 && (this[r3] = t5[r3]);
  this.id = "", this.objectNumber = -1;
}
function O2(t5, e3) {
  this.gState = t5, this.matrix = e3, this.id = "", this.objectNumber = -1;
}
function B(t5, e3, r3, n5, i5) {
  if (!(this instanceof B))
    return new B(t5, e3, r3, n5, i5);
  this.type = "axial" === t5 ? 2 : 3, this.coords = e3, this.colors = r3, O2.call(this, n5, i5);
}
function M(t5, e3, r3, n5, i5) {
  if (!(this instanceof M))
    return new M(t5, e3, r3, n5, i5);
  this.boundingBox = t5, this.xStep = e3, this.yStep = r3, this.stream = "", this.cloneIndex = 0, O2.call(this, n5, i5);
}
function E(e3) {
  var r3, i5 = "string" == typeof arguments[0] ? arguments[0] : "p", o4 = arguments[1], s5 = arguments[2], c5 = arguments[3], u4 = [], d3 = 1, p7 = 16, g5 = "S", m6 = null;
  "object" === _typeof(e3 = e3 || {}) && (i5 = e3.orientation, o4 = e3.unit || o4, s5 = e3.format || s5, c5 = e3.compress || e3.compressPdf || c5, null !== (m6 = e3.encryption || null) && (m6.userPassword = m6.userPassword || "", m6.ownerPassword = m6.ownerPassword || "", m6.userPermissions = m6.userPermissions || []), d3 = "number" == typeof e3.userUnit ? Math.abs(e3.userUnit) : 1, void 0 !== e3.precision && (r3 = e3.precision), void 0 !== e3.floatPrecision && (p7 = e3.floatPrecision), g5 = e3.defaultPathOperation || "S"), u4 = e3.filters || (true === c5 ? ["FlateEncode"] : u4), o4 = o4 || "mm", i5 = ("" + (i5 || "P")).toLowerCase();
  var v4 = e3.putOnlyUsedFonts || false, b2 = {}, y3 = { internal: {}, __private__: {} };
  y3.__private__.PubSub = C;
  var w2 = "1.3", N3 = y3.__private__.getPdfVersion = function() {
    return w2;
  };
  y3.__private__.setPdfVersion = function(t5) {
    w2 = t5;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y3.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y3.__private__.getPageFormat = function(t5) {
    return L2[t5];
  };
  s5 = s5 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _4() {
    this.saveGraphicsState(), lt2(new Vt2(_t2, 0, 0, -_t2, 0, Rr() * _t2).toString() + " cm"), this.setFontSize(this.getFontSize() / _t2), g5 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g5 = "S", S2 = x2.COMPAT;
  }
  var k3 = y3.__private__.combineFontStyleAndFontWeight = function(t5, e4) {
    if ("bold" == t5 && "normal" == e4 || "bold" == t5 && 400 == e4 || "normal" == t5 && "italic" == e4 || "bold" == t5 && "italic" == e4)
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e4 && (t5 = 400 == e4 || "normal" === e4 ? "italic" === t5 ? "italic" : "normal" : 700 != e4 && "bold" !== e4 || "normal" !== t5 ? (700 == e4 ? "bold" : e4) + "" + t5 : "bold"), t5;
  };
  y3.advancedAPI = function(t5) {
    var e4 = S2 === x2.COMPAT;
    return e4 && _4.call(this), "function" != typeof t5 || (t5(this), e4 && P2.call(this)), this;
  }, y3.compatAPI = function(t5) {
    var e4 = S2 === x2.ADVANCED;
    return e4 && P2.call(this), "function" != typeof t5 || (t5(this), e4 && _4.call(this)), this;
  }, y3.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O3, q2 = function(t5) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t5 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y3.roundToPrecision = y3.__private__.roundToPrecision = function(t5, e4) {
    var n5 = r3 || e4;
    if (isNaN(t5) || isNaN(n5))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t5.toFixed(n5).replace(/0+$/, "");
  };
  O3 = y3.hpf = y3.__private__.hpf = "number" == typeof p7 ? function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t5, p7);
  } : "smart" === p7 ? function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t5, t5 > -1 && t5 < 1 ? 16 : 5);
  } : function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t5, 16);
  };
  var R2 = y3.f2 = y3.__private__.f2 = function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t5, 2);
  }, T3 = y3.__private__.f3 = function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t5, 3);
  }, U2 = y3.scale = y3.__private__.scale = function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t5 * _t2 : S2 === x2.ADVANCED ? t5 : void 0;
  }, z2 = function(t5) {
    return S2 === x2.COMPAT ? Rr() - t5 : S2 === x2.ADVANCED ? t5 : void 0;
  }, H2 = function(t5) {
    return U2(z2(t5));
  };
  y3.__private__.setPrecision = y3.setPrecision = function(t5) {
    "number" == typeof parseInt(t5, 10) && (r3 = parseInt(t5, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y3.__private__.getFileId = function() {
    return V2;
  }, Y2 = y3.__private__.setFileId = function(t5) {
    return V2 = void 0 !== t5 && /^[a-fA-F0-9]{32}$/.test(t5) ? t5.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m6 && (Ye = new I(m6.userPermissions, m6.userPassword, m6.ownerPassword, V2)), V2;
  };
  y3.setFileId = function(t5) {
    return Y2(t5), this;
  }, y3.getFileId = function() {
    return G2();
  };
  var J2 = y3.__private__.convertDateToPDFDate = function(t5) {
    var e4 = t5.getTimezoneOffset(), r4 = e4 < 0 ? "+" : "-", n5 = Math.floor(Math.abs(e4 / 60)), i6 = Math.abs(e4 % 60), a4 = [r4, Q2(n5), "'", Q2(i6), "'"].join("");
    return ["D:", t5.getFullYear(), Q2(t5.getMonth() + 1), Q2(t5.getDate()), Q2(t5.getHours()), Q2(t5.getMinutes()), Q2(t5.getSeconds()), a4].join("");
  }, X2 = y3.__private__.convertPDFDateToDate = function(t5) {
    var e4 = parseInt(t5.substr(2, 4), 10), r4 = parseInt(t5.substr(6, 2), 10) - 1, n5 = parseInt(t5.substr(8, 2), 10), i6 = parseInt(t5.substr(10, 2), 10), a4 = parseInt(t5.substr(12, 2), 10), o5 = parseInt(t5.substr(14, 2), 10);
    return new Date(e4, r4, n5, i6, a4, o5, 0);
  }, K2 = y3.__private__.setCreationDate = function(t5) {
    var e4;
    if (void 0 === t5 && (t5 = new Date()), t5 instanceof Date)
      e4 = J2(t5);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t5))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e4 = t5;
    }
    return W2 = e4;
  }, Z2 = y3.__private__.getCreationDate = function(t5) {
    var e4 = W2;
    return "jsDate" === t5 && (e4 = X2(W2)), e4;
  };
  y3.setCreationDate = function(t5) {
    return K2(t5), this;
  }, y3.getCreationDate = function(t5) {
    return Z2(t5);
  };
  var $2, Q2 = y3.__private__.padd2 = function(t5) {
    return ("0" + parseInt(t5)).slice(-2);
  }, tt2 = y3.__private__.padd2Hex = function(t5) {
    return ("00" + (t5 = t5.toString())).substr(t5.length);
  }, et3 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et3 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y3.__private__.setCustomOutputDestination = function(t5) {
    st2 = true, ct2 = t5;
  };
  var ht2 = function(t5) {
    st2 || (ct2 = t5);
  };
  y3.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y3.__private__.out = function(t5) {
    return t5 = t5.toString(), it2 += t5.length + 1, ct2.push(t5), ct2;
  }, ft2 = y3.__private__.write = function(t5) {
    return lt2(1 === arguments.length ? t5.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y3.__private__.getArrayBuffer = function(t5) {
    for (var e4 = t5.length, r4 = new ArrayBuffer(e4), n5 = new Uint8Array(r4); e4--; )
      n5[e4] = t5.charCodeAt(e4);
    return r4;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y3.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e3.fontSize || 16;
  y3.__private__.setFontSize = y3.setFontSize = function(t5) {
    return gt2 = S2 === x2.ADVANCED ? t5 / _t2 : t5, this;
  };
  var mt2, vt2 = y3.__private__.getFontSize = y3.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t2;
  }, bt2 = e3.R2L || false;
  y3.__private__.setR2L = y3.setR2L = function(t5) {
    return bt2 = t5, this;
  }, y3.__private__.getR2L = y3.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y3.__private__.setZoomMode = function(t5) {
    var e4 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t5))
      mt2 = t5;
    else if (isNaN(t5)) {
      if (-1 === e4.indexOf(t5))
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t5 + '" is not recognized.');
      mt2 = t5;
    } else
      mt2 = parseInt(t5, 10);
  };
  y3.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y3.__private__.setPageMode = function(t5) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t5))
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t5 + '" is not recognized.');
    yt2 = t5;
  };
  y3.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y3.__private__.setLayoutMode = function(t5) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t5))
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t5 + '" is not recognized.');
    Nt2 = t5;
  };
  y3.__private__.getLayoutMode = function() {
    return Nt2;
  }, y3.__private__.setDisplayMode = y3.setDisplayMode = function(t5, e4, r4) {
    return wt2(t5), At2(e4), Lt2(r4), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y3.__private__.getDocumentProperty = function(t5) {
    if (-1 === Object.keys(xt2).indexOf(t5))
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t5];
  }, y3.__private__.getDocumentProperties = function() {
    return xt2;
  }, y3.__private__.setDocumentProperties = y3.setProperties = y3.setDocumentProperties = function(t5) {
    for (var e4 in xt2)
      xt2.hasOwnProperty(e4) && t5[e4] && (xt2[e4] = t5[e4]);
    return this;
  }, y3.__private__.setDocumentProperty = function(t5, e4) {
    if (-1 === Object.keys(xt2).indexOf(t5))
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t5] = e4;
  };
  var St2, _t2, Pt2, kt2, It2, Ft2 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et2 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y3), Ut2 = e3.hotfixes || [], zt2 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t5(e4, r4, n5, i6, a4, o5) {
    if (!(this instanceof t5))
      return new t5(e4, r4, n5, i6, a4, o5);
    isNaN(e4) && (e4 = 1), isNaN(r4) && (r4 = 0), isNaN(n5) && (n5 = 0), isNaN(i6) && (i6 = 1), isNaN(a4) && (a4 = 0), isNaN(o5) && (o5 = 0), this._matrix = [e4, r4, n5, i6, a4, o5];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t5) {
    this._matrix[0] = t5;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t5) {
    this._matrix[1] = t5;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t5) {
    this._matrix[2] = t5;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t5) {
    this._matrix[3] = t5;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t5) {
    this._matrix[4] = t5;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t5) {
    this._matrix[5] = t5;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t5) {
    this._matrix[0] = t5;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t5) {
    this._matrix[1] = t5;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t5) {
    this._matrix[2] = t5;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t5) {
    this._matrix[3] = t5;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t5) {
    this._matrix[4] = t5;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t5) {
    this._matrix[5] = t5;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t5) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O3).join(t5);
  }, Vt2.prototype.multiply = function(t5) {
    var e4 = t5.sx * this.sx + t5.shy * this.shx, r4 = t5.sx * this.shy + t5.shy * this.sy, n5 = t5.shx * this.sx + t5.sy * this.shx, i6 = t5.shx * this.shy + t5.sy * this.sy, a4 = t5.tx * this.sx + t5.ty * this.shx + this.tx, o5 = t5.tx * this.shy + t5.ty * this.sy + this.ty;
    return new Vt2(e4, r4, n5, i6, a4, o5);
  }, Vt2.prototype.decompose = function() {
    var t5 = this.sx, e4 = this.shy, r4 = this.shx, n5 = this.sy, i6 = this.tx, a4 = this.ty, o5 = Math.sqrt(t5 * t5 + e4 * e4), s6 = (t5 /= o5) * r4 + (e4 /= o5) * n5;
    r4 -= t5 * s6, n5 -= e4 * s6;
    var c6 = Math.sqrt(r4 * r4 + n5 * n5);
    return s6 /= c6, t5 * (n5 /= c6) < e4 * (r4 /= c6) && (t5 = -t5, e4 = -e4, s6 = -s6, o5 = -o5), { scale: new Vt2(o5, 0, 0, c6, 0, 0), translate: new Vt2(1, 0, 0, 1, i6, a4), rotate: new Vt2(t5, e4, -e4, t5, 0, 0), skew: new Vt2(1, 0, s6, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t5) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t5 = this.sx, e4 = this.shy, r4 = this.shx, n5 = this.sy, i6 = this.tx, a4 = this.ty, o5 = 1 / (t5 * n5 - e4 * r4), s6 = n5 * o5, c6 = -e4 * o5, u5 = -r4 * o5, h4 = t5 * o5;
    return new Vt2(s6, c6, u5, h4, -s6 * i6 - u5 * a4, -c6 * i6 - h4 * a4);
  }, Vt2.prototype.applyToPoint = function(t5) {
    var e4 = t5.x * this.sx + t5.y * this.shx + this.tx, r4 = t5.x * this.shy + t5.y * this.sy + this.ty;
    return new Cr(e4, r4);
  }, Vt2.prototype.applyToRectangle = function(t5) {
    var e4 = this.applyToPoint(t5), r4 = this.applyToPoint(new Cr(t5.x + t5.w, t5.y + t5.h));
    return new jr(e4.x, e4.y, r4.x - e4.x, r4.y - e4.y);
  }, Vt2.prototype.clone = function() {
    var t5 = this.sx, e4 = this.shy, r4 = this.shx, n5 = this.sy, i6 = this.tx, a4 = this.ty;
    return new Vt2(t5, e4, r4, n5, i6, a4);
  }, y3.Matrix = Vt2;
  var Gt2 = y3.matrixMult = function(t5, e4) {
    return e4.multiply(t5);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y3.unitMatrix = y3.identityMatrix = Yt2;
  var Jt2 = function(t5, e4) {
    if (!Bt2[t5]) {
      var r4 = (e4 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e4.id = r4, Bt2[t5] = r4, Ot2[r4] = e4, Tt2.publish("addPattern", e4);
    }
  };
  y3.ShadingPattern = B, y3.TilingPattern = M, y3.addShadingPattern = function(t5, e4) {
    return q2("addShadingPattern()"), Jt2(t5, e4), this;
  }, y3.beginTilingPattern = function(t5) {
    q2("beginTilingPattern()"), Br(t5.boundingBox[0], t5.boundingBox[1], t5.boundingBox[2] - t5.boundingBox[0], t5.boundingBox[3] - t5.boundingBox[1], t5.matrix);
  }, y3.endTilingPattern = function(t5, e4) {
    q2("endTilingPattern()"), e4.stream = ot2[$2].join("\n"), Jt2(t5, e4), Tt2.publish("endTilingPattern", e4), Wt2.pop().restore();
  };
  var Xt2 = y3.__private__.newObject = function() {
    var t5 = Kt2();
    return Zt2(t5, true), t5;
  }, Kt2 = y3.__private__.newObjectDeferred = function() {
    return et3++, rt2[et3] = function() {
      return it2;
    }, et3;
  }, Zt2 = function(t5, e4) {
    return e4 = "boolean" == typeof e4 && e4, rt2[t5] = it2, e4 && lt2(t5 + " 0 obj"), t5;
  }, $t2 = y3.__private__.newAdditionalObject = function() {
    var t5 = { objId: Kt2(), content: "" };
    return at2.push(t5), t5;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y3.__private__.decodeColorString = function(t5) {
    var e4 = t5.split(" ");
    if (2 !== e4.length || "g" !== e4[1] && "G" !== e4[1]) {
      if (5 === e4.length && ("k" === e4[4] || "K" === e4[4])) {
        e4 = [(1 - e4[0]) * (1 - e4[3]), (1 - e4[1]) * (1 - e4[3]), (1 - e4[2]) * (1 - e4[3]), "r"];
      }
    } else {
      var r4 = parseFloat(e4[0]);
      e4 = [r4, r4, r4, "r"];
    }
    for (var n5 = "#", i6 = 0; i6 < 3; i6++)
      n5 += ("0" + Math.floor(255 * parseFloat(e4[i6])).toString(16)).slice(-2);
    return n5;
  }, re2 = y3.__private__.encodeColorString = function(e4) {
    var r4;
    "string" == typeof e4 && (e4 = { ch1: e4 });
    var n5 = e4.ch1, i6 = e4.ch2, a4 = e4.ch3, o5 = e4.ch4, s6 = "draw" === e4.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n5 && "#" !== n5.charAt(0)) {
      var c6 = new f4(n5);
      if (c6.ok)
        n5 = c6.toHex();
      else if (!/^\d*\.?\d*$/.test(n5))
        throw new Error('Invalid color "' + n5 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n5 && /^#[0-9A-Fa-f]{3}$/.test(n5) && (n5 = "#" + n5[1] + n5[1] + n5[2] + n5[2] + n5[3] + n5[3]), "string" == typeof n5 && /^#[0-9A-Fa-f]{6}$/.test(n5)) {
      var u5 = parseInt(n5.substr(1), 16);
      n5 = u5 >> 16 & 255, i6 = u5 >> 8 & 255, a4 = 255 & u5;
    }
    if (void 0 === i6 || void 0 === o5 && n5 === i6 && i6 === a4)
      if ("string" == typeof n5)
        r4 = n5 + " " + s6[0];
      else
        switch (e4.precision) {
          case 2:
            r4 = R2(n5 / 255) + " " + s6[0];
            break;
          case 3:
          default:
            r4 = T3(n5 / 255) + " " + s6[0];
        }
    else if (void 0 === o5 || "object" === _typeof(o5)) {
      if (o5 && !isNaN(o5.a) && 0 === o5.a)
        return r4 = ["1.", "1.", "1.", s6[1]].join(" ");
      if ("string" == typeof n5)
        r4 = [n5, i6, a4, s6[1]].join(" ");
      else
        switch (e4.precision) {
          case 2:
            r4 = [R2(n5 / 255), R2(i6 / 255), R2(a4 / 255), s6[1]].join(" ");
            break;
          default:
          case 3:
            r4 = [T3(n5 / 255), T3(i6 / 255), T3(a4 / 255), s6[1]].join(" ");
        }
    } else if ("string" == typeof n5)
      r4 = [n5, i6, a4, o5, s6[2]].join(" ");
    else
      switch (e4.precision) {
        case 2:
          r4 = [R2(n5), R2(i6), R2(a4), R2(o5), s6[2]].join(" ");
          break;
        case 3:
        default:
          r4 = [T3(n5), T3(i6), T3(a4), T3(o5), s6[2]].join(" ");
      }
    return r4;
  }, ne2 = y3.__private__.getFilters = function() {
    return u4;
  }, ie2 = y3.__private__.putStream = function(t5) {
    var e4 = (t5 = t5 || {}).data || "", r4 = t5.filters || ne2(), n5 = t5.alreadyAppliedFilters || [], i6 = t5.addLength1 || false, a4 = e4.length, o5 = t5.objectId, s6 = function(t6) {
      return t6;
    };
    if (null !== m6 && void 0 === o5)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m6 && (s6 = Ye.encryptor(o5, 0));
    var c6 = {};
    true === r4 && (r4 = ["FlateEncode"]);
    var u5 = t5.additionalKeyValues || [], h4 = (c6 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e4, r4) : { data: e4, reverseChain: [] }).reverseChain + (Array.isArray(n5) ? n5.join(" ") : n5.toString());
    if (0 !== c6.data.length && (u5.push({ key: "Length", value: c6.data.length }), true === i6 && u5.push({ key: "Length1", value: a4 })), 0 != h4.length)
      if (h4.split("/").length - 1 == 1)
        u5.push({ key: "Filter", value: h4 });
      else {
        u5.push({ key: "Filter", value: "[" + h4 + "]" });
        for (var l4 = 0; l4 < u5.length; l4 += 1)
          if ("DecodeParms" === u5[l4].key) {
            for (var f5 = [], d4 = 0; d4 < c6.reverseChain.split("/").length - 1; d4 += 1)
              f5.push("null");
            f5.push(u5[l4].value), u5[l4].value = "[" + f5.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p8 = 0; p8 < u5.length; p8++)
      lt2("/" + u5[p8].key + " " + u5[p8].value);
    lt2(">>"), 0 !== c6.data.length && (lt2("stream"), lt2(s6(c6.data)), lt2("endstream"));
  }, ae2 = y3.__private__.putPage = function(t5) {
    var e4 = t5.number, r4 = t5.data, n5 = t5.objId, i6 = t5.contentsObjId;
    Zt2(n5, true), lt2("<</Type /Page"), lt2("/Parent " + t5.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t5.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O3(t5.mediaBox.bottomLeftX)) + " " + parseFloat(O3(t5.mediaBox.bottomLeftY)) + " " + O3(t5.mediaBox.topRightX) + " " + O3(t5.mediaBox.topRightY) + "]"), null !== t5.cropBox && lt2("/CropBox [" + O3(t5.cropBox.bottomLeftX) + " " + O3(t5.cropBox.bottomLeftY) + " " + O3(t5.cropBox.topRightX) + " " + O3(t5.cropBox.topRightY) + "]"), null !== t5.bleedBox && lt2("/BleedBox [" + O3(t5.bleedBox.bottomLeftX) + " " + O3(t5.bleedBox.bottomLeftY) + " " + O3(t5.bleedBox.topRightX) + " " + O3(t5.bleedBox.topRightY) + "]"), null !== t5.trimBox && lt2("/TrimBox [" + O3(t5.trimBox.bottomLeftX) + " " + O3(t5.trimBox.bottomLeftY) + " " + O3(t5.trimBox.topRightX) + " " + O3(t5.trimBox.topRightY) + "]"), null !== t5.artBox && lt2("/ArtBox [" + O3(t5.artBox.bottomLeftX) + " " + O3(t5.artBox.bottomLeftY) + " " + O3(t5.artBox.topRightX) + " " + O3(t5.artBox.topRightY) + "]"), "number" == typeof t5.userUnit && 1 !== t5.userUnit && lt2("/UserUnit " + t5.userUnit), Tt2.publish("putPage", { objId: n5, pageContext: Rt2[e4], pageNumber: e4, page: r4 }), lt2("/Contents " + i6 + " 0 R"), lt2(">>"), lt2("endobj");
    var a4 = r4.join("\n");
    return S2 === x2.ADVANCED && (a4 += "\nQ"), Zt2(i6, true), ie2({ data: a4, filters: ne2(), objectId: i6 }), lt2("endobj"), n5;
  }, oe2 = y3.__private__.putPages = function() {
    var t5, e4, r4 = [];
    for (t5 = 1; t5 <= Dt2; t5++)
      Rt2[t5].objId = Kt2(), Rt2[t5].contentsObjId = Kt2();
    for (t5 = 1; t5 <= Dt2; t5++)
      r4.push(ae2({ number: t5, data: ot2[t5], objId: Rt2[t5].objId, contentsObjId: Rt2[t5].contentsObjId, mediaBox: Rt2[t5].mediaBox, cropBox: Rt2[t5].cropBox, bleedBox: Rt2[t5].bleedBox, trimBox: Rt2[t5].trimBox, artBox: Rt2[t5].artBox, userUnit: Rt2[t5].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n5 = "/Kids [";
    for (e4 = 0; e4 < Dt2; e4++)
      n5 += r4[e4] + " 0 R ";
    lt2(n5 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t5) {
    Tt2.publish("putFont", { font: t5, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t5.isAlreadyPutted && (t5.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t5.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t5.encoding && lt2("/Encoding /" + t5.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t5 in Ft2)
      Ft2.hasOwnProperty(t5) && (false === v4 || true === v4 && b2.hasOwnProperty(t5)) && se2(Ft2[t5]);
  }, ue2 = function(t5) {
    t5.objectNumber = Xt2();
    var e4 = [];
    e4.push({ key: "Type", value: "/XObject" }), e4.push({ key: "Subtype", value: "/Form" }), e4.push({ key: "BBox", value: "[" + [O3(t5.x), O3(t5.y), O3(t5.x + t5.width), O3(t5.y + t5.height)].join(" ") + "]" }), e4.push({ key: "Matrix", value: "[" + t5.matrix.toString() + "]" });
    var r4 = t5.pages[1].join("\n");
    ie2({ data: r4, additionalKeyValues: e4, objectId: t5.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t5 in zt2)
      zt2.hasOwnProperty(t5) && ue2(zt2[t5]);
  }, le2 = function(t5, e4) {
    var r4, n5 = [], i6 = 1 / (e4 - 1);
    for (r4 = 0; r4 < 1; r4 += i6)
      n5.push(r4);
    if (n5.push(1), 0 != t5[0].offset) {
      var a4 = { offset: 0, color: t5[0].color };
      t5.unshift(a4);
    }
    if (1 != t5[t5.length - 1].offset) {
      var o5 = { offset: 1, color: t5[t5.length - 1].color };
      t5.push(o5);
    }
    for (var s6 = "", c6 = 0, u5 = 0; u5 < n5.length; u5++) {
      for (r4 = n5[u5]; r4 > t5[c6 + 1].offset; )
        c6++;
      var h4 = t5[c6].offset, l4 = (r4 - h4) / (t5[c6 + 1].offset - h4), f5 = t5[c6].color, d4 = t5[c6 + 1].color;
      s6 += tt2(Math.round((1 - l4) * f5[0] + l4 * d4[0]).toString(16)) + tt2(Math.round((1 - l4) * f5[1] + l4 * d4[1]).toString(16)) + tt2(Math.round((1 - l4) * f5[2] + l4 * d4[2]).toString(16));
    }
    return s6.trim();
  }, fe2 = function(t5, e4) {
    e4 || (e4 = 21);
    var r4 = Xt2(), n5 = le2(t5.colors, e4), i6 = [];
    i6.push({ key: "FunctionType", value: "0" }), i6.push({ key: "Domain", value: "[0.0 1.0]" }), i6.push({ key: "Size", value: "[" + e4 + "]" }), i6.push({ key: "BitsPerSample", value: "8" }), i6.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i6.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n5, additionalKeyValues: i6, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r4 }), lt2("endobj"), t5.objectNumber = Xt2(), lt2("<< /ShadingType " + t5.type), lt2("/ColorSpace /DeviceRGB");
    var a4 = "/Coords [" + O3(parseFloat(t5.coords[0])) + " " + O3(parseFloat(t5.coords[1])) + " ";
    2 === t5.type ? a4 += O3(parseFloat(t5.coords[2])) + " " + O3(parseFloat(t5.coords[3])) : a4 += O3(parseFloat(t5.coords[2])) + " " + O3(parseFloat(t5.coords[3])) + " " + O3(parseFloat(t5.coords[4])) + " " + O3(parseFloat(t5.coords[5])), lt2(a4 += "]"), t5.matrix && lt2("/Matrix [" + t5.matrix.toString() + "]"), lt2("/Function " + r4 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t5, e4) {
    var r4 = Kt2(), n5 = Xt2();
    e4.push({ resourcesOid: r4, objectOid: n5 }), t5.objectNumber = n5;
    var i6 = [];
    i6.push({ key: "Type", value: "/Pattern" }), i6.push({ key: "PatternType", value: "1" }), i6.push({ key: "PaintType", value: "1" }), i6.push({ key: "TilingType", value: "1" }), i6.push({ key: "BBox", value: "[" + t5.boundingBox.map(O3).join(" ") + "]" }), i6.push({ key: "XStep", value: O3(t5.xStep) }), i6.push({ key: "YStep", value: O3(t5.yStep) }), i6.push({ key: "Resources", value: r4 + " 0 R" }), t5.matrix && i6.push({ key: "Matrix", value: "[" + t5.matrix.toString() + "]" }), ie2({ data: t5.stream, additionalKeyValues: i6, objectId: t5.objectNumber }), lt2("endobj");
  }, pe2 = function(t5) {
    var e4;
    for (e4 in Ot2)
      Ot2.hasOwnProperty(e4) && (Ot2[e4] instanceof B ? fe2(Ot2[e4]) : Ot2[e4] instanceof M && de2(Ot2[e4], t5));
  }, ge2 = function(t5) {
    for (var e4 in t5.objectNumber = Xt2(), lt2("<<"), t5)
      switch (e4) {
        case "opacity":
          lt2("/ca " + R2(t5[e4]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t5[e4]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t5;
    for (t5 in Mt2)
      Mt2.hasOwnProperty(t5) && ge2(Mt2[t5]);
  }, ve2 = function() {
    for (var t5 in lt2("/XObject <<"), zt2)
      zt2.hasOwnProperty(t5) && zt2[t5].objectNumber >= 0 && lt2("/" + t5 + " " + zt2[t5].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye.v), lt2("/R " + Ye.r), lt2("/U <" + Ye.toHexString(Ye.U) + ">"), lt2("/O <" + Ye.toHexString(Ye.O) + ">"), lt2("/P " + Ye.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t5 in lt2("/Font <<"), Ft2)
      Ft2.hasOwnProperty(t5) && (false === v4 || true === v4 && b2.hasOwnProperty(t5)) && lt2("/" + t5 + " " + Ft2[t5].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t5 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t5) && Ot2[t5] instanceof B && Ot2[t5].objectNumber >= 0 && lt2("/" + t5 + " " + Ot2[t5].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t5) {
    if (Object.keys(Ot2).length > 0) {
      for (var e4 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e4) && Ot2[e4] instanceof y3.TilingPattern && Ot2[e4].objectNumber >= 0 && Ot2[e4].objectNumber < t5 && lt2("/" + e4 + " " + Ot2[e4].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t5;
      for (t5 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t5) && Mt2[t5].objectNumber >= 0 && lt2("/" + t5 + " " + Mt2[t5].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae = function(t5) {
    Zt2(t5.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t5.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe = function() {
    var t5 = [];
    ce2(), me2(), he2(), pe2(t5), Tt2.publish("putResources"), t5.forEach(Ae), Ae({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t5 = 0; t5 < at2.length; t5++) {
      var e4 = at2[t5];
      Zt2(e4.objId, true), lt2(e4.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e = function(t5) {
    Ct2[t5.fontName] = Ct2[t5.fontName] || {}, Ct2[t5.fontName][t5.fontStyle] = t5.id;
  }, Pe = function(t5, e4, r4, n5, i6) {
    var a4 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t5, fontName: e4, fontStyle: r4, encoding: n5, isStandardFont: i6 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a4, instance: this }), Ft2[a4.id] = a4, _e(a4), a4.id;
  }, ke = function(t5) {
    for (var e4 = 0, r4 = pt2.length; e4 < r4; e4++) {
      var n5 = Pe.call(this, t5[e4][0], t5[e4][1], t5[e4][2], pt2[e4][3], true);
      false === v4 && (b2[n5] = true);
      var i6 = t5[e4][0].split("-");
      _e({ id: n5, fontName: i6[0], fontStyle: i6[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft2, dictionary: Ct2 });
  }, Ie = function(t5) {
    return t5.foo = function() {
      try {
        return t5.apply(this, arguments);
      } catch (t6) {
        var e4 = t6.stack || "";
        ~e4.indexOf(" at ") && (e4 = e4.split(" at ")[1]);
        var r4 = "Error in function " + e4.split("\n")[0].split("<")[0] + ": " + t6.message;
        if (!n4.console)
          throw new Error(r4);
        n4.console.error(r4, t6), n4.alert && alert(r4);
      }
    }, t5.foo.bar = t5, t5.foo;
  }, Fe = function(t5, e4) {
    var r4, n5, i6, a4, o5, s6, c6, u5, h4;
    if (i6 = (e4 = e4 || {}).sourceEncoding || "Unicode", o5 = e4.outputEncoding, (e4.autoencode || o5) && Ft2[St2].metadata && Ft2[St2].metadata[i6] && Ft2[St2].metadata[i6].encoding && (a4 = Ft2[St2].metadata[i6].encoding, !o5 && Ft2[St2].encoding && (o5 = Ft2[St2].encoding), !o5 && a4.codePages && (o5 = a4.codePages[0]), "string" == typeof o5 && (o5 = a4[o5]), o5)) {
      for (c6 = false, s6 = [], r4 = 0, n5 = t5.length; r4 < n5; r4++)
        (u5 = o5[t5.charCodeAt(r4)]) ? s6.push(String.fromCharCode(u5)) : s6.push(t5[r4]), s6[r4].charCodeAt(0) >> 8 && (c6 = true);
      t5 = s6.join("");
    }
    for (r4 = t5.length; void 0 === c6 && 0 !== r4; )
      t5.charCodeAt(r4 - 1) >> 8 && (c6 = true), r4--;
    if (!c6)
      return t5;
    for (s6 = e4.noBOM ? [] : [254, 255], r4 = 0, n5 = t5.length; r4 < n5; r4++) {
      if ((h4 = (u5 = t5.charCodeAt(r4)) >> 8) >> 8)
        throw new Error("Character at position " + r4 + " of string '" + t5 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s6.push(h4), s6.push(u5 - (h4 << 8));
    }
    return String.fromCharCode.apply(void 0, s6);
  }, Ce = y3.__private__.pdfEscape = y3.pdfEscape = function(t5, e4) {
    return Fe(t5, e4).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je = y3.__private__.beginPage = function(t5) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d3), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t5[0]), topRightY: Number(t5[1]) } }, Me(Dt2), ht2(ot2[$2]);
  }, Oe = function(t5, e4) {
    var r4, n5, o5;
    switch (i5 = e4 || i5, "string" == typeof t5 && (r4 = A2(t5.toLowerCase()), Array.isArray(r4) && (n5 = r4[0], o5 = r4[1])), Array.isArray(t5) && (n5 = t5[0] * _t2, o5 = t5[1] * _t2), isNaN(n5) && (n5 = s5[0], o5 = s5[1]), (n5 > 14400 || o5 > 14400) && (a3.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n5 = Math.min(14400, n5), o5 = Math.min(14400, o5)), s5 = [n5, o5], i5.substr(0, 1)) {
      case "l":
        o5 > n5 && (s5 = [o5, n5]);
        break;
      case "p":
        n5 > o5 && (s5 = [o5, n5]);
    }
    je(s5), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be = function(t5) {
    t5 > 0 && t5 <= Dt2 && (ot2.splice(t5, 1), Rt2.splice(t5, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me = function(t5) {
    t5 > 0 && t5 <= Dt2 && ($2 = t5);
  }, Ee = y3.__private__.getNumberOfPages = y3.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe = function(t5, e4, r4) {
    var n5, i6 = void 0;
    return r4 = r4 || {}, t5 = void 0 !== t5 ? t5 : Ft2[St2].fontName, e4 = void 0 !== e4 ? e4 : Ft2[St2].fontStyle, n5 = t5.toLowerCase(), void 0 !== Ct2[n5] && void 0 !== Ct2[n5][e4] ? i6 = Ct2[n5][e4] : void 0 !== Ct2[t5] && void 0 !== Ct2[t5][e4] ? i6 = Ct2[t5][e4] : false === r4.disableWarning && a3.warn("Unable to look up font label for font '" + t5 + "', '" + e4 + "'. Refer to getFontList() for available fonts."), i6 || r4.noFallback || null == (i6 = Ct2.times[e4]) && (i6 = Ct2.times.normal), i6;
  }, De = y3.__private__.putInfo = function() {
    var t5 = Xt2(), e4 = function(t6) {
      return t6;
    };
    for (var r4 in null !== m6 && (e4 = Ye.encryptor(t5, 0)), lt2("<<"), lt2("/Producer (" + Ce(e4("jsPDF " + E.version)) + ")"), xt2)
      xt2.hasOwnProperty(r4) && xt2[r4] && lt2("/" + r4.substr(0, 1).toUpperCase() + r4.substr(1) + " (" + Ce(e4(xt2[r4])) + ")");
    lt2("/CreationDate (" + Ce(e4(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re = y3.__private__.putCatalog = function(t5) {
    var e4 = (t5 = t5 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e4 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r4 = "" + mt2;
        "%" === r4.substr(r4.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te = y3.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et3 + 1)), lt2("/Root " + et3 + " 0 R"), lt2("/Info " + (et3 - 1) + " 0 R"), null !== m6 && lt2("/Encrypt " + Ye.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue = y3.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%\xBA\xDF\xAC\xE0");
  }, ze = y3.__private__.putXRef = function() {
    var t5 = "0000000000";
    lt2("xref"), lt2("0 " + (et3 + 1)), lt2("0000000000 65535 f ");
    for (var e4 = 1; e4 <= et3; e4++) {
      "function" == typeof rt2[e4] ? lt2((t5 + rt2[e4]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e4] ? lt2((t5 + rt2[e4]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He = y3.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue(), oe2(), Se(), xe(), null !== m6 && be2(), De(), Re();
    var t5 = it2;
    return ze(), Te(), lt2("startxref"), lt2("" + t5), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We = y3.__private__.getBlob = function(t5) {
    return new Blob([dt2(t5)], { type: "application/pdf" });
  }, Ve = y3.output = y3.__private__.output = Ie(function(t5, e4) {
    switch ("string" == typeof (e4 = e4 || {}) ? e4 = { filename: e4 } : e4.filename = e4.filename || "generated.pdf", t5) {
      case void 0:
        return He();
      case "save":
        y3.save(e4.filename);
        break;
      case "arraybuffer":
        return dt2(He());
      case "blob":
        return We(He());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n4.URL && "function" == typeof n4.URL.createObjectURL)
          return n4.URL && n4.URL.createObjectURL(We(He())) || void 0;
        a3.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r4 = "", i6 = He();
        try {
          r4 = h3(i6);
        } catch (t6) {
          r4 = h3(unescape(encodeURIComponent(i6)));
        }
        return "data:application/pdf;filename=" + e4.filename + ";base64," + r4;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n4)) {
          var o5 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s6 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e4.pdfObjectUrl && (o5 = e4.pdfObjectUrl, s6 = "");
          var c6 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o5 + '"' + s6 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e4) + ");<\/script></body></html>", u5 = n4.open();
          return null !== u5 && u5.document.write(c6), u5;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n4)) {
          var l4 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e4.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e4.filename + '" width="500px" height="400px" /></body></html>', f5 = n4.open();
          if (null !== f5) {
            f5.document.write(l4);
            var d4 = this;
            f5.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f5.document.title = e4.filename, f5.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d4.output("bloburl"));
            };
          }
          return f5;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n4))
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p8 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e4) + '"></iframe></body></html>', g6 = n4.open();
        if (null !== g6 && (g6.document.write(p8), g6.document.title = e4.filename), g6 || "undefined" == typeof safari)
          return g6;
        break;
      case "datauri":
      case "dataurl":
        return n4.document.location.href = this.output("datauristring", e4);
      default:
        return null;
    }
  }), Ge = function(t5) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t5) > -1;
  };
  switch (o4) {
    case "pt":
      _t2 = 1;
      break;
    case "mm":
      _t2 = 72 / 25.4;
      break;
    case "cm":
      _t2 = 72 / 2.54;
      break;
    case "in":
      _t2 = 72;
      break;
    case "px":
      _t2 = 1 == Ge("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t2 = 12;
      break;
    case "ex":
      _t2 = 6;
      break;
    default:
      if ("number" != typeof o4)
        throw new Error("Invalid unit: " + o4);
      _t2 = o4;
  }
  var Ye = null;
  K2(), Y2();
  var Je = function(t5) {
    return null !== m6 ? Ye.encryptor(t5, 0) : function(t6) {
      return t6;
    };
  }, Xe = y3.__private__.getPageInfo = y3.getPageInfo = function(t5) {
    if (isNaN(t5) || t5 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t5].objId, pageNumber: t5, pageContext: Rt2[t5] };
  }, Ke = y3.__private__.getPageInfoByObjId = function(t5) {
    if (isNaN(t5) || t5 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e4 in Rt2)
      if (Rt2[e4].objId === t5)
        break;
    return Xe(e4);
  }, Ze = y3.__private__.getCurrentPageInfo = y3.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y3.addPage = function() {
    return Oe.apply(this, arguments), this;
  }, y3.setPage = function() {
    return Me.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y3.insertPage = function(t5) {
    return this.addPage(), this.movePage($2, t5), this;
  }, y3.movePage = function(t5, e4) {
    var r4, n5;
    if (t5 > e4) {
      r4 = ot2[t5], n5 = Rt2[t5];
      for (var i6 = t5; i6 > e4; i6--)
        ot2[i6] = ot2[i6 - 1], Rt2[i6] = Rt2[i6 - 1];
      ot2[e4] = r4, Rt2[e4] = n5, this.setPage(e4);
    } else if (t5 < e4) {
      r4 = ot2[t5], n5 = Rt2[t5];
      for (var a4 = t5; a4 < e4; a4++)
        ot2[a4] = ot2[a4 + 1], Rt2[a4] = Rt2[a4 + 1];
      ot2[e4] = r4, Rt2[e4] = n5, this.setPage(e4);
    }
    return this;
  }, y3.deletePage = function() {
    return Be.apply(this, arguments), this;
  }, y3.__private__.text = y3.text = function(e4, r4, n5, i6, a4) {
    var o5, s6, c6, u5, h4, l4, f5, d4, p8, g6 = (i6 = i6 || {}).scope || this;
    if ("number" == typeof e4 && "number" == typeof r4 && ("string" == typeof n5 || Array.isArray(n5))) {
      var m7 = n5;
      n5 = r4, r4 = e4, e4 = m7;
    }
    if (arguments[3] instanceof Vt2 == false ? (c6 = arguments[4], u5 = arguments[5], "object" === _typeof(f5 = arguments[3]) && null !== f5 || ("string" == typeof c6 && (u5 = c6, c6 = null), "string" == typeof f5 && (u5 = f5, f5 = null), "number" == typeof f5 && (c6 = f5, f5 = null), i6 = { flags: f5, angle: c6, align: u5 })) : (q2("The transform parameter of text() with a Matrix value"), p8 = a4), isNaN(r4) || isNaN(n5) || null == e4)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e4.length)
      return g6;
    var v5 = "", y4 = false, w3 = "number" == typeof i6.lineHeightFactor ? i6.lineHeightFactor : lr, N4 = g6.internal.scaleFactor;
    function L3(t5) {
      return t5 = t5.split("	").join(Array(i6.TabLen || 9).join(" ")), Ce(t5, f5);
    }
    function A3(t5) {
      for (var e5, r5 = t5.concat(), n6 = [], i7 = r5.length; i7--; )
        "string" == typeof (e5 = r5.shift()) ? n6.push(e5) : Array.isArray(t5) && (1 === e5.length || void 0 === e5[1] && void 0 === e5[2]) ? n6.push(e5[0]) : n6.push([e5[0], e5[1], e5[2]]);
      return n6;
    }
    function _5(t5, e5) {
      var r5;
      if ("string" == typeof t5)
        r5 = e5(t5)[0];
      else if (Array.isArray(t5)) {
        for (var n6, i7, a5 = t5.concat(), o6 = [], s7 = a5.length; s7--; )
          "string" == typeof (n6 = a5.shift()) ? o6.push(e5(n6)[0]) : Array.isArray(n6) && "string" == typeof n6[0] && (i7 = e5(n6[0], n6[1], n6[2]), o6.push([i7[0], i7[1], i7[2]]));
        r5 = o6;
      }
      return r5;
    }
    var P3 = false, k4 = true;
    if ("string" == typeof e4)
      P3 = true;
    else if (Array.isArray(e4)) {
      var I2 = e4.concat();
      s6 = [];
      for (var F2, C2 = I2.length; C2--; )
        ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k4 = false);
      P3 = k4;
    }
    if (false === P3)
      throw new Error('Type of text must be string or Array. "' + e4 + '" is not recognized.');
    "string" == typeof e4 && (e4 = e4.match(/[\r?\n]/) ? e4.split(/\r\n|\r|\n/g) : [e4]);
    var j3 = gt2 / g6.internal.scaleFactor, B2 = j3 * (w3 - 1);
    switch (i6.baseline) {
      case "bottom":
        n5 -= B2;
        break;
      case "top":
        n5 += j3 - B2;
        break;
      case "hanging":
        n5 += j3 - 2 * B2;
        break;
      case "middle":
        n5 += j3 / 2 - B2;
    }
    if ((l4 = i6.maxWidth || 0) > 0 && ("string" == typeof e4 ? e4 = g6.splitTextToSize(e4, l4) : "[object Array]" === Object.prototype.toString.call(e4) && (e4 = e4.reduce(function(t5, e5) {
      return t5.concat(g6.splitTextToSize(e5, l4));
    }, []))), o5 = { text: e4, x: r4, y: n5, options: i6, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o5), e4 = o5.text, c6 = (i6 = o5.options).angle, p8 instanceof Vt2 == false && c6 && "number" == typeof c6) {
      c6 *= Math.PI / 180, 0 === i6.rotationDirection && (c6 = -c6), S2 === x2.ADVANCED && (c6 = -c6);
      var M2 = Math.cos(c6), E2 = Math.sin(c6);
      p8 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c6 && c6 instanceof Vt2 && (p8 = c6);
    S2 !== x2.ADVANCED || p8 || (p8 = Yt2), void 0 !== (h4 = i6.charSpace || _r) && (v5 += O3(U2(h4)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d4 = i6.horizontalScale) && (v5 += O3(100 * d4) + " Tz\n");
    i6.lang;
    var D3 = -1, R3 = void 0 !== i6.renderingMode ? i6.renderingMode : i6.stroke, T4 = g6.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T4.usedRenderingMode ? T4.usedRenderingMode : -1;
    -1 !== D3 ? v5 += D3 + " Tr\n" : -1 !== z3 && (v5 += "0 Tr\n"), -1 !== D3 && (T4.usedRenderingMode = D3), u5 = i6.align || "left";
    var H3, W3 = gt2 * w3, V3 = g6.internal.pageSize.getWidth(), G3 = Ft2[St2];
    h4 = i6.charSpace || _r, l4 = i6.maxWidth || 0, f5 = Object.assign({ autoencode: true, noBOM: true }, i6.flags);
    var Y3 = [];
    if ("[object Array]" === Object.prototype.toString.call(e4)) {
      var J3;
      s6 = A3(e4), "left" !== u5 && (H3 = s6.map(function(t5) {
        return g6.getStringUnitWidth(t5, { font: G3, charSpace: h4, fontSize: gt2, doKerning: false }) * gt2 / N4;
      }));
      var X3, K3 = 0;
      if ("right" === u5) {
        r4 -= H3[0], e4 = [], C2 = s6.length;
        for (var Z3 = 0; Z3 < C2; Z3++)
          0 === Z3 ? (X3 = br2(r4), J3 = yr(n5)) : (X3 = U2(K3 - H3[Z3]), J3 = -W3), e4.push([s6[Z3], X3, J3]), K3 = H3[Z3];
      } else if ("center" === u5) {
        r4 -= H3[0] / 2, e4 = [], C2 = s6.length;
        for (var $3 = 0; $3 < C2; $3++)
          0 === $3 ? (X3 = br2(r4), J3 = yr(n5)) : (X3 = U2((K3 - H3[$3]) / 2), J3 = -W3), e4.push([s6[$3], X3, J3]), K3 = H3[$3];
      } else if ("left" === u5) {
        e4 = [], C2 = s6.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          e4.push(s6[Q3]);
      } else {
        if ("justify" !== u5)
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e4 = [], C2 = s6.length, l4 = 0 !== l4 ? l4 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++)
          J3 = 0 === tt3 ? yr(n5) : -W3, X3 = 0 === tt3 ? br2(r4) : 0, tt3 < C2 - 1 ? Y3.push(O3(U2((l4 - H3[tt3]) / (s6[tt3].split(" ").length - 1)))) : Y3.push(0), e4.push([s6[tt3], X3, J3]);
      }
    }
    var et4 = "boolean" == typeof i6.R2L ? i6.R2L : bt2;
    true === et4 && (e4 = _5(e4, function(t5, e5, r5) {
      return [t5.split("").reverse().join(""), e5, r5];
    })), o5 = { text: e4, x: r4, y: n5, options: i6, mutex: { pdfEscape: Ce, activeFontKey: St2, fonts: Ft2, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o5), e4 = o5.text, y4 = o5.mutex.isHex || false;
    var rt3 = Ft2[St2].encoding;
    "WinAnsiEncoding" !== rt3 && "StandardEncoding" !== rt3 || (e4 = _5(e4, function(t5, e5, r5) {
      return [L3(t5), e5, r5];
    })), s6 = A3(e4), e4 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s6[0]) ? st3 : ot3, ut3 = "", ht3 = function(t5, e5, r5) {
      var n6 = "";
      return r5 instanceof Vt2 ? (r5 = "number" == typeof i6.angle ? Gt2(r5, new Vt2(1, 0, 0, 1, t5, e5)) : Gt2(new Vt2(1, 0, 0, 1, t5, e5), r5), S2 === x2.ADVANCED && (r5 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r5)), n6 = r5.join(" ") + " Tm\n") : n6 = O3(t5) + " " + O3(e5) + " Td\n", n6;
    }, ft3 = 0; ft3 < s6.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y4 ? "<" : "(") + s6[ft3][0] + (y4 ? ">" : ")"), nt3 = parseFloat(s6[ft3][1]), it3 = parseFloat(s6[ft3][2]);
          break;
        case ot3:
          at3 = (y4 ? "<" : "(") + s6[ft3] + (y4 ? ">" : ")"), nt3 = br2(r4), it3 = yr(n5);
      }
      void 0 !== Y3 && void 0 !== Y3[ft3] && (ut3 = Y3[ft3] + " Tw\n"), 0 === ft3 ? e4.push(ut3 + ht3(nt3, it3, p8) + at3) : ct3 === ot3 ? e4.push(ut3 + at3) : ct3 === st3 && e4.push(ut3 + ht3(nt3, it3, p8) + at3);
    }
    e4 = ct3 === ot3 ? e4.join(" Tj\nT* ") : e4.join(" Tj\n"), e4 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St2 + " " + gt2 + " Tf\n", dt3 += O3(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v5, dt3 += e4, lt2(dt3 += "ET"), b2[St2] = true, g6;
  };
  var $e = y3.__private__.clip = y3.clip = function(t5) {
    return lt2("evenodd" === t5 ? "W*" : "W"), this;
  };
  y3.clipEvenOdd = function() {
    return $e("evenodd");
  }, y3.__private__.discardPath = y3.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe = y3.__private__.isValidStyle = function(t5) {
    var e4 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t5) && (e4 = true), e4;
  };
  y3.__private__.setDefaultPathOperation = y3.setDefaultPathOperation = function(t5) {
    return Qe(t5) && (g5 = t5), this;
  };
  var tr = y3.__private__.getStyle = y3.getStyle = function(t5) {
    var e4 = g5;
    switch (t5) {
      case "D":
      case "S":
        e4 = "S";
        break;
      case "F":
        e4 = "f";
        break;
      case "FD":
      case "DF":
        e4 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e4 = t5;
    }
    return e4;
  }, er = y3.close = function() {
    return lt2("h"), this;
  };
  y3.stroke = function() {
    return lt2("S"), this;
  }, y3.fill = function(t5) {
    return rr("f", t5), this;
  }, y3.fillEvenOdd = function(t5) {
    return rr("f*", t5), this;
  }, y3.fillStroke = function(t5) {
    return rr("B", t5), this;
  }, y3.fillStrokeEvenOdd = function(t5) {
    return rr("B*", t5), this;
  };
  var rr = function(e4, r4) {
    "object" === _typeof(r4) ? ar(r4, e4) : lt2(e4);
  }, nr = function(t5) {
    null === t5 || S2 === x2.ADVANCED && void 0 === t5 || (t5 = tr(t5), lt2(t5));
  };
  function ir(t5, e4, r4, n5, i6) {
    var a4 = new M(e4 || this.boundingBox, r4 || this.xStep, n5 || this.yStep, this.gState, i6 || this.matrix);
    a4.stream = this.stream;
    var o5 = t5 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o5, a4), a4;
  }
  var ar = function(t5, e4) {
    var r4 = Bt2[t5.key], n5 = Ot2[r4];
    if (n5 instanceof B)
      lt2("q"), lt2(or(e4)), n5.gState && y3.setGState(n5.gState), lt2(t5.matrix.toString() + " cm"), lt2("/" + r4 + " sh"), lt2("Q");
    else if (n5 instanceof M) {
      var i6 = new Vt2(1, 0, 0, -1, 0, Rr());
      t5.matrix && (i6 = i6.multiply(t5.matrix || Yt2), r4 = ir.call(n5, t5.key, t5.boundingBox, t5.xStep, t5.yStep, i6).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r4 + " scn"), n5.gState && y3.setGState(n5.gState), lt2(e4), lt2("Q");
    }
  }, or = function(t5) {
    switch (t5) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y3.moveTo = function(t5, e4) {
    return lt2(O3(U2(t5)) + " " + O3(H2(e4)) + " m"), this;
  }, cr = y3.lineTo = function(t5, e4) {
    return lt2(O3(U2(t5)) + " " + O3(H2(e4)) + " l"), this;
  }, ur = y3.curveTo = function(t5, e4, r4, n5, i6, a4) {
    return lt2([O3(U2(t5)), O3(H2(e4)), O3(U2(r4)), O3(H2(n5)), O3(U2(i6)), O3(H2(a4)), "c"].join(" ")), this;
  };
  y3.__private__.line = y3.line = function(t5, e4, r4, n5, i6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n5) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r4 - t5, n5 - e4]], t5, e4, [1, 1], i6 || "S") : this.lines([[r4 - t5, n5 - e4]], t5, e4, [1, 1]).stroke();
  }, y3.__private__.lines = y3.lines = function(t5, e4, r4, n5, i6, a4) {
    var o5, s6, c6, u5, h4, l4, f5, d4, p8, g6, m7, v5;
    if ("number" == typeof t5 && (v5 = r4, r4 = e4, e4 = t5, t5 = v5), n5 = n5 || [1, 1], a4 = a4 || false, isNaN(e4) || isNaN(r4) || !Array.isArray(t5) || !Array.isArray(n5) || !Qe(i6) || "boolean" != typeof a4)
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e4, r4), o5 = n5[0], s6 = n5[1], u5 = t5.length, g6 = e4, m7 = r4, c6 = 0; c6 < u5; c6++)
      2 === (h4 = t5[c6]).length ? (g6 = h4[0] * o5 + g6, m7 = h4[1] * s6 + m7, cr(g6, m7)) : (l4 = h4[0] * o5 + g6, f5 = h4[1] * s6 + m7, d4 = h4[2] * o5 + g6, p8 = h4[3] * s6 + m7, g6 = h4[4] * o5 + g6, m7 = h4[5] * s6 + m7, ur(l4, f5, d4, p8, g6, m7));
    return a4 && er(), nr(i6), this;
  }, y3.path = function(t5) {
    for (var e4 = 0; e4 < t5.length; e4++) {
      var r4 = t5[e4], n5 = r4.c;
      switch (r4.op) {
        case "m":
          sr(n5[0], n5[1]);
          break;
        case "l":
          cr(n5[0], n5[1]);
          break;
        case "c":
          ur.apply(this, n5);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y3.__private__.rect = y3.rect = function(t5, e4, r4, n5, i6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n5) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n5 = -n5), lt2([O3(U2(t5)), O3(H2(e4)), O3(U2(r4)), O3(U2(n5)), "re"].join(" ")), nr(i6), this;
  }, y3.__private__.triangle = y3.triangle = function(t5, e4, r4, n5, i6, a4, o5) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n5) || isNaN(i6) || isNaN(a4) || !Qe(o5))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r4 - t5, n5 - e4], [i6 - r4, a4 - n5], [t5 - i6, e4 - a4]], t5, e4, [1, 1], o5, true), this;
  }, y3.__private__.roundedRect = y3.roundedRect = function(t5, e4, r4, n5, i6, a4, o5) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n5) || isNaN(i6) || isNaN(a4) || !Qe(o5))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s6 = 4 / 3 * (Math.SQRT2 - 1);
    return i6 = Math.min(i6, 0.5 * r4), a4 = Math.min(a4, 0.5 * n5), this.lines([[r4 - 2 * i6, 0], [i6 * s6, 0, i6, a4 - a4 * s6, i6, a4], [0, n5 - 2 * a4], [0, a4 * s6, -i6 * s6, a4, -i6, a4], [2 * i6 - r4, 0], [-i6 * s6, 0, -i6, -a4 * s6, -i6, -a4], [0, 2 * a4 - n5], [0, -a4 * s6, i6 * s6, -a4, i6, -a4]], t5 + i6, e4, [1, 1], o5, true), this;
  }, y3.__private__.ellipse = y3.ellipse = function(t5, e4, r4, n5, i6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n5) || !Qe(i6))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a4 = 4 / 3 * (Math.SQRT2 - 1) * r4, o5 = 4 / 3 * (Math.SQRT2 - 1) * n5;
    return sr(t5 + r4, e4), ur(t5 + r4, e4 - o5, t5 + a4, e4 - n5, t5, e4 - n5), ur(t5 - a4, e4 - n5, t5 - r4, e4 - o5, t5 - r4, e4), ur(t5 - r4, e4 + o5, t5 - a4, e4 + n5, t5, e4 + n5), ur(t5 + a4, e4 + n5, t5 + r4, e4 + o5, t5 + r4, e4), nr(i6), this;
  }, y3.__private__.circle = y3.circle = function(t5, e4, r4, n5) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || !Qe(n5))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t5, e4, r4, r4, n5);
  }, y3.setFont = function(t5, e4, r4) {
    return r4 && (e4 = k3(e4, r4)), St2 = qe(t5, e4, { disableWarning: false }), this;
  };
  var hr2 = y3.__private__.getFont = y3.getFont = function() {
    return Ft2[qe.apply(y3, arguments)];
  };
  y3.__private__.getFontList = y3.getFontList = function() {
    var t5, e4, r4 = {};
    for (t5 in Ct2)
      if (Ct2.hasOwnProperty(t5))
        for (e4 in r4[t5] = [], Ct2[t5])
          Ct2[t5].hasOwnProperty(e4) && r4[t5].push(e4);
    return r4;
  }, y3.addFont = function(t5, e4, r4, n5, i6) {
    var a4 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a4.indexOf(arguments[3]) ? i6 = arguments[3] : arguments[3] && -1 == a4.indexOf(arguments[3]) && (r4 = k3(r4, n5)), i6 = i6 || "Identity-H", Pe.call(this, t5, e4, r4, i6);
  };
  var lr, fr = e3.lineWidth || 0.200025, dr = y3.__private__.getLineWidth = y3.getLineWidth = function() {
    return fr;
  }, pr = y3.__private__.setLineWidth = y3.setLineWidth = function(t5) {
    return fr = t5, lt2(O3(U2(t5)) + " w"), this;
  };
  y3.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t5, e4) {
    if (t5 = t5 || [], e4 = e4 || 0, isNaN(e4) || !Array.isArray(t5))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t5 = t5.map(function(t6) {
      return O3(U2(t6));
    }).join(" "), e4 = O3(U2(e4)), lt2("[" + t5 + "] " + e4 + " d"), this;
  };
  var gr = y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt2 * lr;
  };
  y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y3.__private__.setLineHeightFactor = y3.setLineHeightFactor = function(t5) {
    return "number" == typeof (t5 = t5 || 1.15) && (lr = t5), this;
  }, vr = y3.__private__.getLineHeightFactor = y3.getLineHeightFactor = function() {
    return lr;
  };
  mr(e3.lineHeight);
  var br2 = y3.__private__.getHorizontalCoordinate = function(t5) {
    return U2(t5);
  }, yr = y3.__private__.getVerticalCoordinate = function(t5) {
    return S2 === x2.ADVANCED ? t5 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t5);
  }, wr = y3.__private__.getHorizontalCoordinateString = y3.getHorizontalCoordinateString = function(t5) {
    return O3(br2(t5));
  }, Nr = y3.__private__.getVerticalCoordinateString = y3.getVerticalCoordinateString = function(t5) {
    return O3(yr(t5));
  }, Lr = e3.strokeColor || "0 G";
  y3.__private__.getStrokeColor = y3.getDrawColor = function() {
    return ee2(Lr);
  }, y3.__private__.setStrokeColor = y3.setDrawColor = function(t5, e4, r4, n5) {
    return Lr = re2({ ch1: t5, ch2: e4, ch3: r4, ch4: n5, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e3.fillColor || "0 g";
  y3.__private__.getFillColor = y3.getFillColor = function() {
    return ee2(Ar);
  }, y3.__private__.setFillColor = y3.setFillColor = function(t5, e4, r4, n5) {
    return Ar = re2({ ch1: t5, ch2: e4, ch3: r4, ch4: n5, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e3.textColor || "0 g", Sr = y3.__private__.getTextColor = y3.getTextColor = function() {
    return ee2(xr);
  };
  y3.__private__.setTextColor = y3.setTextColor = function(t5, e4, r4, n5) {
    return xr = re2({ ch1: t5, ch2: e4, ch3: r4, ch4: n5, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e3.charSpace, Pr = y3.__private__.getCharSpace = y3.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y3.__private__.setCharSpace = y3.setCharSpace = function(t5) {
    if (isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t5, this;
  };
  var kr = 0;
  y3.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y3.__private__.setLineCap = y3.setLineCap = function(t5) {
    var e4 = y3.CapJoinStyles[t5];
    if (void 0 === e4)
      throw new Error("Line cap style of '" + t5 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e4, lt2(e4 + " J"), this;
  };
  var Ir = 0;
  y3.__private__.setLineJoin = y3.setLineJoin = function(t5) {
    var e4 = y3.CapJoinStyles[t5];
    if (void 0 === e4)
      throw new Error("Line join style of '" + t5 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e4, lt2(e4 + " j"), this;
  }, y3.__private__.setLineMiterLimit = y3.__private__.setMiterLimit = y3.setLineMiterLimit = y3.setMiterLimit = function(t5) {
    if (t5 = t5 || 0, isNaN(t5))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O3(U2(t5)) + " M"), this;
  }, y3.GState = j2, y3.setGState = function(t5) {
    (t5 = "string" == typeof t5 ? Mt2[Et2[t5]] : Fr(null, t5)).equals(qt2) || (lt2("/" + t5.id + " gs"), qt2 = t5);
  };
  var Fr = function(t5, e4) {
    if (!t5 || !Et2[t5]) {
      var r4 = false;
      for (var n5 in Mt2)
        if (Mt2.hasOwnProperty(n5) && Mt2[n5].equals(e4)) {
          r4 = true;
          break;
        }
      if (r4)
        e4 = Mt2[n5];
      else {
        var i6 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i6] = e4, e4.id = i6;
      }
      return t5 && (Et2[t5] = e4.id), Tt2.publish("addGState", e4), e4;
    }
  };
  y3.addGState = function(t5, e4) {
    return Fr(t5, e4), this;
  }, y3.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y3.restoreGraphicsState = function() {
    lt2("Q");
    var t5 = jt2.pop();
    return St2 = t5.key, gt2 = t5.size, xr = t5.color, qt2 = null, this;
  }, y3.setCurrentTransformationMatrix = function(t5) {
    return lt2(t5.toString() + " cm"), this;
  }, y3.comment = function(t5) {
    return lt2("#" + t5), this;
  };
  var Cr = function(t5, e4) {
    var r4 = t5 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r4;
    }, set: function(t6) {
      isNaN(t6) || (r4 = parseFloat(t6));
    } });
    var n5 = e4 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n5;
    }, set: function(t6) {
      isNaN(t6) || (n5 = parseFloat(t6));
    } });
    var i6 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i6;
    }, set: function(t6) {
      i6 = t6.toString();
    } }), this;
  }, jr = function(t5, e4, r4, n5) {
    Cr.call(this, t5, e4), this.type = "rect";
    var i6 = r4 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i6;
    }, set: function(t6) {
      isNaN(t6) || (i6 = parseFloat(t6));
    } });
    var a4 = n5 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a4;
    }, set: function(t6) {
      isNaN(t6) || (a4 = parseFloat(t6));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t5, e4, r4, n5, i6) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t5, kt2 = e4, It2 = i6, je([r4, n5]);
  }, Mr = function(t5) {
    if (Ht2[t5])
      Wt2.pop().restore();
    else {
      var e4 = new Or(), r4 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
      e4.id = r4, Ht2[t5] = r4, zt2[r4] = e4, Tt2.publish("addFormObject", e4), Wt2.pop().restore();
    }
  };
  for (var Er in y3.beginFormObject = function(t5, e4, r4, n5, i6) {
    return Br(t5, e4, r4, n5, i6), this;
  }, y3.endFormObject = function(t5) {
    return Mr(t5), this;
  }, y3.doFormObject = function(t5, e4) {
    var r4 = zt2[Ht2[t5]];
    return lt2("q"), lt2(e4.toString() + " cm"), lt2("/" + r4.id + " Do"), lt2("Q"), this;
  }, y3.getFormObject = function(t5) {
    var e4 = zt2[Ht2[t5]];
    return { x: e4.x, y: e4.y, width: e4.width, height: e4.height, matrix: e4.matrix };
  }, y3.save = function(t5, e4) {
    return t5 = t5 || "generated.pdf", (e4 = e4 || {}).returnPromise = e4.returnPromise || false, false === e4.returnPromise ? (l3(We(He()), t5), "function" == typeof l3.unload && n4.setTimeout && setTimeout(l3.unload, 911), this) : new Promise(function(e5, r4) {
      try {
        var i6 = l3(We(He()), t5);
        "function" == typeof l3.unload && n4.setTimeout && setTimeout(l3.unload, 911), e5(i6);
      } catch (t6) {
        r4(t6.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t5, e4) {
      var r4, n5, i6;
      for (i6 = e4.length - 1; -1 !== i6; i6--)
        r4 = e4[i6][0], n5 = e4[i6][1], t5.subscribe.apply(t5, [r4].concat("function" == typeof n5 ? [n5] : n5));
    }(Tt2, E.API.events) : y3[Er] = E.API[Er]);
  var qr = y3.getPageWidth = function(t5) {
    return (Rt2[t5 = t5 || $2].mediaBox.topRightX - Rt2[t5].mediaBox.bottomLeftX) / _t2;
  }, Dr = y3.setPageWidth = function(t5, e4) {
    Rt2[t5].mediaBox.topRightX = e4 * _t2 + Rt2[t5].mediaBox.bottomLeftX;
  }, Rr = y3.getPageHeight = function(t5) {
    return (Rt2[t5 = t5 || $2].mediaBox.topRightY - Rt2[t5].mediaBox.bottomLeftY) / _t2;
  }, Tr = y3.setPageHeight = function(t5, e4) {
    Rt2[t5].mediaBox.topRightY = e4 * _t2 + Rt2[t5].mediaBox.bottomLeftY;
  };
  return y3.internal = { pdfEscape: Ce, getStyle: tr, getFont: hr2, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br2, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t2, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t5) {
    Dr($2, t5);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t5) {
    Tr($2, t5);
  } }, encryptionOptions: m6, encryption: Ye, getEncryptor: Je, output: Ve, getNumberOfPages: Ee, pages: ot2, out: lt2, f2: R2, f3: T3, getPageInfo: Xe, getPageInfoByObjId: Ke, getCurrentPageInfo: Ze, getPDFVersion: N3, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge }, Object.defineProperty(y3.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t5) {
    Dr($2, t5);
  }, enumerable: true, configurable: true }), Object.defineProperty(y3.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t5) {
    Tr($2, t5);
  }, enumerable: true, configurable: true }), ke.call(y3, pt2), St2 = "F1", Oe(s5, i5), Tt2.publish("initialized"), y3;
}
I.prototype.lsbFirstWord = function(t5) {
  return String.fromCharCode(t5 >> 0 & 255, t5 >> 8 & 255, t5 >> 16 & 255, t5 >> 24 & 255);
}, I.prototype.toHexString = function(t5) {
  return t5.split("").map(function(t6) {
    return ("0" + (255 & t6.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t5) {
  for (var e3 = [], r3 = 0; r3 < t5.length; r3 += 2)
    e3.push(String.fromCharCode(parseInt(t5.substr(r3, 2), 16)));
  return e3.join("");
}, I.prototype.processOwnerPassword = function(t5, e3) {
  return P(x(e3).substr(0, 5), t5);
}, I.prototype.encryptor = function(t5, e3) {
  var r3 = x(this.encryptionKey + String.fromCharCode(255 & t5, t5 >> 8 & 255, t5 >> 16 & 255, 255 & e3, e3 >> 8 & 255)).substr(0, 10);
  return function(t6) {
    return P(r3, t6);
  };
}, j2.prototype.equals = function(e3) {
  var r3, n5 = "id,objectNumber,equals";
  if (!e3 || _typeof(e3) !== _typeof(this))
    return false;
  var i5 = 0;
  for (r3 in this)
    if (!(n5.indexOf(r3) >= 0)) {
      if (this.hasOwnProperty(r3) && !e3.hasOwnProperty(r3))
        return false;
      if (this[r3] !== e3[r3])
        return false;
      i5++;
    }
  for (r3 in e3)
    e3.hasOwnProperty(r3) && n5.indexOf(r3) < 0 && i5--;
  return 0 === i5;
}, E.API = { events: [] }, E.version = "2.5.1";
var q = E.API;
var D = 1;
var R = function(t5) {
  return t5.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
};
var T2 = function(t5) {
  return t5.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var U = function(t5) {
  return t5.toFixed(2);
};
var z = function(t5) {
  return t5.toFixed(5);
};
q.__acroform__ = {};
var H = function(t5, e3) {
  t5.prototype = Object.create(e3.prototype), t5.prototype.constructor = t5;
};
var W = function(t5) {
  return t5 * D;
};
var V = function(t5) {
  var e3 = new ut(), r3 = At.internal.getHeight(t5) || 0, n5 = At.internal.getWidth(t5) || 0;
  return e3.BBox = [0, 0, Number(U(n5)), Number(U(r3))], e3;
};
var G = q.__acroform__.setBit = function(t5, e3) {
  if (t5 = t5 || 0, e3 = e3 || 0, isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t5 |= 1 << e3;
};
var Y = q.__acroform__.clearBit = function(t5, e3) {
  if (t5 = t5 || 0, e3 = e3 || 0, isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t5 &= ~(1 << e3);
};
var J = q.__acroform__.getBit = function(t5, e3) {
  if (isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t5 & 1 << e3) ? 0 : 1;
};
var X = q.__acroform__.getBitForPdf = function(t5, e3) {
  if (isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t5, e3 - 1);
};
var K = q.__acroform__.setBitForPdf = function(t5, e3) {
  if (isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t5, e3 - 1);
};
var Z = q.__acroform__.clearBitForPdf = function(t5, e3) {
  if (isNaN(t5) || isNaN(e3))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t5, e3 - 1);
};
var $ = q.__acroform__.calculateCoordinates = function(t5, e3) {
  var r3 = e3.internal.getHorizontalCoordinate, n5 = e3.internal.getVerticalCoordinate, i5 = t5[0], a4 = t5[1], o4 = t5[2], s5 = t5[3], c5 = {};
  return c5.lowerLeft_X = r3(i5) || 0, c5.lowerLeft_Y = n5(a4 + s5) || 0, c5.upperRight_X = r3(i5 + o4) || 0, c5.upperRight_Y = n5(a4) || 0, [Number(U(c5.lowerLeft_X)), Number(U(c5.lowerLeft_Y)), Number(U(c5.upperRight_X)), Number(U(c5.upperRight_Y))];
};
var Q = function(t5) {
  if (t5.appearanceStreamContent)
    return t5.appearanceStreamContent;
  if (t5.V || t5.DV) {
    var e3 = [], r3 = t5._V || t5.DV, n5 = tt(t5, r3), i5 = t5.scope.internal.getFont(t5.fontName, t5.fontStyle).id;
    e3.push("/Tx BMC"), e3.push("q"), e3.push("BT"), e3.push(t5.scope.__private__.encodeColorString(t5.color)), e3.push("/" + i5 + " " + U(n5.fontSize) + " Tf"), e3.push("1 0 0 1 0 0 Tm"), e3.push(n5.text), e3.push("ET"), e3.push("Q"), e3.push("EMC");
    var a4 = V(t5);
    return a4.scope = t5.scope, a4.stream = e3.join("\n"), a4;
  }
};
var tt = function(t5, e3) {
  var r3 = 0 === t5.fontSize ? t5.maxFontSize : t5.fontSize, n5 = { text: "", fontSize: "" }, i5 = (e3 = ")" == (e3 = "(" == e3.substr(0, 1) ? e3.substr(1) : e3).substr(e3.length - 1) ? e3.substr(0, e3.length - 1) : e3).split(" ");
  i5 = t5.multiline ? i5.map(function(t6) {
    return t6.split("\n");
  }) : i5.map(function(t6) {
    return [t6];
  });
  var a4 = r3, o4 = At.internal.getHeight(t5) || 0;
  o4 = o4 < 0 ? -o4 : o4;
  var s5 = At.internal.getWidth(t5) || 0;
  s5 = s5 < 0 ? -s5 : s5;
  var c5 = function(e4, r4, n6) {
    if (e4 + 1 < i5.length) {
      var a5 = r4 + " " + i5[e4 + 1][0];
      return et2(a5, t5, n6).width <= s5 - 4;
    }
    return false;
  };
  a4++;
  t:
    for (; a4 > 0; ) {
      e3 = "", a4--;
      var u4, h4, l4 = et2("3", t5, a4).height, f5 = t5.multiline ? o4 - a4 : (o4 - l4) / 2, d3 = f5 += 2, p7 = 0, g5 = 0, m6 = 0;
      if (a4 <= 0) {
        e3 = "(...) Tj\n", e3 += "% Width of Text: " + et2(e3, t5, a4 = 12).width + ", FieldWidth:" + s5 + "\n";
        break;
      }
      for (var v4 = "", b2 = 0, y3 = 0; y3 < i5.length; y3++)
        if (i5.hasOwnProperty(y3)) {
          var w2 = false;
          if (1 !== i5[y3].length && m6 !== i5[y3].length - 1) {
            if ((l4 + 2) * (b2 + 2) + 2 > o4)
              continue t;
            v4 += i5[y3][m6], w2 = true, g5 = y3, y3--;
          } else {
            v4 = " " == (v4 += i5[y3][m6] + " ").substr(v4.length - 1) ? v4.substr(0, v4.length - 1) : v4;
            var N3 = parseInt(y3), L2 = c5(N3, v4, a4), A2 = y3 >= i5.length - 1;
            if (L2 && !A2) {
              v4 += " ", m6 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g5 = N3;
              else if (t5.multiline && (l4 + 2) * (b2 + 2) + 2 > o4)
                continue t;
            } else {
              if (!t5.multiline)
                continue t;
              if ((l4 + 2) * (b2 + 2) + 2 > o4)
                continue t;
              g5 = N3;
            }
          }
          for (var x2 = "", S2 = p7; S2 <= g5; S2++) {
            var _4 = i5[S2];
            if (t5.multiline) {
              if (S2 === g5) {
                x2 += _4[m6] + " ", m6 = (m6 + 1) % _4.length;
                continue;
              }
              if (S2 === p7) {
                x2 += _4[_4.length - 1] + " ";
                continue;
              }
            }
            x2 += _4[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h4 = et2(x2, t5, a4).width, t5.textAlign) {
            case "right":
              u4 = s5 - h4 - 2;
              break;
            case "center":
              u4 = (s5 - h4) / 2;
              break;
            case "left":
            default:
              u4 = 2;
          }
          e3 += U(u4) + " " + U(d3) + " Td\n", e3 += "(" + R(x2) + ") Tj\n", e3 += -U(u4) + " 0 Td\n", d3 = -(a4 + 2), h4 = 0, p7 = w2 ? g5 : g5 + 1, b2++, v4 = "";
        } else
          ;
      break;
    }
  return n5.text = e3, n5.fontSize = a4, n5;
};
var et2 = function(t5, e3, r3) {
  var n5 = e3.scope.internal.getFont(e3.fontName, e3.fontStyle), i5 = e3.scope.getStringUnitWidth(t5, { font: n5, fontSize: parseFloat(r3), charSpace: 0 }) * parseFloat(r3);
  return { height: e3.scope.getStringUnitWidth("3", { font: n5, fontSize: parseFloat(r3), charSpace: 0 }) * parseFloat(r3) * 1.5, width: i5 };
};
var rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
var nt = function(t5, e3) {
  var r3 = { type: "reference", object: t5 };
  void 0 === e3.internal.getPageInfo(t5.page).pageContext.annotations.find(function(t6) {
    return t6.type === r3.type && t6.object === r3.object;
  }) && e3.internal.getPageInfo(t5.page).pageContext.annotations.push(r3);
};
var it = function(e3, r3) {
  for (var n5 in e3)
    if (e3.hasOwnProperty(n5)) {
      var i5 = n5, a4 = e3[n5];
      r3.internal.newObjectDeferredBegin(a4.objId, true), "object" === _typeof(a4) && "function" == typeof a4.putStream && a4.putStream(), delete e3[i5];
    }
};
var at = function(e3, r3) {
  if (r3.scope = e3, void 0 !== e3.internal && (void 0 === e3.internal.acroformPlugin || false === e3.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e3.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e3.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e3.internal.scaleFactor, e3.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e3.internal.acroformPlugin.acroFormDictionaryRoot.scope = e3, e3.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e3.internal.events.subscribe("postPutResources", function() {
      !function(t5) {
        t5.internal.events.unsubscribe(t5.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t5.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t5.internal.acroformPlugin.printedOut = true;
      }(e3);
    }), e3.internal.events.subscribe("buildDocument", function() {
      !function(t5) {
        t5.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e4 = t5.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r4 in e4)
          if (e4.hasOwnProperty(r4)) {
            var n5 = e4[r4];
            n5.objId = void 0, n5.hasAnnotation && nt(n5, t5);
          }
      }(e3);
    }), e3.internal.events.subscribe("putCatalog", function() {
      !function(t5) {
        if (void 0 === t5.internal.acroformPlugin.acroFormDictionaryRoot)
          throw new Error("putCatalogCallback: Root missing.");
        t5.internal.write("/AcroForm " + t5.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e3);
    }), e3.internal.events.subscribe("postPutPages", function(r4) {
      !function(e4, r5) {
        var n5 = !e4;
        for (var i5 in e4 || (r5.internal.newObjectDeferredBegin(r5.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r5.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e4 = e4 || r5.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e4.hasOwnProperty(i5)) {
            var a4 = e4[i5], o4 = [], s5 = a4.Rect;
            if (a4.Rect && (a4.Rect = $(a4.Rect, r5)), r5.internal.newObjectDeferredBegin(a4.objId, true), a4.DA = At.createDefaultAppearanceStream(a4), "object" === _typeof(a4) && "function" == typeof a4.getKeyValueListForStream && (o4 = a4.getKeyValueListForStream()), a4.Rect = s5, a4.hasAppearanceStream && !a4.appearanceStreamContent) {
              var c5 = Q(a4);
              o4.push({ key: "AP", value: "<</N " + c5 + ">>" }), r5.internal.acroformPlugin.xForms.push(c5);
            }
            if (a4.appearanceStreamContent) {
              var u4 = "";
              for (var h4 in a4.appearanceStreamContent)
                if (a4.appearanceStreamContent.hasOwnProperty(h4)) {
                  var l4 = a4.appearanceStreamContent[h4];
                  if (u4 += "/" + h4 + " ", u4 += "<<", Object.keys(l4).length >= 1 || Array.isArray(l4)) {
                    for (var i5 in l4)
                      if (l4.hasOwnProperty(i5)) {
                        var f5 = l4[i5];
                        "function" == typeof f5 && (f5 = f5.call(r5, a4)), u4 += "/" + i5 + " " + f5 + " ", r5.internal.acroformPlugin.xForms.indexOf(f5) >= 0 || r5.internal.acroformPlugin.xForms.push(f5);
                      }
                  } else
                    "function" == typeof (f5 = l4) && (f5 = f5.call(r5, a4)), u4 += "/" + i5 + " " + f5, r5.internal.acroformPlugin.xForms.indexOf(f5) >= 0 || r5.internal.acroformPlugin.xForms.push(f5);
                  u4 += ">>";
                }
              o4.push({ key: "AP", value: "<<\n" + u4 + ">>" });
            }
            r5.internal.putStream({ additionalKeyValues: o4, objectId: a4.objId }), r5.internal.out("endobj");
          }
        n5 && it(r5.internal.acroformPlugin.xForms, r5);
      }(r4, e3);
    }), e3.internal.acroformPlugin.isInitialized = true;
  }
};
var ot = q.__acroform__.arrayToPdfArray = function(e3, r3, n5) {
  var i5 = function(t5) {
    return t5;
  };
  if (Array.isArray(e3)) {
    for (var a4 = "[", o4 = 0; o4 < e3.length; o4++)
      switch (0 !== o4 && (a4 += " "), _typeof(e3[o4])) {
        case "boolean":
        case "number":
        case "object":
          a4 += e3[o4].toString();
          break;
        case "string":
          "/" !== e3[o4].substr(0, 1) ? (void 0 !== r3 && n5 && (i5 = n5.internal.getEncryptor(r3)), a4 += "(" + R(i5(e3[o4].toString())) + ")") : a4 += e3[o4].toString();
      }
    return a4 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t5, e3, r3) {
  var n5 = function(t6) {
    return t6;
  };
  return void 0 !== e3 && r3 && (n5 = r3.internal.getEncryptor(e3)), (t5 = t5 || "").toString(), t5 = "(" + R(n5(t5)) + ")";
};
var ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t5) {
    this._objId = t5;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t5 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t5, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t5 = [], e3 = Object.getOwnPropertyNames(this).filter(function(t6) {
    return "content" != t6 && "appearanceStreamContent" != t6 && "scope" != t6 && "objId" != t6 && "_" != t6.substring(0, 1);
  });
  for (var r3 in e3)
    if (false === Object.getOwnPropertyDescriptor(this, e3[r3]).configurable) {
      var n5 = e3[r3], i5 = this[n5];
      i5 && (Array.isArray(i5) ? t5.push({ key: n5, value: ot(i5, this.objId, this.scope) }) : i5 instanceof ct ? (i5.scope = this.scope, t5.push({ key: n5, value: i5.objId + " 0 R" })) : "function" != typeof i5 && t5.push({ key: n5, value: i5 }));
    }
  return t5;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t5, e3 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e3;
  }, set: function(t6) {
    e3 = t6;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e4) {
    t5 = e4.trim();
  }, get: function() {
    return t5 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t5, e3 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e3.length > 0 ? e3 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e3;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t5) {
      var e4 = function(t6) {
        return t6;
      };
      return this.scope && (e4 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e4(t5)) + ")";
    }
  }, set: function(e4) {
    t5 = e4;
  } });
};
H(ht, ct);
var lt = function t4() {
  ct.call(this);
  var e3 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e3;
  }, set: function(t5) {
    if (isNaN(t5))
      throw new Error('Invalid value "' + t5 + '" for attribute F supplied.');
    e3 = t5;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e3, 3));
  }, set: function(t5) {
    true === Boolean(t5) ? this.F = K(e3, 3) : this.F = Z(e3, 3);
  } });
  var r3 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r3;
  }, set: function(t5) {
    if (isNaN(t5))
      throw new Error('Invalid value "' + t5 + '" for attribute Ff supplied.');
    r3 = t5;
  } });
  var n5 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n5.length)
      return n5;
  }, set: function(t5) {
    n5 = void 0 !== t5 ? t5 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n5 || isNaN(n5[0]) ? 0 : n5[0];
  }, set: function(t5) {
    n5[0] = t5;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n5 || isNaN(n5[1]) ? 0 : n5[1];
  }, set: function(t5) {
    n5[1] = t5;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n5 || isNaN(n5[2]) ? 0 : n5[2];
  }, set: function(t5) {
    n5[2] = t5;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n5 || isNaN(n5[3]) ? 0 : n5[3];
  }, set: function(t5) {
    n5[3] = t5;
  } });
  var i5 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i5;
  }, set: function(t5) {
    switch (t5) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i5 = t5;
        break;
      default:
        throw new Error('Invalid value "' + t5 + '" for attribute FT supplied.');
    }
  } });
  var a4 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a4 || a4.length < 1) {
      if (this instanceof yt)
        return;
      a4 = "FieldObject" + t4.FieldNum++;
    }
    var e4 = function(t5) {
      return t5;
    };
    return this.scope && (e4 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e4(a4)) + ")";
  }, set: function(t5) {
    a4 = t5.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a4;
  }, set: function(t5) {
    a4 = t5;
  } });
  var o4 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o4;
  }, set: function(t5) {
    o4 = t5;
  } });
  var s5 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s5;
  }, set: function(t5) {
    s5 = t5;
  } });
  var c5 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c5;
  }, set: function(t5) {
    c5 = t5;
  } });
  var u4 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u4 ? 50 / D : u4;
  }, set: function(t5) {
    u4 = t5;
  } });
  var h4 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h4;
  }, set: function(t5) {
    h4 = t5;
  } });
  var l4 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l4 || this instanceof yt || this instanceof Nt))
      return st(l4, this.objId, this.scope);
  }, set: function(t5) {
    t5 = t5.toString(), l4 = t5;
  } });
  var f5 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f5)
      return this instanceof mt == false ? st(f5, this.objId, this.scope) : f5;
  }, set: function(t5) {
    t5 = t5.toString(), f5 = this instanceof mt == false ? "(" === t5.substr(0, 1) ? T2(t5.substr(1, t5.length - 2)) : T2(t5) : t5;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(f5.substr(1, f5.length - 1)) : f5;
  }, set: function(t5) {
    t5 = t5.toString(), f5 = this instanceof mt == true ? "/" + t5 : t5;
  } });
  var d3 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d3)
      return d3;
  }, set: function(t5) {
    this.V = t5;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d3)
      return this instanceof mt == false ? st(d3, this.objId, this.scope) : d3;
  }, set: function(t5) {
    t5 = t5.toString(), d3 = this instanceof mt == false ? "(" === t5.substr(0, 1) ? T2(t5.substr(1, t5.length - 2)) : T2(t5) : t5;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T2(d3.substr(1, d3.length - 1)) : d3;
  }, set: function(t5) {
    t5 = t5.toString(), d3 = this instanceof mt == true ? "/" + t5 : t5;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p7, g5 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g5;
  }, set: function(t5) {
    t5 = Boolean(t5), g5 = t5;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p7)
      return p7;
  }, set: function(t5) {
    p7 = t5;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m6 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m6)
      return m6;
  }, set: function(t5) {
    if (-1 === [0, 1, 2].indexOf(t5))
      throw new Error('Invalid value "' + t5 + '" for attribute Q supplied.');
    m6 = t5;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t5;
    switch (m6) {
      case 0:
      default:
        t5 = "left";
        break;
      case 1:
        t5 = "center";
        break;
      case 2:
        t5 = "right";
    }
    return t5;
  }, configurable: true, enumerable: true, set: function(t5) {
    switch (t5) {
      case "right":
      case 2:
        m6 = 2;
        break;
      case "center":
      case 1:
        m6 = 1;
        break;
      case "left":
      case 0:
      default:
        m6 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t5 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t5;
  }, set: function(e4) {
    t5 = e4;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t5;
  }, set: function(e4) {
    t5 = e4;
  } });
  var e3 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e3, this.objId, this.scope);
  }, set: function(t6) {
    var r3, n5;
    n5 = [], "string" == typeof (r3 = t6) && (n5 = function(t7, e4, r4) {
      r4 || (r4 = 1);
      for (var n6, i5 = []; n6 = e4.exec(t7); )
        i5.push(n6[r4]);
      return i5;
    }(r3, /\((.*?)\)/g)), e3 = n5;
  } }), this.getOptions = function() {
    return e3;
  }, this.setOptions = function(t6) {
    e3 = t6, this.sort && e3.sort();
  }, this.addOption = function(t6) {
    t6 = (t6 = t6 || "").toString(), e3.push(t6), this.sort && e3.sort();
  }, this.removeOption = function(t6, r3) {
    for (r3 = r3 || false, t6 = (t6 = t6 || "").toString(); -1 !== e3.indexOf(t6) && (e3.splice(e3.indexOf(t6), 1), false !== r3); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t6) {
    true === this.combo && (true === Boolean(t6) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t6) {
    true === Boolean(t6) ? (this.Ff = K(this.Ff, 20), e3.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e3, r3 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t5 = function(t6) {
      return t6;
    };
    if (this.scope && (t5 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r3).length) {
      var e4, n5 = [];
      for (e4 in n5.push("<<"), r3)
        n5.push("/" + e4 + " (" + R(t5(r3[e4])) + ")");
      return n5.push(">>"), n5.join("\n");
    }
  }, set: function(e4) {
    "object" === _typeof(e4) && (r3 = e4);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r3.CA || "";
  }, set: function(t5) {
    "string" == typeof t5 && (r3.CA = t5);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e3;
  }, set: function(t5) {
    e3 = t5;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e3.substr(1, e3.length - 1);
  }, set: function(t5) {
    e3 = "/" + t5;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t5 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t5;
  }, set: function(e3) {
    t5 = void 0 !== e3 ? e3 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e3, r3;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e3;
  }, set: function(t5) {
    e3 = t5;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r3;
  }, set: function(t5) {
    r3 = t5;
  } });
  var n5, i5 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t5 = function(t6) {
      return t6;
    };
    this.scope && (t5 = this.scope.internal.getEncryptor(this.objId));
    var e4, r4 = [];
    for (e4 in r4.push("<<"), i5)
      r4.push("/" + e4 + " (" + R(t5(i5[e4])) + ")");
    return r4.push(">>"), r4.join("\n");
  }, set: function(e4) {
    "object" === _typeof(e4) && (i5 = e4);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i5.CA || "";
  }, set: function(t5) {
    "string" == typeof t5 && (i5.CA = t5);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n5;
  }, set: function(t5) {
    n5 = t5;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n5.substr(1, n5.length - 1);
  }, set: function(t5) {
    n5 = "/" + t5;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t5) {
  if (!("createAppearanceStream" in t5) || !("getCA" in t5))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e3 in this.Kids)
    if (this.Kids.hasOwnProperty(e3)) {
      var r3 = this.Kids[e3];
      r3.appearanceStreamContent = t5.createAppearanceStream(r3.optionName), r3.caption = t5.getCA();
    }
}, bt.prototype.createOption = function(t5) {
  var e3 = new yt();
  return e3.Parent = this, e3.optionName = t5, this.Kids.push(e3), xt.call(this.scope, e3), e3;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t6) {
    true === Boolean(t6) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t5 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t5;
  }, set: function(e3) {
    t5 = e3;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t5;
  }, set: function(e3) {
    Number.isInteger(e3) && (t5 = e3);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t5) {
    true === Boolean(t5) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [], n5 = t5.scope.internal.getFont(t5.fontName, t5.fontStyle).id, i5 = t5.scope.__private__.encodeColorString(t5.color), a4 = tt(t5, t5.caption);
  return r3.push("0.749023 g"), r3.push("0 0 " + U(At.internal.getWidth(t5)) + " " + U(At.internal.getHeight(t5)) + " re"), r3.push("f"), r3.push("BMC"), r3.push("q"), r3.push("0 0 1 rg"), r3.push("/" + n5 + " " + U(a4.fontSize) + " Tf " + i5), r3.push("BT"), r3.push(a4.text), r3.push("ET"), r3.push("Q"), r3.push("EMC"), e3.stream = r3.join("\n"), e3;
}, YesNormal: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = t5.scope.internal.getFont(t5.fontName, t5.fontStyle).id, n5 = t5.scope.__private__.encodeColorString(t5.color), i5 = [], a4 = At.internal.getHeight(t5), o4 = At.internal.getWidth(t5), s5 = tt(t5, t5.caption);
  return i5.push("1 g"), i5.push("0 0 " + U(o4) + " " + U(a4) + " re"), i5.push("f"), i5.push("q"), i5.push("0 0 1 rg"), i5.push("0 0 " + U(o4 - 1) + " " + U(a4 - 1) + " re"), i5.push("W"), i5.push("n"), i5.push("0 g"), i5.push("BT"), i5.push("/" + r3 + " " + U(s5.fontSize) + " Tf " + n5), i5.push(s5.text), i5.push("ET"), i5.push("Q"), e3.stream = i5.join("\n"), e3;
}, OffPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [];
  return r3.push("0.749023 g"), r3.push("0 0 " + U(At.internal.getWidth(t5)) + " " + U(At.internal.getHeight(t5)) + " re"), r3.push("f"), e3.stream = r3.join("\n"), e3;
} }, RadioButton: { Circle: { createAppearanceStream: function(t5) {
  var e3 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e3.N[t5] = At.RadioButton.Circle.YesNormal, e3.D[t5] = At.RadioButton.Circle.YesPushDown, e3;
}, getCA: function() {
  return "l";
}, YesNormal: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [], n5 = At.internal.getWidth(t5) <= At.internal.getHeight(t5) ? At.internal.getWidth(t5) / 4 : At.internal.getHeight(t5) / 4;
  n5 = Number((0.9 * n5).toFixed(5));
  var i5 = At.internal.Bezier_C, a4 = Number((n5 * i5).toFixed(5));
  return r3.push("q"), r3.push("1 0 0 1 " + z(At.internal.getWidth(t5) / 2) + " " + z(At.internal.getHeight(t5) / 2) + " cm"), r3.push(n5 + " 0 m"), r3.push(n5 + " " + a4 + " " + a4 + " " + n5 + " 0 " + n5 + " c"), r3.push("-" + a4 + " " + n5 + " -" + n5 + " " + a4 + " -" + n5 + " 0 c"), r3.push("-" + n5 + " -" + a4 + " -" + a4 + " -" + n5 + " 0 -" + n5 + " c"), r3.push(a4 + " -" + n5 + " " + n5 + " -" + a4 + " " + n5 + " 0 c"), r3.push("f"), r3.push("Q"), e3.stream = r3.join("\n"), e3;
}, YesPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [], n5 = At.internal.getWidth(t5) <= At.internal.getHeight(t5) ? At.internal.getWidth(t5) / 4 : At.internal.getHeight(t5) / 4;
  n5 = Number((0.9 * n5).toFixed(5));
  var i5 = Number((2 * n5).toFixed(5)), a4 = Number((i5 * At.internal.Bezier_C).toFixed(5)), o4 = Number((n5 * At.internal.Bezier_C).toFixed(5));
  return r3.push("0.749023 g"), r3.push("q"), r3.push("1 0 0 1 " + z(At.internal.getWidth(t5) / 2) + " " + z(At.internal.getHeight(t5) / 2) + " cm"), r3.push(i5 + " 0 m"), r3.push(i5 + " " + a4 + " " + a4 + " " + i5 + " 0 " + i5 + " c"), r3.push("-" + a4 + " " + i5 + " -" + i5 + " " + a4 + " -" + i5 + " 0 c"), r3.push("-" + i5 + " -" + a4 + " -" + a4 + " -" + i5 + " 0 -" + i5 + " c"), r3.push(a4 + " -" + i5 + " " + i5 + " -" + a4 + " " + i5 + " 0 c"), r3.push("f"), r3.push("Q"), r3.push("0 g"), r3.push("q"), r3.push("1 0 0 1 " + z(At.internal.getWidth(t5) / 2) + " " + z(At.internal.getHeight(t5) / 2) + " cm"), r3.push(n5 + " 0 m"), r3.push(n5 + " " + o4 + " " + o4 + " " + n5 + " 0 " + n5 + " c"), r3.push("-" + o4 + " " + n5 + " -" + n5 + " " + o4 + " -" + n5 + " 0 c"), r3.push("-" + n5 + " -" + o4 + " -" + o4 + " -" + n5 + " 0 -" + n5 + " c"), r3.push(o4 + " -" + n5 + " " + n5 + " -" + o4 + " " + n5 + " 0 c"), r3.push("f"), r3.push("Q"), e3.stream = r3.join("\n"), e3;
}, OffPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [], n5 = At.internal.getWidth(t5) <= At.internal.getHeight(t5) ? At.internal.getWidth(t5) / 4 : At.internal.getHeight(t5) / 4;
  n5 = Number((0.9 * n5).toFixed(5));
  var i5 = Number((2 * n5).toFixed(5)), a4 = Number((i5 * At.internal.Bezier_C).toFixed(5));
  return r3.push("0.749023 g"), r3.push("q"), r3.push("1 0 0 1 " + z(At.internal.getWidth(t5) / 2) + " " + z(At.internal.getHeight(t5) / 2) + " cm"), r3.push(i5 + " 0 m"), r3.push(i5 + " " + a4 + " " + a4 + " " + i5 + " 0 " + i5 + " c"), r3.push("-" + a4 + " " + i5 + " -" + i5 + " " + a4 + " -" + i5 + " 0 c"), r3.push("-" + i5 + " -" + a4 + " -" + a4 + " -" + i5 + " 0 -" + i5 + " c"), r3.push(a4 + " -" + i5 + " " + i5 + " -" + a4 + " " + i5 + " 0 c"), r3.push("f"), r3.push("Q"), e3.stream = r3.join("\n"), e3;
} }, Cross: { createAppearanceStream: function(t5) {
  var e3 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e3.N[t5] = At.RadioButton.Cross.YesNormal, e3.D[t5] = At.RadioButton.Cross.YesPushDown, e3;
}, getCA: function() {
  return "8";
}, YesNormal: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [], n5 = At.internal.calculateCross(t5);
  return r3.push("q"), r3.push("1 1 " + U(At.internal.getWidth(t5) - 2) + " " + U(At.internal.getHeight(t5) - 2) + " re"), r3.push("W"), r3.push("n"), r3.push(U(n5.x1.x) + " " + U(n5.x1.y) + " m"), r3.push(U(n5.x2.x) + " " + U(n5.x2.y) + " l"), r3.push(U(n5.x4.x) + " " + U(n5.x4.y) + " m"), r3.push(U(n5.x3.x) + " " + U(n5.x3.y) + " l"), r3.push("s"), r3.push("Q"), e3.stream = r3.join("\n"), e3;
}, YesPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = At.internal.calculateCross(t5), n5 = [];
  return n5.push("0.749023 g"), n5.push("0 0 " + U(At.internal.getWidth(t5)) + " " + U(At.internal.getHeight(t5)) + " re"), n5.push("f"), n5.push("q"), n5.push("1 1 " + U(At.internal.getWidth(t5) - 2) + " " + U(At.internal.getHeight(t5) - 2) + " re"), n5.push("W"), n5.push("n"), n5.push(U(r3.x1.x) + " " + U(r3.x1.y) + " m"), n5.push(U(r3.x2.x) + " " + U(r3.x2.y) + " l"), n5.push(U(r3.x4.x) + " " + U(r3.x4.y) + " m"), n5.push(U(r3.x3.x) + " " + U(r3.x3.y) + " l"), n5.push("s"), n5.push("Q"), e3.stream = n5.join("\n"), e3;
}, OffPushDown: function(t5) {
  var e3 = V(t5);
  e3.scope = t5.scope;
  var r3 = [];
  return r3.push("0.749023 g"), r3.push("0 0 " + U(At.internal.getWidth(t5)) + " " + U(At.internal.getHeight(t5)) + " re"), r3.push("f"), e3.stream = r3.join("\n"), e3;
} } }, createDefaultAppearanceStream: function(t5) {
  var e3 = t5.scope.internal.getFont(t5.fontName, t5.fontStyle).id, r3 = t5.scope.__private__.encodeColorString(t5.color);
  return "/" + e3 + " " + t5.fontSize + " Tf " + r3;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t5) {
  var e3 = At.internal.getWidth(t5), r3 = At.internal.getHeight(t5), n5 = Math.min(e3, r3);
  return { x1: { x: (e3 - n5) / 2, y: (r3 - n5) / 2 + n5 }, x2: { x: (e3 - n5) / 2 + n5, y: (r3 - n5) / 2 }, x3: { x: (e3 - n5) / 2, y: (r3 - n5) / 2 }, x4: { x: (e3 - n5) / 2 + n5, y: (r3 - n5) / 2 + n5 } };
} }, At.internal.getWidth = function(e3) {
  var r3 = 0;
  return "object" === _typeof(e3) && (r3 = W(e3.Rect[2])), r3;
}, At.internal.getHeight = function(e3) {
  var r3 = 0;
  return "object" === _typeof(e3) && (r3 = W(e3.Rect[3])), r3;
};
var xt = q.addField = function(t5) {
  if (at(this, t5), !(t5 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e3;
  return (e3 = t5).scope.internal.acroformPlugin.printedOut && (e3.scope.internal.acroformPlugin.printedOut = false, e3.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e3.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e3), t5.page = t5.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
var St = E.AcroForm;
function _t(t5) {
  return t5.reduce(function(t6, e3, r3) {
    return t6[e3] = r3, t6;
  }, {});
}
!function(e3) {
  e3.__addimage__ = {};
  var r3 = "UNKNOWN", n5 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i5 = e3.__addimage__.getImageFileTypeByImageData = function(t5, e4) {
    var i6, a5, o5, s6, c6, u4 = r3;
    if ("RGBA" === (e4 = e4 || r3) || void 0 !== t5.data && t5.data instanceof Uint8ClampedArray && "height" in t5 && "width" in t5)
      return "RGBA";
    if (x2(t5))
      for (c6 in n5)
        for (o5 = n5[c6], i6 = 0; i6 < o5.length; i6 += 1) {
          for (s6 = true, a5 = 0; a5 < o5[i6].length; a5 += 1)
            if (void 0 !== o5[i6][a5] && o5[i6][a5] !== t5[a5]) {
              s6 = false;
              break;
            }
          if (true === s6) {
            u4 = c6;
            break;
          }
        }
    else
      for (c6 in n5)
        for (o5 = n5[c6], i6 = 0; i6 < o5.length; i6 += 1) {
          for (s6 = true, a5 = 0; a5 < o5[i6].length; a5 += 1)
            if (void 0 !== o5[i6][a5] && o5[i6][a5] !== t5.charCodeAt(a5)) {
              s6 = false;
              break;
            }
          if (true === s6) {
            u4 = c6;
            break;
          }
        }
    return u4 === r3 && e4 !== r3 && (u4 = e4), u4;
  }, a4 = function t5(e4) {
    for (var r4 = this.internal.write, n6 = this.internal.putStream, i6 = (0, this.internal.getFilters)(); -1 !== i6.indexOf("FlateEncode"); )
      i6.splice(i6.indexOf("FlateEncode"), 1);
    e4.objectId = this.internal.newObject();
    var a5 = [];
    if (a5.push({ key: "Type", value: "/XObject" }), a5.push({ key: "Subtype", value: "/Image" }), a5.push({ key: "Width", value: e4.width }), a5.push({ key: "Height", value: e4.height }), e4.colorSpace === b2.INDEXED ? a5.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e4.palette.length / 3 - 1) + " " + ("sMask" in e4 && void 0 !== e4.sMask ? e4.objectId + 2 : e4.objectId + 1) + " 0 R]" }) : (a5.push({ key: "ColorSpace", value: "/" + e4.colorSpace }), e4.colorSpace === b2.DEVICE_CMYK && a5.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a5.push({ key: "BitsPerComponent", value: e4.bitsPerComponent }), "decodeParameters" in e4 && void 0 !== e4.decodeParameters && a5.push({ key: "DecodeParms", value: "<<" + e4.decodeParameters + ">>" }), "transparency" in e4 && Array.isArray(e4.transparency)) {
      for (var o5 = "", s6 = 0, c6 = e4.transparency.length; s6 < c6; s6++)
        o5 += e4.transparency[s6] + " " + e4.transparency[s6] + " ";
      a5.push({ key: "Mask", value: "[" + o5 + "]" });
    }
    void 0 !== e4.sMask && a5.push({ key: "SMask", value: e4.objectId + 1 + " 0 R" });
    var u4 = void 0 !== e4.filter ? ["/" + e4.filter] : void 0;
    if (n6({ data: e4.data, additionalKeyValues: a5, alreadyAppliedFilters: u4, objectId: e4.objectId }), r4("endobj"), "sMask" in e4 && void 0 !== e4.sMask) {
      var h5 = "/Predictor " + e4.predictor + " /Colors 1 /BitsPerComponent " + e4.bitsPerComponent + " /Columns " + e4.width, l5 = { width: e4.width, height: e4.height, colorSpace: "DeviceGray", bitsPerComponent: e4.bitsPerComponent, decodeParameters: h5, data: e4.sMask };
      "filter" in e4 && (l5.filter = e4.filter), t5.call(this, l5);
    }
    if (e4.colorSpace === b2.INDEXED) {
      var f6 = this.internal.newObject();
      n6({ data: _4(new Uint8Array(e4.palette)), objectId: f6 }), r4("endobj");
    }
  }, o4 = function() {
    var t5 = this.internal.collections.addImage_images;
    for (var e4 in t5)
      a4.call(this, t5[e4]);
  }, s5 = function() {
    var t5, e4 = this.internal.collections.addImage_images, r4 = this.internal.write;
    for (var n6 in e4)
      r4("/I" + (t5 = e4[n6]).index, t5.objectId, "0", "R");
  }, c5 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o4), this.internal.events.subscribe("putXobjectDict", s5));
  }, h4 = function() {
    var t5 = this.internal.collections.addImage_images;
    return c5.call(this), t5;
  }, l4 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f5 = function(t5) {
    return "function" == typeof e3["process" + t5.toUpperCase()];
  }, d3 = function(e4) {
    return "object" === _typeof(e4) && 1 === e4.nodeType;
  }, p7 = function(t5, r4) {
    if ("IMG" === t5.nodeName && t5.hasAttribute("src")) {
      var n6 = "" + t5.getAttribute("src");
      if (0 === n6.indexOf("data:image/"))
        return u3(unescape(n6).split("base64,").pop());
      var i6 = e3.loadFile(n6, true);
      if (void 0 !== i6)
        return i6;
    }
    if ("CANVAS" === t5.nodeName) {
      if (0 === t5.width || 0 === t5.height)
        throw new Error("Given canvas must have data. Canvas width: " + t5.width + ", height: " + t5.height);
      var a5;
      switch (r4) {
        case "PNG":
          a5 = "image/png";
          break;
        case "WEBP":
          a5 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a5 = "image/jpeg";
      }
      return u3(t5.toDataURL(a5, 1).split("base64,").pop());
    }
  }, g5 = function(t5) {
    var e4 = this.internal.collections.addImage_images;
    if (e4) {
      for (var r4 in e4)
        if (t5 === e4[r4].alias)
          return e4[r4];
    }
  }, m6 = function(t5, e4, r4) {
    return t5 || e4 || (t5 = -96, e4 = -96), t5 < 0 && (t5 = -1 * r4.width * 72 / t5 / this.internal.scaleFactor), e4 < 0 && (e4 = -1 * r4.height * 72 / e4 / this.internal.scaleFactor), 0 === t5 && (t5 = e4 * r4.width / r4.height), 0 === e4 && (e4 = t5 * r4.height / r4.width), [t5, e4];
  }, v4 = function(t5, e4, r4, n6, i6, a5) {
    var o5 = m6.call(this, r4, n6, i6), s6 = this.internal.getCoordinateString, c6 = this.internal.getVerticalCoordinateString, u4 = h4.call(this);
    if (r4 = o5[0], n6 = o5[1], u4[i6.index] = i6, a5) {
      a5 *= Math.PI / 180;
      var l5 = Math.cos(a5), f6 = Math.sin(a5), d4 = function(t6) {
        return t6.toFixed(4);
      }, p8 = [d4(l5), d4(f6), d4(-1 * f6), d4(l5), 0, 0, "cm"];
    }
    this.internal.write("q"), a5 ? (this.internal.write([1, "0", "0", 1, s6(t5), c6(e4 + n6), "cm"].join(" ")), this.internal.write(p8.join(" ")), this.internal.write([s6(r4), "0", "0", s6(n6), "0", "0", "cm"].join(" "))) : this.internal.write([s6(r4), "0", "0", s6(n6), s6(t5), c6(e4 + n6), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i6.index + " Do"), this.internal.write("Q");
  }, b2 = e3.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e3.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y3 = e3.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e3.__addimage__.sHashCode = function(t5) {
    var e4, r4, n6 = 0;
    if ("string" == typeof t5)
      for (r4 = t5.length, e4 = 0; e4 < r4; e4++)
        n6 = (n6 << 5) - n6 + t5.charCodeAt(e4), n6 |= 0;
    else if (x2(t5))
      for (r4 = t5.byteLength / 2, e4 = 0; e4 < r4; e4++)
        n6 = (n6 << 5) - n6 + t5[e4], n6 |= 0;
    return n6;
  }, N3 = e3.__addimage__.validateStringAsBase64 = function(t5) {
    (t5 = t5 || "").toString().trim();
    var e4 = true;
    return 0 === t5.length && (e4 = false), t5.length % 4 != 0 && (e4 = false), false === /^[A-Za-z0-9+/]+$/.test(t5.substr(0, t5.length - 2)) && (e4 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t5.substr(-2)) && (e4 = false), e4;
  }, L2 = e3.__addimage__.extractImageFromDataUrl = function(t5) {
    var e4 = (t5 = t5 || "").split("base64,"), r4 = null;
    if (2 === e4.length) {
      var n6 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e4[0]);
      Array.isArray(n6) && (r4 = { mimeType: n6[1], charset: n6[2], data: e4[1] });
    }
    return r4;
  }, A2 = e3.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e3.__addimage__.isArrayBuffer = function(t5) {
    return A2() && t5 instanceof ArrayBuffer;
  };
  var x2 = e3.__addimage__.isArrayBufferView = function(t5) {
    return A2() && "undefined" != typeof Uint32Array && (t5 instanceof Int8Array || t5 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t5 instanceof Uint8ClampedArray || t5 instanceof Int16Array || t5 instanceof Uint16Array || t5 instanceof Int32Array || t5 instanceof Uint32Array || t5 instanceof Float32Array || t5 instanceof Float64Array);
  }, S2 = e3.__addimage__.binaryStringToUint8Array = function(t5) {
    for (var e4 = t5.length, r4 = new Uint8Array(e4), n6 = 0; n6 < e4; n6++)
      r4[n6] = t5.charCodeAt(n6);
    return r4;
  }, _4 = e3.__addimage__.arrayBufferToBinaryString = function(t5) {
    for (var e4 = "", r4 = x2(t5) ? t5 : new Uint8Array(t5), n6 = 0; n6 < r4.length; n6 += 8192)
      e4 += String.fromCharCode.apply(null, r4.subarray(n6, n6 + 8192));
    return e4;
  };
  e3.addImage = function() {
    var e4, n6, i6, a5, o5, s6, u4, h5, l5;
    if ("number" == typeof arguments[1] ? (n6 = r3, i6 = arguments[1], a5 = arguments[2], o5 = arguments[3], s6 = arguments[4], u4 = arguments[5], h5 = arguments[6], l5 = arguments[7]) : (n6 = arguments[1], i6 = arguments[2], a5 = arguments[3], o5 = arguments[4], s6 = arguments[5], u4 = arguments[6], h5 = arguments[7], l5 = arguments[8]), "object" === _typeof(e4 = arguments[0]) && !d3(e4) && "imageData" in e4) {
      var f6 = e4;
      e4 = f6.imageData, n6 = f6.format || n6 || r3, i6 = f6.x || i6 || 0, a5 = f6.y || a5 || 0, o5 = f6.w || f6.width || o5, s6 = f6.h || f6.height || s6, u4 = f6.alias || u4, h5 = f6.compression || h5, l5 = f6.rotation || f6.angle || l5;
    }
    var p8 = this.internal.getFilters();
    if (void 0 === h5 && -1 !== p8.indexOf("FlateEncode") && (h5 = "SLOW"), isNaN(i6) || isNaN(a5))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c5.call(this);
    var g6 = P2.call(this, e4, n6, u4, h5);
    return v4.call(this, i6, a5, o5, s6, g6, l5), this;
  };
  var P2 = function(t5, n6, a5, o5) {
    var s6, c6, u4;
    if ("string" == typeof t5 && i5(t5) === r3) {
      t5 = unescape(t5);
      var h5 = k3(t5, false);
      ("" !== h5 || void 0 !== (h5 = e3.loadFile(t5, true))) && (t5 = h5);
    }
    if (d3(t5) && (t5 = p7(t5, n6)), n6 = i5(t5, n6), !f5(n6))
      throw new Error("addImage does not support files of type '" + n6 + "', please ensure that a plugin for '" + n6 + "' support is added.");
    if ((null == (u4 = a5) || 0 === u4.length) && (a5 = function(t6) {
      return "string" == typeof t6 || x2(t6) ? w2(t6) : x2(t6.data) ? w2(t6.data) : null;
    }(t5)), (s6 = g5.call(this, a5)) || (A2() && (t5 instanceof Uint8Array || "RGBA" === n6 || (c6 = t5, t5 = S2(t5))), s6 = this["process" + n6.toUpperCase()](t5, l4.call(this), a5, function(t6) {
      return t6 && "string" == typeof t6 && (t6 = t6.toUpperCase()), t6 in e3.image_compression ? t6 : y3.NONE;
    }(o5), c6)), !s6)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s6;
  }, k3 = e3.__addimage__.convertBase64ToBinaryString = function(t5, e4) {
    var r4;
    e4 = "boolean" != typeof e4 || e4;
    var n6, i6 = "";
    if ("string" == typeof t5) {
      n6 = null !== (r4 = L2(t5)) ? r4.data : t5;
      try {
        i6 = u3(n6);
      } catch (t6) {
        if (e4)
          throw N3(n6) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t6.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i6;
  };
  e3.getImageProperties = function(t5) {
    var n6, a5, o5 = "";
    if (d3(t5) && (t5 = p7(t5)), "string" == typeof t5 && i5(t5) === r3 && ("" === (o5 = k3(t5, false)) && (o5 = e3.loadFile(t5) || ""), t5 = o5), a5 = i5(t5), !f5(a5))
      throw new Error("addImage does not support files of type '" + a5 + "', please ensure that a plugin for '" + a5 + "' support is added.");
    if (!A2() || t5 instanceof Uint8Array || (t5 = S2(t5)), !(n6 = this["process" + a5.toUpperCase()](t5)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n6.fileType = a5, n6;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = function(t6) {
    if (void 0 !== t6 && "" != t6)
      return true;
  };
  E.API.events.push(["addPage", function(t6) {
    this.internal.getPageInfo(t6.pageNumber).pageContext.annotations = [];
  }]), t5.events.push(["putPage", function(t6) {
    for (var r3, n5, i5, a4 = this.internal.getCoordinateString, o4 = this.internal.getVerticalCoordinateString, s5 = this.internal.getPageInfoByObjId(t6.objId), c5 = t6.pageContext.annotations, u4 = false, h4 = 0; h4 < c5.length && !u4; h4++)
      switch ((r3 = c5[h4]).type) {
        case "link":
          (e3(r3.options.url) || e3(r3.options.pageNumber)) && (u4 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u4 = true;
      }
    if (0 != u4) {
      this.internal.write("/Annots [");
      for (var l4 = 0; l4 < c5.length; l4++) {
        r3 = c5[l4];
        var f5 = this.internal.pdfEscape, d3 = this.internal.getEncryptor(t6.objId);
        switch (r3.type) {
          case "reference":
            this.internal.write(" " + r3.object.objId + " 0 R ");
            break;
          case "text":
            var p7 = this.internal.newAdditionalObject(), g5 = this.internal.newAdditionalObject(), m6 = this.internal.getEncryptor(p7.objId), v4 = r3.title || "Note";
            i5 = "<</Type /Annot /Subtype /Text " + (n5 = "/Rect [" + a4(r3.bounds.x) + " " + o4(r3.bounds.y + r3.bounds.h) + " " + a4(r3.bounds.x + r3.bounds.w) + " " + o4(r3.bounds.y) + "] ") + "/Contents (" + f5(m6(r3.contents)) + ")", i5 += " /Popup " + g5.objId + " 0 R", i5 += " /P " + s5.objId + " 0 R", i5 += " /T (" + f5(m6(v4)) + ") >>", p7.content = i5;
            var b2 = p7.objId + " 0 R";
            i5 = "<</Type /Annot /Subtype /Popup " + (n5 = "/Rect [" + a4(r3.bounds.x + 30) + " " + o4(r3.bounds.y + r3.bounds.h) + " " + a4(r3.bounds.x + r3.bounds.w + 30) + " " + o4(r3.bounds.y) + "] ") + " /Parent " + b2, r3.open && (i5 += " /Open true"), i5 += " >>", g5.content = i5, this.internal.write(p7.objId, "0 R", g5.objId, "0 R");
            break;
          case "freetext":
            n5 = "/Rect [" + a4(r3.bounds.x) + " " + o4(r3.bounds.y) + " " + a4(r3.bounds.x + r3.bounds.w) + " " + o4(r3.bounds.y + r3.bounds.h) + "] ";
            var y3 = r3.color || "#000000";
            i5 = "<</Type /Annot /Subtype /FreeText " + n5 + "/Contents (" + f5(d3(r3.contents)) + ")", i5 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y3 + ")", i5 += " /Border [0 0 0]", i5 += " >>", this.internal.write(i5);
            break;
          case "link":
            if (r3.options.name) {
              var w2 = this.annotations._nameMap[r3.options.name];
              r3.options.pageNumber = w2.page, r3.options.top = w2.y;
            } else
              r3.options.top || (r3.options.top = 0);
            if (n5 = "/Rect [" + r3.finalBounds.x + " " + r3.finalBounds.y + " " + r3.finalBounds.w + " " + r3.finalBounds.h + "] ", i5 = "", r3.options.url)
              i5 = "<</Type /Annot /Subtype /Link " + n5 + "/Border [0 0 0] /A <</S /URI /URI (" + f5(d3(r3.options.url)) + ") >>";
            else if (r3.options.pageNumber) {
              switch (i5 = "<</Type /Annot /Subtype /Link " + n5 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r3.options.pageNumber).objId + " 0 R", r3.options.magFactor = r3.options.magFactor || "XYZ", r3.options.magFactor) {
                case "Fit":
                  i5 += " /Fit]";
                  break;
                case "FitH":
                  i5 += " /FitH " + r3.options.top + "]";
                  break;
                case "FitV":
                  r3.options.left = r3.options.left || 0, i5 += " /FitV " + r3.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N3 = o4(r3.options.top);
                  r3.options.left = r3.options.left || 0, void 0 === r3.options.zoom && (r3.options.zoom = 0), i5 += " /XYZ " + r3.options.left + " " + N3 + " " + r3.options.zoom + "]";
              }
            }
            "" != i5 && (i5 += " >>", this.internal.write(i5));
        }
      }
      this.internal.write("]");
    }
  }]), t5.createAnnotation = function(t6) {
    var e4 = this.internal.getCurrentPageInfo();
    switch (t6.type) {
      case "link":
        this.link(t6.bounds.x, t6.bounds.y, t6.bounds.w, t6.bounds.h, t6);
        break;
      case "text":
      case "freetext":
        e4.pageContext.annotations.push(t6);
    }
  }, t5.link = function(t6, e4, r3, n5, i5) {
    var a4 = this.internal.getCurrentPageInfo(), o4 = this.internal.getCoordinateString, s5 = this.internal.getVerticalCoordinateString;
    a4.pageContext.annotations.push({ finalBounds: { x: o4(t6), y: s5(e4), w: o4(t6 + r3), h: s5(e4 + n5) }, options: i5, type: "link" });
  }, t5.textWithLink = function(t6, e4, r3, n5) {
    var i5, a4, o4 = this.getTextWidth(t6), s5 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n5.maxWidth) {
      a4 = n5.maxWidth;
      var c5 = this.splitTextToSize(t6, a4).length;
      i5 = Math.ceil(s5 * c5);
    } else
      a4 = o4, i5 = s5;
    return this.text(t6, e4, r3, n5), r3 += 0.2 * s5, "center" === n5.align && (e4 -= o4 / 2), "right" === n5.align && (e4 -= o4), this.link(e4, r3 - s5, a4, i5, n5), o4;
  }, t5.getTextWidth = function(t6) {
    var e4 = this.internal.getFontSize();
    return this.getStringUnitWidth(t6) * e4 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r3 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n5 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i5 = [1570, 1571, 1573, 1575];
  t5.__arabicParser__ = {};
  var a4 = t5.__arabicParser__.isInArabicSubstitutionA = function(t6) {
    return void 0 !== e3[t6.charCodeAt(0)];
  }, o4 = t5.__arabicParser__.isArabicLetter = function(t6) {
    return "string" == typeof t6 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t6);
  }, s5 = t5.__arabicParser__.isArabicEndLetter = function(t6) {
    return o4(t6) && a4(t6) && e3[t6.charCodeAt(0)].length <= 2;
  }, c5 = t5.__arabicParser__.isArabicAlfLetter = function(t6) {
    return o4(t6) && i5.indexOf(t6.charCodeAt(0)) >= 0;
  };
  t5.__arabicParser__.arabicLetterHasIsolatedForm = function(t6) {
    return o4(t6) && a4(t6) && e3[t6.charCodeAt(0)].length >= 1;
  };
  var u4 = t5.__arabicParser__.arabicLetterHasFinalForm = function(t6) {
    return o4(t6) && a4(t6) && e3[t6.charCodeAt(0)].length >= 2;
  };
  t5.__arabicParser__.arabicLetterHasInitialForm = function(t6) {
    return o4(t6) && a4(t6) && e3[t6.charCodeAt(0)].length >= 3;
  };
  var h4 = t5.__arabicParser__.arabicLetterHasMedialForm = function(t6) {
    return o4(t6) && a4(t6) && 4 == e3[t6.charCodeAt(0)].length;
  }, l4 = t5.__arabicParser__.resolveLigatures = function(t6) {
    var e4 = 0, n6 = r3, i6 = "", a5 = 0;
    for (e4 = 0; e4 < t6.length; e4 += 1)
      void 0 !== n6[t6.charCodeAt(e4)] ? (a5++, "number" == typeof (n6 = n6[t6.charCodeAt(e4)]) && (i6 += String.fromCharCode(n6), n6 = r3, a5 = 0), e4 === t6.length - 1 && (n6 = r3, i6 += t6.charAt(e4 - (a5 - 1)), e4 -= a5 - 1, a5 = 0)) : (n6 = r3, i6 += t6.charAt(e4 - a5), e4 -= a5, a5 = 0);
    return i6;
  };
  t5.__arabicParser__.isArabicDiacritic = function(t6) {
    return void 0 !== t6 && void 0 !== n5[t6.charCodeAt(0)];
  };
  var f5 = t5.__arabicParser__.getCorrectForm = function(t6, e4, r4) {
    return o4(t6) ? false === a4(t6) ? -1 : !u4(t6) || !o4(e4) && !o4(r4) || !o4(r4) && s5(e4) || s5(t6) && !o4(e4) || s5(t6) && c5(e4) || s5(t6) && s5(e4) ? 0 : h4(t6) && o4(e4) && !s5(e4) && o4(r4) && u4(r4) ? 3 : s5(t6) || !o4(r4) ? 1 : 2 : -1;
  }, d3 = function(t6) {
    var r4 = 0, n6 = 0, i6 = 0, a5 = "", s6 = "", c6 = "", u5 = (t6 = t6 || "").split("\\s+"), h5 = [];
    for (r4 = 0; r4 < u5.length; r4 += 1) {
      for (h5.push(""), n6 = 0; n6 < u5[r4].length; n6 += 1)
        a5 = u5[r4][n6], s6 = u5[r4][n6 - 1], c6 = u5[r4][n6 + 1], o4(a5) ? (i6 = f5(a5, s6, c6), h5[r4] += -1 !== i6 ? String.fromCharCode(e3[a5.charCodeAt(0)][i6]) : a5) : h5[r4] += a5;
      h5[r4] = l4(h5[r4]);
    }
    return h5.join(" ");
  }, p7 = t5.__arabicParser__.processArabic = t5.processArabic = function() {
    var t6, e4 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r4 = [];
    if (Array.isArray(e4)) {
      var n6 = 0;
      for (r4 = [], n6 = 0; n6 < e4.length; n6 += 1)
        Array.isArray(e4[n6]) ? r4.push([d3(e4[n6][0]), e4[n6][1], e4[n6][2]]) : r4.push([d3(e4[n6])]);
      t6 = r4;
    } else
      t6 = d3(e4);
    return "string" == typeof arguments[0] ? t6 : (arguments[0].text = t6, arguments[0]);
  };
  t5.events.push(["preProcessText", p7]);
}(E.API), E.API.autoPrint = function(t5) {
  var e3;
  switch ((t5 = t5 || {}).variant = t5.variant || "non-conform", t5.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e3 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e3 + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = function() {
    var t6 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t6;
    }, set: function(e5) {
      t6 = e5;
    } });
    var e4 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e4;
    }, set: function(t7) {
      e4 = isNaN(t7) || false === Number.isInteger(t7) || t7 < 0 ? 150 : t7, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e4 + 1);
    } });
    var r3 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r3;
    }, set: function(t7) {
      r3 = isNaN(t7) || false === Number.isInteger(t7) || t7 < 0 ? 300 : t7, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r3 + 1);
    } });
    var n5 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n5;
    }, set: function(t7) {
      n5 = t7;
    } });
    var i5 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i5;
    }, set: function(t7) {
      i5 = t7;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e3.prototype.getContext = function(t6, e4) {
    var r3;
    if ("2d" !== (t6 = t6 || "2d"))
      return null;
    for (r3 in e4)
      this.pdf.context2d.hasOwnProperty(r3) && (this.pdf.context2d[r3] = e4[r3]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e3.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t5.events.push(["initialized", function() {
    this.canvas = new e3(), this.canvas.pdf = this;
  }]);
}(E.API), function(e3) {
  var r3 = { left: 0, top: 0, bottom: 0, right: 0 }, n5 = false, i5 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r3), this.internal.__cell__.margins.width = this.getPageWidth(), a4.call(this));
  }, a4 = function() {
    this.internal.__cell__.lastCell = new o4(), this.internal.__cell__.pages = 1;
  }, o4 = function() {
    var t5 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t5;
    }, set: function(e5) {
      t5 = e5;
    } });
    var e4 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e4;
    }, set: function(t6) {
      e4 = t6;
    } });
    var r4 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r4;
    }, set: function(t6) {
      r4 = t6;
    } });
    var n6 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n6;
    }, set: function(t6) {
      n6 = t6;
    } });
    var i6 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i6;
    }, set: function(t6) {
      i6 = t6;
    } });
    var a5 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a5;
    }, set: function(t6) {
      a5 = t6;
    } });
    var o5 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o5;
    }, set: function(t6) {
      o5 = t6;
    } }), this;
  };
  o4.prototype.clone = function() {
    return new o4(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o4.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e3.setHeaderFunction = function(t5) {
    return i5.call(this), this.internal.__cell__.headerFunction = "function" == typeof t5 ? t5 : void 0, this;
  }, e3.getTextDimensions = function(t5, e4) {
    i5.call(this);
    var r4 = (e4 = e4 || {}).fontSize || this.getFontSize(), n6 = e4.font || this.getFont(), a5 = e4.scaleFactor || this.internal.scaleFactor, o5 = 0, s6 = 0, c6 = 0, u4 = this;
    if (!Array.isArray(t5) && "string" != typeof t5) {
      if ("number" != typeof t5)
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t5 = String(t5);
    }
    var h4 = e4.maxWidth;
    h4 > 0 ? "string" == typeof t5 ? t5 = this.splitTextToSize(t5, h4) : "[object Array]" === Object.prototype.toString.call(t5) && (t5 = t5.reduce(function(t6, e5) {
      return t6.concat(u4.splitTextToSize(e5, h4));
    }, [])) : t5 = Array.isArray(t5) ? t5 : [t5];
    for (var l4 = 0; l4 < t5.length; l4++)
      o5 < (c6 = this.getStringUnitWidth(t5[l4], { font: n6 }) * r4) && (o5 = c6);
    return 0 !== o5 && (s6 = t5.length), { w: o5 /= a5, h: Math.max((s6 * r4 * this.getLineHeightFactor() - r4 * (this.getLineHeightFactor() - 1)) / a5, 0) };
  }, e3.cellAddPage = function() {
    i5.call(this), this.addPage();
    var t5 = this.internal.__cell__.margins || r3;
    return this.internal.__cell__.lastCell = new o4(t5.left, t5.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s5 = e3.cell = function() {
    var t5;
    t5 = arguments[0] instanceof o4 ? arguments[0] : new o4(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i5.call(this);
    var e4 = this.internal.__cell__.lastCell, a5 = this.internal.__cell__.padding, s6 = this.internal.__cell__.margins || r3, c6 = this.internal.__cell__.tableHeaderRow, u4 = this.internal.__cell__.printHeaders;
    return void 0 !== e4.lineNumber && (e4.lineNumber === t5.lineNumber ? (t5.x = (e4.x || 0) + (e4.width || 0), t5.y = e4.y || 0) : e4.y + e4.height + t5.height + s6.bottom > this.getPageHeight() ? (this.cellAddPage(), t5.y = s6.top, u4 && c6 && (this.printHeaderRow(t5.lineNumber, true), t5.y += c6[0].height)) : t5.y = e4.y + e4.height || t5.y), void 0 !== t5.text[0] && (this.rect(t5.x, t5.y, t5.width, t5.height, true === n5 ? "FD" : void 0), "right" === t5.align ? this.text(t5.text, t5.x + t5.width - a5, t5.y + a5, { align: "right", baseline: "top" }) : "center" === t5.align ? this.text(t5.text, t5.x + t5.width / 2, t5.y + a5, { align: "center", baseline: "top", maxWidth: t5.width - a5 - a5 }) : this.text(t5.text, t5.x + a5, t5.y + a5, { align: "left", baseline: "top", maxWidth: t5.width - a5 - a5 })), this.internal.__cell__.lastCell = t5, this;
  };
  e3.table = function(e4, n6, u4, h4, l4) {
    if (i5.call(this), !u4)
      throw new Error("No data for PDF table.");
    var f5, d3, p7, g5, m6 = [], v4 = [], b2 = [], y3 = {}, w2 = {}, N3 = [], L2 = [], A2 = (l4 = l4 || {}).autoSize || false, x2 = false !== l4.printHeaders, S2 = l4.css && void 0 !== l4.css["font-size"] ? 16 * l4.css["font-size"] : l4.fontSize || 12, _4 = l4.margins || Object.assign({ width: this.getPageWidth() }, r3), P2 = "number" == typeof l4.padding ? l4.padding : 3, k3 = l4.headerBackgroundColor || "#c8c8c8", I2 = l4.headerTextColor || "#000";
    if (a4.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _4, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k3, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h4)
      v4 = m6 = Object.keys(u4[0]), b2 = m6.map(function() {
        return "left";
      });
    else if (Array.isArray(h4) && "object" === _typeof(h4[0]))
      for (m6 = h4.map(function(t5) {
        return t5.name;
      }), v4 = h4.map(function(t5) {
        return t5.prompt || t5.name || "";
      }), b2 = h4.map(function(t5) {
        return t5.align || "left";
      }), f5 = 0; f5 < h4.length; f5 += 1)
        w2[h4[f5].name] = h4[f5].width * (19.049976 / 25.4);
    else
      Array.isArray(h4) && "string" == typeof h4[0] && (v4 = m6 = h4, b2 = m6.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h4) && "string" == typeof h4[0])
      for (f5 = 0; f5 < m6.length; f5 += 1) {
        for (y3[g5 = m6[f5]] = u4.map(function(t5) {
          return t5[g5];
        }), this.setFont(void 0, "bold"), N3.push(this.getTextDimensions(v4[f5], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d3 = y3[g5], this.setFont(void 0, "normal"), p7 = 0; p7 < d3.length; p7 += 1)
          N3.push(this.getTextDimensions(d3[p7], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g5] = Math.max.apply(null, N3) + P2 + P2, N3 = [];
      }
    if (x2) {
      var F2 = {};
      for (f5 = 0; f5 < m6.length; f5 += 1)
        F2[m6[f5]] = {}, F2[m6[f5]].text = v4[f5], F2[m6[f5]].align = b2[f5];
      var C2 = c5.call(this, F2, w2);
      L2 = m6.map(function(t5) {
        return new o4(e4, n6, w2[t5], C2, F2[t5].text, void 0, F2[t5].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j3 = h4.reduce(function(t5, e5) {
      return t5[e5.name] = e5.align, t5;
    }, {});
    for (f5 = 0; f5 < u4.length; f5 += 1) {
      "rowStart" in l4 && l4.rowStart instanceof Function && l4.rowStart({ row: f5, data: u4[f5] }, this);
      var O3 = c5.call(this, u4[f5], w2);
      for (p7 = 0; p7 < m6.length; p7 += 1) {
        var B2 = u4[f5][m6[p7]];
        "cellStart" in l4 && l4.cellStart instanceof Function && l4.cellStart({ row: f5, col: p7, data: B2 }, this), s5.call(this, new o4(e4, n6, w2[m6[p7]], O3, B2, f5 + 2, j3[m6[p7]]));
      }
    }
    return this.internal.__cell__.table_x = e4, this.internal.__cell__.table_y = n6, this;
  };
  var c5 = function(t5, e4) {
    var r4 = this.internal.__cell__.padding, n6 = this.internal.__cell__.table_font_size, i6 = this.internal.scaleFactor;
    return Object.keys(t5).map(function(n7) {
      var i7 = t5[n7];
      return this.splitTextToSize(i7.hasOwnProperty("text") ? i7.text : i7, e4[n7] - r4 - r4);
    }, this).map(function(t6) {
      return this.getLineHeightFactor() * t6.length * n6 / i6 + r4 + r4;
    }, this).reduce(function(t6, e5) {
      return Math.max(t6, e5);
    }, 0);
  };
  e3.setTableHeaderRow = function(t5) {
    i5.call(this), this.internal.__cell__.tableHeaderRow = t5;
  }, e3.printHeaderRow = function(t5, e4) {
    if (i5.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r4;
    if (n5 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a5 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o4(a5[0], a5[1], a5[2], a5[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c6 = [], u4 = 0; u4 < this.internal.__cell__.tableHeaderRow.length; u4 += 1) {
      r4 = this.internal.__cell__.tableHeaderRow[u4].clone(), e4 && (r4.y = this.internal.__cell__.margins.top || 0, c6.push(r4)), r4.lineNumber = t5;
      var h4 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s5.call(this, r4), this.setTextColor(h4);
    }
    c6.length > 0 && this.setTableHeaderRow(c6), this.setFont(void 0, "normal"), n5 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
var kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
var It = _t(kt);
var Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900];
var Ct = _t(Ft);
function jt(t5) {
  var e3 = t5.family.replace(/"|'/g, "").toLowerCase(), r3 = function(t6) {
    return Pt[t6 = t6 || "normal"] ? t6 : "normal";
  }(t5.style), n5 = function(t6) {
    if (!t6)
      return 400;
    if ("number" == typeof t6)
      return t6 >= 100 && t6 <= 900 && t6 % 100 == 0 ? t6 : 400;
    if (/^\d00$/.test(t6))
      return parseInt(t6);
    switch (t6) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t5.weight), i5 = function(t6) {
    return "number" == typeof It[t6 = t6 || "normal"] ? t6 : "normal";
  }(t5.stretch);
  return { family: e3, style: r3, weight: n5, stretch: i5, src: t5.src || [], ref: t5.ref || { name: e3, style: [i5, r3, n5].join(" ") } };
}
function Ot(t5, e3, r3, n5) {
  var i5;
  for (i5 = r3; i5 >= 0 && i5 < e3.length; i5 += n5)
    if (t5[e3[i5]])
      return t5[e3[i5]];
  for (i5 = r3; i5 >= 0 && i5 < e3.length; i5 -= n5)
    if (t5[e3[i5]])
      return t5[e3[i5]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
var Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et(t5) {
  return [t5.stretch, t5.style, t5.weight, t5.family].join(" ");
}
function qt(t5, e3, r3) {
  for (var n5 = (r3 = r3 || {}).defaultFontFamily || "times", i5 = Object.assign({}, Bt, r3.genericFontFamilies || {}), a4 = null, o4 = null, s5 = 0; s5 < e3.length; ++s5)
    if (i5[(a4 = jt(e3[s5])).family] && (a4.family = i5[a4.family]), t5.hasOwnProperty(a4.family)) {
      o4 = t5[a4.family];
      break;
    }
  if (!(o4 = o4 || t5[n5]))
    throw new Error("Could not find a font-family for the rule '" + Et(a4) + "' and default family '" + n5 + "'.");
  if (o4 = function(t6, e4) {
    if (e4[t6])
      return e4[t6];
    var r4 = It[t6], n6 = r4 <= It.normal ? -1 : 1, i6 = Ot(e4, kt, r4, n6);
    if (!i6)
      throw new Error("Could not find a matching font-stretch value for " + t6);
    return i6;
  }(a4.stretch, o4), o4 = function(t6, e4) {
    if (e4[t6])
      return e4[t6];
    for (var r4 = Pt[t6], n6 = 0; n6 < r4.length; ++n6)
      if (e4[r4[n6]])
        return e4[r4[n6]];
    throw new Error("Could not find a matching font-style for " + t6);
  }(a4.style, o4), !(o4 = function(t6, e4) {
    if (e4[t6])
      return e4[t6];
    if (400 === t6 && e4[500])
      return e4[500];
    if (500 === t6 && e4[400])
      return e4[400];
    var r4 = Ct[t6], n6 = Ot(e4, Ft, r4, t6 < 400 ? -1 : 1);
    if (!n6)
      throw new Error("Could not find a matching font-weight for value " + t6);
    return n6;
  }(a4.weight, o4)))
    throw new Error("Failed to resolve a font for the rule '" + Et(a4) + "'.");
  return o4;
}
function Dt(t5) {
  return t5.trimLeft();
}
function Rt(t5, e3) {
  for (var r3 = 0; r3 < t5.length; ) {
    if (t5.charAt(r3) === e3)
      return [t5.substring(0, r3), t5.substring(r3 + 1)];
    r3 += 1;
  }
  return null;
}
function Tt(t5) {
  var e3 = t5.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e3 ? null : [e3[0], t5.substring(e3[0].length)];
}
var Ut;
var zt;
var Ht;
var Wt = ["times"];
!function(e3) {
  var r3, n5, i5, o4, s5, c5, u4, h4, l4, d3 = function(t5) {
    return t5 = t5 || {}, this.isStrokeTransparent = t5.isStrokeTransparent || false, this.strokeOpacity = t5.strokeOpacity || 1, this.strokeStyle = t5.strokeStyle || "#000000", this.fillStyle = t5.fillStyle || "#000000", this.isFillTransparent = t5.isFillTransparent || false, this.fillOpacity = t5.fillOpacity || 1, this.font = t5.font || "10px sans-serif", this.textBaseline = t5.textBaseline || "alphabetic", this.textAlign = t5.textAlign || "left", this.lineWidth = t5.lineWidth || 1, this.lineJoin = t5.lineJoin || "miter", this.lineCap = t5.lineCap || "butt", this.path = t5.path || [], this.transform = void 0 !== t5.transform ? t5.transform.clone() : new h4(), this.globalCompositeOperation = t5.globalCompositeOperation || "normal", this.globalAlpha = t5.globalAlpha || 1, this.clip_path = t5.clip_path || [], this.currentPoint = t5.currentPoint || new c5(), this.miterLimit = t5.miterLimit || 10, this.lastPoint = t5.lastPoint || new c5(), this.lineDashOffset = t5.lineDashOffset || 0, this.lineDash = t5.lineDash || [], this.margin = t5.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t5.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t5.ignoreClearRect || t5.ignoreClearRect, this;
  };
  e3.events.push(["initialized", function() {
    this.context2d = new p7(this), r3 = this.internal.f2, n5 = this.internal.getCoordinateString, i5 = this.internal.getVerticalCoordinateString, o4 = this.internal.getHorizontalCoordinate, s5 = this.internal.getVerticalCoordinate, c5 = this.internal.Point, u4 = this.internal.Rectangle, h4 = this.internal.Matrix, l4 = new d3();
  }]);
  var p7 = function(t5) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e4 = t5;
    Object.defineProperty(this, "pdf", { get: function() {
      return e4;
    } });
    var r4 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r4;
    }, set: function(t6) {
      r4 = Boolean(t6);
    } });
    var n6 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n6;
    }, set: function(t6) {
      n6 = Boolean(t6);
    } });
    var i6 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i6;
    }, set: function(t6) {
      isNaN(t6) || (i6 = t6);
    } });
    var a4 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a4;
    }, set: function(t6) {
      isNaN(t6) || (a4 = t6);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l4.margin;
    }, set: function(t6) {
      var e5;
      "number" == typeof t6 ? e5 = [t6, t6, t6, t6] : ((e5 = new Array(4))[0] = t6[0], e5[1] = t6.length >= 2 ? t6[1] : e5[0], e5[2] = t6.length >= 3 ? t6[2] : e5[0], e5[3] = t6.length >= 4 ? t6[3] : e5[1]), l4.margin = e5;
    } });
    var o5 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o5;
    }, set: function(t6) {
      o5 = t6;
    } });
    var s6 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s6;
    }, set: function(t6) {
      s6 = t6;
    } });
    var c6 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c6;
    }, set: function(t6) {
      c6 = t6;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l4;
    }, set: function(t6) {
      t6 instanceof d3 && (l4 = t6);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l4.path;
    }, set: function(t6) {
      l4.path = t6;
    } });
    var u5 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u5;
    }, set: function(t6) {
      u5 = t6;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t6) {
      var e5;
      e5 = g5(t6), this.ctx.fillStyle = e5.style, this.ctx.isFillTransparent = 0 === e5.a, this.ctx.fillOpacity = e5.a, this.pdf.setFillColor(e5.r, e5.g, e5.b, { a: e5.a }), this.pdf.setTextColor(e5.r, e5.g, e5.b, { a: e5.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t6) {
      var e5 = g5(t6);
      this.ctx.strokeStyle = e5.style, this.ctx.isStrokeTransparent = 0 === e5.a, this.ctx.strokeOpacity = e5.a, 0 === e5.a ? this.pdf.setDrawColor(255, 255, 255) : (e5.a, this.pdf.setDrawColor(e5.r, e5.g, e5.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t6) {
      -1 !== ["butt", "round", "square"].indexOf(t6) && (this.ctx.lineCap = t6, this.pdf.setLineCap(t6));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t6) {
      isNaN(t6) || (this.ctx.lineWidth = t6, this.pdf.setLineWidth(t6));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t6) {
      -1 !== ["bevel", "round", "miter"].indexOf(t6) && (this.ctx.lineJoin = t6, this.pdf.setLineJoin(t6));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t6) {
      isNaN(t6) || (this.ctx.miterLimit = t6, this.pdf.setMiterLimit(t6));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t6) {
      this.ctx.textBaseline = t6;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t6) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t6) && (this.ctx.textAlign = t6);
    } });
    var h5 = null;
    function f5(t6, e5) {
      if (null === h5) {
        var r5 = function(t7) {
          var e6 = [];
          return Object.keys(t7).forEach(function(r6) {
            t7[r6].forEach(function(t8) {
              var n7 = null;
              switch (t8) {
                case "bold":
                  n7 = { family: r6, weight: "bold" };
                  break;
                case "italic":
                  n7 = { family: r6, style: "italic" };
                  break;
                case "bolditalic":
                  n7 = { family: r6, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n7 = { family: r6 };
              }
              null !== n7 && (n7.ref = { name: r6, style: t8 }, e6.push(n7));
            });
          }), e6;
        }(t6.getFontList());
        h5 = function(t7) {
          for (var e6 = {}, r6 = 0; r6 < t7.length; ++r6) {
            var n7 = jt(t7[r6]), i7 = n7.family, a5 = n7.stretch, o6 = n7.style, s7 = n7.weight;
            e6[i7] = e6[i7] || {}, e6[i7][a5] = e6[i7][a5] || {}, e6[i7][a5][o6] = e6[i7][a5][o6] || {}, e6[i7][a5][o6][s7] = n7;
          }
          return e6;
        }(r5.concat(e5));
      }
      return h5;
    }
    var p8 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p8;
    }, set: function(t6) {
      h5 = null, p8 = t6;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t6) {
      var e5;
      if (this.ctx.font = t6, null !== (e5 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t6))) {
        var r5 = e5[1], n7 = (e5[2], e5[3]), i7 = e5[4], a5 = (e5[5], e5[6]), o6 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i7)[2];
        i7 = "px" === o6 ? Math.floor(parseFloat(i7) * this.pdf.internal.scaleFactor) : "em" === o6 ? Math.floor(parseFloat(i7) * this.pdf.getFontSize()) : Math.floor(parseFloat(i7) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i7);
        var s7 = function(t7) {
          var e6, r6, n8 = [], i8 = t7.trim();
          if ("" === i8)
            return Wt;
          if (i8 in Mt)
            return [Mt[i8]];
          for (; "" !== i8; ) {
            switch (r6 = null, e6 = (i8 = Dt(i8)).charAt(0)) {
              case '"':
              case "'":
                r6 = Rt(i8.substring(1), e6);
                break;
              default:
                r6 = Tt(i8);
            }
            if (null === r6)
              return Wt;
            if (n8.push(r6[0]), "" !== (i8 = Dt(r6[1])) && "," !== i8.charAt(0))
              return Wt;
            i8 = i8.replace(/^,/, "");
          }
          return n8;
        }(a5);
        if (this.fontFaces) {
          var c7 = qt(f5(this.pdf, this.fontFaces), s7.map(function(t7) {
            return { family: t7, stretch: "normal", weight: n7, style: r5 };
          }));
          this.pdf.setFont(c7.ref.name, c7.ref.style);
        } else {
          var u6 = "";
          ("bold" === n7 || parseInt(n7, 10) >= 700 || "bold" === r5) && (u6 = "bold"), "italic" === r5 && (u6 += "italic"), 0 === u6.length && (u6 = "normal");
          for (var h6 = "", l5 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d4 = 0; d4 < s7.length; d4++) {
            if (void 0 !== this.pdf.internal.getFont(s7[d4], u6, { noFallback: true, disableWarning: true })) {
              h6 = s7[d4];
              break;
            }
            if ("bolditalic" === u6 && void 0 !== this.pdf.internal.getFont(s7[d4], "bold", { noFallback: true, disableWarning: true }))
              h6 = s7[d4], u6 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s7[d4], "normal", { noFallback: true, disableWarning: true })) {
              h6 = s7[d4], u6 = "normal";
              break;
            }
          }
          if ("" === h6) {
            for (var p9 = 0; p9 < s7.length; p9++)
              if (l5[s7[p9]]) {
                h6 = l5[s7[p9]];
                break;
              }
          }
          h6 = "" === h6 ? "Times" : h6, this.pdf.setFont(h6, u6);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t6) {
      this.ctx.globalCompositeOperation = t6;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t6) {
      this.ctx.globalAlpha = t6;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t6) {
      this.ctx.lineDashOffset = t6, T3.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t6) {
      this.ctx.lineDash = t6, T3.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t6) {
      this.ctx.ignoreClearRect = Boolean(t6);
    } });
  };
  p7.prototype.setLineDash = function(t5) {
    this.lineDash = t5;
  }, p7.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p7.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p7.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p7.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p7.prototype.moveTo = function(t5, e4) {
    if (isNaN(t5) || isNaN(e4))
      throw a3.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r4 = this.ctx.transform.applyToPoint(new c5(t5, e4));
    this.path.push({ type: "mt", x: r4.x, y: r4.y }), this.ctx.lastPoint = new c5(t5, e4);
  }, p7.prototype.closePath = function() {
    var e4 = new c5(0, 0), r4 = 0;
    for (r4 = this.path.length - 1; -1 !== r4; r4--)
      if ("begin" === this.path[r4].type && "object" === _typeof(this.path[r4 + 1]) && "number" == typeof this.path[r4 + 1].x) {
        e4 = new c5(this.path[r4 + 1].x, this.path[r4 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c5(e4.x, e4.y);
  }, p7.prototype.lineTo = function(t5, e4) {
    if (isNaN(t5) || isNaN(e4))
      throw a3.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r4 = this.ctx.transform.applyToPoint(new c5(t5, e4));
    this.path.push({ type: "lt", x: r4.x, y: r4.y }), this.ctx.lastPoint = new c5(r4.x, r4.y);
  }, p7.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p7.prototype.quadraticCurveTo = function(t5, e4, r4, n6) {
    if (isNaN(r4) || isNaN(n6) || isNaN(t5) || isNaN(e4))
      throw a3.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i6 = this.ctx.transform.applyToPoint(new c5(r4, n6)), o5 = this.ctx.transform.applyToPoint(new c5(t5, e4));
    this.path.push({ type: "qct", x1: o5.x, y1: o5.y, x: i6.x, y: i6.y }), this.ctx.lastPoint = new c5(i6.x, i6.y);
  }, p7.prototype.bezierCurveTo = function(t5, e4, r4, n6, i6, o5) {
    if (isNaN(i6) || isNaN(o5) || isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6))
      throw a3.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s6 = this.ctx.transform.applyToPoint(new c5(i6, o5)), u5 = this.ctx.transform.applyToPoint(new c5(t5, e4)), h5 = this.ctx.transform.applyToPoint(new c5(r4, n6));
    this.path.push({ type: "bct", x1: u5.x, y1: u5.y, x2: h5.x, y2: h5.y, x: s6.x, y: s6.y }), this.ctx.lastPoint = new c5(s6.x, s6.y);
  }, p7.prototype.arc = function(t5, e4, r4, n6, i6, o5) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6) || isNaN(i6))
      throw a3.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o5 = Boolean(o5), !this.ctx.transform.isIdentity) {
      var s6 = this.ctx.transform.applyToPoint(new c5(t5, e4));
      t5 = s6.x, e4 = s6.y;
      var u5 = this.ctx.transform.applyToPoint(new c5(0, r4)), h5 = this.ctx.transform.applyToPoint(new c5(0, 0));
      r4 = Math.sqrt(Math.pow(u5.x - h5.x, 2) + Math.pow(u5.y - h5.y, 2));
    }
    Math.abs(i6 - n6) >= 2 * Math.PI && (n6 = 0, i6 = 2 * Math.PI), this.path.push({ type: "arc", x: t5, y: e4, radius: r4, startAngle: n6, endAngle: i6, counterclockwise: o5 });
  }, p7.prototype.arcTo = function(t5, e4, r4, n6, i6) {
    throw new Error("arcTo not implemented.");
  }, p7.prototype.rect = function(t5, e4, r4, n6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6))
      throw a3.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t5, e4), this.lineTo(t5 + r4, e4), this.lineTo(t5 + r4, e4 + n6), this.lineTo(t5, e4 + n6), this.lineTo(t5, e4), this.lineTo(t5 + r4, e4), this.lineTo(t5, e4);
  }, p7.prototype.fillRect = function(t5, e4, r4, n6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6))
      throw a3.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m6.call(this)) {
      var i6 = {};
      "butt" !== this.lineCap && (i6.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i6.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t5, e4, r4, n6), this.fill(), i6.hasOwnProperty("lineCap") && (this.lineCap = i6.lineCap), i6.hasOwnProperty("lineJoin") && (this.lineJoin = i6.lineJoin);
    }
  }, p7.prototype.strokeRect = function(t5, e4, r4, n6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6))
      throw a3.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v4.call(this) || (this.beginPath(), this.rect(t5, e4, r4, n6), this.stroke());
  }, p7.prototype.clearRect = function(t5, e4, r4, n6) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6))
      throw a3.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t5, e4, r4, n6));
  }, p7.prototype.save = function(t5) {
    t5 = "boolean" != typeof t5 || t5;
    for (var e4 = this.pdf.internal.getCurrentPageInfo().pageNumber, r4 = 0; r4 < this.pdf.internal.getNumberOfPages(); r4++)
      this.pdf.setPage(r4 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e4), t5) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n6 = new d3(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n6;
    }
  }, p7.prototype.restore = function(t5) {
    t5 = "boolean" != typeof t5 || t5;
    for (var e4 = this.pdf.internal.getCurrentPageInfo().pageNumber, r4 = 0; r4 < this.pdf.internal.getNumberOfPages(); r4++)
      this.pdf.setPage(r4 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e4), t5 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p7.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g5 = function(t5) {
    var e4, r4, n6, i6;
    if (true === t5.isCanvasGradient && (t5 = t5.getColor()), !t5)
      return { r: 0, g: 0, b: 0, a: 0, style: t5 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t5))
      e4 = 0, r4 = 0, n6 = 0, i6 = 0;
    else {
      var a4 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t5);
      if (null !== a4)
        e4 = parseInt(a4[1]), r4 = parseInt(a4[2]), n6 = parseInt(a4[3]), i6 = 1;
      else if (null !== (a4 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t5)))
        e4 = parseInt(a4[1]), r4 = parseInt(a4[2]), n6 = parseInt(a4[3]), i6 = parseFloat(a4[4]);
      else {
        if (i6 = 1, "string" == typeof t5 && "#" !== t5.charAt(0)) {
          var o5 = new f4(t5);
          t5 = o5.ok ? o5.toHex() : "#000000";
        }
        4 === t5.length ? (e4 = t5.substring(1, 2), e4 += e4, r4 = t5.substring(2, 3), r4 += r4, n6 = t5.substring(3, 4), n6 += n6) : (e4 = t5.substring(1, 3), r4 = t5.substring(3, 5), n6 = t5.substring(5, 7)), e4 = parseInt(e4, 16), r4 = parseInt(r4, 16), n6 = parseInt(n6, 16);
      }
    }
    return { r: e4, g: r4, b: n6, a: i6, style: t5 };
  }, m6 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v4 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p7.prototype.fillText = function(t5, e4, r4, n6) {
    if (isNaN(e4) || isNaN(r4) || "string" != typeof t5)
      throw a3.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n6 = isNaN(n6) ? void 0 : n6, !m6.call(this)) {
      var i6 = q2(this.ctx.transform.rotation), o5 = this.ctx.transform.scaleX;
      C2.call(this, { text: t5, x: e4, y: r4, scale: o5, angle: i6, align: this.textAlign, maxWidth: n6 });
    }
  }, p7.prototype.strokeText = function(t5, e4, r4, n6) {
    if (isNaN(e4) || isNaN(r4) || "string" != typeof t5)
      throw a3.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v4.call(this)) {
      n6 = isNaN(n6) ? void 0 : n6;
      var i6 = q2(this.ctx.transform.rotation), o5 = this.ctx.transform.scaleX;
      C2.call(this, { text: t5, x: e4, y: r4, scale: o5, renderingMode: "stroke", angle: i6, align: this.textAlign, maxWidth: n6 });
    }
  }, p7.prototype.measureText = function(t5) {
    if ("string" != typeof t5)
      throw a3.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e4 = this.pdf, r4 = this.pdf.internal.scaleFactor, n6 = e4.internal.getFontSize(), i6 = e4.getStringUnitWidth(t5) * n6 / e4.internal.scaleFactor, o5 = function(t6) {
      var e5 = (t6 = t6 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e5;
      } }), this;
    };
    return new o5({ width: i6 *= Math.round(96 * r4 / 72 * 1e4) / 1e4 });
  }, p7.prototype.scale = function(t5, e4) {
    if (isNaN(t5) || isNaN(e4))
      throw a3.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r4 = new h4(t5, 0, 0, e4, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r4);
  }, p7.prototype.rotate = function(t5) {
    if (isNaN(t5))
      throw a3.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e4 = new h4(Math.cos(t5), Math.sin(t5), -Math.sin(t5), Math.cos(t5), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e4);
  }, p7.prototype.translate = function(t5, e4) {
    if (isNaN(t5) || isNaN(e4))
      throw a3.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r4 = new h4(1, 0, 0, 1, t5, e4);
    this.ctx.transform = this.ctx.transform.multiply(r4);
  }, p7.prototype.transform = function(t5, e4, r4, n6, i6, o5) {
    if (isNaN(t5) || isNaN(e4) || isNaN(r4) || isNaN(n6) || isNaN(i6) || isNaN(o5))
      throw a3.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s6 = new h4(t5, e4, r4, n6, i6, o5);
    this.ctx.transform = this.ctx.transform.multiply(s6);
  }, p7.prototype.setTransform = function(t5, e4, r4, n6, i6, a4) {
    t5 = isNaN(t5) ? 1 : t5, e4 = isNaN(e4) ? 0 : e4, r4 = isNaN(r4) ? 0 : r4, n6 = isNaN(n6) ? 1 : n6, i6 = isNaN(i6) ? 0 : i6, a4 = isNaN(a4) ? 0 : a4, this.ctx.transform = new h4(t5, e4, r4, n6, i6, a4);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p7.prototype.drawImage = function(t5, e4, r4, n6, i6, a4, o5, s6, c6) {
    var l5 = this.pdf.getImageProperties(t5), f5 = 1, d4 = 1, p8 = 1, g6 = 1;
    void 0 !== n6 && void 0 !== s6 && (p8 = s6 / n6, g6 = c6 / i6, f5 = l5.width / n6 * s6 / n6, d4 = l5.height / i6 * c6 / i6), void 0 === a4 && (a4 = e4, o5 = r4, e4 = 0, r4 = 0), void 0 !== n6 && void 0 === s6 && (s6 = n6, c6 = i6), void 0 === n6 && void 0 === s6 && (s6 = l5.width, c6 = l5.height);
    for (var m7, v5 = this.ctx.transform.decompose(), w3 = q2(v5.rotate.shx), A3 = new h4(), S3 = (A3 = (A3 = (A3 = A3.multiply(v5.translate)).multiply(v5.skew)).multiply(v5.scale)).applyToRectangle(new u4(a4 - e4 * p8, o5 - r4 * g6, n6 * f5, i6 * d4)), _5 = y3.call(this, S3), P3 = [], k4 = 0; k4 < _5.length; k4 += 1)
      -1 === P3.indexOf(_5[k4]) && P3.push(_5[k4]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j4 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O4 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B3 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m7 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(m7, this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N3([R3], this.posX + this.margin[3], -E3 + O4 + this.ctx.prevPageLastElemOffset)[0];
        var T4 = (C3 > I3 || C3 < F3) && b2.call(this);
        T4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j4, M3, null).clip().discardPath()), this.pdf.addImage(t5, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T4 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t5, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y3 = function(t5, e4, r4) {
    var n6 = [];
    e4 = e4 || this.pdf.internal.pageSize.width, r4 = r4 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i6 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t5.type) {
      default:
      case "mt":
      case "lt":
        n6.push(Math.floor((t5.y + i6) / r4) + 1);
        break;
      case "arc":
        n6.push(Math.floor((t5.y + i6 - t5.radius) / r4) + 1), n6.push(Math.floor((t5.y + i6 + t5.radius) / r4) + 1);
        break;
      case "qct":
        var a4 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t5.x1, t5.y1, t5.x, t5.y);
        n6.push(Math.floor((a4.y + i6) / r4) + 1), n6.push(Math.floor((a4.y + a4.h + i6) / r4) + 1);
        break;
      case "bct":
        var o5 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t5.x1, t5.y1, t5.x2, t5.y2, t5.x, t5.y);
        n6.push(Math.floor((o5.y + i6) / r4) + 1), n6.push(Math.floor((o5.y + o5.h + i6) / r4) + 1);
        break;
      case "rect":
        n6.push(Math.floor((t5.y + i6) / r4) + 1), n6.push(Math.floor((t5.y + t5.h + i6) / r4) + 1);
    }
    for (var s6 = 0; s6 < n6.length; s6 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n6[s6]; )
        w2.call(this);
    return n6;
  }, w2 = function() {
    var t5 = this.fillStyle, e4 = this.strokeStyle, r4 = this.font, n6 = this.lineCap, i6 = this.lineWidth, a4 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t5, this.strokeStyle = e4, this.font = r4, this.lineCap = n6, this.lineWidth = i6, this.lineJoin = a4;
  }, N3 = function(t5, e4, r4) {
    for (var n6 = 0; n6 < t5.length; n6++)
      switch (t5[n6].type) {
        case "bct":
          t5[n6].x2 += e4, t5[n6].y2 += r4;
        case "qct":
          t5[n6].x1 += e4, t5[n6].y1 += r4;
        case "mt":
        case "lt":
        case "arc":
        default:
          t5[n6].x += e4, t5[n6].y += r4;
      }
    return t5;
  }, L2 = function(t5) {
    return t5.sort(function(t6, e4) {
      return t6 - e4;
    });
  }, A2 = function(t5, e4) {
    for (var r4, n6, i6 = this.fillStyle, a4 = this.strokeStyle, o5 = this.lineCap, s6 = this.lineWidth, c6 = Math.abs(s6 * this.ctx.transform.scaleX), u5 = this.lineJoin, h5 = JSON.parse(JSON.stringify(this.path)), l5 = JSON.parse(JSON.stringify(this.path)), f5 = [], d4 = 0; d4 < l5.length; d4++)
      if (void 0 !== l5[d4].x)
        for (var p8 = y3.call(this, l5[d4]), g6 = 0; g6 < p8.length; g6 += 1)
          -1 === f5.indexOf(p8[g6]) && f5.push(p8[g6]);
    for (var m7 = 0; m7 < f5.length; m7++)
      for (; this.pdf.internal.getNumberOfPages() < f5[m7]; )
        w2.call(this);
    if (L2(f5), this.autoPaging)
      for (var v5 = f5[0], A3 = f5[f5.length - 1], S3 = v5; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i6, this.strokeStyle = a4, this.lineCap = o5, this.lineWidth = c6, this.lineJoin = u5;
        var _5 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k4 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r4 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(r4, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t5, true), this.path = C3;
        }
        if (n6 = JSON.parse(JSON.stringify(h5)), this.path = N3(n6, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e4 || 0 === S3) {
          var j4 = (S3 > v5 || S3 < A3) && b2.call(this);
          j4 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _5, I3, null).clip().discardPath()), x2.call(this, t5, e4), j4 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s6;
      }
    else
      this.lineWidth = c6, x2.call(this, t5, e4), this.lineWidth = s6;
    this.path = h5;
  }, x2 = function(t5, e4) {
    if (("stroke" !== t5 || e4 || !v4.call(this)) && ("stroke" === t5 || e4 || !m6.call(this))) {
      for (var r4, n6, i6 = [], a4 = this.path, o5 = 0; o5 < a4.length; o5++) {
        var s6 = a4[o5];
        switch (s6.type) {
          case "begin":
            i6.push({ begin: true });
            break;
          case "close":
            i6.push({ close: true });
            break;
          case "mt":
            i6.push({ start: s6, deltas: [], abs: [] });
            break;
          case "lt":
            var c6 = i6.length;
            if (a4[o5 - 1] && !isNaN(a4[o5 - 1].x) && (r4 = [s6.x - a4[o5 - 1].x, s6.y - a4[o5 - 1].y], c6 > 0)) {
              for (; c6 >= 0; c6--)
                if (true !== i6[c6 - 1].close && true !== i6[c6 - 1].begin) {
                  i6[c6 - 1].deltas.push(r4), i6[c6 - 1].abs.push(s6);
                  break;
                }
            }
            break;
          case "bct":
            r4 = [s6.x1 - a4[o5 - 1].x, s6.y1 - a4[o5 - 1].y, s6.x2 - a4[o5 - 1].x, s6.y2 - a4[o5 - 1].y, s6.x - a4[o5 - 1].x, s6.y - a4[o5 - 1].y], i6[i6.length - 1].deltas.push(r4);
            break;
          case "qct":
            var u5 = a4[o5 - 1].x + 2 / 3 * (s6.x1 - a4[o5 - 1].x), h5 = a4[o5 - 1].y + 2 / 3 * (s6.y1 - a4[o5 - 1].y), l5 = s6.x + 2 / 3 * (s6.x1 - s6.x), f5 = s6.y + 2 / 3 * (s6.y1 - s6.y), d4 = s6.x, p8 = s6.y;
            r4 = [u5 - a4[o5 - 1].x, h5 - a4[o5 - 1].y, l5 - a4[o5 - 1].x, f5 - a4[o5 - 1].y, d4 - a4[o5 - 1].x, p8 - a4[o5 - 1].y], i6[i6.length - 1].deltas.push(r4);
            break;
          case "arc":
            i6.push({ deltas: [], abs: [], arc: true }), Array.isArray(i6[i6.length - 1].abs) && i6[i6.length - 1].abs.push(s6);
        }
      }
      n6 = e4 ? null : "stroke" === t5 ? "stroke" : "fill";
      for (var g6 = false, b3 = 0; b3 < i6.length; b3++)
        if (i6[b3].arc)
          for (var y4 = i6[b3].abs, w3 = 0; w3 < y4.length; w3++) {
            var N4 = y4[w3];
            "arc" === N4.type ? P2.call(this, N4.x, N4.y, N4.radius, N4.startAngle, N4.endAngle, N4.counterclockwise, void 0, e4, !g6) : j3.call(this, N4.x, N4.y), g6 = true;
          }
        else if (true === i6[b3].close)
          this.pdf.internal.out("h"), g6 = false;
        else if (true !== i6[b3].begin) {
          var L3 = i6[b3].start.x, A3 = i6[b3].start.y;
          O3.call(this, i6[b3].deltas, L3, A3), g6 = true;
        }
      n6 && k3.call(this, n6), e4 && I2.call(this);
    }
  }, S2 = function(t5) {
    var e4 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r4 = e4 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t5 - r4;
      case "top":
        return t5 + e4 - r4;
      case "hanging":
        return t5 + e4 - 2 * r4;
      case "middle":
        return t5 + e4 / 2 - r4;
      case "ideographic":
        return t5;
      case "alphabetic":
      default:
        return t5;
    }
  }, _4 = function(t5) {
    return t5 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p7.prototype.createLinearGradient = function() {
    var t5 = function() {
    };
    return t5.colorStops = [], t5.addColorStop = function(t6, e4) {
      this.colorStops.push([t6, e4]);
    }, t5.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t5.isCanvasGradient = true, t5;
  }, p7.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p7.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t5, e4, r4, n6, i6, a4, o5, s6, c6) {
    for (var u5 = M2.call(this, r4, n6, i6, a4), h5 = 0; h5 < u5.length; h5++) {
      var l5 = u5[h5];
      0 === h5 && (c6 ? F2.call(this, l5.x1 + t5, l5.y1 + e4) : j3.call(this, l5.x1 + t5, l5.y1 + e4)), B2.call(this, t5, e4, l5.x2, l5.y2, l5.x3, l5.y3, l5.x4, l5.y4);
    }
    s6 ? I2.call(this) : k3.call(this, o5);
  }, k3 = function(t5) {
    switch (t5) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t5, e4) {
    this.pdf.internal.out(n5(t5) + " " + i5(e4) + " m");
  }, C2 = function(t5) {
    var e4;
    switch (t5.align) {
      case "right":
      case "end":
        e4 = "right";
        break;
      case "center":
        e4 = "center";
        break;
      case "left":
      case "start":
      default:
        e4 = "left";
    }
    var r4 = this.pdf.getTextDimensions(t5.text), n6 = S2.call(this, t5.y), i6 = _4.call(this, n6) - r4.h, a4 = this.ctx.transform.applyToPoint(new c5(t5.x, n6)), o5 = this.ctx.transform.decompose(), s6 = new h4();
    s6 = (s6 = (s6 = s6.multiply(o5.translate)).multiply(o5.skew)).multiply(o5.scale);
    for (var l5, f5, d4, p8 = this.ctx.transform.applyToRectangle(new u4(t5.x, n6, r4.w, r4.h)), g6 = s6.applyToRectangle(new u4(t5.x, i6, r4.w, r4.h)), m7 = y3.call(this, g6), v5 = [], w3 = 0; w3 < m7.length; w3 += 1)
      -1 === v5.indexOf(m7[w3]) && v5.push(m7[w3]);
    if (L2(v5), this.autoPaging)
      for (var A3 = v5[0], P3 = v5[v5.length - 1], k4 = A3; k4 < P3 + 1; k4++) {
        this.pdf.setPage(k4);
        var I3 = 1 === k4 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j4 = C3 - this.margin[0], O4 = this.pdf.internal.pageSize.width - this.margin[1], B3 = O4 - this.margin[3], M3 = 1 === k4 ? 0 : F3 + (k4 - 2) * j4;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l5 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N3(l5, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N3([JSON.parse(JSON.stringify(g6))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t5.scale >= 0.01 && (f5 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f5 * t5.scale), d4 = this.lineWidth, this.lineWidth = d4 * t5.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O4) {
            var R3 = D3 ? t5.text : this.pdf.splitTextToSize(t5.text, t5.maxWidth || O4 - q3.x)[0], T4 = N3([JSON.parse(JSON.stringify(p8))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k4 > A3 || k4 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B3, j4, null).clip().discardPath()), this.pdf.text(R3, T4.x, T4.y, { angle: t5.angle, align: e4, renderingMode: t5.renderingMode }), U2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t5.scale >= 0.01 && (this.pdf.setFontSize(f5), this.lineWidth = d4);
      }
    else
      t5.scale >= 0.01 && (f5 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f5 * t5.scale), d4 = this.lineWidth, this.lineWidth = d4 * t5.scale), this.pdf.text(t5.text, a4.x + this.posX, a4.y + this.posY, { angle: t5.angle, align: e4, renderingMode: t5.renderingMode, maxWidth: t5.maxWidth }), t5.scale >= 0.01 && (this.pdf.setFontSize(f5), this.lineWidth = d4);
  }, j3 = function(t5, e4, r4, a4) {
    r4 = r4 || 0, a4 = a4 || 0, this.pdf.internal.out(n5(t5 + r4) + " " + i5(e4 + a4) + " l");
  }, O3 = function(t5, e4, r4) {
    return this.pdf.lines(t5, e4, r4, null, null);
  }, B2 = function(t5, e4, n6, i6, a4, c6, u5, h5) {
    this.pdf.internal.out([r3(o4(n6 + t5)), r3(s5(i6 + e4)), r3(o4(a4 + t5)), r3(s5(c6 + e4)), r3(o4(u5 + t5)), r3(s5(h5 + e4)), "c"].join(" "));
  }, M2 = function(t5, e4, r4, n6) {
    for (var i6 = 2 * Math.PI, a4 = Math.PI / 2; e4 > r4; )
      e4 -= i6;
    var o5 = Math.abs(r4 - e4);
    o5 < i6 && n6 && (o5 = i6 - o5);
    for (var s6 = [], c6 = n6 ? -1 : 1, u5 = e4; o5 > 1e-5; ) {
      var h5 = u5 + c6 * Math.min(o5, a4);
      s6.push(E2.call(this, t5, u5, h5)), o5 -= Math.abs(h5 - u5), u5 = h5;
    }
    return s6;
  }, E2 = function(t5, e4, r4) {
    var n6 = (r4 - e4) / 2, i6 = t5 * Math.cos(n6), a4 = t5 * Math.sin(n6), o5 = i6, s6 = -a4, c6 = o5 * o5 + s6 * s6, u5 = c6 + o5 * i6 + s6 * a4, h5 = 4 / 3 * (Math.sqrt(2 * c6 * u5) - u5) / (o5 * a4 - s6 * i6), l5 = o5 - h5 * s6, f5 = s6 + h5 * o5, d4 = l5, p8 = -f5, g6 = n6 + e4, m7 = Math.cos(g6), v5 = Math.sin(g6);
    return { x1: t5 * Math.cos(e4), y1: t5 * Math.sin(e4), x2: l5 * m7 - f5 * v5, y2: l5 * v5 + f5 * m7, x3: d4 * m7 - p8 * v5, y3: d4 * v5 + p8 * m7, x4: t5 * Math.cos(r4), y4: t5 * Math.sin(r4) };
  }, q2 = function(t5) {
    return 180 * t5 / Math.PI;
  }, D2 = function(t5, e4, r4, n6, i6, a4) {
    var o5 = t5 + 0.5 * (r4 - t5), s6 = e4 + 0.5 * (n6 - e4), c6 = i6 + 0.5 * (r4 - i6), h5 = a4 + 0.5 * (n6 - a4), l5 = Math.min(t5, i6, o5, c6), f5 = Math.max(t5, i6, o5, c6), d4 = Math.min(e4, a4, s6, h5), p8 = Math.max(e4, a4, s6, h5);
    return new u4(l5, d4, f5 - l5, p8 - d4);
  }, R2 = function(t5, e4, r4, n6, i6, a4, o5, s6) {
    var c6, h5, l5, f5, d4, p8, g6, m7, v5, b3, y4, w3, N4, L3, A3 = r4 - t5, x3 = n6 - e4, S3 = i6 - r4, _5 = a4 - n6, P3 = o5 - i6, k4 = s6 - a4;
    for (h5 = 0; h5 < 41; h5++)
      v5 = (g6 = (l5 = t5 + (c6 = h5 / 40) * A3) + c6 * ((d4 = r4 + c6 * S3) - l5)) + c6 * (d4 + c6 * (i6 + c6 * P3 - d4) - g6), b3 = (m7 = (f5 = e4 + c6 * x3) + c6 * ((p8 = n6 + c6 * _5) - f5)) + c6 * (p8 + c6 * (a4 + c6 * k4 - p8) - m7), 0 == h5 ? (y4 = v5, w3 = b3, N4 = v5, L3 = b3) : (y4 = Math.min(y4, v5), w3 = Math.min(w3, b3), N4 = Math.max(N4, v5), L3 = Math.max(L3, b3));
    return new u4(Math.round(y4), Math.round(w3), Math.round(N4 - y4), Math.round(L3 - w3));
  }, T3 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t5, e4, r4 = (t5 = this.ctx.lineDash, e4 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t5, lineDashOffset: e4 }));
      this.prevLineDash !== r4 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r4);
    }
  };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var r3 = function(t6) {
    var e3, r4, n6, i6, a5, o4, s5, c5, u4, h4;
    for (/[^\x00-\xFF]/.test(t6), r4 = [], n6 = 0, i6 = (t6 += e3 = "\0\0\0\0".slice(t6.length % 4 || 4)).length; i6 > n6; n6 += 4)
      0 !== (a5 = (t6.charCodeAt(n6) << 24) + (t6.charCodeAt(n6 + 1) << 16) + (t6.charCodeAt(n6 + 2) << 8) + t6.charCodeAt(n6 + 3)) ? (o4 = (a5 = ((a5 = ((a5 = ((a5 = (a5 - (h4 = a5 % 85)) / 85) - (u4 = a5 % 85)) / 85) - (c5 = a5 % 85)) / 85) - (s5 = a5 % 85)) / 85) % 85, r4.push(o4 + 33, s5 + 33, c5 + 33, u4 + 33, h4 + 33)) : r4.push(122);
    return function(t7, e4) {
      for (var r5 = e4; r5 > 0; r5--)
        t7.pop();
    }(r4, e3.length), String.fromCharCode.apply(String, r4) + "~>";
  }, n5 = function(t6) {
    var e3, r4, n6, i6, a5, o4 = String, s5 = "length", c5 = 255, u4 = "charCodeAt", h4 = "slice", l4 = "replace";
    for (t6[h4](-2), t6 = t6[h4](0, -2)[l4](/\s/g, "")[l4]("z", "!!!!!"), n6 = [], i6 = 0, a5 = (t6 += e3 = "uuuuu"[h4](t6[s5] % 5 || 5))[s5]; a5 > i6; i6 += 5)
      r4 = 52200625 * (t6[u4](i6) - 33) + 614125 * (t6[u4](i6 + 1) - 33) + 7225 * (t6[u4](i6 + 2) - 33) + 85 * (t6[u4](i6 + 3) - 33) + (t6[u4](i6 + 4) - 33), n6.push(c5 & r4 >> 24, c5 & r4 >> 16, c5 & r4 >> 8, c5 & r4);
    return function(t7, e4) {
      for (var r5 = e4; r5 > 0; r5--)
        t7.pop();
    }(n6, e3[s5]), o4.fromCharCode.apply(o4, n6);
  }, i5 = function(t6) {
    var e3 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t6 = t6.replace(/\s/g, "")).indexOf(">") && (t6 = t6.substr(0, t6.indexOf(">"))), t6.length % 2 && (t6 += "0"), false === e3.test(t6))
      return "";
    for (var r4 = "", n6 = 0; n6 < t6.length; n6 += 2)
      r4 += String.fromCharCode("0x" + (t6[n6] + t6[n6 + 1]));
    return r4;
  }, a4 = function(t6) {
    for (var r4 = new Uint8Array(t6.length), n6 = t6.length; n6--; )
      r4[n6] = t6.charCodeAt(n6);
    return t6 = (r4 = zlibSync(r4)).reduce(function(t7, e3) {
      return t7 + String.fromCharCode(e3);
    }, "");
  };
  t5.processDataByFilters = function(t6, e3) {
    var o4 = 0, s5 = t6 || "", c5 = [];
    for ("string" == typeof (e3 = e3 || []) && (e3 = [e3]), o4 = 0; o4 < e3.length; o4 += 1)
      switch (e3[o4]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s5 = n5(s5), c5.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s5 = r3(s5), c5.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s5 = i5(s5), c5.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s5 = s5.split("").map(function(t7) {
            return ("0" + t7.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c5.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s5 = a4(s5), c5.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e3[o4] + '" is not implemented');
      }
    return { data: s5, reverseChain: c5.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  t5.loadFile = function(t6, e3, r3) {
    return function(t7, e4, r4) {
      e4 = false !== e4, r4 = "function" == typeof r4 ? r4 : function() {
      };
      var n5 = void 0;
      try {
        n5 = function(t8, e5, r5) {
          var n6 = new XMLHttpRequest(), i5 = 0, a4 = function(t9) {
            var e6 = t9.length, r6 = [], n7 = String.fromCharCode;
            for (i5 = 0; i5 < e6; i5 += 1)
              r6.push(n7(255 & t9.charCodeAt(i5)));
            return r6.join("");
          };
          if (n6.open("GET", t8, !e5), n6.overrideMimeType("text/plain; charset=x-user-defined"), false === e5 && (n6.onload = function() {
            200 === n6.status ? r5(a4(this.responseText)) : r5(void 0);
          }), n6.send(null), e5 && 200 === n6.status)
            return a4(n6.responseText);
        }(t7, e4, r4);
      } catch (t8) {
      }
      return n5;
    }(t6, e3, r3);
  }, t5.loadImageFile = t5.loadFile;
}(E.API), function(e3) {
  function r3() {
    return (n4.html2canvas ? Promise.resolve(n4.html2canvas) : Promise.resolve().then(() => __toESM(require_html2canvas()))).catch(function(t5) {
      return Promise.reject(new Error("Could not load html2canvas: " + t5));
    }).then(function(t5) {
      return t5.default ? t5.default : t5;
    });
  }
  function i5() {
    return (n4.DOMPurify ? Promise.resolve(n4.DOMPurify) : Promise.resolve().then(() => __toESM(require_purify()))).catch(function(t5) {
      return Promise.reject(new Error("Could not load dompurify: " + t5));
    }).then(function(t5) {
      return t5.default ? t5.default : t5;
    });
  }
  var a4 = function(e4) {
    var r4 = _typeof(e4);
    return "undefined" === r4 ? "undefined" : "string" === r4 || e4 instanceof String ? "string" : "number" === r4 || e4 instanceof Number ? "number" : "function" === r4 || e4 instanceof Function ? "function" : e4 && e4.constructor === Array ? "array" : e4 && 1 === e4.nodeType ? "element" : "object" === r4 ? "object" : "unknown";
  }, o4 = function(t5, e4) {
    var r4 = document.createElement(t5);
    for (var n5 in e4.className && (r4.className = e4.className), e4.innerHTML && e4.dompurify && (r4.innerHTML = e4.dompurify.sanitize(e4.innerHTML)), e4.style)
      r4.style[n5] = e4.style[n5];
    return r4;
  }, s5 = function t5(e4) {
    var r4 = Object.assign(t5.convert(Promise.resolve()), JSON.parse(JSON.stringify(t5.template))), n5 = t5.convert(Promise.resolve(), r4);
    return n5 = (n5 = n5.setProgress(1, t5, 1, [t5])).set(e4);
  };
  (s5.prototype = Object.create(Promise.prototype)).constructor = s5, s5.convert = function(t5, e4) {
    return t5.__proto__ = e4 || s5.prototype, t5;
  }, s5.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s5.prototype.from = function(t5, e4) {
    return this.then(function() {
      switch (e4 = e4 || function(t6) {
        switch (a4(t6)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t6.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t5)) {
        case "string":
          return this.then(i5).then(function(e5) {
            return this.set({ src: o4("div", { innerHTML: t5, dompurify: e5 }) });
          });
        case "element":
          return this.set({ src: t5 });
        case "canvas":
          return this.set({ canvas: t5 });
        case "img":
          return this.set({ img: t5 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s5.prototype.to = function(t5) {
    switch (t5) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s5.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t5 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e4 = function t6(e5, r4) {
        for (var n5 = 3 === e5.nodeType ? document.createTextNode(e5.nodeValue) : e5.cloneNode(false), i6 = e5.firstChild; i6; i6 = i6.nextSibling)
          true !== r4 && 1 === i6.nodeType && "SCRIPT" === i6.nodeName || n5.appendChild(t6(i6, r4));
        return 1 === e5.nodeType && ("CANVAS" === e5.nodeName ? (n5.width = e5.width, n5.height = e5.height, n5.getContext("2d").drawImage(e5, 0, 0)) : "TEXTAREA" !== e5.nodeName && "SELECT" !== e5.nodeName || (n5.value = e5.value), n5.addEventListener("load", function() {
          n5.scrollTop = e5.scrollTop, n5.scrollLeft = e5.scrollLeft;
        }, true)), n5;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e4.tagName && (t5.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o4("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o4("div", { className: "html2pdf__container", style: t5 }), this.prop.container.appendChild(e4), this.prop.container.firstChild.appendChild(o4("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s5.prototype.toCanvas = function() {
    var t5 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t5).then(r3).then(function(t6) {
      var e4 = Object.assign({}, this.opt.html2canvas);
      return delete e4.onrendered, t6(this.prop.container, e4);
    }).then(function(t6) {
      (this.opt.html2canvas.onrendered || function() {
      })(t6), this.prop.canvas = t6, document.body.removeChild(this.prop.overlay);
    });
  }, s5.prototype.toContext2d = function() {
    var t5 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t5).then(r3).then(function(t6) {
      var e4 = this.opt.jsPDF, r4 = this.opt.fontFaces, n5 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i6 = Object.assign({ async: true, allowTaint: true, scale: n5, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i6.onrendered, e4.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e4.context2d.posX = this.opt.x, e4.context2d.posY = this.opt.y, e4.context2d.margin = this.opt.margin, e4.context2d.fontFaces = r4, r4)
        for (var a5 = 0; a5 < r4.length; ++a5) {
          var o5 = r4[a5], s6 = o5.src.find(function(t7) {
            return "truetype" === t7.format;
          });
          s6 && e4.addFont(s6.url, o5.ref.name, o5.ref.style);
        }
      return i6.windowHeight = i6.windowHeight || 0, i6.windowHeight = 0 == i6.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i6.windowHeight, e4.context2d.save(true), t6(this.prop.container, i6);
    }).then(function(t6) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t6), this.prop.canvas = t6, document.body.removeChild(this.prop.overlay);
    });
  }, s5.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t5 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t5;
    });
  }, s5.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s5.prototype.output = function(t5, e4, r4) {
    return "img" === (r4 = r4 || "pdf").toLowerCase() || "image" === r4.toLowerCase() ? this.outputImg(t5, e4) : this.outputPdf(t5, e4);
  }, s5.prototype.outputPdf = function(t5, e4) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t5, e4);
    });
  }, s5.prototype.outputImg = function(t5) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t5) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t5 + '" is not supported.';
      }
    });
  }, s5.prototype.save = function(t5) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t5 ? { filename: t5 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s5.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s5.prototype.set = function(t5) {
    if ("object" !== a4(t5))
      return this;
    var e4 = Object.keys(t5 || {}).map(function(e5) {
      if (e5 in s5.template.prop)
        return function() {
          this.prop[e5] = t5[e5];
        };
      switch (e5) {
        case "margin":
          return this.setMargin.bind(this, t5.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t5.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t5.pageSize);
        default:
          return function() {
            this.opt[e5] = t5[e5];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e4);
    });
  }, s5.prototype.get = function(t5, e4) {
    return this.then(function() {
      var r4 = t5 in s5.template.prop ? this.prop[t5] : this.opt[t5];
      return e4 ? e4(r4) : r4;
    });
  }, s5.prototype.setMargin = function(t5) {
    return this.then(function() {
      switch (a4(t5)) {
        case "number":
          t5 = [t5, t5, t5, t5];
        case "array":
          if (2 === t5.length && (t5 = [t5[0], t5[1], t5[0], t5[1]]), 4 === t5.length)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t5;
    }).then(this.setPageSize);
  }, s5.prototype.setPageSize = function(t5) {
    function e4(t6, e5) {
      return Math.floor(t6 * e5 / 72 * 96);
    }
    return this.then(function() {
      (t5 = t5 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t5.inner = { width: t5.width - this.opt.margin[1] - this.opt.margin[3], height: t5.height - this.opt.margin[0] - this.opt.margin[2] }, t5.inner.px = { width: e4(t5.inner.width, t5.k), height: e4(t5.inner.height, t5.k) }, t5.inner.ratio = t5.inner.height / t5.inner.width), this.prop.pageSize = t5;
    });
  }, s5.prototype.setProgress = function(t5, e4, r4, n5) {
    return null != t5 && (this.progress.val = t5), null != e4 && (this.progress.state = e4), null != r4 && (this.progress.n = r4), null != n5 && (this.progress.stack = n5), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s5.prototype.updateProgress = function(t5, e4, r4, n5) {
    return this.setProgress(t5 ? this.progress.val + t5 : null, e4 || null, r4 ? this.progress.n + r4 : null, n5 ? this.progress.stack.concat(n5) : null);
  }, s5.prototype.then = function(t5, e4) {
    var r4 = this;
    return this.thenCore(t5, e4, function(t6, e5) {
      return r4.updateProgress(null, null, 1, [t6]), Promise.prototype.then.call(this, function(e6) {
        return r4.updateProgress(null, t6), e6;
      }).then(t6, e5).then(function(t7) {
        return r4.updateProgress(1), t7;
      });
    });
  }, s5.prototype.thenCore = function(t5, e4, r4) {
    r4 = r4 || Promise.prototype.then;
    t5 && (t5 = t5.bind(this)), e4 && (e4 = e4.bind(this));
    var n5 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s5.convert(Object.assign({}, this), Promise.prototype), i6 = r4.call(n5, t5, e4);
    return s5.convert(i6, this.__proto__);
  }, s5.prototype.thenExternal = function(t5, e4) {
    return Promise.prototype.then.call(this, t5, e4);
  }, s5.prototype.thenList = function(t5) {
    var e4 = this;
    return t5.forEach(function(t6) {
      e4 = e4.thenCore(t6);
    }), e4;
  }, s5.prototype.catch = function(t5) {
    t5 && (t5 = t5.bind(this));
    var e4 = Promise.prototype.catch.call(this, t5);
    return s5.convert(e4, this);
  }, s5.prototype.catchExternal = function(t5) {
    return Promise.prototype.catch.call(this, t5);
  }, s5.prototype.error = function(t5) {
    return this.then(function() {
      throw new Error(t5);
    });
  }, s5.prototype.using = s5.prototype.set, s5.prototype.saveAs = s5.prototype.save, s5.prototype.export = s5.prototype.output, s5.prototype.run = s5.prototype.then, E.getPageSize = function(e4, r4, n5) {
    if ("object" === _typeof(e4)) {
      var i6 = e4;
      e4 = i6.orientation, r4 = i6.unit || r4, n5 = i6.format || n5;
    }
    r4 = r4 || "mm", n5 = n5 || "a4", e4 = ("" + (e4 || "P")).toLowerCase();
    var a5, o5 = ("" + n5).toLowerCase(), s6 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r4) {
      case "pt":
        a5 = 1;
        break;
      case "mm":
        a5 = 72 / 25.4;
        break;
      case "cm":
        a5 = 72 / 2.54;
        break;
      case "in":
        a5 = 72;
        break;
      case "px":
        a5 = 0.75;
        break;
      case "pc":
      case "em":
        a5 = 12;
        break;
      case "ex":
        a5 = 6;
        break;
      default:
        throw "Invalid unit: " + r4;
    }
    var c5, u4 = 0, h4 = 0;
    if (s6.hasOwnProperty(o5))
      u4 = s6[o5][1] / a5, h4 = s6[o5][0] / a5;
    else
      try {
        u4 = n5[1], h4 = n5[0];
      } catch (t5) {
        throw new Error("Invalid format: " + n5);
      }
    if ("p" === e4 || "portrait" === e4)
      e4 = "p", h4 > u4 && (c5 = h4, h4 = u4, u4 = c5);
    else {
      if ("l" !== e4 && "landscape" !== e4)
        throw "Invalid orientation: " + e4;
      e4 = "l", u4 > h4 && (c5 = h4, h4 = u4, u4 = c5);
    }
    return { width: h4, height: u4, unit: r4, k: a5, orientation: e4 };
  }, e3.html = function(t5, e4) {
    (e4 = e4 || {}).callback = e4.callback || function() {
    }, e4.html2canvas = e4.html2canvas || {}, e4.html2canvas.canvas = e4.html2canvas.canvas || this.canvas, e4.jsPDF = e4.jsPDF || this, e4.fontFaces = e4.fontFaces ? e4.fontFaces.map(jt) : null;
    var r4 = new s5(e4);
    return e4.worker ? r4 : r4.from(t5).doCallback();
  };
}(E.API), E.API.addJS = function(t5) {
  return Ht = t5, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3;
  t5.events.push(["postPutResources", function() {
    var t6 = this, r3 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n5 = t6.outline.render().split(/\r\n/), i5 = 0; i5 < n5.length; i5++) {
        var a4 = n5[i5], o4 = r3.exec(a4);
        if (null != o4) {
          var s5 = o4[1];
          t6.internal.newObjectDeferredBegin(s5, false);
        }
        t6.internal.write(a4);
      }
    if (this.outline.createNamedDestinations) {
      var c5 = this.internal.pages.length, u4 = [];
      for (i5 = 0; i5 < c5; i5++) {
        var h4 = t6.internal.newObject();
        u4.push(h4);
        var l4 = t6.internal.getPageInfo(i5 + 1);
        t6.internal.write("<< /D[" + l4.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f5 = t6.internal.newObject();
      t6.internal.write("<< /Names [ ");
      for (i5 = 0; i5 < u4.length; i5++)
        t6.internal.write("(page_" + (i5 + 1) + ")" + u4[i5] + " 0 R");
      t6.internal.write(" ] >>", "endobj"), e3 = t6.internal.newObject(), t6.internal.write("<< /Dests " + f5 + " 0 R"), t6.internal.write(">>", "endobj");
    }
  }]), t5.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e3 + " 0 R"));
  }]), t5.events.push(["initialized", function() {
    var t6 = this;
    t6.outline = { createNamedDestinations: false, root: { children: [] } }, t6.outline.add = function(t7, e4, r3) {
      var n5 = { title: e4, options: r3, children: [] };
      return null == t7 && (t7 = this.root), t7.children.push(n5), n5;
    }, t6.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t6, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t6.outline.genIds_r = function(e4) {
      e4.id = t6.internal.newObjectDeferred();
      for (var r3 = 0; r3 < e4.children.length; r3++)
        this.genIds_r(e4.children[r3]);
    }, t6.outline.renderRoot = function(t7) {
      this.objStart(t7), this.line("/Type /Outlines"), t7.children.length > 0 && (this.line("/First " + this.makeRef(t7.children[0])), this.line("/Last " + this.makeRef(t7.children[t7.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t7)), this.objEnd();
    }, t6.outline.renderItems = function(e4) {
      for (var r3 = this.ctx.pdf.internal.getVerticalCoordinateString, n5 = 0; n5 < e4.children.length; n5++) {
        var i5 = e4.children[n5];
        this.objStart(i5), this.line("/Title " + this.makeString(i5.title)), this.line("/Parent " + this.makeRef(e4)), n5 > 0 && this.line("/Prev " + this.makeRef(e4.children[n5 - 1])), n5 < e4.children.length - 1 && this.line("/Next " + this.makeRef(e4.children[n5 + 1])), i5.children.length > 0 && (this.line("/First " + this.makeRef(i5.children[0])), this.line("/Last " + this.makeRef(i5.children[i5.children.length - 1])));
        var a4 = this.count = this.count_r({ count: 0 }, i5);
        if (a4 > 0 && this.line("/Count " + a4), i5.options && i5.options.pageNumber) {
          var o4 = t6.internal.getPageInfo(i5.options.pageNumber);
          this.line("/Dest [" + o4.objId + " 0 R /XYZ 0 " + r3(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s5 = 0; s5 < e4.children.length; s5++)
        this.renderItems(e4.children[s5]);
    }, t6.outline.line = function(t7) {
      this.ctx.val += t7 + "\r\n";
    }, t6.outline.makeRef = function(t7) {
      return t7.id + " 0 R";
    }, t6.outline.makeString = function(e4) {
      return "(" + t6.internal.pdfEscape(e4) + ")";
    }, t6.outline.objStart = function(t7) {
      this.ctx.val += "\r\n" + t7.id + " 0 obj\r\n<<\r\n";
    }, t6.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t6.outline.count_r = function(t7, e4) {
      for (var r3 = 0; r3 < e4.children.length; r3++)
        t7.count++, this.count_r(t7, e4.children[r3]);
      return t7.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = [192, 193, 194, 195, 196, 197, 198, 199];
  t5.processJPEG = function(t6, r3, n5, i5, a4, o4) {
    var s5, c5 = this.decode.DCT_DECODE, u4 = null;
    if ("string" == typeof t6 || this.__addimage__.isArrayBuffer(t6) || this.__addimage__.isArrayBufferView(t6)) {
      switch (t6 = a4 || t6, t6 = this.__addimage__.isArrayBuffer(t6) ? new Uint8Array(t6) : t6, (s5 = function(t7) {
        for (var r4, n6 = 256 * t7.charCodeAt(4) + t7.charCodeAt(5), i6 = t7.length, a5 = { width: 0, height: 0, numcomponents: 1 }, o5 = 4; o5 < i6; o5 += 2) {
          if (o5 += n6, -1 !== e3.indexOf(t7.charCodeAt(o5 + 1))) {
            r4 = 256 * t7.charCodeAt(o5 + 5) + t7.charCodeAt(o5 + 6), a5 = { width: 256 * t7.charCodeAt(o5 + 7) + t7.charCodeAt(o5 + 8), height: r4, numcomponents: t7.charCodeAt(o5 + 9) };
            break;
          }
          n6 = 256 * t7.charCodeAt(o5 + 2) + t7.charCodeAt(o5 + 3);
        }
        return a5;
      }(t6 = this.__addimage__.isArrayBufferView(t6) ? this.__addimage__.arrayBufferToBinaryString(t6) : t6)).numcomponents) {
        case 1:
          o4 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o4 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o4 = this.color_spaces.DEVICE_RGB;
      }
      u4 = { data: t6, width: s5.width, height: s5.height, colorSpace: o4, bitsPerComponent: 8, filter: c5, index: r3, alias: n5 };
    }
    return u4;
  };
}(E.API);
var Vt;
var Gt;
var Yt;
var Jt;
var Xt;
var Kt = function() {
  var t5, e3, i5;
  function a4(t6) {
    var e4, r3, n5, i6, a5, o5, s5, c5, u4, h4, l4, f5, d3, p7;
    for (this.data = t6, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o5 = null; ; ) {
      switch (e4 = this.readUInt32(), u4 = function() {
        var t7, e5;
        for (e5 = [], t7 = 0; t7 < 4; ++t7)
          e5.push(String.fromCharCode(this.data[this.pos++]));
        return e5;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e4);
          break;
        case "fcTL":
          o5 && this.animation.frames.push(o5), this.pos += 4, o5 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a5 = this.readUInt16(), i6 = this.readUInt16() || 100, o5.delay = 1e3 * a5 / i6, o5.disposeOp = this.data[this.pos++], o5.blendOp = this.data[this.pos++], o5.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u4 && (this.pos += 4, e4 -= 4), t6 = (null != o5 ? o5.data : void 0) || this.imgData, f5 = 0; 0 <= e4 ? f5 < e4 : f5 > e4; 0 <= e4 ? ++f5 : --f5)
            t6.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n5 = this.palette.length / 3, this.transparency.indexed = this.read(e4), this.transparency.indexed.length > n5)
                throw new Error("More transparent colors than palette size");
              if ((h4 = n5 - this.transparency.indexed.length) > 0)
                for (d3 = 0; 0 <= h4 ? d3 < h4 : d3 > h4; 0 <= h4 ? ++d3 : --d3)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e4)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e4);
          }
          break;
        case "tEXt":
          s5 = (l4 = this.read(e4)).indexOf(0), c5 = String.fromCharCode.apply(String, l4.slice(0, s5)), this.text[c5] = String.fromCharCode.apply(String, l4.slice(s5 + 1));
          break;
        case "IEND":
          return o5 && this.animation.frames.push(o5), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = 4 === (p7 = this.colorType) || 6 === p7, r3 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r3, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e4;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a4.prototype.read = function(t6) {
    var e4, r3;
    for (r3 = [], e4 = 0; 0 <= t6 ? e4 < t6 : e4 > t6; 0 <= t6 ? ++e4 : --e4)
      r3.push(this.data[this.pos++]);
    return r3;
  }, a4.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a4.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a4.prototype.decodePixels = function(t6) {
    var e4 = this.pixelBitlength / 8, n5 = new Uint8Array(this.width * this.height * e4), i6 = 0, a5 = this;
    if (null == t6 && (t6 = this.imgData), 0 === t6.length)
      return new Uint8Array(0);
    function o5(r3, o6, s5, c5) {
      var u4, h4, l4, f5, d3, p7, g5, m6, v4, b2, y3, w2, N3, L2, A2, x2, S2, _4, P2, k3, I2, F2 = Math.ceil((a5.width - r3) / s5), C2 = Math.ceil((a5.height - o6) / c5), j3 = a5.width == F2 && a5.height == C2;
      for (L2 = e4 * F2, w2 = j3 ? n5 : new Uint8Array(L2 * C2), p7 = t6.length, N3 = 0, h4 = 0; N3 < C2 && i6 < p7; ) {
        switch (t6[i6++]) {
          case 0:
            for (f5 = S2 = 0; S2 < L2; f5 = S2 += 1)
              w2[h4++] = t6[i6++];
            break;
          case 1:
            for (f5 = _4 = 0; _4 < L2; f5 = _4 += 1)
              u4 = t6[i6++], d3 = f5 < e4 ? 0 : w2[h4 - e4], w2[h4++] = (u4 + d3) % 256;
            break;
          case 2:
            for (f5 = P2 = 0; P2 < L2; f5 = P2 += 1)
              u4 = t6[i6++], l4 = (f5 - f5 % e4) / e4, A2 = N3 && w2[(N3 - 1) * L2 + l4 * e4 + f5 % e4], w2[h4++] = (A2 + u4) % 256;
            break;
          case 3:
            for (f5 = k3 = 0; k3 < L2; f5 = k3 += 1)
              u4 = t6[i6++], l4 = (f5 - f5 % e4) / e4, d3 = f5 < e4 ? 0 : w2[h4 - e4], A2 = N3 && w2[(N3 - 1) * L2 + l4 * e4 + f5 % e4], w2[h4++] = (u4 + Math.floor((d3 + A2) / 2)) % 256;
            break;
          case 4:
            for (f5 = I2 = 0; I2 < L2; f5 = I2 += 1)
              u4 = t6[i6++], l4 = (f5 - f5 % e4) / e4, d3 = f5 < e4 ? 0 : w2[h4 - e4], 0 === N3 ? A2 = x2 = 0 : (A2 = w2[(N3 - 1) * L2 + l4 * e4 + f5 % e4], x2 = l4 && w2[(N3 - 1) * L2 + (l4 - 1) * e4 + f5 % e4]), g5 = d3 + A2 - x2, m6 = Math.abs(g5 - d3), b2 = Math.abs(g5 - A2), y3 = Math.abs(g5 - x2), v4 = m6 <= b2 && m6 <= y3 ? d3 : b2 <= y3 ? A2 : x2, w2[h4++] = (u4 + v4) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t6[i6 - 1]);
        }
        if (!j3) {
          var O3 = ((o6 + N3 * c5) * a5.width + r3) * e4, B2 = N3 * L2;
          for (f5 = 0; f5 < F2; f5 += 1) {
            for (var M2 = 0; M2 < e4; M2 += 1)
              n5[O3++] = w2[B2++];
            O3 += (s5 - 1) * e4;
          }
        }
        N3++;
      }
    }
    return t6 = unzlibSync(t6), 1 == a5.interlaceMethod ? (o5(0, 0, 8, 8), o5(4, 0, 8, 8), o5(0, 4, 4, 8), o5(2, 0, 4, 4), o5(0, 2, 2, 4), o5(1, 0, 2, 2), o5(0, 1, 1, 2)) : o5(0, 0, 1, 1), n5;
  }, a4.prototype.decodePalette = function() {
    var t6, e4, r3, n5, i6, a5, o5, s5, c5;
    for (r3 = this.palette, a5 = this.transparency.indexed || [], i6 = new Uint8Array((a5.length || 0) + r3.length), n5 = 0, t6 = 0, e4 = o5 = 0, s5 = r3.length; o5 < s5; e4 = o5 += 3)
      i6[n5++] = r3[e4], i6[n5++] = r3[e4 + 1], i6[n5++] = r3[e4 + 2], i6[n5++] = null != (c5 = a5[t6++]) ? c5 : 255;
    return i6;
  }, a4.prototype.copyToImageData = function(t6, e4) {
    var r3, n5, i6, a5, o5, s5, c5, u4, h4, l4, f5;
    if (n5 = this.colors, h4 = null, r3 = this.hasAlphaChannel, this.palette.length && (h4 = null != (f5 = this._decodedPalette) ? f5 : this._decodedPalette = this.decodePalette(), n5 = 4, r3 = true), u4 = (i6 = t6.data || t6).length, o5 = h4 || e4, a5 = s5 = 0, 1 === n5)
      for (; a5 < u4; )
        c5 = h4 ? 4 * e4[a5 / 4] : s5, l4 = o5[c5++], i6[a5++] = l4, i6[a5++] = l4, i6[a5++] = l4, i6[a5++] = r3 ? o5[c5++] : 255, s5 = c5;
    else
      for (; a5 < u4; )
        c5 = h4 ? 4 * e4[a5 / 4] : s5, i6[a5++] = o5[c5++], i6[a5++] = o5[c5++], i6[a5++] = o5[c5++], i6[a5++] = r3 ? o5[c5++] : 255, s5 = c5;
  }, a4.prototype.decode = function() {
    var t6;
    return t6 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t6, this.decodePixels()), t6;
  };
  var o4 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n4)) {
      try {
        e3 = n4.document.createElement("canvas"), i5 = e3.getContext("2d");
      } catch (t6) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o4(), t5 = function(t6) {
    var r3;
    if (true === o4())
      return i5.width = t6.width, i5.height = t6.height, i5.clearRect(0, 0, t6.width, t6.height), i5.putImageData(t6, 0, 0), (r3 = new Image()).src = e3.toDataURL(), r3;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a4.prototype.decodeFrames = function(e4) {
    var r3, n5, i6, a5, o5, s5, c5, u4;
    if (this.animation) {
      for (u4 = [], n5 = o5 = 0, s5 = (c5 = this.animation.frames).length; o5 < s5; n5 = ++o5)
        r3 = c5[n5], i6 = e4.createImageData(r3.width, r3.height), a5 = this.decodePixels(new Uint8Array(r3.data)), this.copyToImageData(i6, a5), r3.imageData = i6, u4.push(r3.image = t5(i6));
      return u4;
    }
  }, a4.prototype.renderFrame = function(t6, e4) {
    var r3, n5, i6;
    return r3 = (n5 = this.animation.frames)[e4], i6 = n5[e4 - 1], 0 === e4 && t6.clearRect(0, 0, this.width, this.height), 1 === (null != i6 ? i6.disposeOp : void 0) ? t6.clearRect(i6.xOffset, i6.yOffset, i6.width, i6.height) : 2 === (null != i6 ? i6.disposeOp : void 0) && t6.putImageData(i6.imageData, i6.xOffset, i6.yOffset), 0 === r3.blendOp && t6.clearRect(r3.xOffset, r3.yOffset, r3.width, r3.height), t6.drawImage(r3.image, r3.xOffset, r3.yOffset);
  }, a4.prototype.animate = function(t6) {
    var e4, r3, n5, i6, a5, o5, s5 = this;
    return r3 = 0, o5 = this.animation, i6 = o5.numFrames, n5 = o5.frames, a5 = o5.numPlays, (e4 = function() {
      var o6, c5;
      if (o6 = r3++ % i6, c5 = n5[o6], s5.renderFrame(t6, o6), i6 > 1 && r3 / i6 < a5)
        return s5.animation._timeout = setTimeout(e4, c5.delay);
    })();
  }, a4.prototype.stopAnimation = function() {
    var t6;
    return clearTimeout(null != (t6 = this.animation) ? t6._timeout : void 0);
  }, a4.prototype.render = function(t6) {
    var e4, r3;
    return t6._png && t6._png.stopAnimation(), t6._png = this, t6.width = this.width, t6.height = this.height, e4 = t6.getContext("2d"), this.animation ? (this.decodeFrames(e4), this.animate(e4)) : (r3 = e4.createImageData(this.width, this.height), this.copyToImageData(r3, this.decodePixels()), e4.putImageData(r3, 0, 0));
  }, a4;
}();
function Zt(t5) {
  var e3 = 0;
  if (71 !== t5[e3++] || 73 !== t5[e3++] || 70 !== t5[e3++] || 56 !== t5[e3++] || 56 != (t5[e3++] + 1 & 253) || 97 !== t5[e3++])
    throw new Error("Invalid GIF 87a/89a header.");
  var r3 = t5[e3++] | t5[e3++] << 8, n5 = t5[e3++] | t5[e3++] << 8, i5 = t5[e3++], a4 = i5 >> 7, o4 = 1 << (7 & i5) + 1;
  t5[e3++];
  t5[e3++];
  var s5 = null, c5 = null;
  a4 && (s5 = e3, c5 = o4, e3 += 3 * o4);
  var u4 = true, h4 = [], l4 = 0, f5 = null, d3 = 0, p7 = null;
  for (this.width = r3, this.height = n5; u4 && e3 < t5.length; )
    switch (t5[e3++]) {
      case 33:
        switch (t5[e3++]) {
          case 255:
            if (11 !== t5[e3] || 78 == t5[e3 + 1] && 69 == t5[e3 + 2] && 84 == t5[e3 + 3] && 83 == t5[e3 + 4] && 67 == t5[e3 + 5] && 65 == t5[e3 + 6] && 80 == t5[e3 + 7] && 69 == t5[e3 + 8] && 50 == t5[e3 + 9] && 46 == t5[e3 + 10] && 48 == t5[e3 + 11] && 3 == t5[e3 + 12] && 1 == t5[e3 + 13] && 0 == t5[e3 + 16])
              e3 += 14, p7 = t5[e3++] | t5[e3++] << 8, e3++;
            else
              for (e3 += 12; ; ) {
                if (!((P2 = t5[e3++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === P2)
                  break;
                e3 += P2;
              }
            break;
          case 249:
            if (4 !== t5[e3++] || 0 !== t5[e3 + 4])
              throw new Error("Invalid graphics extension block.");
            var g5 = t5[e3++];
            l4 = t5[e3++] | t5[e3++] << 8, f5 = t5[e3++], 0 == (1 & g5) && (f5 = null), d3 = g5 >> 2 & 7, e3++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t5[e3++]) >= 0))
                throw Error("Invalid block size");
              if (0 === P2)
                break;
              e3 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t5[e3 - 1].toString(16));
        }
        break;
      case 44:
        var m6 = t5[e3++] | t5[e3++] << 8, v4 = t5[e3++] | t5[e3++] << 8, b2 = t5[e3++] | t5[e3++] << 8, y3 = t5[e3++] | t5[e3++] << 8, w2 = t5[e3++], N3 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s5, x2 = c5, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e3, x2 = L2, e3 += 3 * L2;
        }
        var _4 = e3;
        for (e3++; ; ) {
          var P2;
          if (!((P2 = t5[e3++]) >= 0))
            throw Error("Invalid block size");
          if (0 === P2)
            break;
          e3 += P2;
        }
        h4.push({ x: m6, y: v4, width: b2, height: y3, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _4, data_length: e3 - _4, transparent_index: f5, interlaced: !!N3, delay: l4, disposal: d3 });
        break;
      case 59:
        u4 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t5[e3 - 1].toString(16));
    }
  this.numFrames = function() {
    return h4.length;
  }, this.loopCount = function() {
    return p7;
  }, this.frameInfo = function(t6) {
    if (t6 < 0 || t6 >= h4.length)
      throw new Error("Frame index out of range.");
    return h4[t6];
  }, this.decodeAndBlitFrameBGRA = function(e4, n6) {
    var i6 = this.frameInfo(e4), a5 = i6.width * i6.height, o5 = new Uint8Array(a5);
    $t(t5, i6.data_offset, o5, a5);
    var s6 = i6.palette_offset, c6 = i6.transparent_index;
    null === c6 && (c6 = 256);
    var u5 = i6.width, h5 = r3 - u5, l5 = u5, f6 = 4 * (i6.y * r3 + i6.x), d4 = 4 * ((i6.y + i6.height) * r3 + i6.x), p8 = f6, g6 = 4 * h5;
    true === i6.interlaced && (g6 += 4 * r3 * 7);
    for (var m7 = 8, v5 = 0, b3 = o5.length; v5 < b3; ++v5) {
      var y4 = o5[v5];
      if (0 === l5 && (l5 = u5, (p8 += g6) >= d4 && (g6 = 4 * h5 + 4 * r3 * (m7 - 1), p8 = f6 + (u5 + h5) * (m7 << 1), m7 >>= 1)), y4 === c6)
        p8 += 4;
      else {
        var w3 = t5[s6 + 3 * y4], N4 = t5[s6 + 3 * y4 + 1], L3 = t5[s6 + 3 * y4 + 2];
        n6[p8++] = L3, n6[p8++] = N4, n6[p8++] = w3, n6[p8++] = 255;
      }
      --l5;
    }
  }, this.decodeAndBlitFrameRGBA = function(e4, n6) {
    var i6 = this.frameInfo(e4), a5 = i6.width * i6.height, o5 = new Uint8Array(a5);
    $t(t5, i6.data_offset, o5, a5);
    var s6 = i6.palette_offset, c6 = i6.transparent_index;
    null === c6 && (c6 = 256);
    var u5 = i6.width, h5 = r3 - u5, l5 = u5, f6 = 4 * (i6.y * r3 + i6.x), d4 = 4 * ((i6.y + i6.height) * r3 + i6.x), p8 = f6, g6 = 4 * h5;
    true === i6.interlaced && (g6 += 4 * r3 * 7);
    for (var m7 = 8, v5 = 0, b3 = o5.length; v5 < b3; ++v5) {
      var y4 = o5[v5];
      if (0 === l5 && (l5 = u5, (p8 += g6) >= d4 && (g6 = 4 * h5 + 4 * r3 * (m7 - 1), p8 = f6 + (u5 + h5) * (m7 << 1), m7 >>= 1)), y4 === c6)
        p8 += 4;
      else {
        var w3 = t5[s6 + 3 * y4], N4 = t5[s6 + 3 * y4 + 1], L3 = t5[s6 + 3 * y4 + 2];
        n6[p8++] = w3, n6[p8++] = N4, n6[p8++] = L3, n6[p8++] = 255;
      }
      --l5;
    }
  };
}
function $t(t5, e3, r3, n5) {
  for (var i5 = t5[e3++], o4 = 1 << i5, s5 = o4 + 1, c5 = s5 + 1, u4 = i5 + 1, h4 = (1 << u4) - 1, l4 = 0, f5 = 0, d3 = 0, p7 = t5[e3++], g5 = new Int32Array(4096), m6 = null; ; ) {
    for (; l4 < 16 && 0 !== p7; )
      f5 |= t5[e3++] << l4, l4 += 8, 1 === p7 ? p7 = t5[e3++] : --p7;
    if (l4 < u4)
      break;
    var v4 = f5 & h4;
    if (f5 >>= u4, l4 -= u4, v4 !== o4) {
      if (v4 === s5)
        break;
      for (var b2 = v4 < c5 ? v4 : m6, y3 = 0, w2 = b2; w2 > o4; )
        w2 = g5[w2] >> 8, ++y3;
      var N3 = w2;
      if (d3 + y3 + (b2 !== v4 ? 1 : 0) > n5)
        return void a3.log("Warning, gif stream longer than expected.");
      r3[d3++] = N3;
      var L2 = d3 += y3;
      for (b2 !== v4 && (r3[d3++] = N3), w2 = b2; y3--; )
        w2 = g5[w2], r3[--L2] = 255 & w2, w2 >>= 8;
      null !== m6 && c5 < 4096 && (g5[c5++] = m6 << 8 | N3, c5 >= h4 + 1 && u4 < 12 && (++u4, h4 = h4 << 1 | 1)), m6 = v4;
    } else
      c5 = s5 + 1, h4 = (1 << (u4 = i5 + 1)) - 1, m6 = null;
  }
  return d3 !== n5 && a3.log("Warning, gif stream shorter than expected."), r3;
}
function Qt(t5) {
  var e3, r3, n5, i5, a4, o4 = Math.floor, s5 = new Array(64), c5 = new Array(64), u4 = new Array(64), h4 = new Array(64), l4 = new Array(65535), f5 = new Array(65535), d3 = new Array(64), p7 = new Array(64), g5 = [], m6 = 0, v4 = 7, b2 = new Array(64), y3 = new Array(64), w2 = new Array(64), N3 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _4 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k3 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j3(t6, e4) {
    for (var r4 = 0, n6 = 0, i6 = new Array(), a5 = 1; a5 <= 16; a5++) {
      for (var o5 = 1; o5 <= t6[a5]; o5++)
        i6[e4[n6]] = [], i6[e4[n6]][0] = r4, i6[e4[n6]][1] = a5, n6++, r4++;
      r4 *= 2;
    }
    return i6;
  }
  function O3(t6) {
    for (var e4 = t6[0], r4 = t6[1] - 1; r4 >= 0; )
      e4 & 1 << r4 && (m6 |= 1 << v4), r4--, --v4 < 0 && (255 == m6 ? (B2(255), B2(0)) : B2(m6), v4 = 7, m6 = 0);
  }
  function B2(t6) {
    g5.push(t6);
  }
  function M2(t6) {
    B2(t6 >> 8 & 255), B2(255 & t6);
  }
  function E2(t6, e4, r4, n6, i6) {
    for (var a5, o5 = i6[0], s6 = i6[240], c6 = function(t7, e5) {
      var r5, n7, i7, a6, o6, s7, c7, u6, h6, l5, f6 = 0;
      for (h6 = 0; h6 < 8; ++h6) {
        r5 = t7[f6], n7 = t7[f6 + 1], i7 = t7[f6 + 2], a6 = t7[f6 + 3], o6 = t7[f6 + 4], s7 = t7[f6 + 5], c7 = t7[f6 + 6];
        var p8 = r5 + (u6 = t7[f6 + 7]), g7 = r5 - u6, m8 = n7 + c7, v6 = n7 - c7, b4 = i7 + s7, y5 = i7 - s7, w4 = a6 + o6, N4 = a6 - o6, L3 = p8 + w4, A3 = p8 - w4, x3 = m8 + b4, S3 = m8 - b4;
        t7[f6] = L3 + x3, t7[f6 + 4] = L3 - x3;
        var _5 = 0.707106781 * (S3 + A3);
        t7[f6 + 2] = A3 + _5, t7[f6 + 6] = A3 - _5;
        var P3 = 0.382683433 * ((L3 = N4 + y5) - (S3 = v6 + g7)), k4 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y5 + v6), C3 = g7 + F3, j4 = g7 - F3;
        t7[f6 + 5] = j4 + k4, t7[f6 + 3] = j4 - k4, t7[f6 + 1] = C3 + I3, t7[f6 + 7] = C3 - I3, f6 += 8;
      }
      for (f6 = 0, h6 = 0; h6 < 8; ++h6) {
        r5 = t7[f6], n7 = t7[f6 + 8], i7 = t7[f6 + 16], a6 = t7[f6 + 24], o6 = t7[f6 + 32], s7 = t7[f6 + 40], c7 = t7[f6 + 48];
        var O4 = r5 + (u6 = t7[f6 + 56]), B3 = r5 - u6, M3 = n7 + c7, E3 = n7 - c7, q3 = i7 + s7, D2 = i7 - s7, R2 = a6 + o6, T3 = a6 - o6, U2 = O4 + R2, z2 = O4 - R2, H2 = M3 + q3, W2 = M3 - q3;
        t7[f6] = U2 + H2, t7[f6 + 32] = U2 - H2;
        var V2 = 0.707106781 * (W2 + z2);
        t7[f6 + 16] = z2 + V2, t7[f6 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T3 + D2) - (W2 = E3 + B3)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H2 = D2 + E3), K2 = B3 + X2, Z2 = B3 - X2;
        t7[f6 + 40] = Z2 + Y2, t7[f6 + 24] = Z2 - Y2, t7[f6 + 8] = K2 + J2, t7[f6 + 56] = K2 - J2, f6++;
      }
      for (h6 = 0; h6 < 64; ++h6)
        l5 = t7[h6] * e5[h6], d3[h6] = l5 > 0 ? l5 + 0.5 | 0 : l5 - 0.5 | 0;
      return d3;
    }(t6, e4), u5 = 0; u5 < 64; ++u5)
      p7[A2[u5]] = c6[u5];
    var h5 = p7[0] - r4;
    r4 = p7[0], 0 == h5 ? O3(n6[0]) : (O3(n6[f5[a5 = 32767 + h5]]), O3(l4[a5]));
    for (var g6 = 63; g6 > 0 && 0 == p7[g6]; )
      g6--;
    if (0 == g6)
      return O3(o5), r4;
    for (var m7, v5 = 1; v5 <= g6; ) {
      for (var b3 = v5; 0 == p7[v5] && v5 <= g6; )
        ++v5;
      var y4 = v5 - b3;
      if (y4 >= 16) {
        m7 = y4 >> 4;
        for (var w3 = 1; w3 <= m7; ++w3)
          O3(s6);
        y4 &= 15;
      }
      a5 = 32767 + p7[v5], O3(i6[(y4 << 4) + f5[a5]]), O3(l4[a5]), v5++;
    }
    return 63 != g6 && O3(o5), r4;
  }
  function q2(t6) {
    (t6 = Math.min(Math.max(t6, 1), 100), a4 != t6) && (!function(t7) {
      for (var e4 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r4 = 0; r4 < 64; r4++) {
        var n6 = o4((e4[r4] * t7 + 50) / 100);
        n6 = Math.min(Math.max(n6, 1), 255), s5[A2[r4]] = n6;
      }
      for (var i6 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a5 = 0; a5 < 64; a5++) {
        var l5 = o4((i6[a5] * t7 + 50) / 100);
        l5 = Math.min(Math.max(l5, 1), 255), c5[A2[a5]] = l5;
      }
      for (var f6 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d4 = 0, p8 = 0; p8 < 8; p8++)
        for (var g6 = 0; g6 < 8; g6++)
          u4[d4] = 1 / (s5[A2[d4]] * f6[p8] * f6[g6] * 8), h4[d4] = 1 / (c5[A2[d4]] * f6[p8] * f6[g6] * 8), d4++;
    }(t6 < 50 ? Math.floor(5e3 / t6) : Math.floor(200 - 2 * t6)), a4 = t6);
  }
  this.encode = function(t6, a5) {
    a5 && q2(a5), g5 = new Array(), m6 = 0, v4 = 7, M2(65496), M2(65504), M2(16), B2(74), B2(70), B2(73), B2(70), B2(0), B2(1), B2(1), B2(0), M2(1), M2(1), B2(0), B2(0), function() {
      M2(65499), M2(132), B2(0);
      for (var t7 = 0; t7 < 64; t7++)
        B2(s5[t7]);
      B2(1);
      for (var e4 = 0; e4 < 64; e4++)
        B2(c5[e4]);
    }(), function(t7, e4) {
      M2(65472), M2(17), B2(8), M2(e4), M2(t7), B2(3), B2(1), B2(17), B2(0), B2(2), B2(17), B2(1), B2(3), B2(17), B2(1);
    }(t6.width, t6.height), function() {
      M2(65476), M2(418), B2(0);
      for (var t7 = 0; t7 < 16; t7++)
        B2(x2[t7 + 1]);
      for (var e4 = 0; e4 <= 11; e4++)
        B2(S2[e4]);
      B2(16);
      for (var r4 = 0; r4 < 16; r4++)
        B2(_4[r4 + 1]);
      for (var n6 = 0; n6 <= 161; n6++)
        B2(P2[n6]);
      B2(1);
      for (var i6 = 0; i6 < 16; i6++)
        B2(k3[i6 + 1]);
      for (var a6 = 0; a6 <= 11; a6++)
        B2(I2[a6]);
      B2(17);
      for (var o6 = 0; o6 < 16; o6++)
        B2(F2[o6 + 1]);
      for (var s6 = 0; s6 <= 161; s6++)
        B2(C2[s6]);
    }(), M2(65498), M2(12), B2(3), B2(1), B2(0), B2(2), B2(17), B2(3), B2(17), B2(0), B2(63), B2(0);
    var o5 = 0, l5 = 0, f6 = 0;
    m6 = 0, v4 = 7, this.encode.displayName = "_encode_";
    for (var d4, p8, N4, A3, j4, D2, R2, T3, U2, z2 = t6.data, H2 = t6.width, W2 = t6.height, V2 = 4 * H2, G2 = 0; G2 < W2; ) {
      for (d4 = 0; d4 < V2; ) {
        for (j4 = V2 * G2 + d4, R2 = -1, T3 = 0, U2 = 0; U2 < 64; U2++)
          D2 = j4 + (T3 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T3 >= W2 && (D2 -= V2 * (G2 + 1 + T3 - W2)), d4 + R2 >= V2 && (D2 -= d4 + R2 - V2 + 4), p8 = z2[D2++], N4 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p8] + L2[N4 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y3[U2] = (L2[p8 + 768 >> 0] + L2[N4 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p8 + 1280 >> 0] + L2[N4 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o5 = E2(b2, u4, o5, e3, n5), l5 = E2(y3, h4, l5, r3, i5), f6 = E2(w2, h4, f6, r3, i5), d4 += 32;
      }
      G2 += 8;
    }
    if (v4 >= 0) {
      var Y2 = [];
      Y2[1] = v4 + 1, Y2[0] = (1 << v4 + 1) - 1, O3(Y2);
    }
    return M2(65497), new Uint8Array(g5);
  }, t5 = t5 || 50, function() {
    for (var t6 = String.fromCharCode, e4 = 0; e4 < 256; e4++)
      N3[e4] = t6(e4);
  }(), e3 = j3(x2, S2), r3 = j3(k3, I2), n5 = j3(_4, P2), i5 = j3(F2, C2), function() {
    for (var t6 = 1, e4 = 2, r4 = 1; r4 <= 15; r4++) {
      for (var n6 = t6; n6 < e4; n6++)
        f5[32767 + n6] = r4, l4[32767 + n6] = [], l4[32767 + n6][1] = r4, l4[32767 + n6][0] = n6;
      for (var i6 = -(e4 - 1); i6 <= -t6; i6++)
        f5[32767 + i6] = r4, l4[32767 + i6] = [], l4[32767 + i6][1] = r4, l4[32767 + i6][0] = e4 - 1 + i6;
      t6 <<= 1, e4 <<= 1;
    }
  }(), function() {
    for (var t6 = 0; t6 < 256; t6++)
      L2[t6] = 19595 * t6, L2[t6 + 256 >> 0] = 38470 * t6, L2[t6 + 512 >> 0] = 7471 * t6 + 32768, L2[t6 + 768 >> 0] = -11059 * t6, L2[t6 + 1024 >> 0] = -21709 * t6, L2[t6 + 1280 >> 0] = 32768 * t6 + 8421375, L2[t6 + 1536 >> 0] = -27439 * t6, L2[t6 + 1792 >> 0] = -5329 * t6;
  }(), q2(t5);
}
function te(t5, e3) {
  if (this.pos = 0, this.buffer = t5, this.datav = new DataView(t5.buffer), this.is_with_alpha = !!e3, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag))
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t5) {
  function e3(t6) {
    if (!t6)
      throw Error("assert :P");
  }
  function r3(t6, e4, r4) {
    for (var n6 = 0; 4 > n6; n6++)
      if (t6[e4 + n6] != r4.charCodeAt(n6))
        return true;
    return false;
  }
  function n5(t6, e4, r4, n6, i6) {
    for (var a5 = 0; a5 < i6; a5++)
      t6[e4 + a5] = r4[n6 + a5];
  }
  function i5(t6, e4, r4, n6) {
    for (var i6 = 0; i6 < n6; i6++)
      t6[e4 + i6] = r4;
  }
  function a4(t6) {
    return new Int32Array(t6);
  }
  function o4(t6, e4) {
    for (var r4 = [], n6 = 0; n6 < t6; n6++)
      r4.push(new e4());
    return r4;
  }
  function s5(t6, e4) {
    var r4 = [];
    return function t7(r5, n6, i6) {
      for (var a5 = i6[n6], o5 = 0; o5 < a5 && (r5.push(i6.length > n6 + 1 ? [] : new e4()), !(i6.length < n6 + 1)); o5++)
        t7(r5[o5], n6 + 1, i6);
    }(r4, 0, t6), r4;
  }
  var c5 = function() {
    var t6 = this;
    function c6(t7, e4) {
      for (var r4 = 1 << e4 - 1 >>> 0; t7 & r4; )
        r4 >>>= 1;
      return r4 ? (t7 & r4 - 1) + r4 : t7;
    }
    function u5(t7, r4, n6, i6, a5) {
      e3(!(i6 % n6));
      do {
        t7[r4 + (i6 -= n6)] = a5;
      } while (0 < i6);
    }
    function h5(t7, r4, n6, i6, o5) {
      if (e3(2328 >= o5), 512 >= o5)
        var s6 = a4(512);
      else if (null == (s6 = a4(o5)))
        return 0;
      return function(t8, r5, n7, i7, o6, s7) {
        var h6, f7, d5 = r5, p9 = 1 << n7, g7 = a4(16), m8 = a4(16);
        for (e3(0 != o6), e3(null != i7), e3(null != t8), e3(0 < n7), f7 = 0; f7 < o6; ++f7) {
          if (15 < i7[f7])
            return 0;
          ++g7[i7[f7]];
        }
        if (g7[0] == o6)
          return 0;
        for (m8[1] = 0, h6 = 1; 15 > h6; ++h6) {
          if (g7[h6] > 1 << h6)
            return 0;
          m8[h6 + 1] = m8[h6] + g7[h6];
        }
        for (f7 = 0; f7 < o6; ++f7)
          h6 = i7[f7], 0 < i7[f7] && (s7[m8[h6]++] = f7);
        if (1 == m8[15])
          return (i7 = new l5()).g = 0, i7.value = s7[0], u5(t8, d5, 1, p9, i7), p9;
        var v6, b4 = -1, y5 = p9 - 1, w4 = 0, N5 = 1, L4 = 1, A4 = 1 << n7;
        for (f7 = 0, h6 = 1, o6 = 2; h6 <= n7; ++h6, o6 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g7[h6]))
            return 0;
          for (; 0 < g7[h6]; --g7[h6])
            (i7 = new l5()).g = h6, i7.value = s7[f7++], u5(t8, d5 + w4, o6, A4, i7), w4 = c6(w4, h6);
        }
        for (h6 = n7 + 1, o6 = 2; 15 >= h6; ++h6, o6 <<= 1) {
          if (N5 += L4 <<= 1, 0 > (L4 -= g7[h6]))
            return 0;
          for (; 0 < g7[h6]; --g7[h6]) {
            if (i7 = new l5(), (w4 & y5) != b4) {
              for (d5 += A4, v6 = 1 << (b4 = h6) - n7; 15 > b4 && !(0 >= (v6 -= g7[b4])); )
                ++b4, v6 <<= 1;
              p9 += A4 = 1 << (v6 = b4 - n7), t8[r5 + (b4 = w4 & y5)].g = v6 + n7, t8[r5 + b4].value = d5 - r5 - b4;
            }
            i7.g = h6 - n7, i7.value = s7[f7++], u5(t8, d5 + (w4 >> n7), o6, A4, i7), w4 = c6(w4, h6);
          }
        }
        return N5 != 2 * m8[15] - 1 ? 0 : p9;
      }(t7, r4, n6, i6, o5, s6);
    }
    function l5() {
      this.value = this.g = 0;
    }
    function f6() {
      this.value = this.g = 0;
    }
    function d4() {
      this.G = o4(5, l5), this.H = a4(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o4(Dr, f6);
    }
    function p8(t7, r4, n6, i6) {
      e3(null != t7), e3(null != r4), e3(2147483648 > i6), t7.Ca = 254, t7.I = 0, t7.b = -8, t7.Ka = 0, t7.oa = r4, t7.pa = n6, t7.Jd = r4, t7.Yc = n6 + i6, t7.Zc = 4 <= i6 ? n6 + i6 - 4 + 1 : n6, _4(t7);
    }
    function g6(t7, e4) {
      for (var r4 = 0; 0 < e4--; )
        r4 |= k3(t7, 128) << e4;
      return r4;
    }
    function m7(t7, e4) {
      var r4 = g6(t7, e4);
      return P2(t7) ? -r4 : r4;
    }
    function v5(t7, r4, n6, i6) {
      var a5, o5 = 0;
      for (e3(null != t7), e3(null != r4), e3(4294967288 > i6), t7.Sb = i6, t7.Ra = 0, t7.u = 0, t7.h = 0, 4 < i6 && (i6 = 4), a5 = 0; a5 < i6; ++a5)
        o5 += r4[n6 + a5] << 8 * a5;
      t7.Ra = o5, t7.bb = i6, t7.oa = r4, t7.pa = n6;
    }
    function b3(t7) {
      for (; 8 <= t7.u && t7.bb < t7.Sb; )
        t7.Ra >>>= 8, t7.Ra += t7.oa[t7.pa + t7.bb] << Ur - 8 >>> 0, ++t7.bb, t7.u -= 8;
      A3(t7) && (t7.h = 1, t7.u = 0);
    }
    function y4(t7, r4) {
      if (e3(0 <= r4), !t7.h && r4 <= Tr) {
        var n6 = L3(t7) & Rr[r4];
        return t7.u += r4, b3(t7), n6;
      }
      return t7.h = 1, t7.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N4() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t7) {
      return t7.Ra >>> (t7.u & Ur - 1) >>> 0;
    }
    function A3(t7) {
      return e3(t7.bb <= t7.Sb), t7.h || t7.bb == t7.Sb && t7.u > Ur;
    }
    function x2(t7, e4) {
      t7.u = e4, t7.h = A3(t7);
    }
    function S2(t7) {
      t7.u >= zr && (e3(t7.u >= zr), b3(t7));
    }
    function _4(t7) {
      e3(null != t7 && null != t7.oa), t7.pa < t7.Zc ? (t7.I = (t7.oa[t7.pa++] | t7.I << 8) >>> 0, t7.b += 8) : (e3(null != t7 && null != t7.oa), t7.pa < t7.Yc ? (t7.b += 8, t7.I = t7.oa[t7.pa++] | t7.I << 8) : t7.Ka ? t7.b = 0 : (t7.I <<= 8, t7.b += 8, t7.Ka = 1));
    }
    function P2(t7) {
      return g6(t7, 1);
    }
    function k3(t7, e4) {
      var r4 = t7.Ca;
      0 > t7.b && _4(t7);
      var n6 = t7.b, i6 = r4 * e4 >>> 8, a5 = (t7.I >>> n6 > i6) + 0;
      for (a5 ? (r4 -= i6, t7.I -= i6 + 1 << n6 >>> 0) : r4 = i6 + 1, n6 = r4, i6 = 0; 256 <= n6; )
        i6 += 8, n6 >>= 8;
      return n6 = 7 ^ i6 + Hr[n6], t7.b -= n6, t7.Ca = (r4 << n6) - 1, a5;
    }
    function I2(t7, e4, r4) {
      t7[e4 + 0] = r4 >> 24 & 255, t7[e4 + 1] = r4 >> 16 & 255, t7[e4 + 2] = r4 >> 8 & 255, t7[e4 + 3] = r4 >> 0 & 255;
    }
    function F2(t7, e4) {
      return t7[e4 + 0] << 0 | t7[e4 + 1] << 8;
    }
    function C2(t7, e4) {
      return F2(t7, e4) | t7[e4 + 2] << 16;
    }
    function j3(t7, e4) {
      return F2(t7, e4) | F2(t7, e4 + 2) << 16;
    }
    function O3(t7, r4) {
      var n6 = 1 << r4;
      return e3(null != t7), e3(0 < r4), t7.X = a4(n6), null == t7.X ? 0 : (t7.Mb = 32 - r4, t7.Xa = r4, 1);
    }
    function B2(t7, r4) {
      e3(null != t7), e3(null != r4), e3(t7.Xa == r4.Xa), n5(r4.X, 0, t7.X, 0, 1 << r4.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t7, r4, n6, i6) {
      e3(null != n6), e3(null != i6);
      var a5 = n6[0], o5 = i6[0];
      return 0 == a5 && (a5 = (t7 * o5 + r4 / 2) / r4), 0 == o5 && (o5 = (r4 * a5 + t7 / 2) / t7), 0 >= a5 || 0 >= o5 ? 0 : (n6[0] = a5, i6[0] = o5, 1);
    }
    function q2(t7, e4) {
      return t7 + (1 << e4) - 1 >>> e4;
    }
    function D2(t7, e4) {
      return ((4278255360 & t7) + (4278255360 & e4) >>> 0 & 4278255360) + ((16711935 & t7) + (16711935 & e4) >>> 0 & 16711935) >>> 0;
    }
    function R2(e4, r4) {
      t6[r4] = function(r5, n6, i6, a5, o5, s6, c7) {
        var u6;
        for (u6 = 0; u6 < o5; ++u6) {
          var h6 = t6[e4](s6[c7 + u6 - 1], i6, a5 + u6);
          s6[c7 + u6] = D2(r5[n6 + u6], h6);
        }
      };
    }
    function T3() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t7, e4) {
      return ((4278124286 & (t7 ^ e4)) >>> 1) + (t7 & e4) >>> 0;
    }
    function z2(t7) {
      return 0 <= t7 && 256 > t7 ? t7 : 0 > t7 ? 0 : 255 < t7 ? 255 : void 0;
    }
    function H2(t7, e4) {
      return z2(t7 + (t7 - e4 + 0.5 >> 1));
    }
    function W2(t7, e4, r4) {
      return Math.abs(e4 - r4) - Math.abs(t7 - r4);
    }
    function V2(t7, e4, r4, n6, i6, a5, o5) {
      for (n6 = a5[o5 - 1], r4 = 0; r4 < i6; ++r4)
        a5[o5 + r4] = n6 = D2(t7[e4 + r4], n6);
    }
    function G2(t7, e4, r4, n6, i6) {
      var a5;
      for (a5 = 0; a5 < r4; ++a5) {
        var o5 = t7[e4 + a5], s6 = o5 >> 8 & 255, c7 = 16711935 & (c7 = (c7 = 16711935 & o5) + ((s6 << 16) + s6));
        n6[i6 + a5] = (4278255360 & o5) + c7 >>> 0;
      }
    }
    function Y2(t7, e4) {
      e4.jd = t7 >> 0 & 255, e4.hd = t7 >> 8 & 255, e4.ud = t7 >> 16 & 255;
    }
    function J2(t7, e4, r4, n6, i6, a5) {
      var o5;
      for (o5 = 0; o5 < n6; ++o5) {
        var s6 = e4[r4 + o5], c7 = s6 >>> 8, u6 = s6, h6 = 255 & (h6 = (h6 = s6 >>> 16) + ((t7.jd << 24 >> 24) * (c7 << 24 >> 24) >>> 5));
        u6 = 255 & (u6 = (u6 = u6 + ((t7.hd << 24 >> 24) * (c7 << 24 >> 24) >>> 5)) + ((t7.ud << 24 >> 24) * (h6 << 24 >> 24) >>> 5));
        i6[a5 + o5] = (4278255360 & s6) + (h6 << 16) + u6;
      }
    }
    function X2(e4, r4, n6, i6, a5) {
      t6[r4] = function(t7, e5, r5, n7, o5, s6, c7, u6, h6) {
        for (n7 = c7; n7 < u6; ++n7)
          for (c7 = 0; c7 < h6; ++c7)
            o5[s6++] = a5(r5[i6(t7[e5++])]);
      }, t6[e4] = function(e5, r5, o5, s6, c7, u6, h6) {
        var l6 = 8 >> e5.b, f7 = e5.Ea, d5 = e5.K[0], p9 = e5.w;
        if (8 > l6)
          for (e5 = (1 << e5.b) - 1, p9 = (1 << l6) - 1; r5 < o5; ++r5) {
            var g7, m8 = 0;
            for (g7 = 0; g7 < f7; ++g7)
              g7 & e5 || (m8 = i6(s6[c7++])), u6[h6++] = a5(d5[m8 & p9]), m8 >>= l6;
          }
        else
          t6["VP8LMapColor" + n6](s6, c7, d5, p9, u6, h6, r5, o5, f7);
      };
    }
    function K2(t7, e4, r4, n6, i6) {
      for (r4 = e4 + r4; e4 < r4; ) {
        var a5 = t7[e4++];
        n6[i6++] = a5 >> 16 & 255, n6[i6++] = a5 >> 8 & 255, n6[i6++] = a5 >> 0 & 255;
      }
    }
    function Z2(t7, e4, r4, n6, i6) {
      for (r4 = e4 + r4; e4 < r4; ) {
        var a5 = t7[e4++];
        n6[i6++] = a5 >> 16 & 255, n6[i6++] = a5 >> 8 & 255, n6[i6++] = a5 >> 0 & 255, n6[i6++] = a5 >> 24 & 255;
      }
    }
    function $2(t7, e4, r4, n6, i6) {
      for (r4 = e4 + r4; e4 < r4; ) {
        var a5 = (o5 = t7[e4++]) >> 16 & 240 | o5 >> 12 & 15, o5 = o5 >> 0 & 240 | o5 >> 28 & 15;
        n6[i6++] = a5, n6[i6++] = o5;
      }
    }
    function Q2(t7, e4, r4, n6, i6) {
      for (r4 = e4 + r4; e4 < r4; ) {
        var a5 = (o5 = t7[e4++]) >> 16 & 248 | o5 >> 13 & 7, o5 = o5 >> 5 & 224 | o5 >> 3 & 31;
        n6[i6++] = a5, n6[i6++] = o5;
      }
    }
    function tt2(t7, e4, r4, n6, i6) {
      for (r4 = e4 + r4; e4 < r4; ) {
        var a5 = t7[e4++];
        n6[i6++] = a5 >> 0 & 255, n6[i6++] = a5 >> 8 & 255, n6[i6++] = a5 >> 16 & 255;
      }
    }
    function et3(t7, e4, r4, i6, a5, o5) {
      if (0 == o5)
        for (r4 = e4 + r4; e4 < r4; )
          I2(i6, ((o5 = t7[e4++])[0] >> 24 | o5[1] >> 8 & 65280 | o5[2] << 8 & 16711680 | o5[3] << 24) >>> 0), a5 += 32;
      else
        n5(i6, a5, t7, e4, r4);
    }
    function rt2(e4, r4) {
      t6[r4][0] = t6[e4 + "0"], t6[r4][1] = t6[e4 + "1"], t6[r4][2] = t6[e4 + "2"], t6[r4][3] = t6[e4 + "3"], t6[r4][4] = t6[e4 + "4"], t6[r4][5] = t6[e4 + "5"], t6[r4][6] = t6[e4 + "6"], t6[r4][7] = t6[e4 + "7"], t6[r4][8] = t6[e4 + "8"], t6[r4][9] = t6[e4 + "9"], t6[r4][10] = t6[e4 + "10"], t6[r4][11] = t6[e4 + "11"], t6[r4][12] = t6[e4 + "12"], t6[r4][13] = t6[e4 + "13"], t6[r4][14] = t6[e4 + "0"], t6[r4][15] = t6[e4 + "0"];
    }
    function nt2(t7) {
      return t7 == Hn || t7 == Wn || t7 == Vn || t7 == Gn;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t7) {
      return alert("todo:WebPSamplerProcessPlane"), t7.T;
    }
    function ht2(t7, e4) {
      var r4 = t7.T, i6 = e4.ba.f.RGBA, a5 = i6.eb, o5 = i6.fb + t7.ka * i6.A, s6 = vi[e4.ba.S], c7 = t7.y, u6 = t7.O, h6 = t7.f, l6 = t7.N, f7 = t7.ea, d5 = t7.W, p9 = e4.cc, g7 = e4.dc, m8 = e4.Mc, v6 = e4.Nc, b4 = t7.ka, y5 = t7.ka + t7.T, w4 = t7.U, N5 = w4 + 1 >> 1;
      for (0 == b4 ? s6(c7, u6, null, null, h6, l6, f7, d5, h6, l6, f7, d5, a5, o5, null, null, w4) : (s6(e4.ec, e4.fc, c7, u6, p9, g7, m8, v6, h6, l6, f7, d5, a5, o5 - i6.A, a5, o5, w4), ++r4); b4 + 2 < y5; b4 += 2)
        p9 = h6, g7 = l6, m8 = f7, v6 = d5, l6 += t7.Rc, d5 += t7.Rc, o5 += 2 * i6.A, s6(c7, (u6 += 2 * t7.fa) - t7.fa, c7, u6, p9, g7, m8, v6, h6, l6, f7, d5, a5, o5 - i6.A, a5, o5, w4);
      return u6 += t7.fa, t7.j + y5 < t7.o ? (n5(e4.ec, e4.fc, c7, u6, w4), n5(e4.cc, e4.dc, h6, l6, N5), n5(e4.Mc, e4.Nc, f7, d5, N5), r4--) : 1 & y5 || s6(c7, u6, null, null, h6, l6, f7, d5, h6, l6, f7, d5, a5, o5 + i6.A, null, null, w4), r4;
    }
    function lt2(t7, r4, n6) {
      var i6 = t7.F, a5 = [t7.J];
      if (null != i6) {
        var o5 = t7.U, s6 = r4.ba.S, c7 = s6 == Tn || s6 == Vn;
        r4 = r4.ba.f.RGBA;
        var u6 = [0], h6 = t7.ka;
        u6[0] = t7.T, t7.Kb && (0 == h6 ? --u6[0] : (--h6, a5[0] -= t7.width), t7.j + t7.ka + t7.T == t7.o && (u6[0] = t7.o - t7.j - h6));
        var l6 = r4.eb;
        h6 = r4.fb + h6 * r4.A;
        t7 = Sn(i6, a5[0], t7.width, o5, u6, l6, h6 + (c7 ? 0 : 3), r4.A), e3(n6 == u6), t7 && nt2(s6) && An(l6, h6, c7, o5, u6, r4.A);
      }
      return 0;
    }
    function ft2(t7) {
      var e4 = t7.ma, r4 = e4.ba.S, n6 = 11 > r4, i6 = r4 == qn || r4 == Rn || r4 == Tn || r4 == Un || 12 == r4 || nt2(r4);
      if (e4.memory = null, e4.Ib = null, e4.Jb = null, e4.Nd = null, !Mr(e4.Oa, t7, i6 ? 11 : 12))
        return 0;
      if (i6 && nt2(r4) && br2(), t7.da)
        alert("todo:use_scaling");
      else {
        if (n6) {
          if (e4.Ib = ut2, t7.Kb) {
            if (r4 = t7.U + 1 >> 1, e4.memory = a4(t7.U + 2 * r4), null == e4.memory)
              return 0;
            e4.ec = e4.memory, e4.fc = 0, e4.cc = e4.ec, e4.dc = e4.fc + t7.U, e4.Mc = e4.cc, e4.Nc = e4.dc + r4, e4.Ib = ht2, br2();
          }
        } else
          alert("todo:EmitYUV");
        i6 && (e4.Jb = lt2, n6 && mr());
      }
      if (n6 && !Ci) {
        for (t7 = 0; 256 > t7; ++t7)
          ji[t7] = 89858 * (t7 - 128) + _i >> Si, Mi[t7] = -22014 * (t7 - 128) + _i, Bi[t7] = -45773 * (t7 - 128), Oi[t7] = 113618 * (t7 - 128) + _i >> Si;
        for (t7 = Pi; t7 < ki; ++t7)
          e4 = 76283 * (t7 - 16) + _i >> Si, Ei[t7 - Pi] = Vt2(e4, 255), qi[t7 - Pi] = Vt2(e4 + 8 >> 4, 15);
        Ci = 1;
      }
      return 1;
    }
    function dt2(t7) {
      var r4 = t7.ma, n6 = t7.U, i6 = t7.T;
      return e3(!(1 & t7.ka)), 0 >= n6 || 0 >= i6 ? 0 : (n6 = r4.Ib(t7, r4), null != r4.Jb && r4.Jb(t7, r4, n6), r4.Dc += n6, 1);
    }
    function pt2(t7) {
      t7.ma.memory = null;
    }
    function gt2(t7, e4, r4, n6) {
      return 47 != y4(t7, 8) ? 0 : (e4[0] = y4(t7, 14) + 1, r4[0] = y4(t7, 14) + 1, n6[0] = y4(t7, 1), 0 != y4(t7, 3) ? 0 : !t7.h);
    }
    function mt2(t7, e4) {
      if (4 > t7)
        return t7 + 1;
      var r4 = t7 - 2 >> 1;
      return (2 + (1 & t7) << r4) + y4(e4, r4) + 1;
    }
    function vt2(t7, e4) {
      return 120 < e4 ? e4 - 120 : 1 <= (r4 = ((r4 = $n[e4 - 1]) >> 4) * t7 + (8 - (15 & r4))) ? r4 : 1;
      var r4;
    }
    function bt2(t7, e4, r4) {
      var n6 = L3(r4), i6 = t7[e4 += 255 & n6].g - 8;
      return 0 < i6 && (x2(r4, r4.u + 8), n6 = L3(r4), e4 += t7[e4].value, e4 += n6 & (1 << i6) - 1), x2(r4, r4.u + t7[e4].g), t7[e4].value;
    }
    function yt2(t7, r4, n6) {
      return n6.g += t7.g, n6.value += t7.value << r4 >>> 0, e3(8 >= n6.g), t7.g;
    }
    function wt2(t7, r4, n6) {
      var i6 = t7.xc;
      return e3((r4 = 0 == i6 ? 0 : t7.vc[t7.md * (n6 >> i6) + (r4 >> i6)]) < t7.Wb), t7.Ya[r4];
    }
    function Nt2(t7, r4, i6, a5) {
      var o5 = t7.ab, s6 = t7.c * r4, c7 = t7.C;
      r4 = c7 + r4;
      var u6 = i6, h6 = a5;
      for (a5 = t7.Ta, i6 = t7.Ua; 0 < o5--; ) {
        var l6 = t7.gc[o5], f7 = c7, d5 = r4, p9 = u6, g7 = h6, m8 = (h6 = a5, u6 = i6, l6.Ea);
        switch (e3(f7 < d5), e3(d5 <= l6.nc), l6.hc) {
          case 2:
            Gr(p9, g7, (d5 - f7) * m8, h6, u6);
            break;
          case 0:
            var v6 = f7, b4 = d5, y5 = h6, w4 = u6, N5 = (_5 = l6).Ea;
            0 == v6 && (Wr(p9, g7, null, null, 1, y5, w4), V2(p9, g7 + 1, 0, 0, N5 - 1, y5, w4 + 1), g7 += N5, w4 += N5, ++v6);
            for (var L4 = 1 << _5.b, A4 = L4 - 1, x3 = q2(N5, _5.b), S3 = _5.K, _5 = _5.w + (v6 >> _5.b) * x3; v6 < b4; ) {
              var P3 = S3, k4 = _5, I3 = 1;
              for (Vr(p9, g7, y5, w4 - N5, 1, y5, w4); I3 < N5; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N5 && (F3 = N5), (0, Zr[P3[k4++] >> 8 & 15])(p9, g7 + +I3, y5, w4 + I3 - N5, F3 - I3, y5, w4 + I3), I3 = F3;
              }
              g7 += N5, w4 += N5, ++v6 & A4 || (_5 += x3);
            }
            d5 != l6.nc && n5(h6, u6 - m8, h6, u6 + (d5 - f7 - 1) * m8, m8);
            break;
          case 1:
            for (m8 = p9, b4 = g7, N5 = (p9 = l6.Ea) - (w4 = p9 & ~(y5 = (g7 = 1 << l6.b) - 1)), v6 = q2(p9, l6.b), L4 = l6.K, l6 = l6.w + (f7 >> l6.b) * v6; f7 < d5; ) {
              for (A4 = L4, x3 = l6, S3 = new T3(), _5 = b4 + w4, P3 = b4 + p9; b4 < _5; )
                Y2(A4[x3++], S3), $r(S3, m8, b4, g7, h6, u6), b4 += g7, u6 += g7;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m8, b4, N5, h6, u6), b4 += N5, u6 += N5), ++f7 & y5 || (l6 += v6);
            }
            break;
          case 3:
            if (p9 == h6 && g7 == u6 && 0 < l6.b) {
              for (b4 = h6, p9 = m8 = u6 + (d5 - f7) * m8 - (w4 = (d5 - f7) * q2(l6.Ea, l6.b)), g7 = h6, y5 = u6, v6 = [], w4 = (N5 = w4) - 1; 0 <= w4; --w4)
                v6[w4] = g7[y5 + w4];
              for (w4 = N5 - 1; 0 <= w4; --w4)
                b4[p9 + w4] = v6[w4];
              Yr(l6, f7, d5, h6, m8, h6, u6);
            } else
              Yr(l6, f7, d5, p9, g7, h6, u6);
        }
        u6 = a5, h6 = i6;
      }
      h6 != i6 && n5(a5, i6, u6, h6, s6);
    }
    function Lt2(t7, r4) {
      var n6 = t7.V, i6 = t7.Ba + t7.c * t7.C, a5 = r4 - t7.C;
      if (e3(r4 <= t7.l.o), e3(16 >= a5), 0 < a5) {
        var o5 = t7.l, s6 = t7.Ta, c7 = t7.Ua, u6 = o5.width;
        if (Nt2(t7, a5, n6, i6), a5 = c7 = [c7], e3((n6 = t7.C) < (i6 = r4)), e3(o5.v < o5.va), i6 > o5.o && (i6 = o5.o), n6 < o5.j) {
          var h6 = o5.j - n6;
          n6 = o5.j;
          a5[0] += h6 * u6;
        }
        if (n6 >= i6 ? n6 = 0 : (a5[0] += 4 * o5.v, o5.ka = n6 - o5.j, o5.U = o5.va - o5.v, o5.T = i6 - n6, n6 = 1), n6) {
          if (c7 = c7[0], 11 > (n6 = t7.ca).S) {
            var l6 = n6.f.RGBA, f7 = (i6 = n6.S, a5 = o5.U, o5 = o5.T, h6 = l6.eb, l6.A), d5 = o5;
            for (l6 = l6.fb + t7.Ma * l6.A; 0 < d5--; ) {
              var p9 = s6, g7 = c7, m8 = a5, v6 = h6, b4 = l6;
              switch (i6) {
                case En:
                  Qr(p9, g7, m8, v6, b4);
                  break;
                case qn:
                  tn(p9, g7, m8, v6, b4);
                  break;
                case Hn:
                  tn(p9, g7, m8, v6, b4), An(v6, b4, 0, m8, 1, 0);
                  break;
                case Dn:
                  nn3(p9, g7, m8, v6, b4);
                  break;
                case Rn:
                  et3(p9, g7, m8, v6, b4, 1);
                  break;
                case Wn:
                  et3(p9, g7, m8, v6, b4, 1), An(v6, b4, 0, m8, 1, 0);
                  break;
                case Tn:
                  et3(p9, g7, m8, v6, b4, 0);
                  break;
                case Vn:
                  et3(p9, g7, m8, v6, b4, 0), An(v6, b4, 1, m8, 1, 0);
                  break;
                case Un:
                  en(p9, g7, m8, v6, b4);
                  break;
                case Gn:
                  en(p9, g7, m8, v6, b4), xn(v6, b4, m8, 1, 0);
                  break;
                case zn:
                  rn(p9, g7, m8, v6, b4);
                  break;
                default:
                  e3(0);
              }
              c7 += u6, l6 += f7;
            }
            t7.Ma += o5;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e3(t7.Ma <= n6.height);
        }
      }
      t7.C = r4, e3(t7.C <= t7.i);
    }
    function At2(t7) {
      var e4;
      if (0 < t7.ua)
        return 0;
      for (e4 = 0; e4 < t7.Wb; ++e4) {
        var r4 = t7.Ya[e4].G, n6 = t7.Ya[e4].H;
        if (0 < r4[1][n6[1] + 0].g || 0 < r4[2][n6[2] + 0].g || 0 < r4[3][n6[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t7, r4, n6, i6, a5, o5) {
      if (0 != t7.Z) {
        var s6 = t7.qd, c7 = t7.rd;
        for (e3(null != mi[t7.Z]); r4 < n6; ++r4)
          mi[t7.Z](s6, c7, i6, a5, i6, a5, o5), s6 = i6, c7 = a5, a5 += o5;
        t7.qd = s6, t7.rd = c7;
      }
    }
    function St2(t7, r4) {
      var n6 = t7.l.ma, i6 = 0 == n6.Z || 1 == n6.Z ? t7.l.j : t7.C;
      i6 = t7.C < i6 ? i6 : t7.C;
      if (e3(r4 <= t7.l.o), r4 > i6) {
        var a5 = t7.l.width, o5 = n6.ca, s6 = n6.tb + a5 * i6, c7 = t7.V, u6 = t7.Ba + t7.c * i6, h6 = t7.gc;
        e3(1 == t7.ab), e3(3 == h6[0].hc), Xr(h6[0], i6, r4, c7, u6, o5, s6), xt2(n6, i6, r4, o5, s6, a5);
      }
      t7.C = t7.Ma = r4;
    }
    function _t2(t7, r4, n6, i6, a5, o5, s6) {
      var c7 = t7.$ / i6, u6 = t7.$ % i6, h6 = t7.m, l6 = t7.s, f7 = n6 + t7.$, d5 = f7;
      a5 = n6 + i6 * a5;
      var p9 = n6 + i6 * o5, g7 = 280 + l6.ua, m8 = t7.Pb ? c7 : 16777216, v6 = 0 < l6.ua ? l6.Wa : null, b4 = l6.wc, y5 = f7 < p9 ? wt2(l6, u6, c7) : null;
      e3(t7.C < o5), e3(p9 <= a5);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f7 < p9; ) {
            var N5 = 0;
            if (c7 >= m8) {
              var _5 = f7 - n6;
              e3((m8 = t7).Pb), m8.wd = m8.m, m8.xd = _5, 0 < m8.s.ua && B2(m8.s.Wa, m8.s.vb), m8 = c7 + ti;
            }
            if (u6 & b4 || (y5 = wt2(l6, u6, c7)), e3(null != y5), y5.Qb && (r4[f7] = y5.qb, w4 = true), !w4)
              if (S2(h6), y5.jc) {
                N5 = h6, _5 = r4;
                var P3 = f7, k4 = y5.pd[L3(N5) & Dr - 1];
                e3(y5.jc), 256 > k4.g ? (x2(N5, N5.u + k4.g), _5[P3] = k4.value, N5 = 0) : (x2(N5, N5.u + k4.g - 256), e3(256 <= k4.value), N5 = k4.value), 0 == N5 && (w4 = true);
              } else
                N5 = bt2(y5.G[0], y5.H[0], h6);
            if (h6.h)
              break;
            if (w4 || 256 > N5) {
              if (!w4)
                if (y5.nd)
                  r4[f7] = (y5.qb | N5 << 8) >>> 0;
                else {
                  if (S2(h6), w4 = bt2(y5.G[1], y5.H[1], h6), S2(h6), _5 = bt2(y5.G[2], y5.H[2], h6), P3 = bt2(y5.G[3], y5.H[3], h6), h6.h)
                    break;
                  r4[f7] = (P3 << 24 | w4 << 16 | N5 << 8 | _5) >>> 0;
                }
              if (w4 = false, ++f7, ++u6 >= i6 && (u6 = 0, ++c7, null != s6 && c7 <= o5 && !(c7 % 16) && s6(t7, c7), null != v6))
                for (; d5 < f7; )
                  N5 = r4[d5++], v6.X[(506832829 * N5 & 4294967295) >>> v6.Mb] = N5;
            } else if (280 > N5) {
              if (N5 = mt2(N5 - 256, h6), _5 = bt2(y5.G[4], y5.H[4], h6), S2(h6), _5 = vt2(i6, _5 = mt2(_5, h6)), h6.h)
                break;
              if (f7 - n6 < _5 || a5 - f7 < N5)
                break t;
              for (P3 = 0; P3 < N5; ++P3)
                r4[f7 + P3] = r4[f7 + P3 - _5];
              for (f7 += N5, u6 += N5; u6 >= i6; )
                u6 -= i6, ++c7, null != s6 && c7 <= o5 && !(c7 % 16) && s6(t7, c7);
              if (e3(f7 <= a5), u6 & b4 && (y5 = wt2(l6, u6, c7)), null != v6)
                for (; d5 < f7; )
                  N5 = r4[d5++], v6.X[(506832829 * N5 & 4294967295) >>> v6.Mb] = N5;
            } else {
              if (!(N5 < g7))
                break t;
              for (w4 = N5 - 280, e3(null != v6); d5 < f7; )
                N5 = r4[d5++], v6.X[(506832829 * N5 & 4294967295) >>> v6.Mb] = N5;
              N5 = f7, e3(!(w4 >>> (_5 = v6).Xa)), r4[N5] = _5.X[w4], w4 = true;
            }
            w4 || e3(h6.h == A3(h6));
          }
          if (t7.Pb && h6.h && f7 < a5)
            e3(t7.m.h), t7.a = 5, t7.m = t7.wd, t7.$ = t7.xd, 0 < t7.s.ua && B2(t7.s.vb, t7.s.Wa);
          else {
            if (h6.h)
              break t;
            null != s6 && s6(t7, c7 > o5 ? o5 : c7), t7.a = 0, t7.$ = f7 - n6;
          }
          return 1;
        }
      return t7.a = 3, 0;
    }
    function Pt2(t7) {
      e3(null != t7), t7.vc = null, t7.yc = null, t7.Ya = null;
      var r4 = t7.Wa;
      null != r4 && (r4.X = null), t7.vb = null, e3(null != t7);
    }
    function kt2() {
      var e4 = new or();
      return null == e4 ? null : (e4.a = 0, e4.xb = gi, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn = Z2, en = $2, rn = Q2, nn3 = tt2, t6.VP8LMapColor32b = Jr, t6.VP8LMapColor8b = Kr, e4);
    }
    function It2(t7, r4, n6, s6, c7) {
      var u6 = 1, f7 = [t7], p9 = [r4], g7 = s6.m, m8 = s6.s, v6 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n6)
            for (; u6 && y4(g7, 1); ) {
              var w4 = f7, N5 = p9, A4 = s6, _5 = 1, P3 = A4.m, k4 = A4.gc[A4.ab], I3 = y4(P3, 2);
              if (A4.Oc & 1 << I3)
                u6 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k4.hc = I3, k4.Ea = w4[0], k4.nc = N5[0], k4.K = [null], ++A4.ab, e3(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k4.b = y4(P3, 3) + 2, _5 = It2(q2(k4.Ea, k4.b), q2(k4.nc, k4.b), 0, A4, k4.K), k4.K = k4.K[0];
                    break;
                  case 3:
                    var F3, C3 = y4(P3, 8) + 1, j4 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k4.Ea, j4), k4.b = j4, F3 = _5 = It2(C3, 1, 0, A4, k4.K)) {
                      var B3, M3 = C3, E3 = k4, R3 = 1 << (8 >> E3.b), T4 = a4(R3);
                      if (null == T4)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T4[0] = E3.K[0][0], B3 = 1; B3 < 1 * M3; ++B3)
                          T4[B3] = D2(U3[z3 + B3], T4[B3 - 1]);
                        for (; B3 < 4 * R3; ++B3)
                          T4[B3] = 0;
                        E3.K[0] = null, E3.K[0] = T4, F3 = 1;
                      }
                    }
                    _5 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e3(0);
                }
                u6 = _5;
              }
            }
          if (f7 = f7[0], p9 = p9[0], u6 && y4(g7, 1) && !(u6 = 1 <= (b4 = y4(g7, 4)) && 11 >= b4)) {
            s6.a = 3;
            break t;
          }
          var H3;
          if (H3 = u6)
            e: {
              var W3, V3, G3, Y3 = s6, J3 = f7, X3 = p9, K3 = b4, Z3 = n6, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et4 = 1, rt3 = 0, nt3 = Qn[K3];
              r:
                for (; ; ) {
                  if (Z3 && y4($3, 1)) {
                    var it3 = y4($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et4 && (et4 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o4(et4 * nt3, l5), lt3 = et4, ft3 = o4(lt3, d4);
                  if (null == ft3)
                    var dt3 = null;
                  else
                    e3(65536 >= lt3), dt3 = ft3;
                  var pt3 = a4(rt3);
                  if (null == dt3 || null == pt3 || null == ht3) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et4; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft3 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y4(Ot3, 1);
                        if (i5(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y4(Ot3, 1) + 1, Et3 = y4(Ot3, 1), qt3 = y4(Ot3, 0 == Et3 ? 1 : 8);
                          kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y4(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a4(19), Tt3 = y4(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y4(Ot3, 3);
                          var zt3 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o4(128, l5);
                          i:
                            for (; h5(Zt3, 0, 7, Vt3, 19); ) {
                              if (y4(Xt3, 1)) {
                                var $t3 = 2 + 2 * y4(Xt3, 3);
                                if ((zt3 = 2 + y4(Xt3, $t3)) > Gt3)
                                  break i;
                              } else
                                zt3 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && zt3--; ) {
                                S2(Xt3);
                                var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                                x2(Xt3, Xt3.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                                else {
                                  var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y4(Xt3, Yn[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h5(Ft3, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (0 == Ut3)
                        break r;
                      if (Nt3 && 1 == Kn[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et4, Q3.Ya = dt3, Q3.yc = ht3, H3 = 1;
                  break e;
                }
              H3 = 0;
            }
          if (!(u6 = H3)) {
            s6.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m8.ua = 1 << b4, !O3(m8.Wa, b4)) {
              s6.a = 1, u6 = 0;
              break t;
            }
          } else
            m8.ua = 0;
          var de3 = s6, pe3 = f7, ge3 = p9, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n6) {
            s6.xb = pi;
            break t;
          }
          if (null == (v6 = a4(f7 * p9))) {
            s6.a = 1, u6 = 0;
            break t;
          }
          u6 = (u6 = _t2(s6, v6, 0, f7, p9, p9, null)) && !g7.h;
          break t;
        }
      return u6 ? (null != c7 ? c7[0] = v6 : (e3(null == v6), e3(n6)), s6.$ = 0, n6 || Pt2(m8)) : Pt2(m8), u6;
    }
    function Ft2(t7, r4) {
      var n6 = t7.c * t7.i, i6 = n6 + r4 + 16 * r4;
      return e3(t7.c <= r4), t7.V = a4(i6), null == t7.V ? (t7.Ta = null, t7.Ua = 0, t7.a = 1, 0) : (t7.Ta = t7.V, t7.Ua = t7.Ba + n6 + r4, 1);
    }
    function Ct2(t7, r4) {
      var n6 = t7.C, i6 = r4 - n6, a5 = t7.V, o5 = t7.Ba + t7.c * n6;
      for (e3(r4 <= t7.l.o); 0 < i6; ) {
        var s6 = 16 < i6 ? 16 : i6, c7 = t7.l.ma, u6 = t7.l.width, h6 = u6 * s6, l6 = c7.ca, f7 = c7.tb + u6 * n6, d5 = t7.Ta, p9 = t7.Ua;
        Nt2(t7, s6, a5, o5), _n(d5, p9, l6, f7, h6), xt2(c7, n6, n6 + s6, l6, f7, u6), i6 -= s6, a5 += s6 * t7.c, n6 += s6;
      }
      e3(n6 == r4), t7.C = t7.Ma = r4;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a4(4), this.Lb = a4(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t7 = [];
        return function t8(e4, r4, n6) {
          for (var i6 = n6[r4], a5 = 0; a5 < i6 && (e4.push(n6.length > r4 + 1 ? [] : 0), !(n6.length < r4 + 1)); a5++)
            t8(e4[a5], r4 + 1, n6);
        }(t7, 0, [3, 11]), t7;
      }();
    }
    function Et2() {
      this.jb = a4(3), this.Wc = s5([4, 8], Mt2), this.Xc = s5([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a4(4), this.od = new a4(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a4(384), this.Za = 0, this.Ob = a4(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a4(16), this.f = a4(8), this.ea = a4(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o4(8, w3), this.ia = 0, this.pb = o4(4, Tt2), this.Pa = new Et2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s5([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t7, e4) {
      return 0 > t7 ? 0 : t7 > e4 ? e4 : t7;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t7 = new Wt2();
      return null != t7 && (t7.a = 0, t7.sc = "OK", t7.cb = 0, t7.Xb = 0, ni || (ni = Zt2)), t7;
    }
    function Jt2(t7, e4, r4) {
      return 0 == t7.a && (t7.a = e4, t7.sc = r4, t7.cb = 0), 0;
    }
    function Xt2(t7, e4, r4) {
      return 3 <= r4 && 157 == t7[e4 + 0] && 1 == t7[e4 + 1] && 42 == t7[e4 + 2];
    }
    function Kt2(t7, r4) {
      if (null == t7)
        return 0;
      if (t7.a = 0, t7.sc = "OK", null == r4)
        return Jt2(t7, 2, "null VP8Io passed to VP8GetHeaders()");
      var n6 = r4.data, a5 = r4.w, o5 = r4.ha;
      if (4 > o5)
        return Jt2(t7, 7, "Truncated header.");
      var s6 = n6[a5 + 0] | n6[a5 + 1] << 8 | n6[a5 + 2] << 16, c7 = t7.Od;
      if (c7.Rb = !(1 & s6), c7.td = s6 >> 1 & 7, c7.yd = s6 >> 4 & 1, c7.ub = s6 >> 5, 3 < c7.td)
        return Jt2(t7, 3, "Incorrect keyframe parameters.");
      if (!c7.yd)
        return Jt2(t7, 4, "Frame not displayable.");
      a5 += 3, o5 -= 3;
      var u6 = t7.Kc;
      if (c7.Rb) {
        if (7 > o5)
          return Jt2(t7, 7, "cannot parse picture header");
        if (!Xt2(n6, a5, o5))
          return Jt2(t7, 3, "Bad code word");
        u6.c = 16383 & (n6[a5 + 4] << 8 | n6[a5 + 3]), u6.Td = n6[a5 + 4] >> 6, u6.i = 16383 & (n6[a5 + 6] << 8 | n6[a5 + 5]), u6.Ud = n6[a5 + 6] >> 6, a5 += 7, o5 -= 7, t7.za = u6.c + 15 >> 4, t7.Ub = u6.i + 15 >> 4, r4.width = u6.c, r4.height = u6.i, r4.Da = 0, r4.j = 0, r4.v = 0, r4.va = r4.width, r4.o = r4.height, r4.da = 0, r4.ib = r4.width, r4.hb = r4.height, r4.U = r4.width, r4.T = r4.height, i5((s6 = t7.Pa).jb, 0, 255, s6.jb.length), e3(null != (s6 = t7.Qa)), s6.Cb = 0, s6.Bb = 0, s6.Fb = 1, i5(s6.Zb, 0, 0, s6.Zb.length), i5(s6.Lb, 0, 0, s6.Lb);
      }
      if (c7.ub > o5)
        return Jt2(t7, 7, "bad partition length");
      p8(s6 = t7.m, n6, a5, c7.ub), a5 += c7.ub, o5 -= c7.ub, c7.Rb && (u6.Ld = P2(s6), u6.Kd = P2(s6)), u6 = t7.Qa;
      var h6, l6 = t7.Pa;
      if (e3(null != s6), e3(null != u6), u6.Cb = P2(s6), u6.Cb) {
        if (u6.Bb = P2(s6), P2(s6)) {
          for (u6.Fb = P2(s6), h6 = 0; 4 > h6; ++h6)
            u6.Zb[h6] = P2(s6) ? m7(s6, 7) : 0;
          for (h6 = 0; 4 > h6; ++h6)
            u6.Lb[h6] = P2(s6) ? m7(s6, 6) : 0;
        }
        if (u6.Bb)
          for (h6 = 0; 3 > h6; ++h6)
            l6.jb[h6] = P2(s6) ? g6(s6, 8) : 255;
      } else
        u6.Bb = 0;
      if (s6.Ka)
        return Jt2(t7, 3, "cannot parse segment header");
      if ((u6 = t7.ed).zd = P2(s6), u6.Tb = g6(s6, 6), u6.wb = g6(s6, 3), u6.Pc = P2(s6), u6.Pc && P2(s6)) {
        for (l6 = 0; 4 > l6; ++l6)
          P2(s6) && (u6.vd[l6] = m7(s6, 6));
        for (l6 = 0; 4 > l6; ++l6)
          P2(s6) && (u6.od[l6] = m7(s6, 6));
      }
      if (t7.L = 0 == u6.Tb ? 0 : u6.zd ? 1 : 2, s6.Ka)
        return Jt2(t7, 3, "cannot parse filter header");
      var f7 = o5;
      if (o5 = h6 = a5, a5 = h6 + f7, u6 = f7, t7.Xb = (1 << g6(t7.m, 2)) - 1, f7 < 3 * (l6 = t7.Xb))
        n6 = 7;
      else {
        for (h6 += 3 * l6, u6 -= 3 * l6, f7 = 0; f7 < l6; ++f7) {
          var d5 = n6[o5 + 0] | n6[o5 + 1] << 8 | n6[o5 + 2] << 16;
          d5 > u6 && (d5 = u6), p8(t7.Jc[+f7], n6, h6, d5), h6 += d5, u6 -= d5, o5 += 3;
        }
        p8(t7.Jc[+l6], n6, h6, u6), n6 = h6 < a5 ? 0 : 5;
      }
      if (0 != n6)
        return Jt2(t7, n6, "cannot parse partitions");
      for (n6 = g6(h6 = t7.m, 7), o5 = P2(h6) ? m7(h6, 4) : 0, a5 = P2(h6) ? m7(h6, 4) : 0, u6 = P2(h6) ? m7(h6, 4) : 0, l6 = P2(h6) ? m7(h6, 4) : 0, h6 = P2(h6) ? m7(h6, 4) : 0, f7 = t7.Qa, d5 = 0; 4 > d5; ++d5) {
        if (f7.Cb) {
          var v6 = f7.Zb[d5];
          f7.Fb || (v6 += n6);
        } else {
          if (0 < d5) {
            t7.pb[d5] = t7.pb[0];
            continue;
          }
          v6 = n6;
        }
        var b4 = t7.pb[d5];
        b4.Sc[0] = ei[Vt2(v6 + o5, 127)], b4.Sc[1] = ri[Vt2(v6 + 0, 127)], b4.Eb[0] = 2 * ei[Vt2(v6 + a5, 127)], b4.Eb[1] = 101581 * ri[Vt2(v6 + u6, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei[Vt2(v6 + l6, 117)], b4.Qc[1] = ri[Vt2(v6 + h6, 127)], b4.lc = v6 + h6;
      }
      if (!c7.Rb)
        return Jt2(t7, 4, "Not a key frame.");
      for (P2(s6), c7 = t7.Pa, n6 = 0; 4 > n6; ++n6) {
        for (o5 = 0; 8 > o5; ++o5)
          for (a5 = 0; 3 > a5; ++a5)
            for (u6 = 0; 11 > u6; ++u6)
              l6 = k3(s6, ui[n6][o5][a5][u6]) ? g6(s6, 8) : si[n6][o5][a5][u6], c7.Wc[n6][o5].Yb[a5][u6] = l6;
        for (o5 = 0; 17 > o5; ++o5)
          c7.Xc[n6][o5] = c7.Wc[n6][hi[o5]];
      }
      return t7.kc = P2(s6), t7.kc && (t7.Bd = g6(s6, 8)), t7.cb = 1;
    }
    function Zt2(t7, e4, r4, n6, i6, a5, o5) {
      var s6 = e4[i6].Yb[r4];
      for (r4 = 0; 16 > i6; ++i6) {
        if (!k3(t7, s6[r4 + 0]))
          return i6;
        for (; !k3(t7, s6[r4 + 1]); )
          if (s6 = e4[++i6].Yb[0], r4 = 0, 16 == i6)
            return 16;
        var c7 = e4[i6 + 1].Yb;
        if (k3(t7, s6[r4 + 2])) {
          var u6 = t7, h6 = 0;
          if (k3(u6, (f7 = s6)[(l6 = r4) + 3]))
            if (k3(u6, f7[l6 + 6])) {
              for (s6 = 0, l6 = 2 * (h6 = k3(u6, f7[l6 + 8])) + (f7 = k3(u6, f7[l6 + 9 + h6])), h6 = 0, f7 = ii[l6]; f7[s6]; ++s6)
                h6 += h6 + k3(u6, f7[s6]);
              h6 += 3 + (8 << l6);
            } else
              k3(u6, f7[l6 + 7]) ? (h6 = 7 + 2 * k3(u6, 165), h6 += k3(u6, 145)) : h6 = 5 + k3(u6, 159);
          else
            h6 = k3(u6, f7[l6 + 4]) ? 3 + k3(u6, f7[l6 + 5]) : 2;
          s6 = c7[2];
        } else
          h6 = 1, s6 = c7[1];
        c7 = o5 + ai[i6], 0 > (u6 = t7).b && _4(u6);
        var l6, f7 = u6.b, d5 = (l6 = u6.Ca >> 1) - (u6.I >> f7) >> 31;
        --u6.b, u6.Ca += d5, u6.Ca |= 1, u6.I -= (l6 + 1 & d5) << f7, a5[c7] = ((h6 ^ d5) - d5) * n6[(0 < i6) + 0];
      }
      return 16;
    }
    function $t2(t7) {
      var e4 = t7.rb[t7.sb - 1];
      e4.la = 0, e4.Na = 0, i5(t7.zc, 0, 0, t7.zc.length), t7.ja = 0;
    }
    function Qt2(t7, r4) {
      if (null == t7)
        return 0;
      if (null == r4)
        return Jt2(t7, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t7.cb && !Kt2(t7, r4))
        return 0;
      if (e3(t7.cb), null == r4.ac || r4.ac(r4)) {
        r4.ob && (t7.L = 0);
        var s6 = Ri[t7.L];
        if (2 == t7.L ? (t7.yb = 0, t7.zb = 0) : (t7.yb = r4.v - s6 >> 4, t7.zb = r4.j - s6 >> 4, 0 > t7.yb && (t7.yb = 0), 0 > t7.zb && (t7.zb = 0)), t7.Va = r4.o + 15 + s6 >> 4, t7.Hb = r4.va + 15 + s6 >> 4, t7.Hb > t7.za && (t7.Hb = t7.za), t7.Va > t7.Ub && (t7.Va = t7.Ub), 0 < t7.L) {
          var c7 = t7.ed;
          for (s6 = 0; 4 > s6; ++s6) {
            var u6;
            if (t7.Qa.Cb) {
              var h6 = t7.Qa.Lb[s6];
              t7.Qa.Fb || (h6 += c7.Tb);
            } else
              h6 = c7.Tb;
            for (u6 = 0; 1 >= u6; ++u6) {
              var l6 = t7.gd[s6][u6], f7 = h6;
              if (c7.Pc && (f7 += c7.vd[0], u6 && (f7 += c7.od[0])), 0 < (f7 = 0 > f7 ? 0 : 63 < f7 ? 63 : f7)) {
                var d5 = f7;
                0 < c7.wb && ((d5 = 4 < c7.wb ? d5 >> 2 : d5 >> 1) > 9 - c7.wb && (d5 = 9 - c7.wb)), 1 > d5 && (d5 = 1), l6.dd = d5, l6.tc = 2 * f7 + d5, l6.ld = 40 <= f7 ? 2 : 15 <= f7 ? 1 : 0;
              } else
                l6.tc = 0;
              l6.La = u6;
            }
          }
        }
        s6 = 0;
      } else
        Jt2(t7, 6, "Frame setup failed"), s6 = t7.a;
      if (s6 = 0 == s6) {
        if (s6) {
          t7.$c = 0, 0 < t7.Aa || (t7.Ic = Ui);
          t: {
            s6 = t7.Ic;
            c7 = 4 * (d5 = t7.za);
            var p9 = 32 * d5, g7 = d5 + 1, m8 = 0 < t7.L ? d5 * (0 < t7.Aa ? 2 : 1) : 0, v6 = (2 == t7.Aa ? 2 : 1) * d5;
            if ((l6 = c7 + 832 + (u6 = 3 * (16 * s6 + Ri[t7.L]) / 2 * p9) + (h6 = null != t7.Fa && 0 < t7.Fa.length ? t7.Kc.c * t7.Kc.i : 0)) != l6)
              s6 = 0;
            else {
              if (l6 > t7.Vb) {
                if (t7.Vb = 0, t7.Ec = a4(l6), t7.Fc = 0, null == t7.Ec) {
                  s6 = Jt2(t7, 1, "no memory during frame initialization.");
                  break t;
                }
                t7.Vb = l6;
              }
              l6 = t7.Ec, f7 = t7.Fc, t7.Ac = l6, t7.Bc = f7, f7 += c7, t7.Gd = o4(p9, Ht2), t7.Hd = 0, t7.rb = o4(g7 + 1, Rt2), t7.sb = 1, t7.wa = m8 ? o4(m8, Dt2) : null, t7.Y = 0, t7.D.Nb = 0, t7.D.wa = t7.wa, t7.D.Y = t7.Y, 0 < t7.Aa && (t7.D.Y += d5), e3(true), t7.oc = l6, t7.pc = f7, f7 += 832, t7.ya = o4(v6, Ut2), t7.aa = 0, t7.D.ya = t7.ya, t7.D.aa = t7.aa, 2 == t7.Aa && (t7.D.aa += d5), t7.R = 16 * d5, t7.B = 8 * d5, d5 = (p9 = Ri[t7.L]) * t7.R, p9 = p9 / 2 * t7.B, t7.sa = l6, t7.ta = f7 + d5, t7.qa = t7.sa, t7.ra = t7.ta + 16 * s6 * t7.R + p9, t7.Ha = t7.qa, t7.Ia = t7.ra + 8 * s6 * t7.B + p9, t7.$c = 0, f7 += u6, t7.mb = h6 ? l6 : null, t7.nb = h6 ? f7 : null, e3(f7 + h6 <= t7.Fc + t7.Vb), $t2(t7), i5(t7.Ac, t7.Bc, 0, c7), s6 = 1;
            }
          }
          if (s6) {
            if (r4.ka = 0, r4.y = t7.sa, r4.O = t7.ta, r4.f = t7.qa, r4.N = t7.ra, r4.ea = t7.Ha, r4.Vd = t7.Ia, r4.fa = t7.R, r4.Rc = t7.B, r4.F = null, r4.J = 0, !Cn) {
              for (s6 = -255; 255 >= s6; ++s6)
                Pn[255 + s6] = 0 > s6 ? -s6 : s6;
              for (s6 = -1020; 1020 >= s6; ++s6)
                kn[1020 + s6] = -128 > s6 ? -128 : 127 < s6 ? 127 : s6;
              for (s6 = -112; 112 >= s6; ++s6)
                In[112 + s6] = -16 > s6 ? -16 : 15 < s6 ? 15 : s6;
              for (s6 = -255; 510 >= s6; ++s6)
                Fn[255 + s6] = 0 > s6 ? 0 : 255 < s6 ? 255 : s6;
              Cn = 1;
            }
            an = ue2, on = ae2, cn = oe2, un2 = se2, hn = ce2, sn = ie2, ln2 = Je, fn = Xe, dn = $e, pn = Qe, gn = Ke, mn = Ze, vn = tr, bn = er, yn = ze, wn = He, Nn = We, Ln = Ve, fi[0] = xe, fi[1] = le2, fi[2] = Le2, fi[3] = Ae, fi[4] = Se, fi[5] = Pe, fi[6] = _e, fi[7] = ke, fi[8] = Fe, fi[9] = Ie, li[0] = ve2, li[1] = de2, li[2] = pe2, li[3] = ge2, li[4] = be2, li[5] = ye2, li[6] = we2, di[0] = Be, di[1] = fe2, di[2] = Ce, di[3] = je, di[4] = Ee, di[5] = Me, di[6] = qe, s6 = 1;
          } else
            s6 = 0;
        }
        s6 && (s6 = function(t8, r5) {
          for (t8.M = 0; t8.M < t8.Va; ++t8.M) {
            var o5, s7 = t8.Jc[t8.M & t8.Xb], c8 = t8.m, u7 = t8;
            for (o5 = 0; o5 < u7.za; ++o5) {
              var h7 = c8, l7 = u7, f8 = l7.Ac, d6 = l7.Bc + 4 * o5, p10 = l7.zc, g8 = l7.ya[l7.aa + o5];
              if (l7.Qa.Bb ? g8.$b = k3(h7, l7.Pa.jb[0]) ? 2 + k3(h7, l7.Pa.jb[2]) : k3(h7, l7.Pa.jb[1]) : g8.$b = 0, l7.kc && (g8.Ad = k3(h7, l7.Bd)), g8.Za = !k3(h7, 145) + 0, g8.Za) {
                var m9 = g8.Ob, v7 = 0;
                for (l7 = 0; 4 > l7; ++l7) {
                  var b4, y5 = p10[0 + l7];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y5 = ci[f8[d6 + b4]][y5];
                    for (var w4 = oi[k3(h7, y5[0])]; 0 < w4; )
                      w4 = oi[2 * w4 + k3(h7, y5[w4])];
                    y5 = -w4, f8[d6 + b4] = y5;
                  }
                  n5(m9, v7, f8, d6, 4), v7 += 4, p10[0 + l7] = y5;
                }
              } else
                y5 = k3(h7, 156) ? k3(h7, 128) ? 1 : 3 : k3(h7, 163) ? 2 : 0, g8.Ob[0] = y5, i5(f8, d6, y5, 4), i5(p10, 0, y5, 4);
              g8.Dd = k3(h7, 142) ? k3(h7, 114) ? k3(h7, 183) ? 1 : 3 : 2 : 0;
            }
            if (u7.m.Ka)
              return Jt2(t8, 7, "Premature end-of-partition0 encountered.");
            for (; t8.ja < t8.za; ++t8.ja) {
              if (u7 = s7, h7 = (c8 = t8).rb[c8.sb - 1], f8 = c8.rb[c8.sb + c8.ja], o5 = c8.ya[c8.aa + c8.ja], d6 = c8.kc ? o5.Ad : 0)
                h7.la = f8.la = 0, o5.Za || (h7.Na = f8.Na = 0), o5.Hc = 0, o5.Gc = 0, o5.ia = 0;
              else {
                var N5, L4;
                h7 = f8, f8 = u7, d6 = c8.Pa.Xc, p10 = c8.ya[c8.aa + c8.ja], g8 = c8.pb[p10.$b];
                if (l7 = p10.ad, m9 = 0, v7 = c8.rb[c8.sb - 1], y5 = b4 = 0, i5(l7, m9, 0, 384), p10.Za)
                  var A4 = 0, x3 = d6[3];
                else {
                  w4 = a4(16);
                  var S3 = h7.Na + v7.Na;
                  if (S3 = ni(f8, d6[1], S3, g8.Eb, 0, w4, 0), h7.Na = v7.Na = (0 < S3) + 0, 1 < S3)
                    an(w4, 0, l7, m9);
                  else {
                    var _5 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l7[m9 + w4] = _5;
                  }
                  A4 = 1, x3 = d6[0];
                }
                var P3 = 15 & h7.la, I3 = 15 & v7.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_5 = L4 = 0; 4 > _5; ++_5)
                    P3 = P3 >> 1 | (F3 = (S3 = ni(f8, x3, S3 = F3 + (1 & P3), g8.Sc, A4, l7, m9)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l7[m9 + 0]), m9 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N5 = 0; 4 > N5; N5 += 2) {
                  for (L4 = 0, P3 = h7.la >> 4 + N5, I3 = v7.la >> 4 + N5, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _5 = 0; 2 > _5; ++_5)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni(f8, d6[2], S3, g8.Qc, 0, l7, m9))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l7[m9 + 0]), m9 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y5 |= L4 << 4 * N5, x3 |= P3 << 4 << N5, A4 |= (240 & I3) << N5;
                }
                h7.la = x3, v7.la = A4, p10.Hc = b4, p10.Gc = y5, p10.ia = 43690 & y5 ? 0 : g8.ia, d6 = !(b4 | y5);
              }
              if (0 < c8.L && (c8.wa[c8.Y + c8.ja] = c8.gd[o5.$b][o5.Za], c8.wa[c8.Y + c8.ja].La |= !d6), u7.Ka)
                return Jt2(t8, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t8), c8 = r5, u7 = 1, o5 = (s7 = t8).D, h7 = 0 < s7.L && s7.M >= s7.zb && s7.M <= s7.Va, 0 == s7.Aa)
              t: {
                if (o5.M = s7.M, o5.uc = h7, Or(s7, o5), u7 = 1, o5 = (L4 = s7.D).Nb, h7 = (y5 = Ri[s7.L]) * s7.R, f8 = y5 / 2 * s7.B, w4 = 16 * o5 * s7.R, _5 = 8 * o5 * s7.B, d6 = s7.sa, p10 = s7.ta - h7 + w4, g8 = s7.qa, l7 = s7.ra - f8 + _5, m9 = s7.Ha, v7 = s7.Ia - f8 + _5, I3 = 0 == (P3 = L4.M), b4 = P3 >= s7.Va - 1, 2 == s7.Aa && Or(s7, L4), L4.uc)
                  for (F3 = (S3 = s7).D.M, e3(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j4 = (U3 = S3).D).Nb;
                    N5 = U3.R;
                    var j4 = j4.wa[j4.Y + A4], O4 = U3.sa, B3 = U3.ta + 16 * C3 * N5 + 16 * A4, M3 = j4.dd, E3 = j4.tc;
                    if (0 != E3)
                      if (e3(3 <= E3), 1 == U3.L)
                        0 < A4 && wn(O4, B3, N5, E3 + 4), j4.La && Ln(O4, B3, N5, E3), 0 < x3 && yn(O4, B3, N5, E3 + 4), j4.La && Nn(O4, B3, N5, E3);
                      else {
                        var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T4 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j4.ld;
                        0 < A4 && (fn(O4, B3, N5, E3 + 4, M3, C3), pn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j4.La && (mn(O4, B3, N5, E3, M3, C3), bn(D3, R3, T4, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O4, B3, N5, E3 + 4, M3, C3), dn(D3, R3, T4, U3, q3, E3 + 4, M3, C3)), j4.La && (gn(O4, B3, N5, E3, M3, C3), vn(D3, R3, T4, U3, q3, E3, M3, C3));
                      }
                  }
                if (s7.ia && alert("todo:DitherRow"), null != c8.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c8.y = s7.sa, c8.O = s7.ta + w4, c8.f = s7.qa, c8.N = s7.ra + _5, c8.ea = s7.Ha, c8.W = s7.Ia + _5) : (L4 -= y5, c8.y = d6, c8.O = p10, c8.f = g8, c8.N = l7, c8.ea = m9, c8.W = v7), b4 || (P3 -= y5), P3 > c8.o && (P3 = c8.o), c8.F = null, c8.J = null, null != s7.Fa && 0 < s7.Fa.length && L4 < P3 && (c8.J = lr(s7, c8, L4, P3 - L4), c8.F = s7.mb, null == c8.F && 0 == c8.F.length)) {
                    u7 = Jt2(s7, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c8.j && (y5 = c8.j - L4, L4 = c8.j, e3(!(1 & y5)), c8.O += s7.R * y5, c8.N += s7.B * (y5 >> 1), c8.W += s7.B * (y5 >> 1), null != c8.F && (c8.J += c8.width * y5)), L4 < P3 && (c8.O += c8.v, c8.N += c8.v >> 1, c8.W += c8.v >> 1, null != c8.F && (c8.J += c8.v), c8.ka = L4 - c8.j, c8.U = c8.va - c8.v, c8.T = P3 - L4, u7 = c8.put(c8));
                }
                o5 + 1 != s7.Ic || b4 || (n5(s7.sa, s7.ta - h7, d6, p10 + 16 * s7.R, h7), n5(s7.qa, s7.ra - f8, g8, l7 + 8 * s7.B, f8), n5(s7.Ha, s7.Ia - f8, m9, v7 + 8 * s7.B, f8));
              }
            if (!u7)
              return Jt2(t8, 6, "Output aborted.");
          }
          return 1;
        }(t7, r4)), null != r4.bc && r4.bc(r4), s6 &= 1;
      }
      return s6 ? (t7.cb = 0, s6) : 0;
    }
    function te2(t7, e4, r4, n6, i6) {
      i6 = t7[e4 + r4 + 32 * n6] + (i6 >> 3), t7[e4 + r4 + 32 * n6] = -256 & i6 ? 0 > i6 ? 0 : 255 : i6;
    }
    function ee2(t7, e4, r4, n6, i6, a5) {
      te2(t7, e4, 0, r4, n6 + i6), te2(t7, e4, 1, r4, n6 + a5), te2(t7, e4, 2, r4, n6 - a5), te2(t7, e4, 3, r4, n6 - i6);
    }
    function re2(t7) {
      return (20091 * t7 >> 16) + t7;
    }
    function ne2(t7, e4, r4, n6) {
      var i6, o5 = 0, s6 = a4(16);
      for (i6 = 0; 4 > i6; ++i6) {
        var c7 = t7[e4 + 0] + t7[e4 + 8], u6 = t7[e4 + 0] - t7[e4 + 8], h6 = (35468 * t7[e4 + 4] >> 16) - re2(t7[e4 + 12]), l6 = re2(t7[e4 + 4]) + (35468 * t7[e4 + 12] >> 16);
        s6[o5 + 0] = c7 + l6, s6[o5 + 1] = u6 + h6, s6[o5 + 2] = u6 - h6, s6[o5 + 3] = c7 - l6, o5 += 4, e4++;
      }
      for (i6 = o5 = 0; 4 > i6; ++i6)
        c7 = (t7 = s6[o5 + 0] + 4) + s6[o5 + 8], u6 = t7 - s6[o5 + 8], h6 = (35468 * s6[o5 + 4] >> 16) - re2(s6[o5 + 12]), te2(r4, n6, 0, 0, c7 + (l6 = re2(s6[o5 + 4]) + (35468 * s6[o5 + 12] >> 16))), te2(r4, n6, 1, 0, u6 + h6), te2(r4, n6, 2, 0, u6 - h6), te2(r4, n6, 3, 0, c7 - l6), o5++, n6 += 32;
    }
    function ie2(t7, e4, r4, n6) {
      var i6 = t7[e4 + 0] + 4, a5 = 35468 * t7[e4 + 4] >> 16, o5 = re2(t7[e4 + 4]), s6 = 35468 * t7[e4 + 1] >> 16;
      ee2(r4, n6, 0, i6 + o5, t7 = re2(t7[e4 + 1]), s6), ee2(r4, n6, 1, i6 + a5, t7, s6), ee2(r4, n6, 2, i6 - a5, t7, s6), ee2(r4, n6, 3, i6 - o5, t7, s6);
    }
    function ae2(t7, e4, r4, n6, i6) {
      ne2(t7, e4, r4, n6), i6 && ne2(t7, e4 + 16, r4, n6 + 4);
    }
    function oe2(t7, e4, r4, n6) {
      on(t7, e4 + 0, r4, n6, 1), on(t7, e4 + 32, r4, n6 + 128, 1);
    }
    function se2(t7, e4, r4, n6) {
      var i6;
      for (t7 = t7[e4 + 0] + 4, i6 = 0; 4 > i6; ++i6)
        for (e4 = 0; 4 > e4; ++e4)
          te2(r4, n6, e4, i6, t7);
    }
    function ce2(t7, e4, r4, n6) {
      t7[e4 + 0] && un2(t7, e4 + 0, r4, n6), t7[e4 + 16] && un2(t7, e4 + 16, r4, n6 + 4), t7[e4 + 32] && un2(t7, e4 + 32, r4, n6 + 128), t7[e4 + 48] && un2(t7, e4 + 48, r4, n6 + 128 + 4);
    }
    function ue2(t7, e4, r4, n6) {
      var i6, o5 = a4(16);
      for (i6 = 0; 4 > i6; ++i6) {
        var s6 = t7[e4 + 0 + i6] + t7[e4 + 12 + i6], c7 = t7[e4 + 4 + i6] + t7[e4 + 8 + i6], u6 = t7[e4 + 4 + i6] - t7[e4 + 8 + i6], h6 = t7[e4 + 0 + i6] - t7[e4 + 12 + i6];
        o5[0 + i6] = s6 + c7, o5[8 + i6] = s6 - c7, o5[4 + i6] = h6 + u6, o5[12 + i6] = h6 - u6;
      }
      for (i6 = 0; 4 > i6; ++i6)
        s6 = (t7 = o5[0 + 4 * i6] + 3) + o5[3 + 4 * i6], c7 = o5[1 + 4 * i6] + o5[2 + 4 * i6], u6 = o5[1 + 4 * i6] - o5[2 + 4 * i6], h6 = t7 - o5[3 + 4 * i6], r4[n6 + 0] = s6 + c7 >> 3, r4[n6 + 16] = h6 + u6 >> 3, r4[n6 + 32] = s6 - c7 >> 3, r4[n6 + 48] = h6 - u6 >> 3, n6 += 64;
    }
    function he2(t7, e4, r4) {
      var n6, i6 = e4 - 32, a5 = Bn, o5 = 255 - t7[i6 - 1];
      for (n6 = 0; n6 < r4; ++n6) {
        var s6, c7 = a5, u6 = o5 + t7[e4 - 1];
        for (s6 = 0; s6 < r4; ++s6)
          t7[e4 + s6] = c7[u6 + t7[i6 + s6]];
        e4 += 32;
      }
    }
    function le2(t7, e4) {
      he2(t7, e4, 4);
    }
    function fe2(t7, e4) {
      he2(t7, e4, 8);
    }
    function de2(t7, e4) {
      he2(t7, e4, 16);
    }
    function pe2(t7, e4) {
      var r4;
      for (r4 = 0; 16 > r4; ++r4)
        n5(t7, e4 + 32 * r4, t7, e4 - 32, 16);
    }
    function ge2(t7, e4) {
      var r4;
      for (r4 = 16; 0 < r4; --r4)
        i5(t7, e4, t7[e4 - 1], 16), e4 += 32;
    }
    function me2(t7, e4, r4) {
      var n6;
      for (n6 = 0; 16 > n6; ++n6)
        i5(e4, r4 + 32 * n6, t7, 16);
    }
    function ve2(t7, e4) {
      var r4, n6 = 16;
      for (r4 = 0; 16 > r4; ++r4)
        n6 += t7[e4 - 1 + 32 * r4] + t7[e4 + r4 - 32];
      me2(n6 >> 5, t7, e4);
    }
    function be2(t7, e4) {
      var r4, n6 = 8;
      for (r4 = 0; 16 > r4; ++r4)
        n6 += t7[e4 - 1 + 32 * r4];
      me2(n6 >> 4, t7, e4);
    }
    function ye2(t7, e4) {
      var r4, n6 = 8;
      for (r4 = 0; 16 > r4; ++r4)
        n6 += t7[e4 + r4 - 32];
      me2(n6 >> 4, t7, e4);
    }
    function we2(t7, e4) {
      me2(128, t7, e4);
    }
    function Ne2(t7, e4, r4) {
      return t7 + 2 * e4 + r4 + 2 >> 2;
    }
    function Le2(t7, e4) {
      var r4, i6 = e4 - 32;
      i6 = new Uint8Array([Ne2(t7[i6 - 1], t7[i6 + 0], t7[i6 + 1]), Ne2(t7[i6 + 0], t7[i6 + 1], t7[i6 + 2]), Ne2(t7[i6 + 1], t7[i6 + 2], t7[i6 + 3]), Ne2(t7[i6 + 2], t7[i6 + 3], t7[i6 + 4])]);
      for (r4 = 0; 4 > r4; ++r4)
        n5(t7, e4 + 32 * r4, i6, 0, i6.length);
    }
    function Ae(t7, e4) {
      var r4 = t7[e4 - 1], n6 = t7[e4 - 1 + 32], i6 = t7[e4 - 1 + 64], a5 = t7[e4 - 1 + 96];
      I2(t7, e4 + 0, 16843009 * Ne2(t7[e4 - 1 - 32], r4, n6)), I2(t7, e4 + 32, 16843009 * Ne2(r4, n6, i6)), I2(t7, e4 + 64, 16843009 * Ne2(n6, i6, a5)), I2(t7, e4 + 96, 16843009 * Ne2(i6, a5, a5));
    }
    function xe(t7, e4) {
      var r4, n6 = 4;
      for (r4 = 0; 4 > r4; ++r4)
        n6 += t7[e4 + r4 - 32] + t7[e4 - 1 + 32 * r4];
      for (n6 >>= 3, r4 = 0; 4 > r4; ++r4)
        i5(t7, e4 + 32 * r4, n6, 4);
    }
    function Se(t7, e4) {
      var r4 = t7[e4 - 1 + 0], n6 = t7[e4 - 1 + 32], i6 = t7[e4 - 1 + 64], a5 = t7[e4 - 1 - 32], o5 = t7[e4 + 0 - 32], s6 = t7[e4 + 1 - 32], c7 = t7[e4 + 2 - 32], u6 = t7[e4 + 3 - 32];
      t7[e4 + 0 + 96] = Ne2(n6, i6, t7[e4 - 1 + 96]), t7[e4 + 1 + 96] = t7[e4 + 0 + 64] = Ne2(r4, n6, i6), t7[e4 + 2 + 96] = t7[e4 + 1 + 64] = t7[e4 + 0 + 32] = Ne2(a5, r4, n6), t7[e4 + 3 + 96] = t7[e4 + 2 + 64] = t7[e4 + 1 + 32] = t7[e4 + 0 + 0] = Ne2(o5, a5, r4), t7[e4 + 3 + 64] = t7[e4 + 2 + 32] = t7[e4 + 1 + 0] = Ne2(s6, o5, a5), t7[e4 + 3 + 32] = t7[e4 + 2 + 0] = Ne2(c7, s6, o5), t7[e4 + 3 + 0] = Ne2(u6, c7, s6);
    }
    function _e(t7, e4) {
      var r4 = t7[e4 + 1 - 32], n6 = t7[e4 + 2 - 32], i6 = t7[e4 + 3 - 32], a5 = t7[e4 + 4 - 32], o5 = t7[e4 + 5 - 32], s6 = t7[e4 + 6 - 32], c7 = t7[e4 + 7 - 32];
      t7[e4 + 0 + 0] = Ne2(t7[e4 + 0 - 32], r4, n6), t7[e4 + 1 + 0] = t7[e4 + 0 + 32] = Ne2(r4, n6, i6), t7[e4 + 2 + 0] = t7[e4 + 1 + 32] = t7[e4 + 0 + 64] = Ne2(n6, i6, a5), t7[e4 + 3 + 0] = t7[e4 + 2 + 32] = t7[e4 + 1 + 64] = t7[e4 + 0 + 96] = Ne2(i6, a5, o5), t7[e4 + 3 + 32] = t7[e4 + 2 + 64] = t7[e4 + 1 + 96] = Ne2(a5, o5, s6), t7[e4 + 3 + 64] = t7[e4 + 2 + 96] = Ne2(o5, s6, c7), t7[e4 + 3 + 96] = Ne2(s6, c7, c7);
    }
    function Pe(t7, e4) {
      var r4 = t7[e4 - 1 + 0], n6 = t7[e4 - 1 + 32], i6 = t7[e4 - 1 + 64], a5 = t7[e4 - 1 - 32], o5 = t7[e4 + 0 - 32], s6 = t7[e4 + 1 - 32], c7 = t7[e4 + 2 - 32], u6 = t7[e4 + 3 - 32];
      t7[e4 + 0 + 0] = t7[e4 + 1 + 64] = a5 + o5 + 1 >> 1, t7[e4 + 1 + 0] = t7[e4 + 2 + 64] = o5 + s6 + 1 >> 1, t7[e4 + 2 + 0] = t7[e4 + 3 + 64] = s6 + c7 + 1 >> 1, t7[e4 + 3 + 0] = c7 + u6 + 1 >> 1, t7[e4 + 0 + 96] = Ne2(i6, n6, r4), t7[e4 + 0 + 64] = Ne2(n6, r4, a5), t7[e4 + 0 + 32] = t7[e4 + 1 + 96] = Ne2(r4, a5, o5), t7[e4 + 1 + 32] = t7[e4 + 2 + 96] = Ne2(a5, o5, s6), t7[e4 + 2 + 32] = t7[e4 + 3 + 96] = Ne2(o5, s6, c7), t7[e4 + 3 + 32] = Ne2(s6, c7, u6);
    }
    function ke(t7, e4) {
      var r4 = t7[e4 + 0 - 32], n6 = t7[e4 + 1 - 32], i6 = t7[e4 + 2 - 32], a5 = t7[e4 + 3 - 32], o5 = t7[e4 + 4 - 32], s6 = t7[e4 + 5 - 32], c7 = t7[e4 + 6 - 32], u6 = t7[e4 + 7 - 32];
      t7[e4 + 0 + 0] = r4 + n6 + 1 >> 1, t7[e4 + 1 + 0] = t7[e4 + 0 + 64] = n6 + i6 + 1 >> 1, t7[e4 + 2 + 0] = t7[e4 + 1 + 64] = i6 + a5 + 1 >> 1, t7[e4 + 3 + 0] = t7[e4 + 2 + 64] = a5 + o5 + 1 >> 1, t7[e4 + 0 + 32] = Ne2(r4, n6, i6), t7[e4 + 1 + 32] = t7[e4 + 0 + 96] = Ne2(n6, i6, a5), t7[e4 + 2 + 32] = t7[e4 + 1 + 96] = Ne2(i6, a5, o5), t7[e4 + 3 + 32] = t7[e4 + 2 + 96] = Ne2(a5, o5, s6), t7[e4 + 3 + 64] = Ne2(o5, s6, c7), t7[e4 + 3 + 96] = Ne2(s6, c7, u6);
    }
    function Ie(t7, e4) {
      var r4 = t7[e4 - 1 + 0], n6 = t7[e4 - 1 + 32], i6 = t7[e4 - 1 + 64], a5 = t7[e4 - 1 + 96];
      t7[e4 + 0 + 0] = r4 + n6 + 1 >> 1, t7[e4 + 2 + 0] = t7[e4 + 0 + 32] = n6 + i6 + 1 >> 1, t7[e4 + 2 + 32] = t7[e4 + 0 + 64] = i6 + a5 + 1 >> 1, t7[e4 + 1 + 0] = Ne2(r4, n6, i6), t7[e4 + 3 + 0] = t7[e4 + 1 + 32] = Ne2(n6, i6, a5), t7[e4 + 3 + 32] = t7[e4 + 1 + 64] = Ne2(i6, a5, a5), t7[e4 + 3 + 64] = t7[e4 + 2 + 64] = t7[e4 + 0 + 96] = t7[e4 + 1 + 96] = t7[e4 + 2 + 96] = t7[e4 + 3 + 96] = a5;
    }
    function Fe(t7, e4) {
      var r4 = t7[e4 - 1 + 0], n6 = t7[e4 - 1 + 32], i6 = t7[e4 - 1 + 64], a5 = t7[e4 - 1 + 96], o5 = t7[e4 - 1 - 32], s6 = t7[e4 + 0 - 32], c7 = t7[e4 + 1 - 32], u6 = t7[e4 + 2 - 32];
      t7[e4 + 0 + 0] = t7[e4 + 2 + 32] = r4 + o5 + 1 >> 1, t7[e4 + 0 + 32] = t7[e4 + 2 + 64] = n6 + r4 + 1 >> 1, t7[e4 + 0 + 64] = t7[e4 + 2 + 96] = i6 + n6 + 1 >> 1, t7[e4 + 0 + 96] = a5 + i6 + 1 >> 1, t7[e4 + 3 + 0] = Ne2(s6, c7, u6), t7[e4 + 2 + 0] = Ne2(o5, s6, c7), t7[e4 + 1 + 0] = t7[e4 + 3 + 32] = Ne2(r4, o5, s6), t7[e4 + 1 + 32] = t7[e4 + 3 + 64] = Ne2(n6, r4, o5), t7[e4 + 1 + 64] = t7[e4 + 3 + 96] = Ne2(i6, n6, r4), t7[e4 + 1 + 96] = Ne2(a5, i6, n6);
    }
    function Ce(t7, e4) {
      var r4;
      for (r4 = 0; 8 > r4; ++r4)
        n5(t7, e4 + 32 * r4, t7, e4 - 32, 8);
    }
    function je(t7, e4) {
      var r4;
      for (r4 = 0; 8 > r4; ++r4)
        i5(t7, e4, t7[e4 - 1], 8), e4 += 32;
    }
    function Oe(t7, e4, r4) {
      var n6;
      for (n6 = 0; 8 > n6; ++n6)
        i5(e4, r4 + 32 * n6, t7, 8);
    }
    function Be(t7, e4) {
      var r4, n6 = 8;
      for (r4 = 0; 8 > r4; ++r4)
        n6 += t7[e4 + r4 - 32] + t7[e4 - 1 + 32 * r4];
      Oe(n6 >> 4, t7, e4);
    }
    function Me(t7, e4) {
      var r4, n6 = 4;
      for (r4 = 0; 8 > r4; ++r4)
        n6 += t7[e4 + r4 - 32];
      Oe(n6 >> 3, t7, e4);
    }
    function Ee(t7, e4) {
      var r4, n6 = 4;
      for (r4 = 0; 8 > r4; ++r4)
        n6 += t7[e4 - 1 + 32 * r4];
      Oe(n6 >> 3, t7, e4);
    }
    function qe(t7, e4) {
      Oe(128, t7, e4);
    }
    function De(t7, e4, r4) {
      var n6 = t7[e4 - r4], i6 = t7[e4 + 0], a5 = 3 * (i6 - n6) + jn[1020 + t7[e4 - 2 * r4] - t7[e4 + r4]], o5 = On[112 + (a5 + 4 >> 3)];
      t7[e4 - r4] = Bn[255 + n6 + On[112 + (a5 + 3 >> 3)]], t7[e4 + 0] = Bn[255 + i6 - o5];
    }
    function Re(t7, e4, r4, n6) {
      var i6 = t7[e4 + 0], a5 = t7[e4 + r4];
      return Mn[255 + t7[e4 - 2 * r4] - t7[e4 - r4]] > n6 || Mn[255 + a5 - i6] > n6;
    }
    function Te(t7, e4, r4, n6) {
      return 4 * Mn[255 + t7[e4 - r4] - t7[e4 + 0]] + Mn[255 + t7[e4 - 2 * r4] - t7[e4 + r4]] <= n6;
    }
    function Ue(t7, e4, r4, n6, i6) {
      var a5 = t7[e4 - 3 * r4], o5 = t7[e4 - 2 * r4], s6 = t7[e4 - r4], c7 = t7[e4 + 0], u6 = t7[e4 + r4], h6 = t7[e4 + 2 * r4], l6 = t7[e4 + 3 * r4];
      return 4 * Mn[255 + s6 - c7] + Mn[255 + o5 - u6] > n6 ? 0 : Mn[255 + t7[e4 - 4 * r4] - a5] <= i6 && Mn[255 + a5 - o5] <= i6 && Mn[255 + o5 - s6] <= i6 && Mn[255 + l6 - h6] <= i6 && Mn[255 + h6 - u6] <= i6 && Mn[255 + u6 - c7] <= i6;
    }
    function ze(t7, e4, r4, n6) {
      var i6 = 2 * n6 + 1;
      for (n6 = 0; 16 > n6; ++n6)
        Te(t7, e4 + n6, r4, i6) && De(t7, e4 + n6, r4);
    }
    function He(t7, e4, r4, n6) {
      var i6 = 2 * n6 + 1;
      for (n6 = 0; 16 > n6; ++n6)
        Te(t7, e4 + n6 * r4, 1, i6) && De(t7, e4 + n6 * r4, 1);
    }
    function We(t7, e4, r4, n6) {
      var i6;
      for (i6 = 3; 0 < i6; --i6)
        ze(t7, e4 += 4 * r4, r4, n6);
    }
    function Ve(t7, e4, r4, n6) {
      var i6;
      for (i6 = 3; 0 < i6; --i6)
        He(t7, e4 += 4, r4, n6);
    }
    function Ge(t7, e4, r4, n6, i6, a5, o5, s6) {
      for (a5 = 2 * a5 + 1; 0 < i6--; ) {
        if (Ue(t7, e4, r4, a5, o5))
          if (Re(t7, e4, r4, s6))
            De(t7, e4, r4);
          else {
            var c7 = t7, u6 = e4, h6 = r4, l6 = c7[u6 - 2 * h6], f7 = c7[u6 - h6], d5 = c7[u6 + 0], p9 = c7[u6 + h6], g7 = c7[u6 + 2 * h6], m8 = 27 * (b4 = jn[1020 + 3 * (d5 - f7) + jn[1020 + l6 - p9]]) + 63 >> 7, v6 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c7[u6 - 3 * h6] = Bn[255 + c7[u6 - 3 * h6] + b4], c7[u6 - 2 * h6] = Bn[255 + l6 + v6], c7[u6 - h6] = Bn[255 + f7 + m8], c7[u6 + 0] = Bn[255 + d5 - m8], c7[u6 + h6] = Bn[255 + p9 - v6], c7[u6 + 2 * h6] = Bn[255 + g7 - b4];
          }
        e4 += n6;
      }
    }
    function Ye(t7, e4, r4, n6, i6, a5, o5, s6) {
      for (a5 = 2 * a5 + 1; 0 < i6--; ) {
        if (Ue(t7, e4, r4, a5, o5))
          if (Re(t7, e4, r4, s6))
            De(t7, e4, r4);
          else {
            var c7 = t7, u6 = e4, h6 = r4, l6 = c7[u6 - h6], f7 = c7[u6 + 0], d5 = c7[u6 + h6], p9 = On[112 + ((g7 = 3 * (f7 - l6)) + 4 >> 3)], g7 = On[112 + (g7 + 3 >> 3)], m8 = p9 + 1 >> 1;
            c7[u6 - 2 * h6] = Bn[255 + c7[u6 - 2 * h6] + m8], c7[u6 - h6] = Bn[255 + l6 + g7], c7[u6 + 0] = Bn[255 + f7 - p9], c7[u6 + h6] = Bn[255 + d5 - m8];
          }
        e4 += n6;
      }
    }
    function Je(t7, e4, r4, n6, i6, a5) {
      Ge(t7, e4, r4, 1, 16, n6, i6, a5);
    }
    function Xe(t7, e4, r4, n6, i6, a5) {
      Ge(t7, e4, 1, r4, 16, n6, i6, a5);
    }
    function Ke(t7, e4, r4, n6, i6, a5) {
      var o5;
      for (o5 = 3; 0 < o5; --o5)
        Ye(t7, e4 += 4 * r4, r4, 1, 16, n6, i6, a5);
    }
    function Ze(t7, e4, r4, n6, i6, a5) {
      var o5;
      for (o5 = 3; 0 < o5; --o5)
        Ye(t7, e4 += 4, 1, r4, 16, n6, i6, a5);
    }
    function $e(t7, e4, r4, n6, i6, a5, o5, s6) {
      Ge(t7, e4, i6, 1, 8, a5, o5, s6), Ge(r4, n6, i6, 1, 8, a5, o5, s6);
    }
    function Qe(t7, e4, r4, n6, i6, a5, o5, s6) {
      Ge(t7, e4, 1, i6, 8, a5, o5, s6), Ge(r4, n6, 1, i6, 8, a5, o5, s6);
    }
    function tr(t7, e4, r4, n6, i6, a5, o5, s6) {
      Ye(t7, e4 + 4 * i6, i6, 1, 8, a5, o5, s6), Ye(r4, n6 + 4 * i6, i6, 1, 8, a5, o5, s6);
    }
    function er(t7, e4, r4, n6, i6, a5, o5, s6) {
      Ye(t7, e4 + 4, 1, i6, 8, a5, o5, s6), Ye(r4, n6 + 4, 1, i6, 8, a5, o5, s6);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d4(), this.yc = new l5();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N4(), this.Pb = 0, this.wd = new N4(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o4(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t7, e4, r4, n6, i6, a5, o5) {
      for (t7 = null == t7 ? 0 : t7[e4 + 0], e4 = 0; e4 < o5; ++e4)
        i6[a5 + e4] = t7 + r4[n6 + e4] & 255, t7 = i6[a5 + e4];
    }
    function ur(t7, e4, r4, n6, i6, a5, o5) {
      var s6;
      if (null == t7)
        cr(null, null, r4, n6, i6, a5, o5);
      else
        for (s6 = 0; s6 < o5; ++s6)
          i6[a5 + s6] = t7[e4 + s6] + r4[n6 + s6] & 255;
    }
    function hr2(t7, e4, r4, n6, i6, a5, o5) {
      if (null == t7)
        cr(null, null, r4, n6, i6, a5, o5);
      else {
        var s6, c7 = t7[e4 + 0], u6 = c7, h6 = c7;
        for (s6 = 0; s6 < o5; ++s6)
          u6 = h6 + (c7 = t7[e4 + s6]) - u6, h6 = r4[n6 + s6] + (-256 & u6 ? 0 > u6 ? 0 : 255 : u6) & 255, u6 = c7, i6[a5 + s6] = h6;
      }
    }
    function lr(t7, r4, i6, o5) {
      var s6 = r4.width, c7 = r4.o;
      if (e3(null != t7 && null != r4), 0 > i6 || 0 >= o5 || i6 + o5 > c7)
        return null;
      if (!t7.Cc) {
        if (null == t7.ga) {
          var u6;
          if (t7.ga = new sr(), (u6 = null == t7.ga) || (u6 = r4.width * r4.o, e3(0 == t7.Gb.length), t7.Gb = a4(u6), t7.Uc = 0, null == t7.Gb ? u6 = 0 : (t7.mb = t7.Gb, t7.nb = t7.Uc, t7.rc = null, u6 = 1), u6 = !u6), !u6) {
            u6 = t7.ga;
            var h6 = t7.Fa, l6 = t7.P, f7 = t7.qc, d5 = t7.mb, p9 = t7.nb, g7 = l6 + 1, m8 = f7 - 1, b4 = u6.l;
            if (e3(null != h6 && null != d5 && null != r4), mi[0] = null, mi[1] = cr, mi[2] = ur, mi[3] = hr2, u6.ca = d5, u6.tb = p9, u6.c = r4.width, u6.i = r4.height, e3(0 < u6.c && 0 < u6.i), 1 >= f7)
              r4 = 0;
            else if (u6.$a = h6[l6 + 0] >> 0 & 3, u6.Z = h6[l6 + 0] >> 2 & 3, u6.Lc = h6[l6 + 0] >> 4 & 3, l6 = h6[l6 + 0] >> 6 & 3, 0 > u6.$a || 1 < u6.$a || 4 <= u6.Z || 1 < u6.Lc || l6)
              r4 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u6, b4.width = r4.width, b4.height = r4.height, b4.Da = r4.Da, b4.v = r4.v, b4.va = r4.va, b4.j = r4.j, b4.o = r4.o, u6.$a)
              t: {
                e3(1 == u6.$a), r4 = kt2();
                e:
                  for (; ; ) {
                    if (null == r4) {
                      r4 = 0;
                      break t;
                    }
                    if (e3(null != u6), u6.mc = r4, r4.c = u6.c, r4.i = u6.i, r4.l = u6.l, r4.l.ma = u6, r4.l.width = u6.c, r4.l.height = u6.i, r4.a = 0, v5(r4.m, h6, g7, m8), !It2(u6.c, u6.i, 1, r4, null))
                      break e;
                    if (1 == r4.ab && 3 == r4.gc[0].hc && At2(r4.s) ? (u6.ic = 1, h6 = r4.c * r4.i, r4.Ta = null, r4.Ua = 0, r4.V = a4(h6), r4.Ba = 0, null == r4.V ? (r4.a = 1, r4 = 0) : r4 = 1) : (u6.ic = 0, r4 = Ft2(r4, u6.c)), !r4)
                      break e;
                    r4 = 1;
                    break t;
                  }
                u6.mc = null, r4 = 0;
              }
            else
              r4 = m8 >= u6.c * u6.i;
            u6 = !r4;
          }
          if (u6)
            return null;
          1 != t7.ga.Lc ? t7.Ga = 0 : o5 = c7 - i6;
        }
        e3(null != t7.ga), e3(i6 + o5 <= c7);
        t: {
          if (r4 = (h6 = t7.ga).c, c7 = h6.l.o, 0 == h6.$a) {
            if (g7 = t7.rc, m8 = t7.Vc, b4 = t7.Fa, l6 = t7.P + 1 + i6 * r4, f7 = t7.mb, d5 = t7.nb + i6 * r4, e3(l6 <= t7.P + t7.qc), 0 != h6.Z)
              for (e3(null != mi[h6.Z]), u6 = 0; u6 < o5; ++u6)
                mi[h6.Z](g7, m8, b4, l6, f7, d5, r4), g7 = f7, m8 = d5, d5 += r4, l6 += r4;
            else
              for (u6 = 0; u6 < o5; ++u6)
                n5(f7, d5, b4, l6, r4), g7 = f7, m8 = d5, d5 += r4, l6 += r4;
            t7.rc = g7, t7.Vc = m8;
          } else {
            if (e3(null != h6.mc), r4 = i6 + o5, e3(null != (u6 = h6.mc)), e3(r4 <= u6.i), u6.C >= r4)
              r4 = 1;
            else if (h6.ic || mr(), h6.ic) {
              h6 = u6.V, g7 = u6.Ba, m8 = u6.c;
              var y5 = u6.i, w4 = (b4 = 1, l6 = u6.$ / m8, f7 = u6.$ % m8, d5 = u6.m, p9 = u6.s, u6.$), N5 = m8 * y5, L4 = m8 * r4, x3 = p9.wc, _5 = w4 < L4 ? wt2(p9, f7, l6) : null;
              e3(w4 <= N5), e3(r4 <= y5), e3(At2(p9));
              e:
                for (; ; ) {
                  for (; !d5.h && w4 < L4; ) {
                    if (f7 & x3 || (_5 = wt2(p9, f7, l6)), e3(null != _5), S2(d5), 256 > (y5 = bt2(_5.G[0], _5.H[0], d5)))
                      h6[g7 + w4] = y5, ++w4, ++f7 >= m8 && (f7 = 0, ++l6 <= r4 && !(l6 % 16) && St2(u6, l6));
                    else {
                      if (!(280 > y5)) {
                        b4 = 0;
                        break e;
                      }
                      y5 = mt2(y5 - 256, d5);
                      var P3, k4 = bt2(_5.G[4], _5.H[4], d5);
                      if (S2(d5), !(w4 >= (k4 = vt2(m8, k4 = mt2(k4, d5))) && N5 - w4 >= y5)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y5; ++P3)
                        h6[g7 + w4 + P3] = h6[g7 + w4 + P3 - k4];
                      for (w4 += y5, f7 += y5; f7 >= m8; )
                        f7 -= m8, ++l6 <= r4 && !(l6 % 16) && St2(u6, l6);
                      w4 < L4 && f7 & x3 && (_5 = wt2(p9, f7, l6));
                    }
                    e3(d5.h == A3(d5));
                  }
                  St2(u6, l6 > r4 ? r4 : l6);
                  break e;
                }
              !b4 || d5.h && w4 < N5 ? (b4 = 0, u6.a = d5.h ? 5 : 3) : u6.$ = w4, r4 = b4;
            } else
              r4 = _t2(u6, u6.V, u6.Ba, u6.c, u6.i, r4, Ct2);
            if (!r4) {
              o5 = 0;
              break t;
            }
          }
          i6 + o5 >= c7 && (t7.Cc = 1), o5 = 1;
        }
        if (!o5)
          return null;
        if (t7.Cc && (null != (o5 = t7.ga) && (o5.mc = null), t7.ga = null, 0 < t7.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t7.nb + i6 * s6;
    }
    function fr(t7, e4, r4, n6, i6, a5) {
      for (; 0 < i6--; ) {
        var o5, s6 = t7, c7 = e4 + (r4 ? 1 : 0), u6 = t7, h6 = e4 + (r4 ? 0 : 3);
        for (o5 = 0; o5 < n6; ++o5) {
          var l6 = u6[h6 + 4 * o5];
          255 != l6 && (l6 *= 32897, s6[c7 + 4 * o5 + 0] = s6[c7 + 4 * o5 + 0] * l6 >> 23, s6[c7 + 4 * o5 + 1] = s6[c7 + 4 * o5 + 1] * l6 >> 23, s6[c7 + 4 * o5 + 2] = s6[c7 + 4 * o5 + 2] * l6 >> 23);
        }
        e4 += a5;
      }
    }
    function dr(t7, e4, r4, n6, i6) {
      for (; 0 < n6--; ) {
        var a5;
        for (a5 = 0; a5 < r4; ++a5) {
          var o5 = t7[e4 + 2 * a5 + 0], s6 = 15 & (u6 = t7[e4 + 2 * a5 + 1]), c7 = 4369 * s6, u6 = (240 & u6 | u6 >> 4) * c7 >> 16;
          t7[e4 + 2 * a5 + 0] = (240 & o5 | o5 >> 4) * c7 >> 16 & 240 | (15 & o5 | o5 << 4) * c7 >> 16 >> 4 & 15, t7[e4 + 2 * a5 + 1] = 240 & u6 | s6;
        }
        e4 += i6;
      }
    }
    function pr(t7, e4, r4, n6, i6, a5, o5, s6) {
      var c7, u6, h6 = 255;
      for (u6 = 0; u6 < i6; ++u6) {
        for (c7 = 0; c7 < n6; ++c7) {
          var l6 = t7[e4 + c7];
          a5[o5 + 4 * c7] = l6, h6 &= l6;
        }
        e4 += r4, o5 += s6;
      }
      return 255 != h6;
    }
    function gr(t7, e4, r4, n6, i6) {
      var a5;
      for (a5 = 0; a5 < i6; ++a5)
        r4[n6 + a5] = t7[e4 + a5] >> 8;
    }
    function mr() {
      An = fr, xn = dr, Sn = pr, _n = gr;
    }
    function vr(r4, n6, i6) {
      t6[r4] = function(t7, r5, a5, o5, s6, c7, u6, h6, l6, f7, d5, p9, g7, m8, v6, b4, y5) {
        var w4, N5 = y5 - 1 >> 1, L4 = s6[c7 + 0] | u6[h6 + 0] << 16, A4 = l6[f7 + 0] | d5[p9 + 0] << 16;
        e3(null != t7);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n6(t7[r5 + 0], 255 & x3, x3 >> 16, g7, m8), null != a5 && (x3 = 3 * A4 + L4 + 131074 >> 2, n6(a5[o5 + 0], 255 & x3, x3 >> 16, v6, b4)), w4 = 1; w4 <= N5; ++w4) {
          var S3 = s6[c7 + w4] | u6[h6 + w4] << 16, _5 = l6[f7 + w4] | d5[p9 + w4] << 16, P3 = L4 + S3 + A4 + _5 + 524296, k4 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k4 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _5) >> 3) + S3 >> 1, n6(t7[r5 + 2 * w4 - 1], 255 & x3, x3 >> 16, g7, m8 + (2 * w4 - 1) * i6), n6(t7[r5 + 2 * w4 - 0], 255 & L4, L4 >> 16, g7, m8 + (2 * w4 - 0) * i6), null != a5 && (x3 = P3 + A4 >> 1, L4 = k4 + _5 >> 1, n6(a5[o5 + 2 * w4 - 1], 255 & x3, x3 >> 16, v6, b4 + (2 * w4 - 1) * i6), n6(a5[o5 + 2 * w4 + 0], 255 & L4, L4 >> 16, v6, b4 + (2 * w4 + 0) * i6)), L4 = S3, A4 = _5;
        }
        1 & y5 || (x3 = 3 * L4 + A4 + 131074 >> 2, n6(t7[r5 + y5 - 1], 255 & x3, x3 >> 16, g7, m8 + (y5 - 1) * i6), null != a5 && (x3 = 3 * A4 + L4 + 131074 >> 2, n6(a5[o5 + y5 - 1], 255 & x3, x3 >> 16, v6, b4 + (y5 - 1) * i6)));
      };
    }
    function br2() {
      vi[En] = bi, vi[qn] = wi, vi[Dn] = yi, vi[Rn] = Ni, vi[Tn] = Li, vi[Un] = Ai, vi[zn] = xi, vi[Hn] = wi, vi[Wn] = Ni, vi[Vn] = Li, vi[Gn] = Ai;
    }
    function yr(t7) {
      return t7 & ~Fi ? 0 > t7 ? 0 : 255 : t7 >> Ii;
    }
    function wr(t7, e4) {
      return yr((19077 * t7 >> 8) + (26149 * e4 >> 8) - 14234);
    }
    function Nr(t7, e4, r4) {
      return yr((19077 * t7 >> 8) - (6419 * e4 >> 8) - (13320 * r4 >> 8) + 8708);
    }
    function Lr(t7, e4) {
      return yr((19077 * t7 >> 8) + (33050 * e4 >> 8) - 17685);
    }
    function Ar(t7, e4, r4, n6, i6) {
      n6[i6 + 0] = wr(t7, r4), n6[i6 + 1] = Nr(t7, e4, r4), n6[i6 + 2] = Lr(t7, e4);
    }
    function xr(t7, e4, r4, n6, i6) {
      n6[i6 + 0] = Lr(t7, e4), n6[i6 + 1] = Nr(t7, e4, r4), n6[i6 + 2] = wr(t7, r4);
    }
    function Sr(t7, e4, r4, n6, i6) {
      var a5 = Nr(t7, e4, r4);
      e4 = a5 << 3 & 224 | Lr(t7, e4) >> 3, n6[i6 + 0] = 248 & wr(t7, r4) | a5 >> 5, n6[i6 + 1] = e4;
    }
    function _r(t7, e4, r4, n6, i6) {
      var a5 = 240 & Lr(t7, e4) | 15;
      n6[i6 + 0] = 240 & wr(t7, r4) | Nr(t7, e4, r4) >> 4, n6[i6 + 1] = a5;
    }
    function Pr(t7, e4, r4, n6, i6) {
      n6[i6 + 0] = 255, Ar(t7, e4, r4, n6, i6 + 1);
    }
    function kr(t7, e4, r4, n6, i6) {
      xr(t7, e4, r4, n6, i6), n6[i6 + 3] = 255;
    }
    function Ir(t7, e4, r4, n6, i6) {
      Ar(t7, e4, r4, n6, i6), n6[i6 + 3] = 255;
    }
    function Vt2(t7, e4) {
      return 0 > t7 ? 0 : t7 > e4 ? e4 : t7;
    }
    function Fr(e4, r4, n6) {
      t6[e4] = function(t7, e5, i6, a5, o5, s6, c7, u6, h6) {
        for (var l6 = u6 + (-2 & h6) * n6; u6 != l6; )
          r4(t7[e5 + 0], i6[a5 + 0], o5[s6 + 0], c7, u6), r4(t7[e5 + 1], i6[a5 + 0], o5[s6 + 0], c7, u6 + n6), e5 += 2, ++a5, ++s6, u6 += 2 * n6;
        1 & h6 && r4(t7[e5 + 0], i6[a5 + 0], o5[s6 + 0], c7, u6);
      };
    }
    function Cr(t7, e4, r4) {
      return 0 == r4 ? 0 == t7 ? 0 == e4 ? 6 : 5 : 0 == e4 ? 4 : 0 : r4;
    }
    function jr(t7, e4, r4, n6, i6) {
      switch (t7 >>> 30) {
        case 3:
          on(e4, r4, n6, i6, 0);
          break;
        case 2:
          sn(e4, r4, n6, i6);
          break;
        case 1:
          un2(e4, r4, n6, i6);
      }
    }
    function Or(t7, e4) {
      var r4, a5, o5 = e4.M, s6 = e4.Nb, c7 = t7.oc, u6 = t7.pc + 40, h6 = t7.oc, l6 = t7.pc + 584, f7 = t7.oc, d5 = t7.pc + 600;
      for (r4 = 0; 16 > r4; ++r4)
        c7[u6 + 32 * r4 - 1] = 129;
      for (r4 = 0; 8 > r4; ++r4)
        h6[l6 + 32 * r4 - 1] = 129, f7[d5 + 32 * r4 - 1] = 129;
      for (0 < o5 ? c7[u6 - 1 - 32] = h6[l6 - 1 - 32] = f7[d5 - 1 - 32] = 129 : (i5(c7, u6 - 32 - 1, 127, 21), i5(h6, l6 - 32 - 1, 127, 9), i5(f7, d5 - 32 - 1, 127, 9)), a5 = 0; a5 < t7.za; ++a5) {
        var p9 = e4.ya[e4.aa + a5];
        if (0 < a5) {
          for (r4 = -1; 16 > r4; ++r4)
            n5(c7, u6 + 32 * r4 - 4, c7, u6 + 32 * r4 + 12, 4);
          for (r4 = -1; 8 > r4; ++r4)
            n5(h6, l6 + 32 * r4 - 4, h6, l6 + 32 * r4 + 4, 4), n5(f7, d5 + 32 * r4 - 4, f7, d5 + 32 * r4 + 4, 4);
        }
        var g7 = t7.Gd, m8 = t7.Hd + a5, v6 = p9.ad, b4 = p9.Hc;
        if (0 < o5 && (n5(c7, u6 - 32, g7[m8].y, 0, 16), n5(h6, l6 - 32, g7[m8].f, 0, 8), n5(f7, d5 - 32, g7[m8].ea, 0, 8)), p9.Za) {
          var y5 = c7, w4 = u6 - 32 + 16;
          for (0 < o5 && (a5 >= t7.za - 1 ? i5(y5, w4, g7[m8].y[15], 4) : n5(y5, w4, g7[m8 + 1].y, 0, 4)), r4 = 0; 4 > r4; r4++)
            y5[w4 + 128 + r4] = y5[w4 + 256 + r4] = y5[w4 + 384 + r4] = y5[w4 + 0 + r4];
          for (r4 = 0; 16 > r4; ++r4, b4 <<= 2)
            y5 = c7, w4 = u6 + Di[r4], fi[p9.Ob[r4]](y5, w4), jr(b4, v6, 16 * +r4, y5, w4);
        } else if (y5 = Cr(a5, o5, p9.Ob[0]), li[y5](c7, u6), 0 != b4)
          for (r4 = 0; 16 > r4; ++r4, b4 <<= 2)
            jr(b4, v6, 16 * +r4, c7, u6 + Di[r4]);
        for (r4 = p9.Gc, y5 = Cr(a5, o5, p9.Dd), di[y5](h6, l6), di[y5](f7, d5), b4 = v6, y5 = h6, w4 = l6, 255 & (p9 = r4 >> 0) && (170 & p9 ? cn(b4, 256, y5, w4) : hn(b4, 256, y5, w4)), p9 = f7, b4 = d5, 255 & (r4 >>= 8) && (170 & r4 ? cn(v6, 320, p9, b4) : hn(v6, 320, p9, b4)), o5 < t7.Ub - 1 && (n5(g7[m8].y, 0, c7, u6 + 480, 16), n5(g7[m8].f, 0, h6, l6 + 224, 8), n5(g7[m8].ea, 0, f7, d5 + 224, 8)), r4 = 8 * s6 * t7.B, g7 = t7.sa, m8 = t7.ta + 16 * a5 + 16 * s6 * t7.R, v6 = t7.qa, p9 = t7.ra + 8 * a5 + r4, b4 = t7.Ha, y5 = t7.Ia + 8 * a5 + r4, r4 = 0; 16 > r4; ++r4)
          n5(g7, m8 + r4 * t7.R, c7, u6 + 32 * r4, 16);
        for (r4 = 0; 8 > r4; ++r4)
          n5(v6, p9 + r4 * t7.B, h6, l6 + 32 * r4, 8), n5(b4, y5 + r4 * t7.B, f7, d5 + 32 * r4, 8);
      }
    }
    function Br(t7, n6, i6, a5, o5, s6, c7, u6, h6) {
      var l6 = [0], f7 = [0], d5 = 0, p9 = null != h6 ? h6.kd : 0, g7 = null != h6 ? h6 : new nr();
      if (null == t7 || 12 > i6)
        return 7;
      g7.data = t7, g7.w = n6, g7.ha = i6, n6 = [n6], i6 = [i6], g7.gb = [g7.gb];
      t: {
        var m8 = n6, b4 = i6, y5 = g7.gb;
        if (e3(null != t7), e3(null != b4), e3(null != y5), y5[0] = 0, 12 <= b4[0] && !r3(t7, m8[0], "RIFF")) {
          if (r3(t7, m8[0] + 8, "WEBP")) {
            y5 = 3;
            break t;
          }
          var w4 = j3(t7, m8[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y5 = 3;
            break t;
          }
          if (p9 && w4 > b4[0] - 8) {
            y5 = 7;
            break t;
          }
          y5[0] = w4, m8[0] += 12, b4[0] -= 12;
        }
        y5 = 0;
      }
      if (0 != y5)
        return y5;
      for (w4 = 0 < g7.gb[0], i6 = i6[0]; ; ) {
        t: {
          var L4 = t7;
          b4 = n6, y5 = i6;
          var A4 = l6, x3 = f7, S3 = m8 = [0];
          if ((k4 = d5 = [d5])[0] = 0, 8 > y5[0])
            y5 = 7;
          else {
            if (!r3(L4, b4[0], "VP8X")) {
              if (10 != j3(L4, b4[0] + 4)) {
                y5 = 3;
                break t;
              }
              if (18 > y5[0]) {
                y5 = 7;
                break t;
              }
              var _5 = j3(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y5 = 3;
                break t;
              }
              null != S3 && (S3[0] = _5), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y5[0] -= 18, k4[0] = 1;
            }
            y5 = 0;
          }
        }
        if (d5 = d5[0], m8 = m8[0], 0 != y5)
          return y5;
        if (b4 = !!(2 & m8), !w4 && d5)
          return 3;
        if (null != s6 && (s6[0] = !!(16 & m8)), null != c7 && (c7[0] = b4), null != u6 && (u6[0] = 0), c7 = l6[0], m8 = f7[0], d5 && b4 && null == h6) {
          y5 = 0;
          break;
        }
        if (4 > i6) {
          y5 = 7;
          break;
        }
        if (w4 && d5 || !w4 && !d5 && !r3(t7, n6[0], "ALPH")) {
          i6 = [i6], g7.na = [g7.na], g7.P = [g7.P], g7.Sa = [g7.Sa];
          t: {
            _5 = t7, y5 = n6, w4 = i6;
            var k4 = g7.gb;
            A4 = g7.na, x3 = g7.P, S3 = g7.Sa;
            P3 = 22, e3(null != _5), e3(null != w4), L4 = y5[0];
            var I3 = w4[0];
            for (e3(null != A4), e3(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y5[0] = L4, w4[0] = I3, 8 > I3) {
                y5 = 7;
                break t;
              }
              var F3 = j3(_5, L4 + 4);
              if (4294967286 < F3) {
                y5 = 3;
                break t;
              }
              var O4 = 8 + F3 + 1 & -2;
              if (P3 += O4, 0 < k4 && P3 > k4) {
                y5 = 3;
                break t;
              }
              if (!r3(_5, L4, "VP8 ") || !r3(_5, L4, "VP8L")) {
                y5 = 0;
                break t;
              }
              if (I3[0] < O4) {
                y5 = 7;
                break t;
              }
              r3(_5, L4, "ALPH") || (A4[0] = _5, x3[0] = L4 + 8, S3[0] = F3), L4 += O4, I3 -= O4;
            }
          }
          if (i6 = i6[0], g7.na = g7.na[0], g7.P = g7.P[0], g7.Sa = g7.Sa[0], 0 != y5)
            break;
        }
        i6 = [i6], g7.Ja = [g7.Ja], g7.xa = [g7.xa];
        t:
          if (k4 = t7, y5 = n6, w4 = i6, A4 = g7.gb[0], x3 = g7.Ja, S3 = g7.xa, _5 = y5[0], L4 = !r3(k4, _5, "VP8 "), P3 = !r3(k4, _5, "VP8L"), e3(null != k4), e3(null != w4), e3(null != x3), e3(null != S3), 8 > w4[0])
            y5 = 7;
          else {
            if (L4 || P3) {
              if (k4 = j3(k4, _5 + 4), 12 <= A4 && k4 > A4 - 12) {
                y5 = 3;
                break t;
              }
              if (p9 && k4 > w4[0] - 8) {
                y5 = 7;
                break t;
              }
              x3[0] = k4, y5[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && 47 == k4[_5 + 0] && !(k4[_5 + 4] >> 5), x3[0] = w4[0];
            y5 = 0;
          }
        if (i6 = i6[0], g7.Ja = g7.Ja[0], g7.xa = g7.xa[0], n6 = n6[0], 0 != y5)
          break;
        if (4294967286 < g7.Ja)
          return 3;
        if (null == u6 || b4 || (u6[0] = g7.xa ? 2 : 1), c7 = [c7], m8 = [m8], g7.xa) {
          if (5 > i6) {
            y5 = 7;
            break;
          }
          u6 = c7, p9 = m8, b4 = s6, null == t7 || 5 > i6 ? t7 = 0 : 5 <= i6 && 47 == t7[n6 + 0] && !(t7[n6 + 4] >> 5) ? (w4 = [0], k4 = [0], A4 = [0], v5(x3 = new N4(), t7, n6, i6), gt2(x3, w4, k4, A4) ? (null != u6 && (u6[0] = w4[0]), null != p9 && (p9[0] = k4[0]), null != b4 && (b4[0] = A4[0]), t7 = 1) : t7 = 0) : t7 = 0;
        } else {
          if (10 > i6) {
            y5 = 7;
            break;
          }
          u6 = m8, null == t7 || 10 > i6 || !Xt2(t7, n6 + 3, i6 - 3) ? t7 = 0 : (p9 = t7[n6 + 0] | t7[n6 + 1] << 8 | t7[n6 + 2] << 16, b4 = 16383 & (t7[n6 + 7] << 8 | t7[n6 + 6]), t7 = 16383 & (t7[n6 + 9] << 8 | t7[n6 + 8]), 1 & p9 || 3 < (p9 >> 1 & 7) || !(p9 >> 4 & 1) || p9 >> 5 >= g7.Ja || !b4 || !t7 ? t7 = 0 : (c7 && (c7[0] = b4), u6 && (u6[0] = t7), t7 = 1));
        }
        if (!t7)
          return 3;
        if (c7 = c7[0], m8 = m8[0], d5 && (l6[0] != c7 || f7[0] != m8))
          return 3;
        null != h6 && (h6[0] = g7, h6.offset = n6 - h6.w, e3(4294967286 > n6 - h6.w), e3(h6.offset == h6.ha - i6));
        break;
      }
      return 0 == y5 || 7 == y5 && d5 && null == h6 ? (null != s6 && (s6[0] |= null != g7.na && 0 < g7.na.length), null != a5 && (a5[0] = c7), null != o5 && (o5[0] = m8), 0) : y5;
    }
    function Mr(t7, e4, r4) {
      var n6 = e4.width, i6 = e4.height, a5 = 0, o5 = 0, s6 = n6, c7 = i6;
      if (e4.Da = null != t7 && 0 < t7.Da, e4.Da && (s6 = t7.cd, c7 = t7.bd, a5 = t7.v, o5 = t7.j, 11 > r4 || (a5 &= -2, o5 &= -2), 0 > a5 || 0 > o5 || 0 >= s6 || 0 >= c7 || a5 + s6 > n6 || o5 + c7 > i6))
        return 0;
      if (e4.v = a5, e4.j = o5, e4.va = a5 + s6, e4.o = o5 + c7, e4.U = s6, e4.T = c7, e4.da = null != t7 && 0 < t7.da, e4.da) {
        if (!E2(s6, c7, r4 = [t7.ib], a5 = [t7.hb]))
          return 0;
        e4.ib = r4[0], e4.hb = a5[0];
      }
      return e4.ob = null != t7 && t7.ob, e4.Kb = null == t7 || !t7.Sd, e4.da && (e4.ob = e4.ib < 3 * n6 / 4 && e4.hb < 3 * i6 / 4, e4.Kb = 0), 1;
    }
    function Er(t7) {
      if (null == t7)
        return 2;
      if (11 > t7.S) {
        var e4 = t7.f.RGBA;
        e4.fb += (t7.height - 1) * e4.A, e4.A = -e4.A;
      } else
        e4 = t7.f.kb, t7 = t7.height, e4.O += (t7 - 1) * e4.fa, e4.fa = -e4.fa, e4.N += (t7 - 1 >> 1) * e4.Ab, e4.Ab = -e4.Ab, e4.W += (t7 - 1 >> 1) * e4.Db, e4.Db = -e4.Db, null != e4.F && (e4.J += (t7 - 1) * e4.lb, e4.lb = -e4.lb);
      return 0;
    }
    function qr(t7, e4, r4, n6) {
      if (null == n6 || 0 >= t7 || 0 >= e4)
        return 2;
      if (null != r4) {
        if (r4.Da) {
          var i6 = r4.cd, o5 = r4.bd, s6 = -2 & r4.v, c7 = -2 & r4.j;
          if (0 > s6 || 0 > c7 || 0 >= i6 || 0 >= o5 || s6 + i6 > t7 || c7 + o5 > e4)
            return 2;
          t7 = i6, e4 = o5;
        }
        if (r4.da) {
          if (!E2(t7, e4, i6 = [r4.ib], o5 = [r4.hb]))
            return 2;
          t7 = i6[0], e4 = o5[0];
        }
      }
      n6.width = t7, n6.height = e4;
      t: {
        var u6 = n6.width, h6 = n6.height;
        if (t7 = n6.S, 0 >= u6 || 0 >= h6 || !(t7 >= En && 13 > t7))
          t7 = 2;
        else {
          if (0 >= n6.Rd && null == n6.sd) {
            s6 = o5 = i6 = e4 = 0;
            var l6 = (c7 = u6 * zi[t7]) * h6;
            if (11 > t7 || (o5 = (h6 + 1) / 2 * (e4 = (u6 + 1) / 2), 12 == t7 && (s6 = (i6 = u6) * h6)), null == (h6 = a4(l6 + 2 * o5 + s6))) {
              t7 = 1;
              break t;
            }
            n6.sd = h6, 11 > t7 ? ((u6 = n6.f.RGBA).eb = h6, u6.fb = 0, u6.A = c7, u6.size = l6) : ((u6 = n6.f.kb).y = h6, u6.O = 0, u6.fa = c7, u6.Fd = l6, u6.f = h6, u6.N = 0 + l6, u6.Ab = e4, u6.Cd = o5, u6.ea = h6, u6.W = 0 + l6 + o5, u6.Db = e4, u6.Ed = o5, 12 == t7 && (u6.F = h6, u6.J = 0 + l6 + 2 * o5), u6.Tc = s6, u6.lb = i6);
          }
          if (e4 = 1, i6 = n6.S, o5 = n6.width, s6 = n6.height, i6 >= En && 13 > i6)
            if (11 > i6)
              t7 = n6.f.RGBA, e4 &= (c7 = Math.abs(t7.A)) * (s6 - 1) + o5 <= t7.size, e4 &= c7 >= o5 * zi[i6], e4 &= null != t7.eb;
            else {
              t7 = n6.f.kb, c7 = (o5 + 1) / 2, l6 = (s6 + 1) / 2, u6 = Math.abs(t7.fa);
              h6 = Math.abs(t7.Ab);
              var f7 = Math.abs(t7.Db), d5 = Math.abs(t7.lb), p9 = d5 * (s6 - 1) + o5;
              e4 &= u6 * (s6 - 1) + o5 <= t7.Fd, e4 &= h6 * (l6 - 1) + c7 <= t7.Cd, e4 = (e4 &= f7 * (l6 - 1) + c7 <= t7.Ed) & u6 >= o5 & h6 >= c7 & f7 >= c7, e4 &= null != t7.y, e4 &= null != t7.f, e4 &= null != t7.ea, 12 == i6 && (e4 &= d5 >= o5, e4 &= p9 <= t7.Tc, e4 &= null != t7.F);
            }
          else
            e4 = 0;
          t7 = e4 ? 0 : 2;
        }
      }
      return 0 != t7 || null != r4 && r4.fd && (t7 = Er(n6)), t7;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t6.Predictor0 = function() {
      return 4278190080;
    }, t6.Predictor1 = function(t7) {
      return t7;
    }, t6.Predictor2 = function(t7, e4, r4) {
      return e4[r4 + 0];
    }, t6.Predictor3 = function(t7, e4, r4) {
      return e4[r4 + 1];
    }, t6.Predictor4 = function(t7, e4, r4) {
      return e4[r4 - 1];
    }, t6.Predictor5 = function(t7, e4, r4) {
      return U2(U2(t7, e4[r4 + 1]), e4[r4 + 0]);
    }, t6.Predictor6 = function(t7, e4, r4) {
      return U2(t7, e4[r4 - 1]);
    }, t6.Predictor7 = function(t7, e4, r4) {
      return U2(t7, e4[r4 + 0]);
    }, t6.Predictor8 = function(t7, e4, r4) {
      return U2(e4[r4 - 1], e4[r4 + 0]);
    }, t6.Predictor9 = function(t7, e4, r4) {
      return U2(e4[r4 + 0], e4[r4 + 1]);
    }, t6.Predictor10 = function(t7, e4, r4) {
      return U2(U2(t7, e4[r4 - 1]), U2(e4[r4 + 0], e4[r4 + 1]));
    }, t6.Predictor11 = function(t7, e4, r4) {
      var n6 = e4[r4 + 0];
      return 0 >= W2(n6 >> 24 & 255, t7 >> 24 & 255, (e4 = e4[r4 - 1]) >> 24 & 255) + W2(n6 >> 16 & 255, t7 >> 16 & 255, e4 >> 16 & 255) + W2(n6 >> 8 & 255, t7 >> 8 & 255, e4 >> 8 & 255) + W2(255 & n6, 255 & t7, 255 & e4) ? n6 : t7;
    }, t6.Predictor12 = function(t7, e4, r4) {
      var n6 = e4[r4 + 0];
      return (z2((t7 >> 24 & 255) + (n6 >> 24 & 255) - ((e4 = e4[r4 - 1]) >> 24 & 255)) << 24 | z2((t7 >> 16 & 255) + (n6 >> 16 & 255) - (e4 >> 16 & 255)) << 16 | z2((t7 >> 8 & 255) + (n6 >> 8 & 255) - (e4 >> 8 & 255)) << 8 | z2((255 & t7) + (255 & n6) - (255 & e4))) >>> 0;
    }, t6.Predictor13 = function(t7, e4, r4) {
      var n6 = e4[r4 - 1];
      return (H2((t7 = U2(t7, e4[r4 + 0])) >> 24 & 255, n6 >> 24 & 255) << 24 | H2(t7 >> 16 & 255, n6 >> 16 & 255) << 16 | H2(t7 >> 8 & 255, n6 >> 8 & 255) << 8 | H2(t7 >> 0 & 255, n6 >> 0 & 255)) >>> 0;
    };
    var Wr = t6.PredictorAdd0;
    t6.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t6.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t7) {
      return t7 >> 8 & 255;
    }, function(t7) {
      return t7;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t7) {
      return t7;
    }, function(t7) {
      return t7 >> 8 & 255;
    });
    var Gr, Yr = t6.ColorIndexInverseTransform, Jr = t6.MapARGB, Xr = t6.VP8LColorIndexInverseTransformAlpha, Kr = t6.MapAlpha, Zr = t6.VP8LPredictorsAdd = [];
    Zr.length = 16, (t6.VP8LPredictors = []).length = 16, (t6.VP8LPredictorsAdd_C = []).length = 16, (t6.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn, en, rn, nn3, an, on, sn, cn, un2, hn, ln2, fn, dn, pn, gn, mn, vn, bn, yn, wn, Nn, Ln, An, xn, Sn, _n, Pn = a4(511), kn = a4(2041), In = a4(225), Fn = a4(767), Cn = 0, jn = kn, On = In, Bn = Fn, Mn = Pn, En = 0, qn = 1, Dn = 2, Rn = 3, Tn = 4, Un = 5, zn = 6, Hn = 7, Wn = 8, Vn = 9, Gn = 10, Yn = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti = 8, ei = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ii = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], fi = [], di = [], pi = 1, gi = 2, mi = [], vi = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi = t6.UpsampleRgbLinePair, yi = t6.UpsampleBgrLinePair, wi = t6.UpsampleRgbaLinePair, Ni = t6.UpsampleBgraLinePair, Li = t6.UpsampleArgbLinePair, Ai = t6.UpsampleRgba4444LinePair, xi = t6.UpsampleRgb565LinePair, Si = 16, _i = 1 << Si - 1, Pi = -227, ki = 482, Ii = 6, Fi = (256 << Ii) - 1, Ci = 0, ji = a4(256), Oi = a4(256), Bi = a4(256), Mi = a4(256), Ei = a4(ki - Pi), qi = a4(ki - Pi);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Ti = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui = 1;
    this.WebPDecodeRGBA = function(t7, r4, n6, i6, a5) {
      var o5 = qn, s6 = new rr(), c7 = new ot2();
      s6.ba = c7, c7.S = o5, c7.width = [c7.width], c7.height = [c7.height];
      var u6 = c7.width, h6 = c7.height, l6 = new st2();
      if (null == l6 || null == t7)
        var f7 = 2;
      else
        e3(null != l6), f7 = Br(t7, r4, n6, l6.width, l6.height, l6.Pd, l6.Qd, l6.format, null);
      if (0 != f7 ? u6 = 0 : (null != u6 && (u6[0] = l6.width[0]), null != h6 && (h6[0] = l6.height[0]), u6 = 1), u6) {
        c7.width = c7.width[0], c7.height = c7.height[0], null != i6 && (i6[0] = c7.width), null != a5 && (a5[0] = c7.height);
        t: {
          if (i6 = new Gt2(), (a5 = new nr()).data = t7, a5.w = r4, a5.ha = n6, a5.kd = 1, r4 = [0], e3(null != a5), (0 == (t7 = Br(a5.data, a5.w, a5.ha, null, null, null, r4, null, a5)) || 7 == t7) && r4[0] && (t7 = 4), 0 == (r4 = t7)) {
            if (e3(null != s6), i6.data = a5.data, i6.w = a5.w + a5.offset, i6.ha = a5.ha - a5.offset, i6.put = dt2, i6.ac = ft2, i6.bc = pt2, i6.ma = s6, a5.xa) {
              if (null == (t7 = kt2())) {
                s6 = 1;
                break t;
              }
              if (function(t8, r5) {
                var n7 = [0], i7 = [0], a6 = [0];
                e:
                  for (; ; ) {
                    if (null == t8)
                      return 0;
                    if (null == r5)
                      return t8.a = 2, 0;
                    if (t8.l = r5, t8.a = 0, v5(t8.m, r5.data, r5.w, r5.ha), !gt2(t8.m, n7, i7, a6)) {
                      t8.a = 3;
                      break e;
                    }
                    if (t8.xb = gi, r5.width = n7[0], r5.height = i7[0], !It2(n7[0], i7[0], 1, t8, null))
                      break e;
                    return 1;
                  }
                return e3(0 != t8.a), 0;
              }(t7, i6)) {
                if (i6 = 0 == (r4 = qr(i6.width, i6.height, s6.Oa, s6.ba))) {
                  e: {
                    i6 = t7;
                    r:
                      for (; ; ) {
                        if (null == i6) {
                          i6 = 0;
                          break e;
                        }
                        if (e3(null != i6.s.yc), e3(null != i6.s.Ya), e3(0 < i6.s.Wb), e3(null != (n6 = i6.l)), e3(null != (a5 = n6.ma)), 0 != i6.xb) {
                          if (i6.ca = a5.ba, i6.tb = a5.tb, e3(null != i6.ca), !Mr(a5.Oa, n6, Rn)) {
                            i6.a = 2;
                            break r;
                          }
                          if (!Ft2(i6, n6.width))
                            break r;
                          if (n6.da)
                            break r;
                          if ((n6.da || nt2(i6.ca.S)) && mr(), 11 > i6.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i6.ca.f.kb.F && mr()), i6.Pb && 0 < i6.s.ua && null == i6.s.vb.X && !O3(i6.s.vb, i6.s.Wa.Xa)) {
                            i6.a = 1;
                            break r;
                          }
                          i6.xb = 0;
                        }
                        if (!_t2(i6, i6.V, i6.Ba, i6.c, i6.i, n6.o, Lt2))
                          break r;
                        a5.Dc = i6.Ma, i6 = 1;
                        break e;
                      }
                    e3(0 != i6.a), i6 = 0;
                  }
                  i6 = !i6;
                }
                i6 && (r4 = t7.a);
              } else
                r4 = t7.a;
            } else {
              if (null == (t7 = new Yt2())) {
                s6 = 1;
                break t;
              }
              if (t7.Fa = a5.na, t7.P = a5.P, t7.qc = a5.Sa, Kt2(t7, i6)) {
                if (0 == (r4 = qr(i6.width, i6.height, s6.Oa, s6.ba))) {
                  if (t7.Aa = 0, n6 = s6.Oa, e3(null != (a5 = t7)), null != n6) {
                    if (0 < (u6 = 0 > (u6 = n6.Md) ? 0 : 100 < u6 ? 255 : 255 * u6 / 100)) {
                      for (h6 = l6 = 0; 4 > h6; ++h6)
                        12 > (f7 = a5.pb[h6]).lc && (f7.ia = u6 * Ti[0 > f7.lc ? 0 : f7.lc] >> 3), l6 |= f7.ia;
                      l6 && (alert("todo:VP8InitRandom"), a5.ia = 1);
                    }
                    a5.Ga = n6.Id, 100 < a5.Ga ? a5.Ga = 100 : 0 > a5.Ga && (a5.Ga = 0);
                  }
                  Qt2(t7, i6) || (r4 = t7.a);
                }
              } else
                r4 = t7.a;
            }
            0 == r4 && null != s6.Oa && s6.Oa.fd && (r4 = Er(s6.ba));
          }
          s6 = r4;
        }
        o5 = 0 != s6 ? null : 11 > o5 ? c7.f.RGBA.eb : c7.f.kb.y;
      } else
        o5 = null;
      return o5;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u4(t6, e4) {
    for (var r4 = "", n6 = 0; n6 < 4; n6++)
      r4 += String.fromCharCode(t6[e4++]);
    return r4;
  }
  function h4(t6, e4) {
    return (t6[e4 + 0] << 0 | t6[e4 + 1] << 8 | t6[e4 + 2] << 16) >>> 0;
  }
  function l4(t6, e4) {
    return (t6[e4 + 0] << 0 | t6[e4 + 1] << 8 | t6[e4 + 2] << 16 | t6[e4 + 3] << 24) >>> 0;
  }
  new c5();
  var f5 = [0], d3 = [0], p7 = [], g5 = new c5(), m6 = t5, v4 = function(t6, e4) {
    var r4 = {}, n6 = 0, i6 = false, a5 = 0, o5 = 0;
    if (r4.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t7, e5, r5, n7) {
      for (var i7 = 0; i7 < n7; i7++)
        if (t7[e5 + i7] != r5.charCodeAt(i7))
          return true;
      return false;
    }(t6, e4, "RIFF", 4)) {
      var s6, c6;
      l4(t6, e4 += 4);
      for (e4 += 8; e4 < t6.length; ) {
        var f6 = u4(t6, e4), d4 = l4(t6, e4 += 4);
        e4 += 4;
        var p8 = d4 + (1 & d4);
        switch (f6) {
          case "VP8 ":
          case "VP8L":
            void 0 === r4.frames[n6] && (r4.frames[n6] = {});
            (v5 = r4.frames[n6]).src_off = i6 ? o5 : e4 - 8, v5.src_size = a5 + d4 + 8, n6++, i6 && (i6 = false, a5 = 0, o5 = 0);
            break;
          case "VP8X":
            (v5 = r4.header = {}).feature_flags = t6[e4];
            var g6 = e4 + 4;
            v5.canvas_width = 1 + h4(t6, g6);
            g6 += 3;
            v5.canvas_height = 1 + h4(t6, g6);
            g6 += 3;
            break;
          case "ALPH":
            i6 = true, a5 = p8 + 8, o5 = e4 - 8;
            break;
          case "ANIM":
            (v5 = r4.header).bgcolor = l4(t6, e4);
            g6 = e4 + 4;
            v5.loop_count = (s6 = t6)[(c6 = g6) + 0] << 0 | s6[c6 + 1] << 8;
            g6 += 2;
            break;
          case "ANMF":
            var m7, v5;
            (v5 = r4.frames[n6] = {}).offset_x = 2 * h4(t6, e4), e4 += 3, v5.offset_y = 2 * h4(t6, e4), e4 += 3, v5.width = 1 + h4(t6, e4), e4 += 3, v5.height = 1 + h4(t6, e4), e4 += 3, v5.duration = h4(t6, e4), e4 += 3, m7 = t6[e4++], v5.dispose = 1 & m7, v5.blend = m7 >> 1 & 1;
        }
        "ANMF" != f6 && (e4 += p8);
      }
      return r4;
    }
  }(m6, 0);
  v4.response = m6, v4.rgbaoutput = true, v4.dataurl = false;
  var b2 = v4.header ? v4.header : null, y3 = v4.frames ? v4.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f5 = [b2.canvas_height], d3 = [b2.canvas_width];
    for (var w2 = 0; w2 < y3.length && 0 != y3[w2].blend; w2++)
      ;
  }
  var N3 = y3[0], L2 = g5.WebPDecodeRGBA(m6, N3.src_off, N3.src_size, d3, f5);
  N3.rgba = L2, N3.imgwidth = d3[0], N3.imgheight = f5[0];
  for (var A2 = 0; A2 < d3[0] * f5[0] * 4; A2++)
    p7[A2] = L2[A2];
  return this.width = d3, this.height = f5, this.data = p7, this;
}
!function(t5) {
  var r3 = function() {
    return "function" == typeof zlibSync;
  }, n5 = function(r4, n6, a5, h5) {
    var l5 = 4, f6 = s5;
    switch (h5) {
      case t5.image_compression.FAST:
        l5 = 1, f6 = o4;
        break;
      case t5.image_compression.MEDIUM:
        l5 = 6, f6 = c5;
        break;
      case t5.image_compression.SLOW:
        l5 = 9, f6 = u4;
    }
    r4 = i5(r4, n6, a5, f6);
    var d3 = zlibSync(r4, { level: l5 });
    return t5.__addimage__.arrayBufferToBinaryString(d3);
  }, i5 = function(t6, e3, r4, n6) {
    for (var i6, a5, o5, s6 = t6.length / e3, c6 = new Uint8Array(t6.length + s6), u5 = l4(), h5 = 0; h5 < s6; h5 += 1) {
      if (o5 = h5 * e3, i6 = t6.subarray(o5, o5 + e3), n6)
        c6.set(n6(i6, r4, a5), o5 + h5);
      else {
        for (var d3, p7 = u5.length, g5 = []; d3 < p7; d3 += 1)
          g5[d3] = u5[d3](i6, r4, a5);
        var m6 = f5(g5.concat());
        c6.set(g5[m6], o5 + h5);
      }
      a5 = i6;
    }
    return c6;
  }, a4 = function(t6) {
    var e3 = Array.apply([], t6);
    return e3.unshift(0), e3;
  }, o4 = function(t6, e3) {
    var r4, n6 = [], i6 = t6.length;
    n6[0] = 1;
    for (var a5 = 0; a5 < i6; a5 += 1)
      r4 = t6[a5 - e3] || 0, n6[a5 + 1] = t6[a5] - r4 + 256 & 255;
    return n6;
  }, s5 = function(t6, e3, r4) {
    var n6, i6 = [], a5 = t6.length;
    i6[0] = 2;
    for (var o5 = 0; o5 < a5; o5 += 1)
      n6 = r4 && r4[o5] || 0, i6[o5 + 1] = t6[o5] - n6 + 256 & 255;
    return i6;
  }, c5 = function(t6, e3, r4) {
    var n6, i6, a5 = [], o5 = t6.length;
    a5[0] = 3;
    for (var s6 = 0; s6 < o5; s6 += 1)
      n6 = t6[s6 - e3] || 0, i6 = r4 && r4[s6] || 0, a5[s6 + 1] = t6[s6] + 256 - (n6 + i6 >>> 1) & 255;
    return a5;
  }, u4 = function(t6, e3, r4) {
    var n6, i6, a5, o5, s6 = [], c6 = t6.length;
    s6[0] = 4;
    for (var u5 = 0; u5 < c6; u5 += 1)
      n6 = t6[u5 - e3] || 0, i6 = r4 && r4[u5] || 0, a5 = r4 && r4[u5 - e3] || 0, o5 = h4(n6, i6, a5), s6[u5 + 1] = t6[u5] - o5 + 256 & 255;
    return s6;
  }, h4 = function(t6, e3, r4) {
    if (t6 === e3 && e3 === r4)
      return t6;
    var n6 = Math.abs(e3 - r4), i6 = Math.abs(t6 - r4), a5 = Math.abs(t6 + e3 - r4 - r4);
    return n6 <= i6 && n6 <= a5 ? t6 : i6 <= a5 ? e3 : r4;
  }, l4 = function() {
    return [a4, o4, s5, c5, u4];
  }, f5 = function(t6) {
    var e3 = t6.map(function(t7) {
      return t7.reduce(function(t8, e4) {
        return t8 + Math.abs(e4);
      }, 0);
    });
    return e3.indexOf(Math.min.apply(null, e3));
  };
  t5.processPNG = function(e3, i6, a5, o5) {
    var s6, c6, u5, h5, l5, f6, d3, p7, g5, m6, v4, b2, y3, w2, N3, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e3) && (e3 = new Uint8Array(e3)), this.__addimage__.isArrayBufferView(e3)) {
      if (e3 = (u5 = new Kt(e3)).imgData, c6 = u5.bits, s6 = u5.colorSpace, l5 = u5.colors, -1 !== [4, 6].indexOf(u5.colorType)) {
        if (8 === u5.bits) {
          g5 = (p7 = 32 == u5.pixelBitlength ? new Uint32Array(u5.decodePixels().buffer) : 16 == u5.pixelBitlength ? new Uint16Array(u5.decodePixels().buffer) : new Uint8Array(u5.decodePixels().buffer)).length, v4 = new Uint8Array(g5 * u5.colors), m6 = new Uint8Array(g5);
          var x2, S2 = u5.pixelBitlength - u5.bits;
          for (w2 = 0, N3 = 0; w2 < g5; w2++) {
            for (y3 = p7[w2], x2 = 0; x2 < S2; )
              v4[N3++] = y3 >>> x2 & 255, x2 += u5.bits;
            m6[w2] = y3 >>> x2 & 255;
          }
        }
        if (16 === u5.bits) {
          g5 = (p7 = new Uint32Array(u5.decodePixels().buffer)).length, v4 = new Uint8Array(g5 * (32 / u5.pixelBitlength) * u5.colors), m6 = new Uint8Array(g5 * (32 / u5.pixelBitlength)), b2 = u5.colors > 1, w2 = 0, N3 = 0;
          for (var _4 = 0; w2 < g5; )
            y3 = p7[w2++], v4[N3++] = y3 >>> 0 & 255, b2 && (v4[N3++] = y3 >>> 16 & 255, y3 = p7[w2++], v4[N3++] = y3 >>> 0 & 255), m6[_4++] = y3 >>> 16 & 255;
          c6 = 8;
        }
        o5 !== t5.image_compression.NONE && r3() ? (e3 = n5(v4, u5.width * u5.colors, u5.colors, o5), d3 = n5(m6, u5.width, 1, o5)) : (e3 = v4, d3 = m6, L2 = void 0);
      }
      if (3 === u5.colorType && (s6 = this.color_spaces.INDEXED, f6 = u5.palette, u5.transparency.indexed)) {
        var P2 = u5.transparency.indexed, k3 = 0;
        for (w2 = 0, g5 = P2.length; w2 < g5; ++w2)
          k3 += P2[w2];
        if ((k3 /= 255) === g5 - 1 && -1 !== P2.indexOf(0))
          h5 = [P2.indexOf(0)];
        else if (k3 !== g5) {
          for (p7 = u5.decodePixels(), m6 = new Uint8Array(p7.length), w2 = 0, g5 = p7.length; w2 < g5; w2++)
            m6[w2] = P2[p7[w2]];
          d3 = n5(m6, u5.width, 1);
        }
      }
      var I2 = function(e4) {
        var r4;
        switch (e4) {
          case t5.image_compression.FAST:
            r4 = 11;
            break;
          case t5.image_compression.MEDIUM:
            r4 = 13;
            break;
          case t5.image_compression.SLOW:
            r4 = 14;
            break;
          default:
            r4 = 12;
        }
        return r4;
      }(o5);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l5 + " /BitsPerComponent " + c6 + " /Columns " + u5.width, (this.__addimage__.isArrayBuffer(e3) || this.__addimage__.isArrayBufferView(e3)) && (e3 = this.__addimage__.arrayBufferToBinaryString(e3)), (d3 && this.__addimage__.isArrayBuffer(d3) || this.__addimage__.isArrayBufferView(d3)) && (d3 = this.__addimage__.arrayBufferToBinaryString(d3)), { alias: a5, data: e3, index: i6, filter: L2, decodeParameters: A2, transparency: h5, palette: f6, sMask: d3, predictor: I2, width: u5.width, height: u5.height, bitsPerComponent: c6, colorSpace: s6 };
    }
  };
}(E.API), function(t5) {
  t5.processGIF89A = function(e3, r3, n5, i5) {
    var a4 = new Zt(e3), o4 = a4.width, s5 = a4.height, c5 = [];
    a4.decodeAndBlitFrameRGBA(0, c5);
    var u4 = { data: c5, width: o4, height: s5 }, h4 = new Qt(100).encode(u4, 100);
    return t5.processJPEG.call(this, h4, r3, n5, i5);
  }, t5.processGIF87A = t5.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t5 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t5);
    for (var e3 = 0; e3 < t5; e3++) {
      var r3 = this.datav.getUint8(this.pos++, true), n5 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a4 = this.datav.getUint8(this.pos++, true);
      this.palette[e3] = { red: i5, green: n5, blue: r3, quad: a4 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t5 = "bit" + this.bitPP, e3 = this.width * this.height * 4;
    this.data = new Uint8Array(e3), this[t5]();
  } catch (t6) {
    a3.log("bit decode error:" + t6);
  }
}, te.prototype.bit1 = function() {
  var t5, e3 = Math.ceil(this.width / 8), r3 = e3 % 4;
  for (t5 = this.height - 1; t5 >= 0; t5--) {
    for (var n5 = this.bottom_up ? t5 : this.height - 1 - t5, i5 = 0; i5 < e3; i5++)
      for (var a4 = this.datav.getUint8(this.pos++, true), o4 = n5 * this.width * 4 + 8 * i5 * 4, s5 = 0; s5 < 8 && 8 * i5 + s5 < this.width; s5++) {
        var c5 = this.palette[a4 >> 7 - s5 & 1];
        this.data[o4 + 4 * s5] = c5.blue, this.data[o4 + 4 * s5 + 1] = c5.green, this.data[o4 + 4 * s5 + 2] = c5.red, this.data[o4 + 4 * s5 + 3] = 255;
      }
    0 !== r3 && (this.pos += 4 - r3);
  }
}, te.prototype.bit4 = function() {
  for (var t5 = Math.ceil(this.width / 2), e3 = t5 % 4, r3 = this.height - 1; r3 >= 0; r3--) {
    for (var n5 = this.bottom_up ? r3 : this.height - 1 - r3, i5 = 0; i5 < t5; i5++) {
      var a4 = this.datav.getUint8(this.pos++, true), o4 = n5 * this.width * 4 + 2 * i5 * 4, s5 = a4 >> 4, c5 = 15 & a4, u4 = this.palette[s5];
      if (this.data[o4] = u4.blue, this.data[o4 + 1] = u4.green, this.data[o4 + 2] = u4.red, this.data[o4 + 3] = 255, 2 * i5 + 1 >= this.width)
        break;
      u4 = this.palette[c5], this.data[o4 + 4] = u4.blue, this.data[o4 + 4 + 1] = u4.green, this.data[o4 + 4 + 2] = u4.red, this.data[o4 + 4 + 3] = 255;
    }
    0 !== e3 && (this.pos += 4 - e3);
  }
}, te.prototype.bit8 = function() {
  for (var t5 = this.width % 4, e3 = this.height - 1; e3 >= 0; e3--) {
    for (var r3 = this.bottom_up ? e3 : this.height - 1 - e3, n5 = 0; n5 < this.width; n5++) {
      var i5 = this.datav.getUint8(this.pos++, true), a4 = r3 * this.width * 4 + 4 * n5;
      if (i5 < this.palette.length) {
        var o4 = this.palette[i5];
        this.data[a4] = o4.red, this.data[a4 + 1] = o4.green, this.data[a4 + 2] = o4.blue, this.data[a4 + 3] = 255;
      } else
        this.data[a4] = 255, this.data[a4 + 1] = 255, this.data[a4 + 2] = 255, this.data[a4 + 3] = 255;
    }
    0 !== t5 && (this.pos += 4 - t5);
  }
}, te.prototype.bit15 = function() {
  for (var t5 = this.width % 3, e3 = parseInt("11111", 2), r3 = this.height - 1; r3 >= 0; r3--) {
    for (var n5 = this.bottom_up ? r3 : this.height - 1 - r3, i5 = 0; i5 < this.width; i5++) {
      var a4 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o4 = (a4 & e3) / e3 * 255 | 0, s5 = (a4 >> 5 & e3) / e3 * 255 | 0, c5 = (a4 >> 10 & e3) / e3 * 255 | 0, u4 = a4 >> 15 ? 255 : 0, h4 = n5 * this.width * 4 + 4 * i5;
      this.data[h4] = c5, this.data[h4 + 1] = s5, this.data[h4 + 2] = o4, this.data[h4 + 3] = u4;
    }
    this.pos += t5;
  }
}, te.prototype.bit16 = function() {
  for (var t5 = this.width % 3, e3 = parseInt("11111", 2), r3 = parseInt("111111", 2), n5 = this.height - 1; n5 >= 0; n5--) {
    for (var i5 = this.bottom_up ? n5 : this.height - 1 - n5, a4 = 0; a4 < this.width; a4++) {
      var o4 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s5 = (o4 & e3) / e3 * 255 | 0, c5 = (o4 >> 5 & r3) / r3 * 255 | 0, u4 = (o4 >> 11) / e3 * 255 | 0, h4 = i5 * this.width * 4 + 4 * a4;
      this.data[h4] = u4, this.data[h4 + 1] = c5, this.data[h4 + 2] = s5, this.data[h4 + 3] = 255;
    }
    this.pos += t5;
  }
}, te.prototype.bit24 = function() {
  for (var t5 = this.height - 1; t5 >= 0; t5--) {
    for (var e3 = this.bottom_up ? t5 : this.height - 1 - t5, r3 = 0; r3 < this.width; r3++) {
      var n5 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a4 = this.datav.getUint8(this.pos++, true), o4 = e3 * this.width * 4 + 4 * r3;
      this.data[o4] = a4, this.data[o4 + 1] = i5, this.data[o4 + 2] = n5, this.data[o4 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t5 = this.height - 1; t5 >= 0; t5--)
    for (var e3 = this.bottom_up ? t5 : this.height - 1 - t5, r3 = 0; r3 < this.width; r3++) {
      var n5 = this.datav.getUint8(this.pos++, true), i5 = this.datav.getUint8(this.pos++, true), a4 = this.datav.getUint8(this.pos++, true), o4 = this.datav.getUint8(this.pos++, true), s5 = e3 * this.width * 4 + 4 * r3;
      this.data[s5] = a4, this.data[s5 + 1] = i5, this.data[s5 + 2] = n5, this.data[s5 + 3] = o4;
    }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  t5.processBMP = function(e3, r3, n5, i5) {
    var a4 = new te(e3, false), o4 = a4.width, s5 = a4.height, c5 = { data: a4.getData(), width: o4, height: s5 }, u4 = new Qt(100).encode(c5, 100);
    return t5.processJPEG.call(this, u4, r3, n5, i5);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  t5.processWEBP = function(e3, r3, n5, i5) {
    var a4 = new ee(e3, false), o4 = a4.width, s5 = a4.height, c5 = { data: a4.getData(), width: o4, height: s5 }, u4 = new Qt(100).encode(c5, 100);
    return t5.processJPEG.call(this, u4, r3, n5, i5);
  };
}(E.API), E.API.processRGBA = function(t5, e3, r3) {
  for (var n5 = t5.data, i5 = n5.length, a4 = new Uint8Array(i5 / 4 * 3), o4 = new Uint8Array(i5 / 4), s5 = 0, c5 = 0, u4 = 0; u4 < i5; u4 += 4) {
    var h4 = n5[u4], l4 = n5[u4 + 1], f5 = n5[u4 + 2], d3 = n5[u4 + 3];
    a4[s5++] = h4, a4[s5++] = l4, a4[s5++] = f5, o4[c5++] = d3;
  }
  var p7 = this.__addimage__.arrayBufferToBinaryString(a4);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o4), data: p7, index: e3, alias: r3, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t5.width, height: t5.height };
}, E.API.setLanguage = function(t5) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t5] && (this.internal.languageSettings.languageCode = t5, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e3, r3) {
  var n5, i5, a4 = (r3 = r3 || {}).font || this.internal.getFont(), o4 = r3.fontSize || this.internal.getFontSize(), s5 = r3.charSpace || this.internal.getCharSpace(), c5 = r3.widths ? r3.widths : a4.metadata.Unicode.widths, u4 = c5.fof ? c5.fof : 1, h4 = r3.kerning ? r3.kerning : a4.metadata.Unicode.kerning, l4 = h4.fof ? h4.fof : 1, f5 = false !== r3.doKerning, d3 = 0, p7 = e3.length, g5 = 0, m6 = c5[0] || u4, v4 = [];
  for (n5 = 0; n5 < p7; n5++)
    i5 = e3.charCodeAt(n5), "function" == typeof a4.metadata.widthOfString ? v4.push((a4.metadata.widthOfGlyph(a4.metadata.characterToGlyph(i5)) + s5 * (1e3 / o4) || 0) / 1e3) : (d3 = f5 && "object" === _typeof(h4[i5]) && !isNaN(parseInt(h4[i5][g5], 10)) ? h4[i5][g5] / l4 : 0, v4.push((c5[i5] || m6) / u4 + d3)), g5 = i5;
  return v4;
}, Yt = Vt.getStringUnitWidth = function(t5, e3) {
  var r3 = (e3 = e3 || {}).fontSize || this.internal.getFontSize(), n5 = e3.font || this.internal.getFont(), i5 = e3.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t5 = Vt.processArabic(t5)), "function" == typeof n5.metadata.widthOfString ? n5.metadata.widthOfString(t5, r3, i5) / r3 : Gt.apply(this, arguments).reduce(function(t6, e4) {
    return t6 + e4;
  }, 0);
}, Jt = function(t5, e3, r3, n5) {
  for (var i5 = [], a4 = 0, o4 = t5.length, s5 = 0; a4 !== o4 && s5 + e3[a4] < r3; )
    s5 += e3[a4], a4++;
  i5.push(t5.slice(0, a4));
  var c5 = a4;
  for (s5 = 0; a4 !== o4; )
    s5 + e3[a4] > n5 && (i5.push(t5.slice(c5, a4)), s5 = 0, c5 = a4), s5 += e3[a4], a4++;
  return c5 !== a4 && i5.push(t5.slice(c5, a4)), i5;
}, Xt = function(t5, e3, r3) {
  r3 || (r3 = {});
  var n5, i5, a4, o4, s5, c5, u4, h4 = [], l4 = [h4], f5 = r3.textIndent || 0, d3 = 0, p7 = 0, g5 = t5.split(" "), m6 = Gt.apply(this, [" ", r3])[0];
  if (c5 = -1 === r3.lineIndent ? g5[0].length + 2 : r3.lineIndent || 0) {
    var v4 = Array(c5).join(" "), b2 = [];
    g5.map(function(t6) {
      (t6 = t6.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t6.map(function(t7, e4) {
        return (e4 && t7.length ? "\n" : "") + t7;
      })) : b2.push(t6[0]);
    }), g5 = b2, c5 = Yt.apply(this, [v4, r3]);
  }
  for (a4 = 0, o4 = g5.length; a4 < o4; a4++) {
    var y3 = 0;
    if (n5 = g5[a4], c5 && "\n" == n5[0] && (n5 = n5.substr(1), y3 = 1), f5 + d3 + (p7 = (i5 = Gt.apply(this, [n5, r3])).reduce(function(t6, e4) {
      return t6 + e4;
    }, 0)) > e3 || y3) {
      if (p7 > e3) {
        for (s5 = Jt.apply(this, [n5, i5, e3 - (f5 + d3), e3]), h4.push(s5.shift()), h4 = [s5.pop()]; s5.length; )
          l4.push([s5.shift()]);
        p7 = i5.slice(n5.length - (h4[0] ? h4[0].length : 0)).reduce(function(t6, e4) {
          return t6 + e4;
        }, 0);
      } else
        h4 = [n5];
      l4.push(h4), f5 = p7 + c5, d3 = m6;
    } else
      h4.push(n5), f5 += d3 + p7, d3 = m6;
  }
  return u4 = c5 ? function(t6, e4) {
    return (e4 ? v4 : "") + t6.join(" ");
  } : function(t6) {
    return t6.join(" ");
  }, l4.map(u4);
}, Vt.splitTextToSize = function(t5, e3, r3) {
  var n5, i5 = (r3 = r3 || {}).fontSize || this.internal.getFontSize(), a4 = function(t6) {
    if (t6.widths && t6.kerning)
      return { widths: t6.widths, kerning: t6.kerning };
    var e4 = this.internal.getFont(t6.fontName, t6.fontStyle);
    return e4.metadata.Unicode ? { widths: e4.metadata.Unicode.widths || { 0: 1 }, kerning: e4.metadata.Unicode.kerning || {} } : { font: e4.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, r3);
  n5 = Array.isArray(t5) ? t5 : String(t5).split(/\r?\n/);
  var o4 = 1 * this.internal.scaleFactor * e3 / i5;
  a4.textIndent = r3.textIndent ? 1 * r3.textIndent * this.internal.scaleFactor / i5 : 0, a4.lineIndent = r3.lineIndent;
  var s5, c5, u4 = [];
  for (s5 = 0, c5 = n5.length; s5 < c5; s5++)
    u4 = u4.concat(Xt.apply(this, [n5[s5], o4, a4]));
  return u4;
}, function(e3) {
  e3.__fontmetrics__ = e3.__fontmetrics__ || {};
  for (var r3 = "klmnopqrstuvwxyz", n5 = {}, i5 = {}, a4 = 0; a4 < r3.length; a4++)
    n5[r3[a4]] = "0123456789abcdef"[a4], i5["0123456789abcdef"[a4]] = r3[a4];
  var o4 = function(t5) {
    return "0x" + parseInt(t5, 10).toString(16);
  }, s5 = e3.__fontmetrics__.compress = function(e4) {
    var r4, n6, a5, c6, u5 = ["{"];
    for (var h5 in e4) {
      if (r4 = e4[h5], isNaN(parseInt(h5, 10)) ? n6 = "'" + h5 + "'" : (h5 = parseInt(h5, 10), n6 = (n6 = o4(h5).slice(2)).slice(0, -1) + i5[n6.slice(-1)]), "number" == typeof r4)
        r4 < 0 ? (a5 = o4(r4).slice(3), c6 = "-") : (a5 = o4(r4).slice(2), c6 = ""), a5 = c6 + a5.slice(0, -1) + i5[a5.slice(-1)];
      else {
        if ("object" !== _typeof(r4))
          throw new Error("Don't know what to do with value type " + _typeof(r4) + ".");
        a5 = s5(r4);
      }
      u5.push(n6 + a5);
    }
    return u5.push("}"), u5.join("");
  }, c5 = e3.__fontmetrics__.uncompress = function(t5) {
    if ("string" != typeof t5)
      throw new Error("Invalid argument passed to uncompress.");
    for (var e4, r4, i6, a5, o5 = {}, s6 = 1, c6 = o5, u5 = [], h5 = "", l5 = "", f5 = t5.length - 1, d3 = 1; d3 < f5; d3 += 1)
      "'" == (a5 = t5[d3]) ? e4 ? (i6 = e4.join(""), e4 = void 0) : e4 = [] : e4 ? e4.push(a5) : "{" == a5 ? (u5.push([c6, i6]), c6 = {}, i6 = void 0) : "}" == a5 ? ((r4 = u5.pop())[0][r4[1]] = c6, i6 = void 0, c6 = r4[0]) : "-" == a5 ? s6 = -1 : void 0 === i6 ? n5.hasOwnProperty(a5) ? (h5 += n5[a5], i6 = parseInt(h5, 16) * s6, s6 = 1, h5 = "") : h5 += a5 : n5.hasOwnProperty(a5) ? (l5 += n5[a5], c6[i6] = parseInt(l5, 16) * s6, s6 = 1, i6 = void 0, l5 = "") : l5 += a5;
    return o5;
  }, u4 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c5("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h4 = { Unicode: { Courier: u4, "Courier-Bold": u4, "Courier-BoldOblique": u4, "Courier-Oblique": u4, Helvetica: u4, "Helvetica-Bold": u4, "Helvetica-BoldOblique": u4, "Helvetica-Oblique": u4, "Times-Roman": u4, "Times-Bold": u4, "Times-BoldItalic": u4, "Times-Italic": u4 } }, l4 = { Unicode: { "Courier-Oblique": c5("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c5("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c5("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c5("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c5("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c5("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c5("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c5("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c5("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c5("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c5("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c5("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c5("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c5("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e3.events.push(["addFont", function(t5) {
    var e4 = t5.font, r4 = l4.Unicode[e4.postScriptName];
    r4 && (e4.metadata.Unicode = {}, e4.metadata.Unicode.widths = r4.widths, e4.metadata.Unicode.kerning = r4.kerning);
    var n6 = h4.Unicode[e4.postScriptName];
    n6 && (e4.metadata.Unicode.encoding = n6, e4.encoding = n6.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = function(t6) {
    for (var e4 = t6.length, r3 = new Uint8Array(e4), n5 = 0; n5 < e4; n5++)
      r3[n5] = t6.charCodeAt(n5);
    return r3;
  };
  t5.API.events.push(["addFont", function(r3) {
    var n5 = void 0, i5 = r3.font, a4 = r3.instance;
    if (!i5.isStandardFont) {
      if (void 0 === a4)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i5.postScriptName + "').");
      if ("string" != typeof (n5 = false === a4.existsFileInVFS(i5.postScriptName) ? a4.loadFile(i5.postScriptName) : a4.getFileFromVFS(i5.postScriptName)))
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i5.postScriptName + "').");
      !function(r4, n6) {
        n6 = /^\x00\x01\x00\x00/.test(n6) ? e3(n6) : e3(u3(n6)), r4.metadata = t5.API.TTFFont.open(n6), r4.metadata.Unicode = r4.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r4.metadata.glyIdsUsed = [0];
      }(i5, n5);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t5) {
  function e3() {
    return (n4.canvg ? Promise.resolve(n4.canvg) : Promise.resolve().then(() => (init_index_es(), index_es_exports))).catch(function(t6) {
      return Promise.reject(new Error("Could not load canvg: " + t6));
    }).then(function(t6) {
      return t6.default ? t6.default : t6;
    });
  }
  E.API.addSvgAsImage = function(t6, r3, n5, i5, o4, s5, c5, u4) {
    if (isNaN(r3) || isNaN(n5))
      throw a3.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i5) || isNaN(o4))
      throw a3.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h4 = document.createElement("canvas");
    h4.width = i5, h4.height = o4;
    var l4 = h4.getContext("2d");
    l4.fillStyle = "#fff", l4.fillRect(0, 0, h4.width, h4.height);
    var f5 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d3 = this;
    return e3().then(function(e4) {
      return e4.fromString(l4, t6, f5);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t7) {
      return t7.render(f5);
    }).then(function() {
      d3.addImage(h4.toDataURL("image/jpeg", 1), r3, n5, i5, o4, c5, u4);
    });
  };
}(), E.API.putTotalPages = function(t5) {
  var e3, r3 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e3 = new RegExp(t5, "g"), r3 = this.internal.getNumberOfPages()) : (e3 = new RegExp(this.pdfEscape16(t5, this.internal.getFont()), "g"), r3 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n5 = 1; n5 <= this.internal.getNumberOfPages(); n5++)
    for (var i5 = 0; i5 < this.internal.pages[n5].length; i5++)
      this.internal.pages[n5][i5] = this.internal.pages[n5][i5].replace(e3, r3);
  return this;
}, E.API.viewerPreferences = function(e3, r3) {
  var n5;
  e3 = e3 || {}, r3 = r3 || false;
  var i5, a4, o4, s5 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c5 = Object.keys(s5), u4 = [], h4 = 0, l4 = 0, f5 = 0;
  function d3(t5, e4) {
    var r4, n6 = false;
    for (r4 = 0; r4 < t5.length; r4 += 1)
      t5[r4] === e4 && (n6 = true);
    return n6;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s5)), this.internal.viewerpreferences.isSubscribed = false), n5 = this.internal.viewerpreferences.configuration, "reset" === e3 || true === r3) {
    var p7 = c5.length;
    for (f5 = 0; f5 < p7; f5 += 1)
      n5[c5[f5]].value = n5[c5[f5]].defaultValue, n5[c5[f5]].explicitSet = false;
  }
  if ("object" === _typeof(e3)) {
    for (a4 in e3)
      if (o4 = e3[a4], d3(c5, a4) && void 0 !== o4) {
        if ("boolean" === n5[a4].type && "boolean" == typeof o4)
          n5[a4].value = o4;
        else if ("name" === n5[a4].type && d3(n5[a4].valueSet, o4))
          n5[a4].value = o4;
        else if ("integer" === n5[a4].type && Number.isInteger(o4))
          n5[a4].value = o4;
        else if ("array" === n5[a4].type) {
          for (h4 = 0; h4 < o4.length; h4 += 1)
            if (i5 = true, 1 === o4[h4].length && "number" == typeof o4[h4][0])
              u4.push(String(o4[h4] - 1));
            else if (o4[h4].length > 1) {
              for (l4 = 0; l4 < o4[h4].length; l4 += 1)
                "number" != typeof o4[h4][l4] && (i5 = false);
              true === i5 && u4.push([o4[h4][0] - 1, o4[h4][1] - 1].join(" "));
            }
          n5[a4].value = "[" + u4.join(" ") + "]";
        } else
          n5[a4].value = n5[a4].defaultValue;
        n5[a4].explicitSet = true;
      }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t5, e4 = [];
    for (t5 in n5)
      true === n5[t5].explicitSet && ("name" === n5[t5].type ? e4.push("/" + t5 + " /" + n5[t5].value) : e4.push("/" + t5 + " " + n5[t5].value));
    0 !== e4.length && this.internal.write("/ViewerPreferences\n<<\n" + e4.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n5, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t5) {
  var e3 = function() {
    var t6 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e4 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r4 = unescape(encodeURIComponent(t6)), n5 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i5 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a4 = unescape(encodeURIComponent("</x:xmpmeta>")), o4 = r4.length + n5.length + i5.length + e4.length + a4.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o4 + " >>"), this.internal.write("stream"), this.internal.write(e4 + r4 + n5 + i5 + a4), this.internal.write("endstream"), this.internal.write("endobj");
  }, r3 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t5.addMetadata = function(t6, n5) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t6, namespaceuri: n5 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r3), this.internal.events.subscribe("postPutResources", e3)), this;
  };
}(E.API), function(t5) {
  var e3 = t5.API, r3 = e3.pdfEscape16 = function(t6, e4) {
    for (var r4, n6 = e4.metadata.Unicode.widths, i6 = ["", "0", "00", "000", "0000"], a4 = [""], o4 = 0, s5 = t6.length; o4 < s5; ++o4) {
      if (r4 = e4.metadata.characterToGlyph(t6.charCodeAt(o4)), e4.metadata.glyIdsUsed.push(r4), e4.metadata.toUnicode[r4] = t6.charCodeAt(o4), -1 == n6.indexOf(r4) && (n6.push(r4), n6.push([parseInt(e4.metadata.widthOfGlyph(r4), 10)])), "0" == r4)
        return a4.join("");
      r4 = r4.toString(16), a4.push(i6[4 - r4.length], r4);
    }
    return a4.join("");
  }, n5 = function(t6) {
    var e4, r4, n6, i6, a4, o4, s5;
    for (a4 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n6 = [], o4 = 0, s5 = (r4 = Object.keys(t6).sort(function(t7, e5) {
      return t7 - e5;
    })).length; o4 < s5; o4++)
      e4 = r4[o4], n6.length >= 100 && (a4 += "\n" + n6.length + " beginbfchar\n" + n6.join("\n") + "\nendbfchar", n6 = []), void 0 !== t6[e4] && null !== t6[e4] && "function" == typeof t6[e4].toString && (i6 = ("0000" + t6[e4].toString(16)).slice(-4), e4 = ("0000" + (+e4).toString(16)).slice(-4), n6.push("<" + e4 + "><" + i6 + ">"));
    return n6.length && (a4 += "\n" + n6.length + " beginbfchar\n" + n6.join("\n") + "\nendbfchar\n"), a4 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e3.events.push(["putFont", function(e4) {
    !function(e5) {
      var r4 = e5.font, i6 = e5.out, a4 = e5.newObject, o4 = e5.putStream;
      if (r4.metadata instanceof t5.API.TTFFont && "Identity-H" === r4.encoding) {
        for (var s5 = r4.metadata.Unicode.widths, c5 = r4.metadata.subset.encode(r4.metadata.glyIdsUsed, 1), u4 = "", h4 = 0; h4 < c5.length; h4++)
          u4 += String.fromCharCode(c5[h4]);
        var l4 = a4();
        o4({ data: u4, addLength1: true, objectId: l4 }), i6("endobj");
        var f5 = a4();
        o4({ data: n5(r4.metadata.toUnicode), addLength1: true, objectId: f5 }), i6("endobj");
        var d3 = a4();
        i6("<<"), i6("/Type /FontDescriptor"), i6("/FontName /" + F(r4.fontName)), i6("/FontFile2 " + l4 + " 0 R"), i6("/FontBBox " + t5.API.PDFObject.convert(r4.metadata.bbox)), i6("/Flags " + r4.metadata.flags), i6("/StemV " + r4.metadata.stemV), i6("/ItalicAngle " + r4.metadata.italicAngle), i6("/Ascent " + r4.metadata.ascender), i6("/Descent " + r4.metadata.decender), i6("/CapHeight " + r4.metadata.capHeight), i6(">>"), i6("endobj");
        var p7 = a4();
        i6("<<"), i6("/Type /Font"), i6("/BaseFont /" + F(r4.fontName)), i6("/FontDescriptor " + d3 + " 0 R"), i6("/W " + t5.API.PDFObject.convert(s5)), i6("/CIDToGIDMap /Identity"), i6("/DW 1000"), i6("/Subtype /CIDFontType2"), i6("/CIDSystemInfo"), i6("<<"), i6("/Supplement 0"), i6("/Registry (Adobe)"), i6("/Ordering (" + r4.encoding + ")"), i6(">>"), i6(">>"), i6("endobj"), r4.objectNumber = a4(), i6("<<"), i6("/Type /Font"), i6("/Subtype /Type0"), i6("/ToUnicode " + f5 + " 0 R"), i6("/BaseFont /" + F(r4.fontName)), i6("/Encoding /" + r4.encoding), i6("/DescendantFonts [" + p7 + " 0 R]"), i6(">>"), i6("endobj"), r4.isAlreadyPutted = true;
      }
    }(e4);
  }]);
  e3.events.push(["putFont", function(e4) {
    !function(e5) {
      var r4 = e5.font, i6 = e5.out, a4 = e5.newObject, o4 = e5.putStream;
      if (r4.metadata instanceof t5.API.TTFFont && "WinAnsiEncoding" === r4.encoding) {
        for (var s5 = r4.metadata.rawData, c5 = "", u4 = 0; u4 < s5.length; u4++)
          c5 += String.fromCharCode(s5[u4]);
        var h4 = a4();
        o4({ data: c5, addLength1: true, objectId: h4 }), i6("endobj");
        var l4 = a4();
        o4({ data: n5(r4.metadata.toUnicode), addLength1: true, objectId: l4 }), i6("endobj");
        var f5 = a4();
        i6("<<"), i6("/Descent " + r4.metadata.decender), i6("/CapHeight " + r4.metadata.capHeight), i6("/StemV " + r4.metadata.stemV), i6("/Type /FontDescriptor"), i6("/FontFile2 " + h4 + " 0 R"), i6("/Flags 96"), i6("/FontBBox " + t5.API.PDFObject.convert(r4.metadata.bbox)), i6("/FontName /" + F(r4.fontName)), i6("/ItalicAngle " + r4.metadata.italicAngle), i6("/Ascent " + r4.metadata.ascender), i6(">>"), i6("endobj"), r4.objectNumber = a4();
        for (var d3 = 0; d3 < r4.metadata.hmtx.widths.length; d3++)
          r4.metadata.hmtx.widths[d3] = parseInt(r4.metadata.hmtx.widths[d3] * (1e3 / r4.metadata.head.unitsPerEm));
        i6("<</Subtype/TrueType/Type/Font/ToUnicode " + l4 + " 0 R/BaseFont/" + F(r4.fontName) + "/FontDescriptor " + f5 + " 0 R/Encoding/" + r4.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t5.API.PDFObject.convert(r4.metadata.hmtx.widths) + ">>"), i6("endobj"), r4.isAlreadyPutted = true;
      }
    }(e4);
  }]);
  var i5 = function(t6) {
    var e4, n6 = t6.text || "", i6 = t6.x, a4 = t6.y, o4 = t6.options || {}, s5 = t6.mutex || {}, c5 = s5.pdfEscape, u4 = s5.activeFontKey, h4 = s5.fonts, l4 = u4, f5 = "", d3 = 0, p7 = "", g5 = h4[l4].encoding;
    if ("Identity-H" !== h4[l4].encoding)
      return { text: n6, x: i6, y: a4, options: o4, mutex: s5 };
    for (p7 = n6, l4 = u4, Array.isArray(n6) && (p7 = n6[0]), d3 = 0; d3 < p7.length; d3 += 1)
      h4[l4].metadata.hasOwnProperty("cmap") && (e4 = h4[l4].metadata.cmap.unicode.codeMap[p7[d3].charCodeAt(0)]), e4 || p7[d3].charCodeAt(0) < 256 && h4[l4].metadata.hasOwnProperty("Unicode") ? f5 += p7[d3] : f5 += "";
    var m6 = "";
    return parseInt(l4.slice(1)) < 14 || "WinAnsiEncoding" === g5 ? m6 = c5(f5, l4).split("").map(function(t7) {
      return t7.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g5 && (m6 = r3(f5, h4[l4])), s5.isHex = true, { text: m6, x: i6, y: a4, options: o4, mutex: s5 };
  };
  e3.events.push(["postProcessText", function(t6) {
    var e4 = t6.text || "", r4 = [], n6 = { text: e4, x: t6.x, y: t6.y, options: t6.options, mutex: t6.mutex };
    if (Array.isArray(e4)) {
      var a4 = 0;
      for (a4 = 0; a4 < e4.length; a4 += 1)
        Array.isArray(e4[a4]) && 3 === e4[a4].length ? r4.push([i5(Object.assign({}, n6, { text: e4[a4][0] })).text, e4[a4][1], e4[a4][2]]) : r4.push(i5(Object.assign({}, n6, { text: e4[a4] })).text);
      t6.text = r4;
    } else
      t6.text = i5(Object.assign({}, n6, { text: e4 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t5) {
  var e3 = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t5.existsFileInVFS = function(t6) {
    return e3.call(this), void 0 !== this.internal.vFS[t6];
  }, t5.addFileToVFS = function(t6, r3) {
    return e3.call(this), this.internal.vFS[t6] = r3, this;
  }, t5.getFileFromVFS = function(t6) {
    return e3.call(this), void 0 !== this.internal.vFS[t6] ? this.internal.vFS[t6] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t5) {
  t5.__bidiEngine__ = t5.prototype.__bidiEngine__ = function(t6) {
    var r4, n5, i5, a4, o4, s5, c5, u4 = e3, h4 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l4 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f5 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d3 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p7 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g5 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m6 = false, v4 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t7) {
      var e4 = t7.charCodeAt(), r5 = e4 >> 8, n6 = d3[r5];
      return void 0 !== n6 ? u4[256 * n6 + (255 & e4)] : 252 === r5 || 253 === r5 ? "AL" : g5.test(r5) ? "L" : 8 === r5 ? "R" : "N";
    }, y3 = function(t7) {
      for (var e4, r5 = 0; r5 < t7.length; r5++) {
        if ("L" === (e4 = b2(t7.charAt(r5))))
          return false;
        if ("R" === e4)
          return true;
      }
      return false;
    }, w2 = function(t7, e4, o5, s6) {
      var c6, u5, h5, l5, f6 = e4[s6];
      switch (f6) {
        case "L":
        case "R":
          m6 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m6 && (f6 = "AN");
          break;
        case "AL":
          m6 = true, f6 = "R";
          break;
        case "WS":
          f6 = "N";
          break;
        case "CS":
          s6 < 1 || s6 + 1 >= e4.length || "EN" !== (c6 = o5[s6 - 1]) && "AN" !== c6 || "EN" !== (u5 = e4[s6 + 1]) && "AN" !== u5 ? f6 = "N" : m6 && (u5 = "AN"), f6 = u5 === c6 ? u5 : "N";
          break;
        case "ES":
          f6 = "EN" === (c6 = s6 > 0 ? o5[s6 - 1] : "B") && s6 + 1 < e4.length && "EN" === e4[s6 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s6 > 0 && "EN" === o5[s6 - 1]) {
            f6 = "EN";
            break;
          }
          if (m6) {
            f6 = "N";
            break;
          }
          for (h5 = s6 + 1, l5 = e4.length; h5 < l5 && "ET" === e4[h5]; )
            h5++;
          f6 = h5 < l5 && "EN" === e4[h5] ? "EN" : "N";
          break;
        case "NSM":
          if (i5 && !a4) {
            for (l5 = e4.length, h5 = s6 + 1; h5 < l5 && "NSM" === e4[h5]; )
              h5++;
            if (h5 < l5) {
              var d4 = t7[s6], p8 = d4 >= 1425 && d4 <= 2303 || 64286 === d4;
              if (c6 = e4[h5], p8 && ("R" === c6 || "AL" === c6)) {
                f6 = "R";
                break;
              }
            }
          }
          f6 = s6 < 1 || "B" === (c6 = e4[s6 - 1]) ? "N" : o5[s6 - 1];
          break;
        case "B":
          m6 = false, r4 = true, f6 = v4;
          break;
        case "S":
          n5 = true, f6 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m6 = false;
          break;
        case "BN":
          f6 = "N";
      }
      return f6;
    }, N3 = function(t7, e4, r5) {
      var n6 = t7.split("");
      return r5 && L2(n6, r5, { hiLevel: v4 }), n6.reverse(), e4 && e4.reverse(), n6.join("");
    }, L2 = function(t7, e4, i6) {
      var a5, o5, s6, c6, u5, d4 = -1, p8 = t7.length, g6 = 0, y4 = [], N4 = v4 ? l4 : h4, L3 = [];
      for (m6 = false, r4 = false, n5 = false, o5 = 0; o5 < p8; o5++)
        L3[o5] = b2(t7[o5]);
      for (s6 = 0; s6 < p8; s6++) {
        if (u5 = g6, y4[s6] = w2(t7, L3, y4, s6), a5 = 240 & (g6 = N4[u5][f5[y4[s6]]]), g6 &= 15, e4[s6] = c6 = N4[g6][5], a5 > 0)
          if (16 === a5) {
            for (o5 = d4; o5 < s6; o5++)
              e4[o5] = 1;
            d4 = -1;
          } else
            d4 = -1;
        if (N4[g6][6])
          -1 === d4 && (d4 = s6);
        else if (d4 > -1) {
          for (o5 = d4; o5 < s6; o5++)
            e4[o5] = c6;
          d4 = -1;
        }
        "B" === L3[s6] && (e4[s6] = 0), i6.hiLevel |= c6;
      }
      n5 && function(t8, e5, r5) {
        for (var n6 = 0; n6 < r5; n6++)
          if ("S" === t8[n6]) {
            e5[n6] = v4;
            for (var i7 = n6 - 1; i7 >= 0 && "WS" === t8[i7]; i7--)
              e5[i7] = v4;
          }
      }(L3, e4, p8);
    }, A2 = function(t7, e4, n6, i6, a5) {
      if (!(a5.hiLevel < t7)) {
        if (1 === t7 && 1 === v4 && !r4)
          return e4.reverse(), void (n6 && n6.reverse());
        for (var o5, s6, c6, u5, h5 = e4.length, l5 = 0; l5 < h5; ) {
          if (i6[l5] >= t7) {
            for (c6 = l5 + 1; c6 < h5 && i6[c6] >= t7; )
              c6++;
            for (u5 = l5, s6 = c6 - 1; u5 < s6; u5++, s6--)
              o5 = e4[u5], e4[u5] = e4[s6], e4[s6] = o5, n6 && (o5 = n6[u5], n6[u5] = n6[s6], n6[s6] = o5);
            l5 = c6;
          }
          l5++;
        }
      }
    }, x2 = function(t7, e4, r5) {
      var n6 = t7.split(""), i6 = { hiLevel: v4 };
      return r5 || (r5 = []), L2(n6, r5, i6), function(t8, e5, r6) {
        if (0 !== r6.hiLevel && c5)
          for (var n7, i7 = 0; i7 < t8.length; i7++)
            1 === e5[i7] && (n7 = p7.indexOf(t8[i7])) >= 0 && (t8[i7] = p7[n7 + 1]);
      }(n6, r5, i6), A2(2, n6, e4, r5, i6), A2(1, n6, e4, r5, i6), n6.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t7, e4, r5) {
      if (function(t8, e5) {
        if (e5)
          for (var r6 = 0; r6 < t8.length; r6++)
            e5[r6] = r6;
        void 0 === a4 && (a4 = y3(t8)), void 0 === s5 && (s5 = y3(t8));
      }(t7, e4), i5 || !o4 || s5)
        if (i5 && o4 && a4 ^ s5)
          v4 = a4 ? 1 : 0, t7 = N3(t7, e4, r5);
        else if (!i5 && o4 && s5)
          v4 = a4 ? 1 : 0, t7 = x2(t7, e4, r5), t7 = N3(t7, e4);
        else if (!i5 || a4 || o4 || s5) {
          if (i5 && !o4 && a4 ^ s5)
            t7 = N3(t7, e4), a4 ? (v4 = 0, t7 = x2(t7, e4, r5)) : (v4 = 1, t7 = x2(t7, e4, r5), t7 = N3(t7, e4));
          else if (i5 && a4 && !o4 && s5)
            v4 = 1, t7 = x2(t7, e4, r5), t7 = N3(t7, e4);
          else if (!i5 && !o4 && a4 ^ s5) {
            var n6 = c5;
            a4 ? (v4 = 1, t7 = x2(t7, e4, r5), v4 = 0, c5 = false, t7 = x2(t7, e4, r5), c5 = n6) : (v4 = 0, t7 = x2(t7, e4, r5), t7 = N3(t7, e4), v4 = 1, c5 = false, t7 = x2(t7, e4, r5), c5 = n6, t7 = N3(t7, e4));
          }
        } else
          v4 = 0, t7 = x2(t7, e4, r5);
      else
        v4 = a4 ? 1 : 0, t7 = x2(t7, e4, r5);
      return t7;
    }, this.__bidiEngine__.setOptions = function(t7) {
      t7 && (i5 = t7.isInputVisual, o4 = t7.isOutputVisual, a4 = t7.isInputRtl, s5 = t7.isOutputRtl, c5 = t7.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t6), this.__bidiEngine__;
  };
  var e3 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r3 = new t5.__bidiEngine__({ isInputVisual: true });
  t5.API.events.push(["postProcessText", function(t6) {
    var e4 = t6.text, n5 = (t6.x, t6.y, t6.options || {}), i5 = (t6.mutex, n5.lang, []);
    if (n5.isInputVisual = "boolean" != typeof n5.isInputVisual || n5.isInputVisual, r3.setOptions(n5), "[object Array]" === Object.prototype.toString.call(e4)) {
      var a4 = 0;
      for (i5 = [], a4 = 0; a4 < e4.length; a4 += 1)
        "[object Array]" === Object.prototype.toString.call(e4[a4]) ? i5.push([r3.doBidiReorder(e4[a4][0]), e4[a4][1], e4[a4][2]]) : i5.push([r3.doBidiReorder(e4[a4])]);
      t6.text = i5;
    } else
      t6.text = r3.doBidiReorder(e4);
    r3.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t5(t6) {
    var e3;
    if (this.rawData = t6, e3 = this.contents = new ne(t6), this.contents.pos = 4, "ttcf" === e3.readString(4))
      throw new Error("TTCF not supported.");
    e3.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t5.open = function(e3) {
    return new t5(e3);
  }, t5.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t5.prototype.registerTTF = function() {
    var t6, e3, r3, n5, i5;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var e4, r4, n6, i6;
      for (i6 = [], e4 = 0, r4 = (n6 = this.bbox).length; e4 < r4; e4++)
        t6 = n6[e4], i6.push(Math.round(t6 * this.scaleFactor));
      return i6;
    }.call(this), this.stemV = 0, this.post.exists ? (r3 = 255 & (n5 = this.post.italic_angle), 0 != (32768 & (e3 = n5 >> 16)) && (e3 = -(1 + (65535 ^ e3))), this.italicAngle = +(e3 + "." + r3)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i5 = this.familyClass) || 2 === i5 || 3 === i5 || 4 === i5 || 5 === i5 || 7 === i5, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t5.prototype.characterToGlyph = function(t6) {
    var e3;
    return (null != (e3 = this.cmap.unicode) ? e3.codeMap[t6] : void 0) || 0;
  }, t5.prototype.widthOfGlyph = function(t6) {
    var e3;
    return e3 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t6).advance * e3;
  }, t5.prototype.widthOfString = function(t6, e3, r3) {
    var n5, i5, a4, o4;
    for (a4 = 0, i5 = 0, o4 = (t6 = "" + t6).length; 0 <= o4 ? i5 < o4 : i5 > o4; i5 = 0 <= o4 ? ++i5 : --i5)
      n5 = t6.charCodeAt(i5), a4 += this.widthOfGlyph(this.characterToGlyph(n5)) + r3 * (1e3 / e3) || 0;
    return a4 * (e3 / 1e3);
  }, t5.prototype.lineHeight = function(t6, e3) {
    var r3;
    return null == e3 && (e3 = false), r3 = e3 ? this.lineGap : 0, (this.ascender + r3 - this.decender) / 1e3 * t6;
  }, t5;
}();
var re;
var ne = function() {
  function t5(t6) {
    this.data = null != t6 ? t6 : [], this.pos = 0, this.length = this.data.length;
  }
  return t5.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t5.prototype.writeByte = function(t6) {
    return this.data[this.pos++] = t6;
  }, t5.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t5.prototype.writeUInt32 = function(t6) {
    return this.writeByte(t6 >>> 24 & 255), this.writeByte(t6 >> 16 & 255), this.writeByte(t6 >> 8 & 255), this.writeByte(255 & t6);
  }, t5.prototype.readInt32 = function() {
    var t6;
    return (t6 = this.readUInt32()) >= 2147483648 ? t6 - 4294967296 : t6;
  }, t5.prototype.writeInt32 = function(t6) {
    return t6 < 0 && (t6 += 4294967296), this.writeUInt32(t6);
  }, t5.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t5.prototype.writeUInt16 = function(t6) {
    return this.writeByte(t6 >> 8 & 255), this.writeByte(255 & t6);
  }, t5.prototype.readInt16 = function() {
    var t6;
    return (t6 = this.readUInt16()) >= 32768 ? t6 - 65536 : t6;
  }, t5.prototype.writeInt16 = function(t6) {
    return t6 < 0 && (t6 += 65536), this.writeUInt16(t6);
  }, t5.prototype.readString = function(t6) {
    var e3, r3;
    for (r3 = [], e3 = 0; 0 <= t6 ? e3 < t6 : e3 > t6; e3 = 0 <= t6 ? ++e3 : --e3)
      r3[e3] = String.fromCharCode(this.readByte());
    return r3.join("");
  }, t5.prototype.writeString = function(t6) {
    var e3, r3, n5;
    for (n5 = [], e3 = 0, r3 = t6.length; 0 <= r3 ? e3 < r3 : e3 > r3; e3 = 0 <= r3 ? ++e3 : --e3)
      n5.push(this.writeByte(t6.charCodeAt(e3)));
    return n5;
  }, t5.prototype.readShort = function() {
    return this.readInt16();
  }, t5.prototype.writeShort = function(t6) {
    return this.writeInt16(t6);
  }, t5.prototype.readLongLong = function() {
    var t6, e3, r3, n5, i5, a4, o4, s5;
    return t6 = this.readByte(), e3 = this.readByte(), r3 = this.readByte(), n5 = this.readByte(), i5 = this.readByte(), a4 = this.readByte(), o4 = this.readByte(), s5 = this.readByte(), 128 & t6 ? -1 * (72057594037927940 * (255 ^ t6) + 281474976710656 * (255 ^ e3) + 1099511627776 * (255 ^ r3) + 4294967296 * (255 ^ n5) + 16777216 * (255 ^ i5) + 65536 * (255 ^ a4) + 256 * (255 ^ o4) + (255 ^ s5) + 1) : 72057594037927940 * t6 + 281474976710656 * e3 + 1099511627776 * r3 + 4294967296 * n5 + 16777216 * i5 + 65536 * a4 + 256 * o4 + s5;
  }, t5.prototype.writeLongLong = function(t6) {
    var e3, r3;
    return e3 = Math.floor(t6 / 4294967296), r3 = 4294967295 & t6, this.writeByte(e3 >> 24 & 255), this.writeByte(e3 >> 16 & 255), this.writeByte(e3 >> 8 & 255), this.writeByte(255 & e3), this.writeByte(r3 >> 24 & 255), this.writeByte(r3 >> 16 & 255), this.writeByte(r3 >> 8 & 255), this.writeByte(255 & r3);
  }, t5.prototype.readInt = function() {
    return this.readInt32();
  }, t5.prototype.writeInt = function(t6) {
    return this.writeInt32(t6);
  }, t5.prototype.read = function(t6) {
    var e3, r3;
    for (e3 = [], r3 = 0; 0 <= t6 ? r3 < t6 : r3 > t6; r3 = 0 <= t6 ? ++r3 : --r3)
      e3.push(this.readByte());
    return e3;
  }, t5.prototype.write = function(t6) {
    var e3, r3, n5, i5;
    for (i5 = [], r3 = 0, n5 = t6.length; r3 < n5; r3++)
      e3 = t6[r3], i5.push(this.writeByte(e3));
    return i5;
  }, t5;
}();
var ie = function() {
  var t5;
  function e3(t6) {
    var e4, r3, n5;
    for (this.scalarType = t6.readInt(), this.tableCount = t6.readShort(), this.searchRange = t6.readShort(), this.entrySelector = t6.readShort(), this.rangeShift = t6.readShort(), this.tables = {}, r3 = 0, n5 = this.tableCount; 0 <= n5 ? r3 < n5 : r3 > n5; r3 = 0 <= n5 ? ++r3 : --r3)
      e4 = { tag: t6.readString(4), checksum: t6.readInt(), offset: t6.readInt(), length: t6.readInt() }, this.tables[e4.tag] = e4;
  }
  return e3.prototype.encode = function(e4) {
    var r3, n5, i5, a4, o4, s5, c5, u4, h4, l4, f5, d3, p7;
    for (p7 in f5 = Object.keys(e4).length, s5 = Math.log(2), h4 = 16 * Math.floor(Math.log(f5) / s5), a4 = Math.floor(h4 / s5), u4 = 16 * f5 - h4, (n5 = new ne()).writeInt(this.scalarType), n5.writeShort(f5), n5.writeShort(h4), n5.writeShort(a4), n5.writeShort(u4), i5 = 16 * f5, c5 = n5.pos + i5, o4 = null, d3 = [], e4)
      for (l4 = e4[p7], n5.writeString(p7), n5.writeInt(t5(l4)), n5.writeInt(c5), n5.writeInt(l4.length), d3 = d3.concat(l4), "head" === p7 && (o4 = c5), c5 += l4.length; c5 % 4; )
        d3.push(0), c5++;
    return n5.write(d3), r3 = 2981146554 - t5(n5.data), n5.pos = o4 + 8, n5.writeUInt32(r3), n5.data;
  }, t5 = function(t6) {
    var e4, r3, n5, i5;
    for (t6 = ve.call(t6); t6.length % 4; )
      t6.push(0);
    for (n5 = new ne(t6), r3 = 0, e4 = 0, i5 = t6.length; e4 < i5; e4 = e4 += 4)
      r3 += n5.readUInt32();
    return 4294967295 & r3;
  }, e3;
}();
var ae = {}.hasOwnProperty;
var oe = function(t5, e3) {
  for (var r3 in e3)
    ae.call(e3, r3) && (t5[r3] = e3[r3]);
  function n5() {
    this.constructor = t5;
  }
  return n5.prototype = e3.prototype, t5.prototype = new n5(), t5.__super__ = e3.prototype, t5;
};
re = function() {
  function t5(t6) {
    var e3;
    this.file = t6, e3 = this.file.directory.tables[this.tag], this.exists = !!e3, e3 && (this.offset = e3.offset, this.length = e3.length, this.parse(this.file.contents));
  }
  return t5.prototype.parse = function() {
  }, t5.prototype.encode = function() {
  }, t5.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t5;
}();
var se = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "head", e3.prototype.parse = function(t6) {
    return t6.pos = this.offset, this.version = t6.readInt(), this.revision = t6.readInt(), this.checkSumAdjustment = t6.readInt(), this.magicNumber = t6.readInt(), this.flags = t6.readShort(), this.unitsPerEm = t6.readShort(), this.created = t6.readLongLong(), this.modified = t6.readLongLong(), this.xMin = t6.readShort(), this.yMin = t6.readShort(), this.xMax = t6.readShort(), this.yMax = t6.readShort(), this.macStyle = t6.readShort(), this.lowestRecPPEM = t6.readShort(), this.fontDirectionHint = t6.readShort(), this.indexToLocFormat = t6.readShort(), this.glyphDataFormat = t6.readShort();
  }, e3.prototype.encode = function(t6) {
    var e4;
    return (e4 = new ne()).writeInt(this.version), e4.writeInt(this.revision), e4.writeInt(this.checkSumAdjustment), e4.writeInt(this.magicNumber), e4.writeShort(this.flags), e4.writeShort(this.unitsPerEm), e4.writeLongLong(this.created), e4.writeLongLong(this.modified), e4.writeShort(this.xMin), e4.writeShort(this.yMin), e4.writeShort(this.xMax), e4.writeShort(this.yMax), e4.writeShort(this.macStyle), e4.writeShort(this.lowestRecPPEM), e4.writeShort(this.fontDirectionHint), e4.writeShort(t6), e4.writeShort(this.glyphDataFormat), e4.data;
  }, e3;
}();
var ce = function() {
  function t5(t6, e3) {
    var r3, n5, i5, a4, o4, s5, c5, u4, h4, l4, f5, d3, p7, g5, m6, v4, b2;
    switch (this.platformID = t6.readUInt16(), this.encodingID = t6.readShort(), this.offset = e3 + t6.readInt(), h4 = t6.pos, t6.pos = this.offset, this.format = t6.readUInt16(), this.length = t6.readUInt16(), this.language = t6.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s5 = 0; s5 < 256; ++s5)
          this.codeMap[s5] = t6.readByte();
        break;
      case 4:
        for (f5 = t6.readUInt16(), l4 = f5 / 2, t6.pos += 6, i5 = function() {
          var e4, r4;
          for (r4 = [], s5 = e4 = 0; 0 <= l4 ? e4 < l4 : e4 > l4; s5 = 0 <= l4 ? ++e4 : --e4)
            r4.push(t6.readUInt16());
          return r4;
        }(), t6.pos += 2, p7 = function() {
          var e4, r4;
          for (r4 = [], s5 = e4 = 0; 0 <= l4 ? e4 < l4 : e4 > l4; s5 = 0 <= l4 ? ++e4 : --e4)
            r4.push(t6.readUInt16());
          return r4;
        }(), c5 = function() {
          var e4, r4;
          for (r4 = [], s5 = e4 = 0; 0 <= l4 ? e4 < l4 : e4 > l4; s5 = 0 <= l4 ? ++e4 : --e4)
            r4.push(t6.readUInt16());
          return r4;
        }(), u4 = function() {
          var e4, r4;
          for (r4 = [], s5 = e4 = 0; 0 <= l4 ? e4 < l4 : e4 > l4; s5 = 0 <= l4 ? ++e4 : --e4)
            r4.push(t6.readUInt16());
          return r4;
        }(), n5 = (this.length - t6.pos + this.offset) / 2, o4 = function() {
          var e4, r4;
          for (r4 = [], s5 = e4 = 0; 0 <= n5 ? e4 < n5 : e4 > n5; s5 = 0 <= n5 ? ++e4 : --e4)
            r4.push(t6.readUInt16());
          return r4;
        }(), s5 = m6 = 0, b2 = i5.length; m6 < b2; s5 = ++m6)
          for (g5 = i5[s5], r3 = v4 = d3 = p7[s5]; d3 <= g5 ? v4 <= g5 : v4 >= g5; r3 = d3 <= g5 ? ++v4 : --v4)
            0 === u4[s5] ? a4 = r3 + c5[s5] : 0 !== (a4 = o4[u4[s5] / 2 + (r3 - d3) - (l4 - s5)] || 0) && (a4 += c5[s5]), this.codeMap[r3] = 65535 & a4;
    }
    t6.pos = h4;
  }
  return t5.encode = function(t6, e3) {
    var r3, n5, i5, a4, o4, s5, c5, u4, h4, l4, f5, d3, p7, g5, m6, v4, b2, y3, w2, N3, L2, A2, x2, S2, _4, P2, k3, I2, F2, C2, j3, O3, B2, M2, E2, q2, D2, R2, T3, U2, z2, H2, W2, V2, G2, Y2;
    switch (I2 = new ne(), a4 = Object.keys(t6).sort(function(t7, e4) {
      return t7 - e4;
    }), e3) {
      case "macroman":
        for (p7 = 0, g5 = function() {
          var t7 = [];
          for (d3 = 0; d3 < 256; ++d3)
            t7.push(0);
          return t7;
        }(), v4 = { 0: 0 }, i5 = {}, F2 = 0, B2 = a4.length; F2 < B2; F2++)
          null == v4[W2 = t6[n5 = a4[F2]]] && (v4[W2] = ++p7), i5[n5] = { old: t6[n5], new: v4[t6[n5]] }, g5[n5] = v4[t6[n5]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g5), { charMap: i5, subtable: I2.data, maxGlyphID: p7 + 1 };
      case "unicode":
        for (P2 = [], h4 = [], b2 = 0, v4 = {}, r3 = {}, m6 = c5 = null, C2 = 0, M2 = a4.length; C2 < M2; C2++)
          null == v4[w2 = t6[n5 = a4[C2]]] && (v4[w2] = ++b2), r3[n5] = { old: w2, new: v4[w2] }, o4 = v4[w2] - n5, null != m6 && o4 === c5 || (m6 && h4.push(m6), P2.push(n5), c5 = o4), m6 = n5;
        for (m6 && h4.push(m6), h4.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l4 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s5 = [], N3 = [], f5 = [], d3 = j3 = 0, E2 = P2.length; j3 < E2; d3 = ++j3) {
          if (_4 = P2[d3], u4 = h4[d3], 65535 === _4) {
            s5.push(0), N3.push(0);
            break;
          }
          if (_4 - (k3 = r3[_4].new) >= 32768)
            for (s5.push(0), N3.push(2 * (f5.length + x2 - d3)), n5 = O3 = _4; _4 <= u4 ? O3 <= u4 : O3 >= u4; n5 = _4 <= u4 ? ++O3 : --O3)
              f5.push(r3[n5].new);
          else
            s5.push(k3 - _4), N3.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f5.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l4), I2.writeUInt16(L2), z2 = 0, q2 = h4.length; z2 < q2; z2++)
          n5 = h4[z2], I2.writeUInt16(n5);
        for (I2.writeUInt16(0), H2 = 0, D2 = P2.length; H2 < D2; H2++)
          n5 = P2[H2], I2.writeUInt16(n5);
        for (V2 = 0, R2 = s5.length; V2 < R2; V2++)
          o4 = s5[V2], I2.writeUInt16(o4);
        for (G2 = 0, T3 = N3.length; G2 < T3; G2++)
          y3 = N3[G2], I2.writeUInt16(y3);
        for (Y2 = 0, U2 = f5.length; Y2 < U2; Y2++)
          p7 = f5[Y2], I2.writeUInt16(p7);
        return { charMap: r3, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t5;
}();
var ue = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "cmap", e3.prototype.parse = function(t6) {
    var e4, r3, n5;
    for (t6.pos = this.offset, this.version = t6.readUInt16(), n5 = t6.readUInt16(), this.tables = [], this.unicode = null, r3 = 0; 0 <= n5 ? r3 < n5 : r3 > n5; r3 = 0 <= n5 ? ++r3 : --r3)
      e4 = new ce(t6, this.offset), this.tables.push(e4), e4.isUnicode && null == this.unicode && (this.unicode = e4);
    return true;
  }, e3.encode = function(t6, e4) {
    var r3, n5;
    return null == e4 && (e4 = "macroman"), r3 = ce.encode(t6, e4), (n5 = new ne()).writeUInt16(0), n5.writeUInt16(1), r3.table = n5.data.concat(r3.subtable), r3;
  }, e3;
}();
var he = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "hhea", e3.prototype.parse = function(t6) {
    return t6.pos = this.offset, this.version = t6.readInt(), this.ascender = t6.readShort(), this.decender = t6.readShort(), this.lineGap = t6.readShort(), this.advanceWidthMax = t6.readShort(), this.minLeftSideBearing = t6.readShort(), this.minRightSideBearing = t6.readShort(), this.xMaxExtent = t6.readShort(), this.caretSlopeRise = t6.readShort(), this.caretSlopeRun = t6.readShort(), this.caretOffset = t6.readShort(), t6.pos += 8, this.metricDataFormat = t6.readShort(), this.numberOfMetrics = t6.readUInt16();
  }, e3;
}();
var le = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "OS/2", e3.prototype.parse = function(t6) {
    if (t6.pos = this.offset, this.version = t6.readUInt16(), this.averageCharWidth = t6.readShort(), this.weightClass = t6.readUInt16(), this.widthClass = t6.readUInt16(), this.type = t6.readShort(), this.ySubscriptXSize = t6.readShort(), this.ySubscriptYSize = t6.readShort(), this.ySubscriptXOffset = t6.readShort(), this.ySubscriptYOffset = t6.readShort(), this.ySuperscriptXSize = t6.readShort(), this.ySuperscriptYSize = t6.readShort(), this.ySuperscriptXOffset = t6.readShort(), this.ySuperscriptYOffset = t6.readShort(), this.yStrikeoutSize = t6.readShort(), this.yStrikeoutPosition = t6.readShort(), this.familyClass = t6.readShort(), this.panose = function() {
      var e4, r3;
      for (r3 = [], e4 = 0; e4 < 10; ++e4)
        r3.push(t6.readByte());
      return r3;
    }(), this.charRange = function() {
      var e4, r3;
      for (r3 = [], e4 = 0; e4 < 4; ++e4)
        r3.push(t6.readInt());
      return r3;
    }(), this.vendorID = t6.readString(4), this.selection = t6.readShort(), this.firstCharIndex = t6.readShort(), this.lastCharIndex = t6.readShort(), this.version > 0 && (this.ascent = t6.readShort(), this.descent = t6.readShort(), this.lineGap = t6.readShort(), this.winAscent = t6.readShort(), this.winDescent = t6.readShort(), this.codePageRange = function() {
      var e4, r3;
      for (r3 = [], e4 = 0; e4 < 2; e4 = ++e4)
        r3.push(t6.readInt());
      return r3;
    }(), this.version > 1))
      return this.xHeight = t6.readShort(), this.capHeight = t6.readShort(), this.defaultChar = t6.readShort(), this.breakChar = t6.readShort(), this.maxContext = t6.readShort();
  }, e3;
}();
var fe = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "post", e3.prototype.parse = function(t6) {
    var e4, r3, n5;
    switch (t6.pos = this.offset, this.format = t6.readInt(), this.italicAngle = t6.readInt(), this.underlinePosition = t6.readShort(), this.underlineThickness = t6.readShort(), this.isFixedPitch = t6.readInt(), this.minMemType42 = t6.readInt(), this.maxMemType42 = t6.readInt(), this.minMemType1 = t6.readInt(), this.maxMemType1 = t6.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i5;
        for (r3 = t6.readUInt16(), this.glyphNameIndex = [], i5 = 0; 0 <= r3 ? i5 < r3 : i5 > r3; i5 = 0 <= r3 ? ++i5 : --i5)
          this.glyphNameIndex.push(t6.readUInt16());
        for (this.names = [], n5 = []; t6.pos < this.offset + this.length; )
          e4 = t6.readByte(), n5.push(this.names.push(t6.readString(e4)));
        return n5;
      case 151552:
        return r3 = t6.readUInt16(), this.offsets = t6.read(r3);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var e5, r4, n6;
          for (n6 = [], i5 = e5 = 0, r4 = this.file.maxp.numGlyphs; 0 <= r4 ? e5 < r4 : e5 > r4; i5 = 0 <= r4 ? ++e5 : --e5)
            n6.push(t6.readUInt32());
          return n6;
        }.call(this);
    }
  }, e3;
}();
var de = function(t5, e3) {
  this.raw = t5, this.length = t5.length, this.platformID = e3.platformID, this.encodingID = e3.encodingID, this.languageID = e3.languageID;
};
var pe = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "name", e3.prototype.parse = function(t6) {
    var e4, r3, n5, i5, a4, o4, s5, c5, u4, h4, l4;
    for (t6.pos = this.offset, t6.readShort(), e4 = t6.readShort(), o4 = t6.readShort(), r3 = [], i5 = 0; 0 <= e4 ? i5 < e4 : i5 > e4; i5 = 0 <= e4 ? ++i5 : --i5)
      r3.push({ platformID: t6.readShort(), encodingID: t6.readShort(), languageID: t6.readShort(), nameID: t6.readShort(), length: t6.readShort(), offset: this.offset + o4 + t6.readShort() });
    for (s5 = {}, i5 = u4 = 0, h4 = r3.length; u4 < h4; i5 = ++u4)
      n5 = r3[i5], t6.pos = n5.offset, c5 = t6.readString(n5.length), a4 = new de(c5, n5), null == s5[l4 = n5.nameID] && (s5[l4] = []), s5[n5.nameID].push(a4);
    this.strings = s5, this.copyright = s5[0], this.fontFamily = s5[1], this.fontSubfamily = s5[2], this.uniqueSubfamily = s5[3], this.fontName = s5[4], this.version = s5[5];
    try {
      this.postscriptName = s5[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t7) {
      this.postscriptName = s5[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s5[7], this.manufacturer = s5[8], this.designer = s5[9], this.description = s5[10], this.vendorUrl = s5[11], this.designerUrl = s5[12], this.license = s5[13], this.licenseUrl = s5[14], this.preferredFamily = s5[15], this.preferredSubfamily = s5[17], this.compatibleFull = s5[18], this.sampleText = s5[19];
  }, e3;
}();
var ge = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "maxp", e3.prototype.parse = function(t6) {
    return t6.pos = this.offset, this.version = t6.readInt(), this.numGlyphs = t6.readUInt16(), this.maxPoints = t6.readUInt16(), this.maxContours = t6.readUInt16(), this.maxCompositePoints = t6.readUInt16(), this.maxComponentContours = t6.readUInt16(), this.maxZones = t6.readUInt16(), this.maxTwilightPoints = t6.readUInt16(), this.maxStorage = t6.readUInt16(), this.maxFunctionDefs = t6.readUInt16(), this.maxInstructionDefs = t6.readUInt16(), this.maxStackElements = t6.readUInt16(), this.maxSizeOfInstructions = t6.readUInt16(), this.maxComponentElements = t6.readUInt16(), this.maxComponentDepth = t6.readUInt16();
  }, e3;
}();
var me = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "hmtx", e3.prototype.parse = function(t6) {
    var e4, r3, n5, i5, a4, o4, s5;
    for (t6.pos = this.offset, this.metrics = [], e4 = 0, o4 = this.file.hhea.numberOfMetrics; 0 <= o4 ? e4 < o4 : e4 > o4; e4 = 0 <= o4 ? ++e4 : --e4)
      this.metrics.push({ advance: t6.readUInt16(), lsb: t6.readInt16() });
    for (n5 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r4, i6;
      for (i6 = [], e4 = r4 = 0; 0 <= n5 ? r4 < n5 : r4 > n5; e4 = 0 <= n5 ? ++r4 : --r4)
        i6.push(t6.readInt16());
      return i6;
    }(), this.widths = function() {
      var t7, e5, r4, n6;
      for (n6 = [], t7 = 0, e5 = (r4 = this.metrics).length; t7 < e5; t7++)
        i5 = r4[t7], n6.push(i5.advance);
      return n6;
    }.call(this), r3 = this.widths[this.widths.length - 1], s5 = [], e4 = a4 = 0; 0 <= n5 ? a4 < n5 : a4 > n5; e4 = 0 <= n5 ? ++a4 : --a4)
      s5.push(this.widths.push(r3));
    return s5;
  }, e3.prototype.forGlyph = function(t6) {
    return t6 in this.metrics ? this.metrics[t6] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t6 - this.metrics.length] };
  }, e3;
}();
var ve = [].slice;
var be = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "glyf", e3.prototype.parse = function() {
    return this.cache = {};
  }, e3.prototype.glyphFor = function(t6) {
    var e4, r3, n5, i5, a4, o4, s5, c5, u4, h4;
    return t6 in this.cache ? this.cache[t6] : (i5 = this.file.loca, e4 = this.file.contents, r3 = i5.indexOf(t6), 0 === (n5 = i5.lengthOf(t6)) ? this.cache[t6] = null : (e4.pos = this.offset + r3, a4 = (o4 = new ne(e4.read(n5))).readShort(), c5 = o4.readShort(), h4 = o4.readShort(), s5 = o4.readShort(), u4 = o4.readShort(), this.cache[t6] = -1 === a4 ? new we(o4, c5, h4, s5, u4) : new ye(o4, a4, c5, h4, s5, u4), this.cache[t6]));
  }, e3.prototype.encode = function(t6, e4, r3) {
    var n5, i5, a4, o4, s5;
    for (a4 = [], i5 = [], o4 = 0, s5 = e4.length; o4 < s5; o4++)
      n5 = t6[e4[o4]], i5.push(a4.length), n5 && (a4 = a4.concat(n5.encode(r3)));
    return i5.push(a4.length), { table: a4, offsets: i5 };
  }, e3;
}();
var ye = function() {
  function t5(t6, e3, r3, n5, i5, a4) {
    this.raw = t6, this.numberOfContours = e3, this.xMin = r3, this.yMin = n5, this.xMax = i5, this.yMax = a4, this.compound = false;
  }
  return t5.prototype.encode = function() {
    return this.raw.data;
  }, t5;
}();
var we = function() {
  function t5(t6, e3, r3, n5, i5) {
    var a4, o4;
    for (this.raw = t6, this.xMin = e3, this.yMin = r3, this.xMax = n5, this.yMax = i5, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a4 = this.raw; o4 = a4.readShort(), this.glyphOffsets.push(a4.pos), this.glyphIDs.push(a4.readUInt16()), 32 & o4; )
      a4.pos += 1 & o4 ? 4 : 2, 128 & o4 ? a4.pos += 8 : 64 & o4 ? a4.pos += 4 : 8 & o4 && (a4.pos += 2);
  }
  return 1, 8, 32, 64, 128, t5.prototype.encode = function() {
    var t6, e3, r3;
    for (e3 = new ne(ve.call(this.raw.data)), t6 = 0, r3 = this.glyphIDs.length; t6 < r3; ++t6)
      e3.pos = this.glyphOffsets[t6];
    return e3.data;
  }, t5;
}();
var Ne = function(t5) {
  function e3() {
    return e3.__super__.constructor.apply(this, arguments);
  }
  return oe(e3, re), e3.prototype.tag = "loca", e3.prototype.parse = function(t6) {
    var e4, r3;
    return t6.pos = this.offset, e4 = this.file.head.indexToLocFormat, this.offsets = 0 === e4 ? function() {
      var e5, n5;
      for (n5 = [], r3 = 0, e5 = this.length; r3 < e5; r3 += 2)
        n5.push(2 * t6.readUInt16());
      return n5;
    }.call(this) : function() {
      var e5, n5;
      for (n5 = [], r3 = 0, e5 = this.length; r3 < e5; r3 += 4)
        n5.push(t6.readUInt32());
      return n5;
    }.call(this);
  }, e3.prototype.indexOf = function(t6) {
    return this.offsets[t6];
  }, e3.prototype.lengthOf = function(t6) {
    return this.offsets[t6 + 1] - this.offsets[t6];
  }, e3.prototype.encode = function(t6, e4) {
    for (var r3 = new Uint32Array(this.offsets.length), n5 = 0, i5 = 0, a4 = 0; a4 < r3.length; ++a4)
      if (r3[a4] = n5, i5 < e4.length && e4[i5] == a4) {
        ++i5, r3[a4] = n5;
        var o4 = this.offsets[a4], s5 = this.offsets[a4 + 1] - o4;
        s5 > 0 && (n5 += s5);
      }
    for (var c5 = new Array(4 * r3.length), u4 = 0; u4 < r3.length; ++u4)
      c5[4 * u4 + 3] = 255 & r3[u4], c5[4 * u4 + 2] = (65280 & r3[u4]) >> 8, c5[4 * u4 + 1] = (16711680 & r3[u4]) >> 16, c5[4 * u4] = (4278190080 & r3[u4]) >> 24;
    return c5;
  }, e3;
}();
var Le = function() {
  function t5(t6) {
    this.font = t6, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t5.prototype.generateCmap = function() {
    var t6, e3, r3, n5, i5;
    for (e3 in n5 = this.font.cmap.tables[0].codeMap, t6 = {}, i5 = this.subset)
      r3 = i5[e3], t6[e3] = n5[r3];
    return t6;
  }, t5.prototype.glyphsFor = function(t6) {
    var e3, r3, n5, i5, a4, o4, s5;
    for (n5 = {}, a4 = 0, o4 = t6.length; a4 < o4; a4++)
      n5[i5 = t6[a4]] = this.font.glyf.glyphFor(i5);
    for (i5 in e3 = [], n5)
      (null != (r3 = n5[i5]) ? r3.compound : void 0) && e3.push.apply(e3, r3.glyphIDs);
    if (e3.length > 0)
      for (i5 in s5 = this.glyphsFor(e3))
        r3 = s5[i5], n5[i5] = r3;
    return n5;
  }, t5.prototype.encode = function(t6, e3) {
    var r3, n5, i5, a4, o4, s5, c5, u4, h4, l4, f5, d3, p7, g5, m6;
    for (n5 in r3 = ue.encode(this.generateCmap(), "unicode"), a4 = this.glyphsFor(t6), f5 = { 0: 0 }, m6 = r3.charMap)
      f5[(s5 = m6[n5]).old] = s5.new;
    for (d3 in l4 = r3.maxGlyphID, a4)
      d3 in f5 || (f5[d3] = l4++);
    return u4 = function(t7) {
      var e4, r4;
      for (e4 in r4 = {}, t7)
        r4[t7[e4]] = e4;
      return r4;
    }(f5), h4 = Object.keys(u4).sort(function(t7, e4) {
      return t7 - e4;
    }), p7 = function() {
      var t7, e4, r4;
      for (r4 = [], t7 = 0, e4 = h4.length; t7 < e4; t7++)
        o4 = h4[t7], r4.push(u4[o4]);
      return r4;
    }(), i5 = this.font.glyf.encode(a4, p7, f5), c5 = this.font.loca.encode(i5.offsets, p7), g5 = { cmap: this.font.cmap.raw(), glyf: i5.table, loca: c5, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e3) }, this.font.os2.exists && (g5["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g5);
  }, t5;
}();
E.API.PDFObject = function() {
  var t5;
  function e3() {
  }
  return t5 = function(t6, e4) {
    return (Array(e4 + 1).join("0") + t6).slice(-e4);
  }, e3.convert = function(r3) {
    var n5, i5, a4, o4;
    if (Array.isArray(r3))
      return "[" + function() {
        var t6, i6, a5;
        for (a5 = [], t6 = 0, i6 = r3.length; t6 < i6; t6++)
          n5 = r3[t6], a5.push(e3.convert(n5));
        return a5;
      }().join(" ") + "]";
    if ("string" == typeof r3)
      return "/" + r3;
    if (null != r3 ? r3.isString : void 0)
      return "(" + r3 + ")";
    if (r3 instanceof Date)
      return "(D:" + t5(r3.getUTCFullYear(), 4) + t5(r3.getUTCMonth(), 2) + t5(r3.getUTCDate(), 2) + t5(r3.getUTCHours(), 2) + t5(r3.getUTCMinutes(), 2) + t5(r3.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r3)) {
      for (i5 in a4 = ["<<"], r3)
        o4 = r3[i5], a4.push("/" + i5 + " " + e3.convert(o4));
      return a4.push(">>"), a4.join("\n");
    }
    return "" + r3;
  }, e3;
}();

// src/backgroundLogic/HistoricaExportHelper.ts
var HistoricaExportHelper = class {
  async convertHTMLToImageData(el) {
    const image = await toPng(el);
    return image;
  }
  async convertImageToPdf(imageData) {
    const image = new Image();
    image.src = imageData;
    const width = image.naturalWidth;
    const height = image.naturalHeight;
    const pdf = new E();
    pdf.addImage(
      imageData,
      "PNG",
      0,
      0,
      width,
      height
    );
    return pdf;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  latestFile: "",
  showUseFulInformation: false,
  defaultStyle: "2",
  showRelativeTime: false,
  usingSmartTheme: true,
  language: "en"
};
var HistoricaPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.configManager = new ConfigManager(this, DEFAULT_SETTINGS);
    this.historicaFileHelper = new HistoricaFileHelper(this);
    this.historicaExportHelper = new HistoricaExportHelper();
    this.historicaDocumentProcesser = new HistoricaDocumentProcesser();
    this.historicaTimelineRenderer = new HistoricaTimelineRenderer(this);
    this.historicaUserBlockProcesser = new HistoricaUserBlockProcesser(this);
    this.historicaChrono = new HistoricaChrono();
    this.historicaFileParser = new HistoricaDocumentFileParser(this, this.historicaDocumentProcesser);
    this.modesToKeep = ["hypermd", "markdown", "null", "xml"];
    this.refreshLeaves = () => {
      this.app.workspace.iterateCodeMirrors((cm) => cm.setOption("mode", cm.getOption("mode")));
    };
  }
  async onload() {
    await this.configManager.loadSettings();
    this.app.workspace.onLayoutReady(() => {
      this.refreshLeaves();
    });
    this.registerMarkdownCodeBlockProcessor("historica", async (source, el) => {
      let blockConfig = (0, import_toml.parse)(source);
      blockConfig = await this.historicaUserBlockProcesser.verifyBlockConfig(blockConfig);
      const customChrono = await this.historicaChrono.setupCustomChrono(blockConfig.language);
      let tokensWithTypeText = [];
      if (blockConfig.include_files === "all") {
        const allFiles = this.app.vault.getMarkdownFiles();
        for (const file of allFiles) {
          await this.historicaFileParser.parseTFileAndUpdateDocuments(file, tokensWithTypeText);
        }
      } else if (blockConfig.include_files.length === 0) {
        let currentFile = await this.historicaFileHelper.getCurrentFile();
        await this.configManager.writeLatestFileToData(currentFile);
        await this.historicaFileParser.parseTFileAndUpdateDocuments(currentFile, tokensWithTypeText);
      } else if (blockConfig.include_files !== "all" && blockConfig.include_files.length > 0) {
        for (const file of blockConfig.include_files) {
          const currentFile = this.app.vault.getAbstractFileByPath(file);
          if (currentFile instanceof import_obsidian8.TFile) {
            await this.historicaFileParser.parseTFileAndUpdateDocuments(currentFile, tokensWithTypeText);
          }
        }
      } else {
        new import_obsidian8.Notice("No file to include, check your config, include_files may be empty, list of file name or simply use 'all' to include all files in the vault");
      }
      tokensWithTypeText = tokensWithTypeText.filter((token) => {
        return "tokens" in token ? token.tokens === void 0 : true;
      });
      console.log(tokensWithTypeText);
      let timelineData = await this.historicaDocumentProcesser.GetTimelineDataFromDocumentArrayWithChrono(
        tokensWithTypeText,
        customChrono,
        three_default,
        corpus_default,
        this.configManager.settings.showUseFulInformation,
        // @ts-ignore
        blockConfig.query,
        blockConfig.pin_time
      );
      await this.historicaTimelineRenderer.renderTimelineEntry(timelineData, blockConfig, el);
      await this.configManager.writeLatestFileToData(await this.historicaFileHelper.getCurrentFile());
    });
    this.addSettingTab(new HistoricaSettingTab(this.app, this));
  }
  async onunload() {
    await this.configManager.writeLatestFileToData(await this.historicaFileHelper.getCurrentFile());
    for (const key in CodeMirror.modes) {
      if (CodeMirror.modes.hasOwnProperty(key) && !this.modesToKeep.includes(key)) {
        delete CodeMirror.modes[key];
      }
      this.refreshLeaves();
    }
  }
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

doc-path/lib/path.js:
  (**
   * @license MIT
   * doc-path <https://github.com/mrodrig/doc-path>
   * Copyright (c) 2015-present, Michael Rodrigues.
   *)

html2canvas/dist/html2canvas.js:
  (*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   *)
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

dompurify/dist/purify.js:
  (*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE *)

svg-pathdata/lib/SVGPathData.module.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

jspdf/dist/jspdf.es.min.js:
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   *)
  (**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
*/
