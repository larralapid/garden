/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  SharedStuff: () => SharedStuff,
  default: () => ObsidianSpotify
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/EndpointsBase.js
var EndpointsBase = class {
  constructor(api) {
    __publicField(this, "api");
    this.api = api;
  }
  async getRequest(url) {
    return await this.api.makeRequest("GET", url);
  }
  async postRequest(url, body, contentType = void 0) {
    return await this.api.makeRequest("POST", url, body, contentType);
  }
  async putRequest(url, body, contentType = void 0) {
    return await this.api.makeRequest("PUT", url, body, contentType);
  }
  async deleteRequest(url, body) {
    return await this.api.makeRequest("DELETE", url, body);
  }
  paramsFor(args) {
    const params = new URLSearchParams();
    for (let key of Object.getOwnPropertyNames(args)) {
      if (args[key] || args[key] === 0 || !args[key] && typeof args[key] === "boolean") {
        params.append(key, args[key].toString());
      }
    }
    return [...params].length > 0 ? `?${params.toString()}` : "";
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/AlbumsEndpoints.js
var AlbumsEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      const album = await this.getRequest(`albums/${idOrIds}${params2}`);
      return album;
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`albums${params}`);
    return response.albums;
  }
  tracks(albumId, market, limit, offset) {
    const params = this.paramsFor({ market, limit, offset });
    return this.getRequest(`albums/${albumId}/tracks${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/ArtistsEndpoints.js
var ArtistsEndpoints = class extends EndpointsBase {
  async get(idOrIds) {
    if (typeof idOrIds === "string") {
      const artist = this.getRequest(`artists/${idOrIds}`);
      return artist;
    }
    const params = this.paramsFor({ ids: idOrIds });
    const response = await this.getRequest(`artists${params}`);
    return response.artists;
  }
  albums(id, includeGroups, market, limit, offset) {
    const params = this.paramsFor({
      include_groups: includeGroups,
      market,
      limit,
      offset
    });
    return this.getRequest(`artists/${id}/albums${params}`);
  }
  topTracks(id, market) {
    const params = this.paramsFor({ market });
    return this.getRequest(`artists/${id}/top-tracks${params}`);
  }
  relatedArtists(id) {
    return this.getRequest(`artists/${id}/related-artists`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/AudiobooksEndpoints.js
var AudiobooksEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      return this.getRequest(`audiobooks/${idOrIds}${params2}`);
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`audiobooks${params}`);
    return response.audiobooks;
  }
  getAudiobookChapters(id, market, limit, offset) {
    const params = this.paramsFor({ market, limit, offset });
    return this.getRequest(`audiobooks/${id}/chapters${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/BrowseEndpoints.js
var BrowseEndpoints = class extends EndpointsBase {
  getCategories(country, locale, limit, offset) {
    const params = this.paramsFor({ country, locale, limit, offset });
    return this.getRequest(`browse/categories${params}`);
  }
  getCategory(categoryId, country, locale) {
    const params = this.paramsFor({ country, locale });
    return this.getRequest(`browse/categories/${categoryId}${params}`);
  }
  getNewReleases(country, limit, offset) {
    const params = this.paramsFor({ country, limit, offset });
    return this.getRequest(`browse/new-releases${params}`);
  }
  getFeaturedPlaylists(country, locale, timestamp, limit, offset) {
    const params = this.paramsFor({ country, locale, timestamp, limit, offset });
    return this.getRequest(`browse/featured-playlists${params}`);
  }
  getPlaylistsForCategory(category_id, country, limit, offset) {
    const params = this.paramsFor({ country, limit, offset });
    return this.getRequest(`browse/categories/${category_id}/playlists${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/ChaptersEndpoints.js
var ChaptersEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      return this.getRequest(`chapters/${idOrIds}${params2}`);
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`chapters${params}`);
    return response.chapters;
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/EpisodesEndpoints.js
var EpisodesEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      return this.getRequest(`episodes/${idOrIds}${params2}`);
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`episodes${params}`);
    return response.episodes;
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/RecommendationsEndpoints.js
var RecommendationsEndpoints = class extends EndpointsBase {
  get(request) {
    const params = this.paramsFor(request);
    return this.getRequest(`recommendations${params}`);
  }
  genreSeeds() {
    return this.getRequest("recommendations/available-genre-seeds");
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/MarketsEndpoints.js
var MarketsEndpoints = class extends EndpointsBase {
  getAvailableMarkets() {
    return this.getRequest("markets");
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/PlayerEndpoints.js
var PlayerEndpoints = class extends EndpointsBase {
  getPlaybackState(market, additional_types) {
    const params = this.paramsFor({ market, additional_types });
    return this.getRequest(`me/player${params}`);
  }
  getAvailableDevices() {
    return this.getRequest("me/player/devices");
  }
  getCurrentlyPlayingTrack(market, additional_types) {
    const params = this.paramsFor({ market, additional_types });
    return this.getRequest(`me/player/currently-playing${params}`);
  }
  getRecentlyPlayedTracks(limit, queryRange) {
    const paramObj = { limit };
    if (queryRange) {
      if (queryRange.type === "before") {
        paramObj.before = queryRange.timestamp;
      } else if (queryRange.type === "after") {
        paramObj.after = queryRange.timestamp;
      }
    }
    const params = this.paramsFor(paramObj);
    return this.getRequest(`me/player/recently-played${params}`);
  }
  getUsersQueue() {
    return this.getRequest("me/player/queue");
  }
  async transferPlayback(device_ids, play) {
    if (device_ids.length > 1) {
      throw new Error("Although an array is accepted, only a single device_id is currently supported. Supplying more than one will return 400 Bad Request");
    }
    await this.putRequest("me/player", { device_ids, play });
  }
  async startResumePlayback(device_id, context_uri, uris, offset, positionMs) {
    const params = this.paramsFor({ device_id });
    await this.putRequest(`me/player/play${params}`, { context_uri, uris, offset, positionMs });
  }
  async pausePlayback(device_id) {
    const params = this.paramsFor({ device_id });
    await this.putRequest(`me/player/pause${params}`);
  }
  async skipToNext(device_id) {
    const params = this.paramsFor({ device_id });
    await this.postRequest(`me/player/next${params}`);
  }
  async skipToPrevious(device_id) {
    const params = this.paramsFor({ device_id });
    await this.postRequest(`me/player/previous${params}`);
  }
  async seekToPosition(position_ms, device_id) {
    const params = this.paramsFor({ position_ms, device_id });
    await this.putRequest(`me/player/seek${params}`);
  }
  async setRepeatMode(state, device_id) {
    const params = this.paramsFor({ state, device_id });
    await this.putRequest(`me/player/repeat${params}`);
  }
  async setPlaybackVolume(volume_percent, device_id) {
    const params = this.paramsFor({ volume_percent, device_id });
    await this.putRequest(`me/player/volume${params}`);
  }
  async togglePlaybackShuffle(state, device_id) {
    const params = this.paramsFor({ state, device_id });
    await this.putRequest(`me/player/shuffle${params}`);
  }
  async addItemToPlaybackQueue(uri, device_id) {
    const params = this.paramsFor({ uri, device_id });
    await this.postRequest(`me/player/queue${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/PlaylistsEndpoints.js
var PlaylistsEndpoints = class extends EndpointsBase {
  getPlaylist(playlist_id, market, fields, additional_types) {
    const params = this.paramsFor({ market, fields, additional_types: additional_types == null ? void 0 : additional_types.join(",") });
    return this.getRequest(`playlists/${playlist_id}${params}`);
  }
  getPlaylistItems(playlist_id, market, fields, limit, offset, additional_types) {
    const params = this.paramsFor({ market, fields, limit, offset, additional_types: additional_types == null ? void 0 : additional_types.join(",") });
    return this.getRequest(`playlists/${playlist_id}/tracks${params}`);
  }
  async changePlaylistDetails(playlist_id, request) {
    await this.putRequest(`playlists/${playlist_id}`, request);
  }
  movePlaylistItems(playlist_id, range_start, range_length, moveToPosition) {
    return this.updatePlaylistItems(playlist_id, {
      range_start,
      range_length,
      insert_before: moveToPosition
    });
  }
  updatePlaylistItems(playlist_id, request) {
    return this.putRequest(`playlists/${playlist_id}/tracks`, request);
  }
  async addItemsToPlaylist(playlist_id, uris, position) {
    await this.postRequest(`playlists/${playlist_id}/tracks`, { position, uris });
  }
  async removeItemsFromPlaylist(playlist_id, request) {
    await this.deleteRequest(`playlists/${playlist_id}/tracks`, request);
  }
  getUsersPlaylists(user_id, limit, offset) {
    const params = this.paramsFor({ limit, offset });
    return this.getRequest(`users/${user_id}/playlists${params}`);
  }
  createPlaylist(user_id, request) {
    return this.postRequest(`users/${user_id}/playlists`, request);
  }
  getPlaylistCoverImage(playlist_id) {
    return this.getRequest(`playlists/${playlist_id}/images`);
  }
  async addCustomPlaylistCoverImage(playlist_id, imageData) {
    let base64EncodedJpeg = "";
    if (imageData instanceof Buffer) {
      base64EncodedJpeg = imageData.toString("base64");
    } else if (imageData instanceof HTMLCanvasElement) {
      base64EncodedJpeg = imageData.toDataURL("image/jpeg").split(";base64,")[1];
    } else if (imageData instanceof HTMLImageElement) {
      const canvas = document.createElement("canvas");
      canvas.width = imageData.width;
      canvas.height = imageData.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Could not get canvas context");
      }
      ctx.drawImage(imageData, 0, 0);
      base64EncodedJpeg = canvas.toDataURL("image/jpeg").split(";base64,")[1];
    } else if (typeof imageData === "string") {
      base64EncodedJpeg = imageData;
    } else {
      throw new Error("ImageData must be a Buffer, HTMLImageElement, HTMLCanvasElement, or string containing a base64 encoded jpeg");
    }
    await this.addCustomPlaylistCoverImageFromBase64String(playlist_id, base64EncodedJpeg);
  }
  async addCustomPlaylistCoverImageFromBase64String(playlist_id, base64EncodedJpeg) {
    await this.putRequest(`playlists/${playlist_id}/images`, base64EncodedJpeg, "image/jpeg");
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/SearchEndpoints.js
var SearchEndpoints = class extends EndpointsBase {
  async execute(q, type, market, limit, offset, include_external) {
    const params = this.paramsFor({ q, type, market, limit, offset, include_external });
    return await this.getRequest(`search${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/ShowsEndpoints.js
var ShowsEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      return this.getRequest(`shows/${idOrIds}${params2}`);
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`shows${params}`);
    return response.shows;
  }
  episodes(id, market, limit, offset) {
    const params = this.paramsFor({ market, limit, offset });
    return this.getRequest(`shows/${id}/episodes${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/TracksEndpoints.js
var TracksEndpoints = class extends EndpointsBase {
  async get(idOrIds, market) {
    if (typeof idOrIds === "string") {
      const params2 = this.paramsFor({ market });
      return this.getRequest(`tracks/${idOrIds}${params2}`);
    }
    const params = this.paramsFor({ ids: idOrIds, market });
    const response = await this.getRequest(`tracks${params}`);
    return response.tracks;
  }
  async audioFeatures(idOrIds) {
    if (typeof idOrIds === "string") {
      return this.getRequest(`audio-features/${idOrIds}`);
    }
    const params = this.paramsFor({ ids: idOrIds });
    const response = await this.getRequest(`audio-features${params}`);
    return response.audio_features;
  }
  audioAnalysis(id) {
    return this.getRequest(`audio-analysis/${id}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/IAuthStrategy.js
var emptyAccessToken = { access_token: "emptyAccessToken", token_type: "", expires_in: 0, refresh_token: "", expires: -1 };
function isEmptyAccessToken(value) {
  return value === emptyAccessToken;
}

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/UsersEndpoints.js
var UsersEndpoints = class extends EndpointsBase {
  profile(userId) {
    return this.getRequest(`users/${userId}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/endpoints/CurrentUserEndpoints.js
var CurrentUserEndpoints = class extends EndpointsBase {
  constructor(api) {
    super(api);
    __publicField(this, "albums");
    __publicField(this, "audiobooks");
    __publicField(this, "episodes");
    __publicField(this, "playlists");
    __publicField(this, "shows");
    __publicField(this, "tracks");
    this.albums = new CurrentUserAlbumsEndpoints(api);
    this.audiobooks = new CurrentUserAudiobooksEndpoints(api);
    this.episodes = new CurrentUserEpisodesEndpoints(api);
    this.playlists = new CurrentUserPlaylistsEndpoints(api);
    this.shows = new CurrentUserShowsEndpoints(api);
    this.tracks = new CurrentUserTracksEndpoints(api);
  }
  profile() {
    return this.getRequest("me");
  }
  topItems(type, time_range, limit, offset) {
    const params = this.paramsFor({ time_range, limit, offset });
    return this.getRequest(`me/top/${type}${params}`);
  }
  followedArtists(after, limit) {
    const params = this.paramsFor({ type: "artist", after, limit });
    return this.getRequest(`me/following${params}`);
  }
  async followArtistsOrUsers(ids, type) {
    const params = this.paramsFor({ type });
    await this.putRequest(`me/following${params}`, { ids });
  }
  async unfollowArtistsOrUsers(ids, type) {
    const params = this.paramsFor({ type });
    await this.deleteRequest(`me/following${params}`, { ids });
  }
  followsArtistsOrUsers(ids, type) {
    const params = this.paramsFor({ ids, type });
    return this.getRequest(`me/following/contains${params}`);
  }
};
var CurrentUserAlbumsEndpoints = class extends EndpointsBase {
  savedAlbums(limit, offset, market) {
    const params = this.paramsFor({ limit, offset, market });
    return this.getRequest(`me/albums${params}`);
  }
  async saveAlbums(ids) {
    await this.putRequest("me/albums", ids);
  }
  async removeSavedAlbums(ids) {
    await this.deleteRequest("me/albums", ids);
  }
  hasSavedAlbums(ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`me/albums/contains${params}`);
  }
};
var CurrentUserAudiobooksEndpoints = class extends EndpointsBase {
  savedAudiobooks(limit, offset) {
    const params = this.paramsFor({ limit, offset });
    return this.getRequest(`me/audiobooks${params}`);
  }
  async saveAudiobooks(ids) {
    await this.putRequest("me/audiobooks", ids);
  }
  async removeSavedAudiobooks(ids) {
    await this.deleteRequest("me/audiobooks", ids);
  }
  hasSavedAudiobooks(ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`me/audiobooks/contains${params}`);
  }
};
var CurrentUserEpisodesEndpoints = class extends EndpointsBase {
  savedEpisodes(market, limit, offset) {
    const params = this.paramsFor({ market, limit, offset });
    return this.getRequest(`me/episodes${params}`);
  }
  async saveEpisodes(ids) {
    await this.putRequest(`me/episodes`, ids);
  }
  async removeSavedEpisodes(ids) {
    await this.deleteRequest(`me/episodes`, ids);
  }
  hasSavedEpisodes(ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`me/episodes/contains${params}`);
  }
};
var CurrentUserPlaylistsEndpoints = class extends EndpointsBase {
  playlists(limit, offset) {
    const params = this.paramsFor({ limit, offset });
    return this.getRequest(`me/playlists${params}`);
  }
  async follow(playlist_id) {
    await this.putRequest(`playlists/${playlist_id}/followers`);
  }
  async unfollow(playlist_id) {
    await this.deleteRequest(`playlists/${playlist_id}/followers`);
  }
  isFollowing(playlistId, ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`playlists/${playlistId}/followers/contains${params}`);
  }
};
var CurrentUserShowsEndpoints = class extends EndpointsBase {
  savedShows(limit, offset) {
    const params = this.paramsFor({ limit, offset });
    return this.getRequest(`me/shows${params}`);
  }
  saveShows(ids) {
    const params = this.paramsFor({ ids });
    return this.putRequest(`me/shows${params}`);
  }
  removeSavedShows(ids, market) {
    const params = this.paramsFor({ ids, market });
    return this.deleteRequest(`me/shows${params}`);
  }
  hasSavedShow(ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`me/shows/contains${params}`);
  }
};
var CurrentUserTracksEndpoints = class extends EndpointsBase {
  savedTracks(limit, offset, market) {
    const params = this.paramsFor({ limit, offset, market });
    return this.getRequest(`me/tracks${params}`);
  }
  async saveTracks(ids) {
    await this.putRequest("me/tracks", ids);
  }
  async removeSavedTracks(ids) {
    await this.deleteRequest("me/tracks", ids);
  }
  hasSavedTracks(ids) {
    const params = this.paramsFor({ ids });
    return this.getRequest(`me/tracks/contains${params}`);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/Crypto.js
var Crypto = class {
  static get current() {
    return this.hasSubtleCrypto ? window.crypto : this.tryLoadNodeWebCrypto();
  }
  static get hasSubtleCrypto() {
    return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
  }
  static tryLoadNodeWebCrypto() {
    try {
      const { webcrypto } = require("crypto");
      return webcrypto;
    } catch (e) {
      throw e;
    }
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/AccessTokenHelpers.js
var AccessTokenHelpers = class {
  static async refreshCachedAccessToken(clientId, item) {
    const updated = await AccessTokenHelpers.refreshToken(clientId, item.refresh_token);
    return AccessTokenHelpers.toCachable(updated);
  }
  static toCachable(item) {
    if (item.expires && item.expires === -1) {
      return item;
    }
    return { ...item, expires: this.calculateExpiry(item) };
  }
  static calculateExpiry(item) {
    return Date.now() + item.expires_in * 1e3;
  }
  static async refreshToken(clientId, refreshToken) {
    const params = new URLSearchParams();
    params.append("client_id", clientId);
    params.append("grant_type", "refresh_token");
    params.append("refresh_token", refreshToken);
    const result = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params
    });
    const text = await result.text();
    if (!result.ok) {
      throw new Error(`Failed to refresh token: ${result.statusText}, ${text}`);
    }
    const json = JSON.parse(text);
    return json;
  }
  static generateCodeVerifier(length) {
    let text = "";
    let possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < length; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
  static async generateCodeChallenge(codeVerifier) {
    const data = new TextEncoder().encode(codeVerifier);
    const digest = await Crypto.current.subtle.digest("SHA-256", data);
    const digestBytes = [...new Uint8Array(digest)];
    const hasBuffer = typeof Buffer !== "undefined";
    const digestAsBase64 = hasBuffer ? Buffer.from(digest).toString("base64") : btoa(String.fromCharCode.apply(null, digestBytes));
    return digestAsBase64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/ClientCredentialsStrategy.js
var _ClientCredentialsStrategy = class {
  constructor(clientId, clientSecret, scopes = []) {
    __publicField(this, "clientId");
    __publicField(this, "clientSecret");
    __publicField(this, "scopes");
    __publicField(this, "configuration", null);
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.scopes = scopes;
  }
  get cache() {
    return this.configuration.cachingStrategy;
  }
  setConfiguration(configuration) {
    this.configuration = configuration;
  }
  async getOrCreateAccessToken() {
    const token = await this.cache.getOrCreate(_ClientCredentialsStrategy.cacheKey, async () => {
      const token2 = await this.getTokenFromApi();
      return AccessTokenHelpers.toCachable(token2);
    }, async (_) => {
      const refreshed = await this.getTokenFromApi();
      return AccessTokenHelpers.toCachable(refreshed);
    });
    return token;
  }
  async getAccessToken() {
    const token = await this.cache.get(_ClientCredentialsStrategy.cacheKey);
    return token;
  }
  removeAccessToken() {
    this.cache.remove(_ClientCredentialsStrategy.cacheKey);
  }
  async getTokenFromApi() {
    const options = {
      grant_type: "client_credentials",
      scope: this.scopes.join(" ")
    };
    const bodyAsString = Object.keys(options).map((key) => key + "=" + options[key]).join("&");
    const hasBuffer = typeof Buffer !== "undefined";
    const credentials = `${this.clientId}:${this.clientSecret}`;
    const basicAuth = hasBuffer ? Buffer.from(credentials).toString("base64") : btoa(credentials);
    const result = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": `Basic ${basicAuth}`
      },
      body: bodyAsString
    });
    if (result.status !== 200) {
      throw new Error("Failed to get access token.");
    }
    const json = await result.json();
    return json;
  }
};
var ClientCredentialsStrategy = _ClientCredentialsStrategy;
__publicField(ClientCredentialsStrategy, "cacheKey", "spotify-sdk:ClientCredentialsStrategy:token");

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/ImplicitGrantStrategy.js
var _ImplicitGrantStrategy = class {
  constructor(clientId, redirectUri, scopes) {
    __publicField(this, "clientId");
    __publicField(this, "redirectUri");
    __publicField(this, "scopes");
    __publicField(this, "configuration", null);
    this.clientId = clientId;
    this.redirectUri = redirectUri;
    this.scopes = scopes;
  }
  get cache() {
    return this.configuration.cachingStrategy;
  }
  setConfiguration(configuration) {
    this.configuration = configuration;
  }
  async getOrCreateAccessToken() {
    const token = await this.cache.getOrCreate(_ImplicitGrantStrategy.cacheKey, async () => {
      const token2 = await this.redirectOrVerifyToken();
      return AccessTokenHelpers.toCachable(token2);
    }, async (expiring) => {
      return AccessTokenHelpers.refreshCachedAccessToken(this.clientId, expiring);
    });
    return token;
  }
  async getAccessToken() {
    const token = await this.cache.get(_ImplicitGrantStrategy.cacheKey);
    return token;
  }
  removeAccessToken() {
    this.cache.remove(_ImplicitGrantStrategy.cacheKey);
  }
  async redirectOrVerifyToken() {
    var _a, _b, _c, _d;
    const hashParams = new URLSearchParams(window.location.hash.substring(1));
    const accessToken = hashParams.get("access_token");
    if (accessToken) {
      return Promise.resolve({
        access_token: accessToken,
        token_type: (_a = hashParams.get("token_type")) != null ? _a : "",
        expires_in: parseInt((_b = hashParams.get("expires_in")) != null ? _b : "0"),
        refresh_token: (_c = hashParams.get("refresh_token")) != null ? _c : "",
        expires: Number(hashParams.get("expires")) || 0
      });
    }
    const scopes = (_d = this.scopes) != null ? _d : [];
    var scope = scopes.join(" ");
    const params = new URLSearchParams();
    params.append("client_id", this.clientId);
    params.append("response_type", "token");
    params.append("redirect_uri", this.redirectUri);
    params.append("scope", scope);
    const authUrl = "https://accounts.spotify.com/authorize?" + params.toString();
    this.configuration.redirectionStrategy.redirect(authUrl);
    return emptyAccessToken;
  }
};
var ImplicitGrantStrategy = _ImplicitGrantStrategy;
__publicField(ImplicitGrantStrategy, "cacheKey", "spotify-sdk:ImplicitGrantStrategy:token");

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/AuthorizationCodeWithPKCEStrategy.js
var _AuthorizationCodeWithPKCEStrategy = class {
  constructor(clientId, redirectUri, scopes) {
    __publicField(this, "clientId");
    __publicField(this, "redirectUri");
    __publicField(this, "scopes");
    __publicField(this, "configuration", null);
    this.clientId = clientId;
    this.redirectUri = redirectUri;
    this.scopes = scopes;
  }
  get cache() {
    return this.configuration.cachingStrategy;
  }
  setConfiguration(configuration) {
    this.configuration = configuration;
  }
  async getOrCreateAccessToken() {
    const token = await this.cache.getOrCreate(_AuthorizationCodeWithPKCEStrategy.cacheKey, async () => {
      const token2 = await this.redirectOrVerifyToken();
      return AccessTokenHelpers.toCachable(token2);
    }, async (expiring) => {
      return AccessTokenHelpers.refreshCachedAccessToken(this.clientId, expiring);
    });
    return token;
  }
  async getAccessToken() {
    const token = await this.cache.get(_AuthorizationCodeWithPKCEStrategy.cacheKey);
    return token;
  }
  removeAccessToken() {
    this.cache.remove(_AuthorizationCodeWithPKCEStrategy.cacheKey);
  }
  async redirectOrVerifyToken() {
    const hashParams = new URLSearchParams(window.location.search);
    const code = hashParams.get("code");
    if (code) {
      const token = await this.verifyAndExchangeCode(code);
      this.removeCodeFromUrl();
      return token;
    }
    this.redirectToSpotify();
    return emptyAccessToken;
  }
  async redirectToSpotify() {
    const verifier = AccessTokenHelpers.generateCodeVerifier(128);
    const challenge = await AccessTokenHelpers.generateCodeChallenge(verifier);
    const singleUseVerifier = { verifier, expiresOnAccess: true };
    this.cache.setCacheItem("spotify-sdk:verifier", singleUseVerifier);
    const redirectTarget = await this.generateRedirectUrlForUser(this.scopes, challenge);
    await this.configuration.redirectionStrategy.redirect(redirectTarget);
  }
  async verifyAndExchangeCode(code) {
    const cachedItem = await this.cache.get("spotify-sdk:verifier");
    const verifier = cachedItem == null ? void 0 : cachedItem.verifier;
    if (!verifier) {
      throw new Error("No verifier found in cache - can't validate query string callback parameters.");
    }
    await this.configuration.redirectionStrategy.onReturnFromRedirect();
    return await this.exchangeCodeForToken(code, verifier);
  }
  removeCodeFromUrl() {
    const url = new URL(window.location.href);
    url.searchParams.delete("code");
    const newUrl = url.search ? url.href : url.href.replace("?", "");
    window.history.replaceState({}, document.title, newUrl);
  }
  async generateRedirectUrlForUser(scopes, challenge) {
    const scope = scopes.join(" ");
    const params = new URLSearchParams();
    params.append("client_id", this.clientId);
    params.append("response_type", "code");
    params.append("redirect_uri", this.redirectUri);
    params.append("scope", scope);
    params.append("code_challenge_method", "S256");
    params.append("code_challenge", challenge);
    return `https://accounts.spotify.com/authorize?${params.toString()}`;
  }
  async exchangeCodeForToken(code, verifier) {
    const params = new URLSearchParams();
    params.append("client_id", this.clientId);
    params.append("grant_type", "authorization_code");
    params.append("code", code);
    params.append("redirect_uri", this.redirectUri);
    params.append("code_verifier", verifier);
    const result = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: params
    });
    const text = await result.text();
    if (!result.ok) {
      throw new Error(`Failed to exchange code for token: ${result.statusText}, ${text}`);
    }
    const json = JSON.parse(text);
    return json;
  }
};
var AuthorizationCodeWithPKCEStrategy = _AuthorizationCodeWithPKCEStrategy;
__publicField(AuthorizationCodeWithPKCEStrategy, "cacheKey", "spotify-sdk:AuthorizationCodeWithPKCEStrategy:token");

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/serialization/DefaultResponseDeserializer.js
var DefaultResponseDeserializer = class {
  async deserialize(response) {
    const text = await response.text();
    if (text.length > 0) {
      const json = JSON.parse(text);
      return json;
    }
    return null;
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/responsevalidation/DefaultResponseValidator.js
var DefaultResponseValidator = class {
  async validateResponse(response) {
    switch (response.status) {
      case 401:
        throw new Error("Bad or expired token. This can happen if the user revoked a token or the access token has expired. You should re-authenticate the user.");
      case 403:
        const body = await response.text();
        throw new Error(`Bad OAuth request (wrong consumer key, bad nonce, expired timestamp...). Unfortunately, re-authenticating the user won't help here. Body: ${body}`);
      case 429:
        throw new Error("The app has exceeded its rate limits.");
      default:
        if (!response.status.toString().startsWith("20")) {
          const body2 = await response.text();
          throw new Error(`Unrecognised response code: ${response.status} - ${response.statusText}. Body: ${body2}`);
        }
    }
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/errorhandling/NoOpErrorHandler.js
var NoOpErrorHandler = class {
  async handleErrors(_) {
    return false;
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/redirection/DocumentLocationRedirectionStrategy.js
var DocumentLocationRedirectionStrategy = class {
  async redirect(targetUrl) {
    document.location = targetUrl.toString();
  }
  async onReturnFromRedirect() {
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/caching/GenericCache.js
var GenericCache = class {
  constructor(storage, updateFunctions = /* @__PURE__ */ new Map(), autoRenewInterval = 0, autoRenewWindow = 2 * 60 * 1e3) {
    __publicField(this, "storage");
    __publicField(this, "updateFunctions");
    __publicField(this, "autoRenewInterval");
    __publicField(this, "autoRenewWindow");
    this.storage = storage;
    this.updateFunctions = updateFunctions;
    this.autoRenewInterval = autoRenewInterval;
    this.autoRenewWindow = autoRenewWindow;
    if (this.autoRenewInterval > 0) {
      setInterval(() => this.autoRenewRenewableItems(), this.autoRenewInterval);
    }
  }
  async getOrCreate(cacheKey, createFunction, updateFunction) {
    if (updateFunction) {
      this.updateFunctions.set(cacheKey, updateFunction);
    }
    const item = await this.get(cacheKey);
    if (item) {
      return item;
    }
    const newCacheItem = await createFunction();
    if (!newCacheItem) {
      throw new Error("Could not create cache item");
    }
    if (!isEmptyAccessToken(newCacheItem)) {
      this.setCacheItem(cacheKey, newCacheItem);
    }
    return newCacheItem;
  }
  async get(cacheKey) {
    let asString = this.storage.get(cacheKey);
    let cachedItem = asString ? JSON.parse(asString) : null;
    if (this.itemDueToExpire(cachedItem) && this.updateFunctions.has(cacheKey)) {
      const updateFunction = this.updateFunctions.get(cacheKey);
      await this.tryUpdateItem(cacheKey, cachedItem, updateFunction);
      asString = this.storage.get(cacheKey);
      cachedItem = asString ? JSON.parse(asString) : null;
    }
    if (!cachedItem) {
      return null;
    }
    if (cachedItem.expires && (cachedItem.expires === -1 || cachedItem.expires <= Date.now())) {
      this.remove(cacheKey);
      return null;
    }
    if (cachedItem.expiresOnAccess && cachedItem.expiresOnAccess === true) {
      this.remove(cacheKey);
      return cachedItem;
    }
    return cachedItem;
  }
  set(cacheKey, value, expiresIn) {
    const expires = Date.now() + expiresIn;
    const cacheItem = { ...value, expires };
    this.setCacheItem(cacheKey, cacheItem);
  }
  setCacheItem(cacheKey, cacheItem) {
    const asString = JSON.stringify(cacheItem);
    this.storage.set(cacheKey, asString);
  }
  remove(cacheKey) {
    this.storage.remove(cacheKey);
  }
  itemDueToExpire(item) {
    if (!item) {
      return false;
    }
    if (!item.expires) {
      return false;
    }
    return item.expires - Date.now() < this.autoRenewWindow;
  }
  async autoRenewRenewableItems() {
    this.updateFunctions.forEach(async (updateFunction, key) => {
      const cachedItem = await this.get(key);
      if (!cachedItem) {
        return;
      }
      if (updateFunction && this.itemDueToExpire(cachedItem)) {
        await this.tryUpdateItem(key, cachedItem, updateFunction);
      }
    });
  }
  async tryUpdateItem(key, cachedItem, updateFunction) {
    try {
      const updated = await updateFunction(cachedItem);
      if (updated) {
        this.setCacheItem(key, updated);
      }
    } catch (e) {
      console.error(e);
    }
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/caching/LocalStorageCachingStrategy.js
var LocalStorageCachingStrategy = class extends GenericCache {
  constructor() {
    super(new LocalStorageCacheStore());
  }
};
var LocalStorageCacheStore = class {
  get(key) {
    return localStorage.getItem(key);
  }
  set(key, value) {
    localStorage.setItem(key, value);
  }
  remove(key) {
    localStorage.removeItem(key);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/caching/InMemoryCachingStrategy.js
var InMemoryCachingStrategy = class extends GenericCache {
  constructor() {
    super(new DictionaryCacheStore());
  }
};
var DictionaryCacheStore = class {
  constructor() {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
  }
  get(key) {
    var _a;
    return (_a = this.cache.get(key)) != null ? _a : null;
  }
  set(key, value) {
    this.cache.set(key, value);
  }
  remove(key) {
    this.cache.delete(key);
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/auth/ProvidedAccessTokenStrategy.js
var ProvidedAccessTokenStrategy = class {
  constructor(clientId, accessToken, refreshTokenAction) {
    __publicField(this, "clientId");
    __publicField(this, "accessToken");
    __publicField(this, "refreshTokenAction");
    this.clientId = clientId;
    this.accessToken = accessToken;
    this.refreshTokenAction = refreshTokenAction || AccessTokenHelpers.refreshCachedAccessToken;
    if (!this.accessToken.expires) {
      this.accessToken.expires = AccessTokenHelpers.calculateExpiry(this.accessToken);
    }
  }
  setConfiguration(_) {
  }
  async getOrCreateAccessToken() {
    if (this.accessToken.expires && this.accessToken.expires <= Date.now()) {
      const refreshed = await this.refreshTokenAction(this.clientId, this.accessToken);
      this.accessToken = refreshed;
    }
    return this.accessToken;
  }
  async getAccessToken() {
    return this.accessToken;
  }
  removeAccessToken() {
    this.accessToken = {
      access_token: "",
      token_type: "",
      expires_in: 0,
      refresh_token: "",
      expires: 0
    };
  }
};

// node_modules/@spotify/web-api-ts-sdk/dist/mjs/SpotifyApi.js
var _SpotifyApi = class {
  constructor(authentication, config) {
    __publicField(this, "sdkConfig");
    __publicField(this, "authenticationStrategy");
    __publicField(this, "albums");
    __publicField(this, "artists");
    __publicField(this, "audiobooks");
    __publicField(this, "browse");
    __publicField(this, "chapters");
    __publicField(this, "episodes");
    __publicField(this, "recommendations");
    __publicField(this, "markets");
    __publicField(this, "player");
    __publicField(this, "playlists");
    __publicField(this, "shows");
    __publicField(this, "tracks");
    __publicField(this, "users");
    __publicField(this, "search");
    __publicField(this, "currentUser");
    this.sdkConfig = this.initializeSdk(config);
    this.albums = new AlbumsEndpoints(this);
    this.artists = new ArtistsEndpoints(this);
    this.audiobooks = new AudiobooksEndpoints(this);
    this.browse = new BrowseEndpoints(this);
    this.chapters = new ChaptersEndpoints(this);
    this.episodes = new EpisodesEndpoints(this);
    this.recommendations = new RecommendationsEndpoints(this);
    this.markets = new MarketsEndpoints(this);
    this.player = new PlayerEndpoints(this);
    this.playlists = new PlaylistsEndpoints(this);
    this.shows = new ShowsEndpoints(this);
    this.tracks = new TracksEndpoints(this);
    this.users = new UsersEndpoints(this);
    this.currentUser = new CurrentUserEndpoints(this);
    const search = new SearchEndpoints(this);
    this.search = search.execute.bind(search);
    this.authenticationStrategy = authentication;
    this.authenticationStrategy.setConfiguration(this.sdkConfig);
  }
  async makeRequest(method, url, body = void 0, contentType = void 0) {
    try {
      const accessToken = await this.authenticationStrategy.getOrCreateAccessToken();
      if (isEmptyAccessToken(accessToken)) {
        console.warn("No access token found, authenticating now.");
        return null;
      }
      const token = accessToken == null ? void 0 : accessToken.access_token;
      const fullUrl = _SpotifyApi.rootUrl + url;
      const opts = {
        method,
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": contentType != null ? contentType : "application/json"
        },
        body: body ? typeof body === "string" ? body : JSON.stringify(body) : void 0
      };
      this.sdkConfig.beforeRequest(fullUrl, opts);
      const result = await this.sdkConfig.fetch(fullUrl, opts);
      this.sdkConfig.afterRequest(fullUrl, opts, result);
      if (result.status === 204) {
        return null;
      }
      await this.sdkConfig.responseValidator.validateResponse(result);
      return this.sdkConfig.deserializer.deserialize(result);
    } catch (error) {
      const handled = await this.sdkConfig.errorHandler.handleErrors(error);
      if (!handled) {
        throw error;
      }
      return null;
    }
  }
  initializeSdk(config) {
    const isBrowser = typeof window !== "undefined";
    const defaultConfig = {
      fetch: (req, init) => fetch(req, init),
      beforeRequest: (_, __) => {
      },
      afterRequest: (_, __, ___) => {
      },
      deserializer: new DefaultResponseDeserializer(),
      responseValidator: new DefaultResponseValidator(),
      errorHandler: new NoOpErrorHandler(),
      redirectionStrategy: new DocumentLocationRedirectionStrategy(),
      cachingStrategy: isBrowser ? new LocalStorageCachingStrategy() : new InMemoryCachingStrategy()
    };
    return { ...defaultConfig, ...config };
  }
  switchAuthenticationStrategy(authentication) {
    this.authenticationStrategy = authentication;
    this.authenticationStrategy.setConfiguration(this.sdkConfig);
    this.authenticationStrategy.getOrCreateAccessToken();
  }
  /**
   * Use this when you're running in a browser and you want to control when first authentication+redirect happens.
  */
  async authenticate() {
    const response = await this.authenticationStrategy.getOrCreateAccessToken();
    return {
      authenticated: response.expires > Date.now() && !isEmptyAccessToken(response),
      accessToken: response
    };
  }
  /**
   * @returns the current access token. null implies the SpotifyApi is not yet authenticated.
   */
  async getAccessToken() {
    return this.authenticationStrategy.getAccessToken();
  }
  /**
   * Removes the access token if it exists.
   */
  logOut() {
    this.authenticationStrategy.removeAccessToken();
  }
  static withUserAuthorization(clientId, redirectUri, scopes = [], config) {
    const strategy = new AuthorizationCodeWithPKCEStrategy(clientId, redirectUri, scopes);
    return new _SpotifyApi(strategy, config);
  }
  static withClientCredentials(clientId, clientSecret, scopes = [], config) {
    const strategy = new ClientCredentialsStrategy(clientId, clientSecret, scopes);
    return new _SpotifyApi(strategy, config);
  }
  static withImplicitGrant(clientId, redirectUri, scopes = [], config) {
    const strategy = new ImplicitGrantStrategy(clientId, redirectUri, scopes);
    return new _SpotifyApi(strategy, config);
  }
  /**
   * Use this when you're running in a Node environment, and accepting the access token from a client-side `performUserAuthorization` call.
   * You can also use this method if you already have an access token and don't want to use the built-in authentication strategies.
   */
  static withAccessToken(clientId, token, config) {
    const strategy = new ProvidedAccessTokenStrategy(clientId, token);
    return new _SpotifyApi(strategy, config);
  }
  static async performUserAuthorization(clientId, redirectUri, scopes, onAuthorizationOrUrl, config) {
    const strategy = new AuthorizationCodeWithPKCEStrategy(clientId, redirectUri, scopes);
    const client = new _SpotifyApi(strategy, config);
    const accessToken = await client.authenticationStrategy.getOrCreateAccessToken();
    if (!isEmptyAccessToken(accessToken)) {
      if (typeof onAuthorizationOrUrl === "string") {
        console.log("Posting access token to postback URL.");
        await fetch(onAuthorizationOrUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(accessToken)
        });
      } else {
        await onAuthorizationOrUrl(accessToken);
      }
    }
    return {
      authenticated: accessToken.expires > Date.now() && !isEmptyAccessToken(accessToken),
      accessToken
    };
  }
};
var SpotifyApi = _SpotifyApi;
__publicField(SpotifyApi, "rootUrl", "https://api.spotify.com/v1/");

// RefreshClass.ts
var RefreshClass = class {
  static async refreshInit(args) {
    const sharedstuff2 = args.sharedstuff;
    const refreshspot = args.refreshspot;
    const settings = args.settings;
    const manifest = args.manifest;
    var TIMEOUT = 3e3;
    sharedstuff2.set("offlinerefresh", async () => {
      console.log("[" + manifest.name + "] Now offline, refreshing Spotify Token after online and restting timer");
    });
    window.addEventListener("offline", sharedstuff2.get("offlinerefresh"));
    sharedstuff2.set(
      "onlinerefresh",
      async () => {
        console.log("[" + manifest.name + "] Refreshing Spotify Token after online and restting timer");
        await refreshspot(settings, manifest);
        clearInterval(sharedstuff2.get("spotifyrefreshtimer"));
        setTimeout(async () => {
          let spotifyrefreshtimer2 = setInterval(async () => {
            await refreshspot(settings, manifest);
          }, 36e5);
          sharedstuff2.set("spotifyrefreshtimer", spotifyrefreshtimer2);
        }, TIMEOUT);
      }
    );
    window.addEventListener("online", sharedstuff2.get("onlinerefresh"));
    await refreshspot(settings, manifest);
    let spotifyrefreshtimer = setInterval(async () => {
      await refreshspot(settings, manifest);
    }, 36e5);
    sharedstuff2.set("spotifyrefreshtimer", spotifyrefreshtimer);
  }
  static async logoutOrunload(args) {
    const sharedstuff2 = args.sharedstuff;
    const settings = args.settings;
    const manifest = args.manifest;
    window.spotifysdk = null;
    clearInterval(sharedstuff2.get("spotifyrefreshtimer"));
    window.removeEventListener("offline", sharedstuff2.get("offlinerefresh"));
    window.removeEventListener("online", sharedstuff2.get("onlinerefresh"));
    console.log("[" + manifest.name + "] Both the spotify sdk and auto token refresher have been cleaned up");
  }
};

// main.ts
var SharedStuff = class {
  constructor(stuff) {
    this.stuff = stuff;
    this.stuff = {};
  }
  set(name, value) {
    this.stuff[name] = value;
  }
  get(name) {
    return this.stuff[name];
  }
  delete(name) {
    delete this.stuff[name];
  }
  has(name) {
    return this.stuff.hasOwnProperty(name);
  }
  keys() {
    return Object.keys(this.stuff);
  }
  values() {
    return Object.values(this.stuff);
  }
  entries() {
    return Object.entries(this.stuff);
  }
};
var sharedstuff = new SharedStuff({});
var DEFAULT_SETTINGS = {
  spotify_client_id: "",
  spotify_client_secret: "",
  spotify_access_token: {
    access_token: "",
    token_type: "",
    expires_in: 0,
    refresh_token: ""
  }
};
var ObsidianSpotify = class extends import_obsidian.Plugin {
  async onload() {
    this.addSettingTab(new ObsidianSpotifySettingsTab(this.app, this));
    await this.loadSettings();
    sharedstuff.set("manifest", this.manifest);
    async function refreshspot(setting, manifest) {
      let json_spotify = setting.spotify_access_token;
      let refresh_token = json_spotify.refresh_token;
      let body = new URLSearchParams(
        {
          grant_type: "refresh_token",
          refresh_token,
          client_id: setting.spotify_client_id
        }
      ).toString();
      let access_token = await (0, import_obsidian.requestUrl)({
        "url": "https://accounts.spotify.com/api/token",
        "method": "POST",
        "headers": {
          "content-type": "application/x-www-form-urlencoded",
          "Authorization": "Basic " + btoa(setting.spotify_client_id + ":" + setting.spotify_client_secret)
        },
        "body": body,
        "throw": false
      });
      let data = await access_token.json;
      console.log("[" + manifest.name + "] Spotify Token Refreshed");
      window.spotifysdk = SpotifyApi.withAccessToken(setting.spotify_client_id, data);
      window.spotifysdk["authenticationStrategy"].refreshTokenAction = async () => {
        return;
      };
    }
    sharedstuff.set("refreshspot", refreshspot);
    if (this.settings.spotify_access_token.refresh_token) {
      RefreshClass.refreshInit({ sharedstuff, refreshspot, settings: this.settings, manifest: this.manifest });
    } else {
      window.spotifysdk = null;
    }
    function spotify_auth_login(spotify_client_id, manifest) {
      const generateRandomString = (length) => {
        const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        const values = crypto.getRandomValues(new Uint8Array(length));
        return values.reduce((acc, x) => acc + possible[x % possible.length], "");
      };
      let state = generateRandomString(64);
      let scope = "user-follow-modify user-follow-read user-read-playback-position user-top-read user-read-recently-played user-library-modify user-library-read user-read-email user-read-private ugc-image-upload app-remote-control streaming playlist-read-private playlist-read-collaborative playlist-modify-private playlist-modify-public user-read-playback-state user-modify-playback-state user-read-currently-playing user-modify-playback-state user-read-recently-played";
      let params = {
        response_type: "code",
        client_id: spotify_client_id,
        scope,
        redirect_uri: "obsidian://spotify/auth",
        state
      };
      let endpoint = new URL("https://accounts.spotify.com/authorize");
      endpoint.search = new URLSearchParams(params).toString();
      window.location.assign(endpoint);
      sharedstuff.set("spotifystate", state);
      console.log("[" + manifest.name + "] Opening login page");
    }
    async function spotify_auth_logout(manifest, this2) {
      window.spotifysdk.logOut();
      console.log(this2);
      this2.settings.spotify_access_token = {
        access_token: "",
        token_type: "",
        expires_in: 0,
        refresh_token: ""
      };
      await this2.saveSettings();
      RefreshClass.logoutOrunload({ sharedstuff, settings: this2.settings, manifest });
      console.log("[" + manifest.name + "] Logged out");
    }
    sharedstuff.set("spotify_auth_login_function", spotify_auth_login);
    sharedstuff.set("spotify_auth_logout_function", spotify_auth_logout);
    this.addCommand({
      id: "spotify-auth-login",
      name: "Login",
      callback: () => {
        sharedstuff.get("spotify_auth_login_function")(this.settings.spotify_client_id, this.manifest);
      }
    });
    this.addCommand({
      id: "spotify-auth-logout",
      name: "Logout",
      callback: async () => {
        let this2 = this;
        await sharedstuff.get("spotify_auth_logout_function")(this.manifest, this2);
      }
    });
    this.registerObsidianProtocolHandler("spotify/auth", async (e) => {
      console.log("[" + this.manifest.name + "] Spotify Auth Code Received From Callback");
      let correctstate = sharedstuff.get("spotifystate");
      let state = e.state;
      if (!(state == correctstate)) {
        console.log("[" + this.manifest.name + "] State mismatch");
        return;
      }
      let code = e.code;
      let body = new URLSearchParams(
        {
          client_id: this.settings.spotify_client_id,
          grant_type: "authorization_code",
          code,
          redirect_uri: "obsidian://spotify/auth"
        }
      ).toString();
      let access_token = await (0, import_obsidian.requestUrl)({
        "url": "https://accounts.spotify.com/api/token",
        "method": "POST",
        "headers": {
          "content-type": "application/x-www-form-urlencoded",
          "Authorization": "Basic " + Buffer.from(this.settings.spotify_client_id + ":" + this.settings.spotify_client_secret).toString("base64")
        },
        "body": body,
        "throw": false
      });
      let data = await access_token.json;
      this.settings.spotify_access_token = data;
      await this.saveSettings();
      window.spotifysdk = SpotifyApi.withAccessToken(this.settings.spotify_client_id, this.settings.spotify_access_token);
      window.spotifysdk["authenticationStrategy"].refreshTokenAction = async () => {
        return;
      };
      console.log("[" + this.manifest.name + "] Authed successfuly");
      RefreshClass.refreshInit({ sharedstuff, refreshspot, settings: this.settings, manifest: this.manifest });
    });
  }
  onunload() {
    RefreshClass.logoutOrunload({ sharedstuff, settings: this.settings, manifest: this.manifest });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ObsidianSpotifySettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    let manifest = sharedstuff.get("manifest");
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Spotify Client ID").setDesc("Find it in your spotify dev").addText((text) => text.setPlaceholder("Enter your client ID").setValue(this.plugin.settings.spotify_client_id).onChange(async (value) => {
      this.plugin.settings.spotify_client_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Spotify Client secret").setDesc("Find it in your spotify dev").addText((text) => text.setPlaceholder("Enter your client secret").setValue(this.plugin.settings.spotify_client_secret).onChange(async (value) => {
      this.plugin.settings.spotify_client_secret = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("Spotify auth").setCta().onClick(async () => {
      sharedstuff.get("spotify_auth_login_function")(this.plugin.settings.spotify_client_id, manifest);
    }));
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("Spotify logout").setCta().onClick(async () => {
      sharedstuff.get("spotify_auth_logout_function")(manifest, this.plugin);
    }));
  }
};
