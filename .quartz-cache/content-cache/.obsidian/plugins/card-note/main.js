/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-excalidraw-plugin/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-excalidraw-plugin/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getEA2 = (view) => {
      try {
        return window.ExcalidrawAutomate.getAPI(view);
      } catch (e) {
        console.log({ message: "Excalidraw not available", fn: getEA2 });
        return null;
      }
    };
    exports.getEA = getEA2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CardNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/dragUpdate.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");

// src/utility.ts
var BLOCKIDREPLACE = () => /[^a-zA-Z\d-]+/g;
var FILENAMEREPLACE = () => /[!"#$%&()*+,.:;<=>?@^`{|}~/[\]\\\r\n]/g;
var HEADINGREPLACE = () => /([:#|^\\\r\n]|%%|\[\[|]])/g;
var getCacheOffset = (c) => {
  const cacheStart = c.position.start.offset, cacheEnd = c.position.end.offset;
  return [cacheStart, cacheEnd];
};
function throttle(cb, secondTimeout = 0) {
  let timer = false;
  let result;
  return (...args) => {
    if (!timer) {
      timer = true;
      setTimeout(() => {
        timer = false;
      }, 1e3 * secondTimeout);
      result = cb(...args);
    }
    return result;
  };
}
var LineBreak = "\n";
var MarkdownFileExtension = ".md";
function isBreak(name) {
  return name === void 0;
}
function createFullPath(file) {
  const fileName = `${file.fileName}${file.extension}`;
  return file.folderPath.length === 0 ? fileName : `${file.folderPath}/${fileName}`;
}
async function ReCheck(config) {
  let errorMessage;
  let args = config.create();
  let result;
  while (true) {
    try {
      result = await config.provide(args, result, errorMessage);
      if (isBreak(result)) {
        return result;
      }
      const validResult = await config.check(result);
      if (validResult instanceof Error) {
        throw validResult;
      } else {
        return validResult;
      }
    } catch (error) {
      args = config.update(args);
      errorMessage = error.message;
      continue;
    }
  }
}
var LIST = /^([ \t]*)(?<listSymbol>[*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
var TASK = /^([ \t]*)(?<task>\[.\])?( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
function listItemParser(text2) {
  const match = LIST.exec(text2);
  if (match) {
    const groups = match.groups, listSymbol = groups == null ? void 0 : groups.listSymbol, item = groups == null ? void 0 : groups.item;
    if (item) {
      const taskMatch = TASK.exec(item), taskGroups = taskMatch == null ? void 0 : taskMatch.groups, task = taskGroups == null ? void 0 : taskGroups.task, taskItem = taskGroups == null ? void 0 : taskGroups.item;
      return task ? {
        type: "task",
        listSymbol,
        task,
        item: taskItem != null ? taskItem : ""
      } : {
        type: "list",
        listSymbol,
        item
      };
    } else {
      return {
        type: "list",
        listSymbol,
        item: ""
      };
    }
  }
}
var WIKILINK = () => new RegExp(/^(?<left>!?\[\[)(?<link>.*?)(?<display>\|(?<displayText>.*))?(?<right>]])$/);
var MARKDOWNLINK = () => /^(?<left>!?\[)(?<displayText>.*?)(?<mid>]\(\s*)(?<link>[^ ]+)(?<right>(?:\s+.*?)?\))$/;
function UpdateLinkText(sourcePath, linkInfo, newPath) {
  const linkMatch = [
    {
      regex: WIKILINK(),
      newText: (match, path) => {
        var _a, _b, _c, _d;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.display) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${path}${display}${(_d = match.groups) == null ? void 0 : _d.right}`;
      }
    },
    {
      regex: MARKDOWNLINK(),
      newText(match, path) {
        var _a, _b, _c, _d, _e;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.displayText) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${display}${(_d = match.groups) == null ? void 0 : _d.mid}${path}${(_e = match.groups) == null ? void 0 : _e.right}`;
      }
    }
  ];
  for (const r of linkMatch) {
    const match = r.regex.exec(linkInfo.link.original);
    if (match) {
      const np = newPath(linkInfo);
      const newText = r.newText(match, np);
      return {
        change: newText,
        reference: linkInfo.link,
        sourcePath
      };
    }
  }
  return {
    change: `[[${newPath(linkInfo)}]]`,
    reference: linkInfo.link,
    sourcePath
  };
}
function LinkToChanges(linkMap, newPath) {
  const change = {
    data: {},
    keys: () => Object.keys(change.data),
    add: (key, value) => {
      const values = change.data[key];
      if (values && !values.contains(value)) {
        if (!values.contains(value)) {
          values.push(value);
        }
      } else {
        change.data[key] = [value];
      }
    },
    remove: (key, value) => {
      const values = change.data[key];
      values == null ? void 0 : values.remove(value);
    },
    removeKey: (key) => {
      delete change.data[key];
    },
    get: (key) => change.data[key],
    clear: (key) => change.removeKey(key),
    clearAll: () => {
      change.data = {};
    },
    contains: (key, value) => {
      var _a;
      return (_a = change.data[key]) == null ? void 0 : _a.contains(value);
    },
    count: () => {
      let c = 0;
      for (const key in change.data) {
        const len = change.data[key].length;
        c += len;
      }
      return c;
    }
  };
  linkMap.forEach((value, key) => {
    const changeInfo = value.map((text2) => UpdateLinkText(key, text2, newPath));
    change.data[key] = changeInfo;
  });
  return change;
}
var reverseRelative = /* @__PURE__ */ new Map([
  ["top", "bottom"],
  ["right", "left"],
  ["bottom", "top"],
  ["left", "right"]
]);
function getRelativePosition(center, relative) {
  const { x: xStart, y: yStart, width, height } = center;
  const xEnd = xStart + width, yEnd = yStart + height;
  const { x: xR, y: yR, width: Rwidth } = relative;
  const xREnd = xR + Rwidth;
  return xR >= xEnd ? "right" : xREnd <= xStart ? "left" : yR <= yStart ? "top" : yR >= yEnd ? "bottom" : void 0;
}

// src/dragUpdate.ts
var import_obsidian3 = require("obsidian");

// src/ui.ts
var import_obsidian = require("obsidian");
var FileNameCheckModal = class extends import_obsidian.Modal {
  constructor(config) {
    super(config.plugin.app);
    this.getNameDesc = (fileName, blockName) => {
      const frag = document.createDocumentFragment();
      frag.createDiv().innerText = `Create file ${fileName}`;
      if (blockName) {
        frag.createDiv().innerText = `or`;
        frag.createDiv().innerText = `Link to block ${fileName}`;
      }
      return frag;
    };
    this.plugin = config.plugin;
    this.userInput = config.name;
    this.section = config.section;
    this.onSubmit = config.onSubmit;
    this.errorMessage = config.errorMessage;
  }
  onOpen() {
    const linkReferenceDescription = this.section.type === "reference" ? isHeadingBlock(this.section.block) ? " or link to heading" : " or link to block" : "";
    const { contentEl } = this;
    let userInputText;
    const nameSetting = new import_obsidian.Setting(contentEl).setDesc(`Create file${linkReferenceDescription}`).addText((text2) => {
      var _a;
      userInputText = text2;
      text2.setValue((_a = this.userInput) != null ? _a : "");
      text2.onChange((value) => {
        this.userInput = value;
      });
    }).addButton((btn) => {
      btn.setIcon("dices").setTooltip("Create random block id").setCta().onClick(() => {
        this.userInput = this.plugin.createRandomHexString();
        userInputText == null ? void 0 : userInputText.setValue(this.userInput);
      });
    });
    const actions = new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setIcon("file-plus-2").setTooltip("Create file").setCta().onClick(() => {
        this.onSubmit({ type: "createFile", newName: this.userInput.trimEnd() });
        this.close();
      });
    });
    if (this.section.type === "reference") {
      const section = this.section;
      actions.addButton((btn) => {
        btn.setIcon("link").setTooltip("Link to reference").setCta().onClick(() => {
          this.onSubmit({
            type: "linkToReference",
            section,
            newName: this.userInput.trimEnd()
          });
          this.close();
        });
      });
    }
    actions.addButton((btn) => {
      btn.setIcon("scissors").setTooltip("Cut").setCta().onClick(() => {
        this.onSubmit({ type: "cut" });
        this.close();
      });
    }).addButton((btn) => {
      btn.setIcon("x").setTooltip(`Cancel`).setCta().onClick(() => {
        this.onSubmit({ type: "cancel" });
        this.close();
      });
    });
    if (this.errorMessage) {
      actions.setDesc(this.errorMessage);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  trySetDescription(setting, desc) {
    try {
      setting == null ? void 0 : setting.setDesc(desc);
    } catch (e) {
      console.log("expect set description before closing Modal", e);
    }
  }
  debounce(fn, sec) {
    let timer;
    return (...arg) => {
      clearTimeout(timer);
      return new Promise((resolve) => {
        timer = setTimeout(() => {
          const res = fn(...arg);
          resolve(res);
        }, sec * 1e3);
      });
    };
  }
  parseToValidFile(text2) {
    return text2.replace(FILENAMEREPLACE(), "");
  }
  parseToValidBlockName(text2) {
    if (this.section.type === "reference") {
      const block = this.section.block;
      return isHeadingBlock(block) ? text2 : text2.replace(BLOCKIDREPLACE(), "");
    }
  }
};

// src/adapters/obsidian-excalidraw-plugin/index.ts
var import_obsidian2 = require("obsidian");
var import_obsidian_excalidraw_plugin = __toESM(require_lib());
var VIEW_TYPE_EXCALIDRAW = "excalidraw";
function getEA(view) {
  return (0, import_obsidian_excalidraw_plugin.getEA)(view);
}
function isExcalidrawView(view) {
  return view.getViewType() === VIEW_TYPE_EXCALIDRAW;
}
var MAX_IMAGE_SIZE = 500;
async function insertEmbeddableOnDrawing(event, view, fileLink, file, plugin) {
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addEmbeddable(
      pos.x,
      pos.y,
      MAX_IMAGE_SIZE,
      MAX_IMAGE_SIZE,
      fileLink,
      file
    );
    await ea.addElementsToView(false, true, true);
    ea.selectElementsInView([id]);
    return id;
  } catch (error) {
    console.log(error);
  }
}
async function createTextOnDrawing(event, view, text2, plugin) {
  var _a, _b, _c, _d, _e;
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const appState = view.excalidrawAPI.getAppState();
    ea.style.strokeColor = (_a = appState.currentItemStrokeColor) != null ? _a : "black";
    ea.style.opacity = (_b = appState.currentItemOpacity) != null ? _b : 1;
    ea.style.fontFamily = (_c = appState.currentItemFontFamily) != null ? _c : 1;
    ea.style.fontSize = (_d = appState.currentItemFontSize) != null ? _d : 20;
    ea.style.textAlign = (_e = appState.currentItemTextAlign) != null ? _e : "left";
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addText(
      pos.x,
      pos.y,
      text2
    );
    await view.addElements(ea.getElements(), false, true, void 0, true);
    return id;
  } catch (error) {
    console.log(error);
  }
}
async function addLink(fromNodeId, toNodeId, view, plugin) {
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    ea.copyViewElementsToEAforEditing(ea.getViewElements());
    const edgeId = ea.connectObjects(fromNodeId, null, toNodeId, null, {
      startArrowHead: plugin.arrowToFrom() ? "arrow" : null,
      endArrowHead: plugin.arrowToEnd() ? "arrow" : null
    });
    const label = plugin.settings.defaultLinkLabel;
    if (label) {
      const labelId = ea.addLabelToLine(edgeId, label);
      const edge = ea.elementsDict[edgeId];
      edge.boundElements.push(
        {
          type: "text",
          id: labelId
        }
      );
      const labelElement = ea.elementsDict[labelId];
      labelElement.containerId = edgeId;
      labelElement.angle = 0;
    }
    await ea.addElementsToView(false, true, true);
  } catch (error) {
    console.log(error);
  }
}

// src/adapters/obsidian/index.ts
var OBSIDIAN_CANVAS = "canvas";
function isObsidianCanvasView(view) {
  return (view == null ? void 0 : view.getViewType()) === OBSIDIAN_CANVAS;
}
function isCanvasFileNode(node) {
  return "file" in node && "canvas" in node;
}
function isCanvasEditorNode(node) {
  return node ? ("file" in node || "text" in node) && "id" in node : false;
}
function getOffset(node) {
  const child = isCanvasFileNode(node) ? node.child : void 0;
  return child === void 0 ? 0 : (child == null ? void 0 : child.before.length) + (child == null ? void 0 : child.heading.length);
}

// src/dragUpdate.ts
function isNamedBlock(block) {
  return "name" in block && block.name !== void 0;
}
function isHeadingBlock(block) {
  return "type" in block && block.type === "heading";
}
function isListBlock(block) {
  return "type" in block && block.type === "list";
}
function getSelectOffset(select) {
  var _a;
  if (select.type === "line" && ((_a = select.section) == null ? void 0 : _a.type) === "reference") {
    const pos = select.section.block.cache.position;
    return {
      from: pos.start.offset - select.textOffset,
      to: pos.end.offset - select.textOffset
    };
  } else {
    return {
      from: select.selection.from,
      to: select.selection.to
    };
  }
}
function getLinkBlocks(select, file, plugin) {
  const textOffset = select.textOffset;
  if (!file) {
    return [[], []];
  } else if (select.type === "mutiple") {
    const res = select.selections.map((sel) => plugin.findLinkBlocks(file, sel.from + textOffset, sel.to + textOffset));
    const blocks = res.flatMap((r) => r[0]);
    const headings = res.flatMap((r) => r[1]);
    return [blocks, headings];
  } else {
    const { from, to } = getSelectOffset(select);
    return plugin.findLinkBlocks(file, from + textOffset, to + textOffset);
  }
}
async function userAction(plugin, section, selected) {
  const folderPath = plugin.settings.defaultFolder;
  const getUserRename = (config) => {
    return new Promise((resolve) => {
      const onSubmit = (action2) => {
        resolve({ ...action2 });
      };
      new FileNameCheckModal({ ...config, onSubmit }).open();
    });
  };
  const provide = async (arg, unvalid, error) => {
    if ((unvalid == null ? void 0 : unvalid.type) !== "cancel" && (unvalid == null ? void 0 : unvalid.type) !== "cut") {
      const newName = unvalid == null ? void 0 : unvalid.newName;
      const name = newName && newName.length !== 0 ? newName : arg.name;
      return getUserRename({ ...arg, name, errorMessage: error });
    }
  };
  const check = async (value) => {
    if (value.type !== "cancel" && value.type !== "cut") {
      const newName = value.newName;
      if (value.type === "createFile") {
        const file = await plugin.checkFileName({ folderPath, fileName: newName, extension: MarkdownFileExtension });
        return file instanceof Error ? file : { ...value, file };
      }
      if (value.type === "linkToReference") {
        const findUnvalidBlockSymbol = () => BLOCKIDREPLACE().exec(value.newName);
        return isHeadingBlock(value.section.block) ? value : findUnvalidBlockSymbol() ? new Error("Block id only accept alphanumeric and -") : value;
      }
    }
    return value;
  };
  const action = await ReCheck({
    create() {
      var _a;
      const getDefault = () => {
        return selected.content.split(LineBreak, 1)[0].substring(0, 20).trim();
      };
      const defulatName = section.type === "reference" ? isNamedBlock(section.block) ? section.block.name : isListBlock(section.block) ? (_a = listItemParser(selected.content)) == null ? void 0 : _a.item : getDefault() : getDefault();
      return {
        plugin,
        section,
        name: defulatName != null ? defulatName : ""
      };
    },
    update(prev) {
      return prev;
    },
    provide,
    check
  });
  return action;
}
function getSection(source, selected, plugin) {
  var _a, _b, _c;
  const sourceFile = getFile(source);
  if (sourceFile instanceof import_obsidian3.TFile && selected.type !== "mutiple") {
    const offset = (_a = source == null ? void 0 : source.offset) != null ? _a : 0;
    const fileCache = plugin.app.metadataCache.getFileCache(sourceFile), matchStart = (block2) => {
      const start = selected.selection.from + offset;
      return block2.position.start.offset === start;
    }, touch = (block2) => {
      const start = selected.selection.from + offset, end = selected.selection.to + offset, blockStart = block2.position.start.offset, blockEnd = block2.position.end.offset;
      return blockEnd > start && blockEnd <= end || blockStart >= start && blockStart < end;
    }, findCorrespondBlock = () => {
      var _a2;
      const start = selected.selection.from + offset;
      const block2 = (_a2 = fileCache == null ? void 0 : fileCache.sections) == null ? void 0 : _a2.find((cache) => {
        if (cache.type === "list") {
          return cache.position.start.offset <= start && start <= cache.position.end.offset;
        } else {
          return matchStart(cache);
        }
      });
      return block2;
    };
    const blockCache = findCorrespondBlock(), getList = () => {
      var _a2;
      const listItem = (_a2 = fileCache == null ? void 0 : fileCache.listItems) == null ? void 0 : _a2.find((item) => {
        const listStartPosition = item.position.start, listEndPosition = item.position.end, listStart = listStartPosition.offset, listEnd = listEndPosition.offset, listLineStart = listStart - listStartPosition.col, selectStart = selected.selection.from + offset, selectEnd = selected.selection.to + offset;
        return selectStart >= listLineStart && (listStart >= selectStart && listEnd <= selectEnd);
      });
      if (listItem) {
        return {
          type: "list",
          cache: listItem,
          name: listItem.id
        };
      }
    }, getHeading = () => {
      var _a2;
      const heading = (_a2 = fileCache == null ? void 0 : fileCache.headings) == null ? void 0 : _a2.find(matchStart);
      if (heading) {
        return {
          type: "heading",
          name: heading == null ? void 0 : heading.heading,
          cache: heading
        };
      }
    }, getBlock = () => {
      if (blockCache) {
        if (blockCache.type === "list") {
          return getList();
        } else if (blockCache.type === "heading") {
          return getHeading();
        } else {
          return blockCache.id ? {
            type: "linkBlock",
            cache: blockCache,
            name: blockCache.id
          } : {
            cache: blockCache
          };
        }
      }
    };
    const block = (_c = (_b = getList()) != null ? _b : getHeading()) != null ? _c : getBlock();
    return block ? {
      type: "reference",
      block,
      file: sourceFile
    } : {
      type: "unreference"
    };
  } else {
    return {
      type: "unreference"
    };
  }
}
function fileUpdateObserver(plugin, file) {
  let res, waiting = [];
  const metadataCache = plugin.app.metadataCache;
  const e = metadataCache.on("changed", (changeFile, data, cache) => {
    if (changeFile === file) {
      const r = {
        file: changeFile,
        data,
        cache
      };
      res = Promise.resolve(r);
      waiting.forEach((resolve) => resolve(r));
      waiting = [];
    }
  });
  return {
    getUpdate: () => res != null ? res : new Promise((resolve) => {
      waiting.push(resolve);
    }),
    close: () => metadataCache.offref(e)
  };
}
async function onFilesUpdated(plugin, files, on, timeLimited) {
  const time = timeLimited * files.length, observers = files.map((file) => fileUpdateObserver(plugin, file)), closeObserver = () => observers.forEach((ob) => ob.close()), update2 = observers.map((ob) => ob.getUpdate());
  return new Promise((resolve, reject) => {
    resolve(Promise.all(update2).then((data) => {
      closeObserver();
      on(data);
    }));
    setTimeout(() => {
      closeObserver();
      reject(`files: ${files.map((file) => file.path)} are not detected in ${time} seconds, `);
    }, 1e3 * time);
  });
}
function getFile(ed) {
  const hasFile = (fe) => {
    return "file" in fe;
  };
  if ((ed == null ? void 0 : ed.fileEditor) && hasFile(ed.fileEditor)) {
    return ed.fileEditor.file;
  }
}
async function extractSelect(action, extract, view, activeFile, whiteboard, plugin) {
  const updateInternalLinks = async (sourceFile, createNewPath, match, updateAfterDraw) => {
    var _a;
    const linksInFiles = plugin.findLinks(sourceFile, match);
    onFilesUpdated(plugin, updateAfterDraw, async (data) => {
      const [selfLinks, _2] = await linksInFiles;
      if (selfLinks) {
        const linksSet = selfLinks.map((l) => l.link.link);
        const res = /* @__PURE__ */ new Map();
        data.map((d) => {
          var _a2, _b;
          const links = (_a2 = d.cache.links) != null ? _a2 : [];
          const embeds = (_b = d.cache.embeds) != null ? _b : [];
          const all = links.concat(embeds);
          const linkRef = all.filter((cache) => linksSet.contains(cache.link)).map(plugin.createLinkInfo);
          return {
            file: d.file.path,
            linkRef
          };
        }).forEach((d) => {
          if (d.linkRef.length > 0) {
            res.set(d.file, d.linkRef);
          }
        });
        plugin.updateInternalLinks(res, (text2) => {
          const newPath = createNewPath({ path: text2.path, subpath: text2.subpath });
          return `${newPath.path}${newPath.subpath}`;
        });
      }
    }, 10);
    const [_, outer] = await linksInFiles;
    const canvasHasMatchLinks = plugin.getCanvas((canvasPath, embed) => {
      var _a2;
      const subpath = embed.subpath;
      return match({ path: (_a2 = embed.file) != null ? _a2 : "", subpath });
    });
    const whiteboardPath = (_a = whiteboard.located.file) == null ? void 0 : _a.path, updateLinksInDraw = () => {
      whiteboard.updateLinks({
        getNewPath: createNewPath,
        linkMatch: match
      });
    };
    if (outer.has(whiteboardPath != null ? whiteboardPath : "")) {
      outer.delete(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    } else if (canvasHasMatchLinks.contains(whiteboardPath != null ? whiteboardPath : "")) {
      canvasHasMatchLinks.remove(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    }
    plugin.updateInternalLinks(outer, (text2) => {
      const newPath = createNewPath({ path: text2.path, subpath: text2.subpath });
      return `${newPath.path}${newPath.subpath}`;
    });
    plugin.updateCanvasLinks(canvasHasMatchLinks, (node) => {
      if (match({ path: node.file, subpath: node.subpath })) {
        const newPath = createNewPath({ path: node.file, subpath: node.subpath });
        return {
          ...node,
          file: newPath.path + MarkdownFileExtension,
          subpath: newPath.subpath
        };
      }
      return node;
    });
  };
  if (action.type === "createFile") {
    const updateConfig = () => {
      const sourceFile = getFile(activeFile);
      if (sourceFile) {
        const match = (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && subpathSet.contains(link.subpath);
        const createNewPath = (oldPath) => {
          return plugin.createLinkText(newFile, oldPath.subpath, oldPath.displayText);
        };
        const [blocks, headings] = getLinkBlocks(extract, sourceFile, plugin);
        const subpathSet = [...blocks.map((block) => `#^${block.id}`), ...headings.map((cache) => `#${plugin.normalizeHeadingToLinkText(cache.heading)}`)];
        return {
          sourceFile,
          match,
          createNewPath,
          subpathSet
        };
      }
    };
    const config = updateConfig();
    const filePath = action.file.fileName;
    const newFile = await plugin.app.vault.create(filePath, extract.content);
    const newFileLink = plugin.createLinkText(newFile);
    const replaceTextWithLink = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract), insert: newFileLink.text } : extract.selections.map((line) => {
          return { from: line.from, to: line.to, insert: newFileLink.text };
        })
      });
      view.dispatch(trans);
    };
    replaceTextWithLink();
    if (config && config.subpathSet.length !== 0) {
      const { sourceFile, createNewPath, match } = config;
      await updateInternalLinks(sourceFile, createNewPath, match, [sourceFile, newFile]);
    }
    whiteboard.draw(newFileLink);
  } else if (action.type === "linkToReference") {
    const block = action.section.block, sourceFile = action.section.file;
    const name = action.newName;
    const subpath = isHeadingBlock(block) ? {
      symbol: "#",
      path: plugin.normalizeHeadingToLinkText(name)
    } : {
      symbol: "#^",
      path: name
    };
    const oldBlock = isNamedBlock(block) ? block : void 0;
    const newPath = plugin.createLinkText(sourceFile, subpath.symbol + subpath.path);
    if (oldBlock) {
      const reName = () => oldBlock.name !== name;
      if (reName()) {
        const oldName = oldBlock.name, oldPath = isHeadingBlock(oldBlock) ? "#" + plugin.normalizeHeadingToLinkText(oldName) : "#^" + oldName, from = block.cache.position.end.offset - extract.textOffset - oldName.length, to = block.cache.position.end.offset - extract.textOffset;
        const trans = view.state.update({
          changes: { from, to, insert: subpath.path }
        });
        view.dispatch(trans);
        await updateInternalLinks(
          sourceFile,
          (old) => newPath,
          (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && link.subpath === oldPath,
          [sourceFile]
        );
      }
    } else {
      const insertNamePosition = block.cache.position.end.offset - extract.textOffset;
      const trans = view.state.update({
        changes: { from: insertNamePosition, insert: " ^" + name }
      });
      view.dispatch(trans);
    }
    whiteboard.draw(newPath);
  } else {
    const deleteText = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract) } : extract.selections.map((line) => {
          return { from: line.from, to: line.to };
        })
      });
      view.dispatch(trans);
    };
    deleteText();
    whiteboard.draw(extract.content);
  }
}
var dragExtension = (plugin) => {
  const addDragStartEvent = (dragSymbol, view) => {
    let info;
    let source;
    let listener;
    const handleDrop = async (e) => {
      const createFileAndDraw = async (whiteboard) => {
        var _a;
        const section = info.type === "line" && info.section ? info.section : getSection(source, info, plugin);
        const action = await userAction(plugin, section, info);
        if (!isBreak(action) && action.type !== "cancel") {
          extractSelect(
            action,
            { ...info, textOffset: (_a = source == null ? void 0 : source.offset) != null ? _a : 0 },
            view,
            source,
            whiteboard,
            plugin
          );
        }
      };
      const drawView = plugin.getDropView(e);
      if (isExcalidrawView(drawView)) {
        createFileAndDraw(
          {
            located: drawView,
            draw: async (target) => {
              const createNode = typeof target === "string" ? createTextOnDrawing(e, drawView, target, plugin) : insertEmbeddableOnDrawing(e, drawView, target.text, target.file, plugin);
              if (plugin.settings.autoLink && isCanvasEditorNode(source == null ? void 0 : source.fileEditor)) {
                const createNodeId = await createNode;
                if (createNodeId) {
                  await addLink(source.fileEditor.id, createNodeId, drawView, plugin);
                }
              }
            },
            updateLinks: (para) => {
              const { linkMatch, getNewPath } = para;
              const nodes = Array.from(drawView.canvasNodeFactory.nodes.entries()).map((value) => {
                const [id, refNode] = value;
                const getLinkInfo = (node) => {
                  return { path: node.filePath, subpath: node.subpath };
                };
                if (isCanvasFileNode(refNode) && linkMatch(getLinkInfo(refNode))) {
                  return { id, link: getNewPath(getLinkInfo(refNode)) };
                }
              }).filter((v) => v !== void 0);
              nodes.forEach(
                (node) => {
                  const elements = drawView.excalidrawAPI.getSceneElements().filter((e2) => e2.id === node.id);
                  elements.forEach((elem) => {
                    drawView.excalidrawData.elementLinks.set(node.id, node.link.text);
                    ExcalidrawLib.mutateElement(elem, { link: node.link.text });
                  });
                }
              );
              drawView.setDirty(99);
              drawView.updateScene({});
            }
          }
        );
      } else if (isObsidianCanvasView(drawView)) {
        const pos = drawView.canvas.posFromEvt(e);
        createFileAndDraw({
          located: drawView,
          draw: async (target) => {
            const dropCanvas = drawView.canvas;
            const createNode = typeof target === "string" ? dropCanvas.createTextNode({
              text: target,
              pos,
              save: false
            }) : dropCanvas.createFileNode({
              file: target.file,
              pos,
              subpath: target.subpath,
              save: false
            });
            if (plugin.settings.autoLink && isCanvasEditorNode(source == null ? void 0 : source.fileEditor)) {
              const fromSide = getRelativePosition(source.fileEditor, createNode);
              if (fromSide && reverseRelative.has(fromSide)) {
                const toSide = reverseRelative.get(fromSide);
                const edgeID = plugin.createRandomHexString(16);
                const fromEnd = plugin.arrowToFrom() ? "arrow" : "none";
                const toEnd = plugin.arrowToEnd() ? "arrow" : "none";
                const label = plugin.settings.defaultLinkLabel;
                const edgeSample = dropCanvas.edges.values().next().value;
                if (edgeSample) {
                  const e2 = new edgeSample.constructor(
                    dropCanvas,
                    edgeID,
                    { side: fromSide, node: source.fileEditor, end: fromEnd },
                    { side: toSide, node: createNode, end: toEnd }
                  );
                  e2.setLabel(label);
                  dropCanvas.addEdge(e2);
                  e2.attach();
                  e2.render();
                } else {
                  const data = dropCanvas.getData();
                  dropCanvas.importData({
                    nodes: data.nodes,
                    edges: [...data.edges, {
                      id: edgeID,
                      fromNode: source.fileEditor.id,
                      fromSide,
                      fromEnd,
                      toNode: createNode.id,
                      toSide,
                      toEnd,
                      label
                    }]
                  });
                }
              }
            } else {
              await dropCanvas.requestFrame();
            }
            dropCanvas.requestSave();
          },
          updateLinks: (para) => {
            const { linkMatch, getNewPath } = para;
            drawView.canvas.nodes.forEach((node, id) => {
              var _a;
              const path = (node2) => ({
                path: node2.filePath,
                file: node2.file,
                subpath: node2.subpath
              });
              if (isCanvasFileNode(node) && linkMatch(path(node))) {
                const newPath = getNewPath(path(node));
                node.setFilePath(newPath.file.path, (_a = newPath.subpath) != null ? _a : "");
              }
            });
            drawView.canvas.requestSave();
          }
        });
      }
    };
    dragSymbol.addEventListener("dragstart", (e) => {
      source = plugin.getActiveEditorFile();
      const getSelection = () => {
        const selectLines = view.state.selection.ranges.map((range) => ({
          from: range.from,
          to: range.to
        }));
        const content = selectLines.map((range) => {
          return view.state.sliceDoc(range.from, range.to);
        }).join().trim();
        return { content, selectLines };
      };
      const getLineString = () => {
        var _a;
        const statefield = view.state.field(dragSymbolSet);
        const start = statefield.iter().from;
        const doc = view.state.doc;
        const line = view.state.doc.lineAt(start);
        const foldableRange = (0, import_language.foldable)(view.state, line.from, line.to);
        if (foldableRange) {
          return {
            type: "foldable",
            startLine: line,
            selection: {
              from: line.from,
              to: foldableRange.to
            },
            content: doc.sliceString(line.from, foldableRange.to)
          };
        } else {
          const selected = {
            type: "line",
            line,
            selection: {
              from: line.from,
              to: line.to
            }
          };
          const referenceTextOffset = (_a = source == null ? void 0 : source.offset) != null ? _a : 0;
          const section = getSection(source, { ...selected, content: "" }, plugin);
          const content = section && section.type === "reference" ? doc.sliceString(
            section.block.cache.position.start.offset - referenceTextOffset,
            section.block.cache.position.end.offset - referenceTextOffset
          ) : line.text;
          return {
            ...selected,
            content,
            section
          };
        }
      };
      const defaultSelect = getSelection();
      info = defaultSelect.content.length === 0 ? getLineString() : defaultSelect.selectLines.length === 1 ? { type: "single", selection: defaultSelect.selectLines.first(), content: defaultSelect.content } : { type: "mutiple", selections: defaultSelect.selectLines, content: defaultSelect.content };
      setTimeout(() => {
        listener = plugin.listenDragAndDrop(e, info.content, handleDrop);
      });
    });
    return {
      reset: () => listener == null ? void 0 : listener.reset()
    };
  };
  const dragMarker = new class extends import_view.GutterMarker {
    destroy(dom) {
    }
    toDOM(view) {
      const dragSymbol = document.createElement("div");
      dragSymbol.draggable = true;
      const symbol = dragSymbol.createSpan();
      symbol.innerText = plugin.settings.dragSymbol;
      symbol.style.fontSize = `${plugin.settings.dragSymbolSize}px`;
      const { reset } = addDragStartEvent(dragSymbol, view);
      dragSymbol.addEventListener("dragend", () => {
        reset();
      });
      return dragSymbol;
    }
  }();
  const mousemoveEffect = import_state.StateEffect.define({
    map: (val, mapping) => ({ from: mapping.mapPos(val.from), to: mapping.mapPos(val.to) })
  });
  const dragSymbolSet = import_state.StateField.define({
    create() {
      return import_state.RangeSet.empty;
    },
    update(set, transaction) {
      set = set.map(transaction.changes);
      for (const e of transaction.effects) {
        if (e.is(mousemoveEffect)) {
          set = import_state.RangeSet.of(dragMarker.range(e.value.from));
        }
      }
      return set;
    },
    //依此stateField狀態所需要更新的Extension都可以放在provide funciton中提供出來
    provide: (value) => {
      const gut = (0, import_view.gutter)({
        class: "cn-drag-symbol",
        markers: (v) => {
          const range_set = v.state.field(value);
          return v.state.doc.length !== 0 ? range_set : import_state.RangeSet.empty;
        },
        initialSpacer: () => dragMarker
      });
      return [gut];
    }
  });
  const addSymbolWhenMouseMove = (event, view) => {
    const pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    });
    if (pos) {
      const dragLine = view.state.field(dragSymbolSet);
      const line = view.lineBlockAt(pos);
      let hasDragPoint = false;
      dragLine.between(line.from, line.from, () => {
        hasDragPoint = true;
      });
      if (!hasDragPoint) {
        view.dispatch({
          effects: mousemoveEffect.of({ from: line.from, to: line.to })
        });
      }
    }
    return pos;
  };
  const mouseMoveWatch = import_view.EditorView.domEventHandlers({
    mousemove: (event, view) => {
      throttle(addSymbolWhenMouseMove, 0.2)(event, view);
    }
  });
  return [
    dragSymbolSet,
    mouseMoveWatch
  ];
};

// src/view/cardSearchView.ts
var import_obsidian10 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
  value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/await_block.js
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i) => {
          if (i !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i] === block2) {
                info.blocks[i] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then(
      (value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      },
      (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      }
    );
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = /** @type {T} */
    promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance8, create_fragment10, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance8 ? instance8(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/view/components/Search.svelte
var import_obsidian9 = require("obsidian");

// node_modules/svelte-window/src/timer.js
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now2 = hasNativePerformanceNow ? () => performance.now() : () => Date.now();
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  const start = now2();
  function tick2() {
    if (now2() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick2);
    }
  }
  const timeoutID = {
    id: requestAnimationFrame(tick2)
  };
  return timeoutID;
}

// node_modules/svelte-window/src/domHelpers.js
var size = -1;
function getScrollbarSize(recalculate = false) {
  if (size === -1 || recalculate) {
    const div = document.createElement("div");
    const style = div.style;
    style.width = "50px";
    style.height = "50px";
    style.overflow = "scroll";
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}

// node_modules/svelte-window/src/GridComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-duw07k", ".outerElement.svelte-duw07k{position:relative;overflow:auto;-webkit-overflow-scrolling:touch;will-change:transform}");
}
var get_default_slot_changes = (dirty) => ({ items: dirty[0] & /*items*/
256 });
var get_default_slot_context = (ctx) => ({ items: (
  /*items*/
  ctx[8]
) });
function create_fragment(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_default_slot_context
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "style", div0_style_value = "height: " + /*estimatedTotalHeight*/
      ctx[9] + "px;" + /*isScrolling*/
      (ctx[7] ? "pointer-events: 'none';" : "") + "width: " + /*estimatedTotalWidth*/
      ctx[10] + "px;");
      attr(div1, "class", div1_class_value = null_to_empty(
        /*className*/
        ctx[2]
      ) + " svelte-duw07k");
      attr(div1, "style", div1_style_value = "height:" + (typeof /*height*/
      ctx[4] === "number" ? (
        /*height*/
        ctx[4] + "px"
      ) : (
        /*height*/
        ctx[4]
      )) + ";width:" + (typeof /*width*/
      ctx[6] === "number" ? (
        /*width*/
        ctx[6] + "px"
      ) : (
        /*width*/
        ctx[6]
      )) + ";direction:" + /*direction*/
      ctx[3] + ";" + /*style*/
      (ctx[5] || ""));
      toggle_class(div1, "outerElement", true);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[49](div0);
      ctx[50](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "scroll",
          /*_onScroll*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*items*/
        256 | dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*estimatedTotalHeight, isScrolling, estimatedTotalWidth*/
      1664 && div0_style_value !== (div0_style_value = "height: " + /*estimatedTotalHeight*/
      ctx2[9] + "px;" + /*isScrolling*/
      (ctx2[7] ? "pointer-events: 'none';" : "") + "width: " + /*estimatedTotalWidth*/
      ctx2[10] + "px;")) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty[0] & /*className*/
      4 && div1_class_value !== (div1_class_value = null_to_empty(
        /*className*/
        ctx2[2]
      ) + " svelte-duw07k")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*height, width, direction, style*/
      120 && div1_style_value !== (div1_style_value = "height:" + (typeof /*height*/
      ctx2[4] === "number" ? (
        /*height*/
        ctx2[4] + "px"
      ) : (
        /*height*/
        ctx2[4]
      )) + ";width:" + (typeof /*width*/
      ctx2[6] === "number" ? (
        /*width*/
        ctx2[6] + "px"
      ) : (
        /*width*/
        ctx2[6]
      )) + ";direction:" + /*direction*/
      ctx2[3] + ";" + /*style*/
      (ctx2[5] || ""))) {
        attr(div1, "style", div1_style_value);
      }
      if (!current || dirty[0] & /*className*/
      4) {
        toggle_class(div1, "outerElement", true);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[49](null);
      ctx[50](null);
      mounted = false;
      dispose();
    }
  };
}
var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;
var defaultItemKey = ({ columnIndex, data, rowIndex }) => `${rowIndex}:${columnIndex}`;
function instance_1($$self, $$props, $$invalidate) {
  let itemKey_;
  let isScrollingRender;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { className = void 0 } = $$props;
  let { columnCount = void 0 } = $$props;
  let { columnWidth = void 0 } = $$props;
  let { direction = "ltr" } = $$props;
  let { height = void 0 } = $$props;
  let { initialScrollLeft = void 0 } = $$props;
  let { initialScrollTop = void 0 } = $$props;
  let { innerRef = void 0 } = $$props;
  let { innerElementType = void 0 } = $$props;
  let { innerTagName = void 0 } = $$props;
  let { itemData = void 0 } = $$props;
  let { itemKey = void 0 } = $$props;
  let { onItemsRendered = void 0 } = $$props;
  let { onScroll = void 0 } = $$props;
  let { outerRef = null } = $$props;
  let { outerElementType = void 0 } = $$props;
  let { outerTagName = void 0 } = $$props;
  let { overscanColumnCount = void 0 } = $$props;
  let { overscanColumnsCount = void 0 } = $$props;
  let { overscanCount = void 0 } = $$props;
  let { overscanRowCount = void 0 } = $$props;
  let { overscanRowsCount = void 0 } = $$props;
  let { rowCount = void 0 } = $$props;
  let { rowHeight = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { useIsScrolling = false } = $$props;
  let { width = void 0 } = $$props;
  let { specificFunctionProps } = $$props;
  const { getColumnOffset, getColumnStartIndexForOffset, getColumnStopIndexForStartIndex, getColumnWidth, getEstimatedTotalHeight, getEstimatedTotalWidth, getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment, getRowHeight, getRowOffset, getRowStartIndexForOffset, getRowStopIndexForStartIndex, initInstanceProps, shouldResetStyleCacheOnItemSizeChange } = specificFunctionProps;
  let _styleCache = {}, _styleCacheCheck = {};
  const _getItemStyleCache = (a, b, c) => {
    if (a === _styleCacheCheck.a && b === _styleCacheCheck.b && c === _styleCacheCheck.c) {
      return _styleCache;
    }
    _styleCacheCheck = { a, b, c };
    _styleCache = {};
    return _styleCache;
  };
  const instance8 = { _getItemStyleCache };
  let props;
  let isScrolling = false, horizontalScrollDirection = "forward", scrollLeft = typeof initialScrollLeft === "number" ? initialScrollLeft : 0, scrollTop = typeof initialScrollTop === "number" ? initialScrollTop : 0, scrollUpdateWasRequested = false, verticalScrollDirection = "forward", _instanceProps, _resetIsScrollingTimeoutId = null;
  let request_resetIsScrollingDebounced = false, request_getItemStyleCache = false, items = [], estimatedTotalHeight, estimatedTotalWidth;
  const scrollTo = ({ scrollLeft: scrollLeft_, scrollTop: scrollTop_ }) => {
    request_resetIsScrollingDebounced = true;
    if (scrollLeft_ !== void 0) {
      scrollLeft_ = Math.max(0, scrollLeft_);
    }
    if (scrollTop_ !== void 0) {
      scrollTop_ = Math.max(0, scrollTop_);
    }
    if (scrollLeft_ === void 0) {
      scrollLeft_ = scrollLeft;
    }
    if (scrollTop_ === void 0) {
      scrollTop_ = scrollTop;
    }
    if (scrollLeft === scrollLeft_ && scrollTop === scrollTop_) {
      return null;
    }
    $$invalidate(38, horizontalScrollDirection = scrollLeft < scrollLeft_ ? "forward" : "backward");
    $$invalidate(39, scrollLeft = scrollLeft_);
    $$invalidate(40, scrollTop = scrollTop_);
    scrollUpdateWasRequested = true;
    $$invalidate(41, verticalScrollDirection = scrollTop < scrollTop_ ? "forward" : "backward");
  };
  const scrollToItem = ({ align = "auto", columnIndex, rowIndex }) => {
    const scrollbarSize = getScrollbarSize();
    if (columnIndex !== void 0) {
      columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
    }
    if (rowIndex !== void 0) {
      rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
    }
    const estimatedTotalHeight2 = getEstimatedTotalHeight(props, _instanceProps);
    const estimatedTotalWidth2 = getEstimatedTotalWidth(props, _instanceProps);
    const horizontalScrollbarSize = estimatedTotalWidth2 > width ? scrollbarSize : 0;
    const verticalScrollbarSize = estimatedTotalHeight2 > height ? scrollbarSize : 0;
    scrollTo({
      scrollLeft: columnIndex !== void 0 ? getOffsetForColumnAndAlignment(props, columnIndex, align, scrollLeft, _instanceProps, verticalScrollbarSize) : scrollLeft,
      scrollTop: rowIndex !== void 0 ? getOffsetForRowAndAlignment(props, rowIndex, align, scrollTop, _instanceProps, horizontalScrollbarSize) : scrollTop
    });
  };
  onMount(() => {
    if (outerRef != null) {
      if (typeof initialScrollLeft === "number") {
        $$invalidate(1, outerRef.scrollLeft = initialScrollLeft, outerRef);
      }
      if (typeof initialScrollTop === "number") {
        $$invalidate(1, outerRef.scrollTop = initialScrollTop, outerRef);
      }
    }
    _callPropsCallbacks();
  });
  onDestroy(() => {
    if (_resetIsScrollingTimeoutId !== null) {
      cancelTimeout(_resetIsScrollingTimeoutId);
    }
  });
  let columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex;
  const render = () => {
    if (columnCount > 0 && rowCount) {
      $$invalidate(8, items.length = (rowStopIndex - rowStartIndex + 1) * (columnStopIndex - columnStartIndex + 1), items);
      let i = 0;
      for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
        for (let columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
          $$invalidate(
            8,
            items[i++] = {
              columnIndex,
              data: itemData,
              isScrolling: isScrollingRender,
              key: itemKey_({ columnIndex, data: itemData, rowIndex }),
              rowIndex,
              style: _getItemStyle(rowIndex, columnIndex)
            },
            items
          );
        }
      }
    }
    $$invalidate(9, estimatedTotalHeight = getEstimatedTotalHeight(props, _instanceProps));
    $$invalidate(10, estimatedTotalWidth = getEstimatedTotalWidth(props, _instanceProps));
  };
  let _onItemsRenderedCache = {}, _onScrollCache = {};
  const _callPropsCallbacks = () => {
    if (typeof onItemsRendered === "function") {
      if (columnCount > 0 && rowCount > 0) {
        const [
          overscanColumnStartIndex,
          overscanColumnStopIndex,
          visibleColumnStartIndex,
          visibleColumnStopIndex
        ] = _getHorizontalRangeToRender();
        const [
          overscanRowStartIndex,
          overscanRowStopIndex,
          visibleRowStartIndex,
          visibleRowStopIndex
        ] = _getVerticalRangeToRender();
        const ch2 = _onItemsRenderedCache;
        if (overscanColumnStartIndex !== ch2.overscanColumnStartIndex || overscanColumnStopIndex !== ch2.overscanColumnStopIndex || overscanRowStartIndex !== ch2.overscanRowStartIndex || overscanRowStopIndex !== ch2.overscanRowStopIndex || visibleColumnStartIndex !== ch2.visibleColumnStartIndex || visibleColumnStopIndex !== ch2.visibleColumnStopIndex || visibleRowStartIndex !== ch2.visibleRowStartIndex || visibleRowStopIndex !== ch2.visibleRowStopIndex) {
          onItemsRendered({
            overscanColumnStartIndex,
            overscanColumnStopIndex,
            overscanRowStartIndex,
            overscanRowStopIndex,
            visibleColumnStartIndex,
            visibleColumnStopIndex,
            visibleRowStartIndex,
            visibleRowStopIndex
          });
          _onItemsRenderedCache = {
            overscanColumnStartIndex,
            overscanColumnStopIndex,
            overscanRowStartIndex,
            overscanRowStopIndex,
            visibleColumnStartIndex,
            visibleColumnStopIndex,
            visibleRowStartIndex,
            visibleRowStopIndex
          };
        }
      }
    }
    const ch = _onScrollCache;
    if (typeof onScroll === "function" && !(scrollLeft === ch.scrollLeft && scrollTop === ch.scrollTop && horizontalScrollDirection === ch.horizontalScrollDirection && verticalScrollDirection === ch.verticalScrollDirection && scrollUpdateWasRequested === scrollUpdateWasRequested)) {
      onScroll({
        scrollLeft,
        scrollTop,
        horizontalScrollDirection,
        verticalScrollDirection,
        scrollUpdateWasRequested
      });
      _onScrollCache = {
        scrollLeft,
        scrollTop,
        horizontalScrollDirection,
        verticalScrollDirection,
        scrollUpdateWasRequested
      };
    }
  };
  const _getItemStyle = (rowIndex, columnIndex) => {
    const itemStyleCache = _getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);
    const key = `${rowIndex}:${columnIndex}`;
    let style2;
    if (itemStyleCache.hasOwnProperty(key)) {
      style2 = itemStyleCache[key];
    } else {
      const offset = getColumnOffset(props, columnIndex, _instanceProps);
      const isRtl = direction === "rtl";
      itemStyleCache[key] = style2 = {
        position: "absolute",
        left: isRtl ? void 0 : offset,
        right: isRtl ? offset : void 0,
        top: getRowOffset(props, rowIndex, _instanceProps),
        height: getRowHeight(props, rowIndex, _instanceProps),
        width: getColumnWidth(props, columnIndex, _instanceProps)
      };
    }
    return style2;
  };
  const _getHorizontalRangeToRender = () => {
    const overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;
    if (columnCount === 0 || rowCount === 0) {
      return [0, 0, 0, 0];
    }
    const startIndex = getColumnStartIndexForOffset(props, scrollLeft, _instanceProps);
    const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, _instanceProps);
    const overscanBackward = !isScrolling || horizontalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
    const overscanForward = !isScrolling || horizontalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
    return [
      Math.max(0, startIndex - overscanBackward),
      Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),
      startIndex,
      stopIndex
    ];
  };
  const _getVerticalRangeToRender = () => {
    const overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;
    if (columnCount === 0 || rowCount === 0) {
      return [0, 0, 0, 0];
    }
    const startIndex = getRowStartIndexForOffset(props, scrollTop, _instanceProps);
    const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, _instanceProps);
    const overscanBackward = !isScrolling || verticalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
    const overscanForward = !isScrolling || verticalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
    return [
      Math.max(0, startIndex - overscanBackward),
      Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),
      startIndex,
      stopIndex
    ];
  };
  const _onScroll = (event) => {
    const { clientHeight, clientWidth, scrollLeft: scrollLeft_, scrollTop: scrollTop_, scrollHeight, scrollWidth } = event.currentTarget;
    request_resetIsScrollingDebounced = true;
    if (scrollLeft === scrollLeft_ && scrollTop === scrollTop_) {
      return null;
    }
    let calculatedScrollLeft = scrollLeft_;
    if (direction === "rtl") {
      switch (getRTLOffsetType()) {
        case "negative":
          calculatedScrollLeft = -scrollLeft_;
          break;
        case "positive-descending":
          calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft_;
          break;
      }
    }
    calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
    const calculatedscrollTop = Math.max(0, Math.min(scrollTop_, scrollHeight - clientHeight));
    $$invalidate(7, isScrolling = true);
    $$invalidate(38, horizontalScrollDirection = scrollLeft < scrollLeft_ ? "forward" : "backward");
    $$invalidate(39, scrollLeft = calculatedScrollLeft);
    $$invalidate(40, scrollTop = calculatedscrollTop);
    $$invalidate(41, verticalScrollDirection = scrollTop < scrollTop_ ? "forward" : "backward");
    scrollUpdateWasRequested = false;
  };
  const _resetIsScrollingDebounced = () => {
    if (_resetIsScrollingTimeoutId !== null) {
      cancelTimeout(_resetIsScrollingTimeoutId);
    }
    _resetIsScrollingTimeoutId = requestTimeout(_resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
  };
  const _resetIsScrolling = () => {
    _resetIsScrollingTimeoutId = null;
    $$invalidate(7, isScrolling = false);
    $$invalidate(41, verticalScrollDirection = "");
    $$invalidate(38, horizontalScrollDirection = "");
    request_getItemStyleCache = true;
  };
  afterUpdate(() => {
    if (request_resetIsScrollingDebounced) {
      request_resetIsScrollingDebounced = false;
      _resetIsScrollingDebounced();
    }
    if (request_getItemStyleCache) {
      request_getItemStyleCache = false;
      _getItemStyleCache(-1);
    }
    if (scrollUpdateWasRequested && outerRef != null) {
      if (direction === "rtl") {
        switch (getRTLOffsetType()) {
          case "negative":
            $$invalidate(1, outerRef.scrollLeft = -scrollLeft, outerRef);
            break;
          case "positive-ascending":
            $$invalidate(1, outerRef.scrollLeft = scrollLeft, outerRef);
            break;
          default:
            const { clientWidth, scrollWidth } = outerRef;
            $$invalidate(1, outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft, outerRef);
            break;
        }
      } else {
        $$invalidate(1, outerRef.scrollLeft = Math.max(0, scrollLeft), outerRef);
      }
      $$invalidate(1, outerRef.scrollTop = Math.max(0, scrollTop), outerRef);
    }
    _callPropsCallbacks();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerRef = $$value;
      $$invalidate(0, innerRef);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      outerRef = $$value;
      $$invalidate(1, outerRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("columnCount" in $$props2)
      $$invalidate(12, columnCount = $$props2.columnCount);
    if ("columnWidth" in $$props2)
      $$invalidate(13, columnWidth = $$props2.columnWidth);
    if ("direction" in $$props2)
      $$invalidate(3, direction = $$props2.direction);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("initialScrollLeft" in $$props2)
      $$invalidate(14, initialScrollLeft = $$props2.initialScrollLeft);
    if ("initialScrollTop" in $$props2)
      $$invalidate(15, initialScrollTop = $$props2.initialScrollTop);
    if ("innerRef" in $$props2)
      $$invalidate(0, innerRef = $$props2.innerRef);
    if ("innerElementType" in $$props2)
      $$invalidate(16, innerElementType = $$props2.innerElementType);
    if ("innerTagName" in $$props2)
      $$invalidate(17, innerTagName = $$props2.innerTagName);
    if ("itemData" in $$props2)
      $$invalidate(18, itemData = $$props2.itemData);
    if ("itemKey" in $$props2)
      $$invalidate(19, itemKey = $$props2.itemKey);
    if ("onItemsRendered" in $$props2)
      $$invalidate(20, onItemsRendered = $$props2.onItemsRendered);
    if ("onScroll" in $$props2)
      $$invalidate(21, onScroll = $$props2.onScroll);
    if ("outerRef" in $$props2)
      $$invalidate(1, outerRef = $$props2.outerRef);
    if ("outerElementType" in $$props2)
      $$invalidate(22, outerElementType = $$props2.outerElementType);
    if ("outerTagName" in $$props2)
      $$invalidate(23, outerTagName = $$props2.outerTagName);
    if ("overscanColumnCount" in $$props2)
      $$invalidate(24, overscanColumnCount = $$props2.overscanColumnCount);
    if ("overscanColumnsCount" in $$props2)
      $$invalidate(25, overscanColumnsCount = $$props2.overscanColumnsCount);
    if ("overscanCount" in $$props2)
      $$invalidate(26, overscanCount = $$props2.overscanCount);
    if ("overscanRowCount" in $$props2)
      $$invalidate(27, overscanRowCount = $$props2.overscanRowCount);
    if ("overscanRowsCount" in $$props2)
      $$invalidate(28, overscanRowsCount = $$props2.overscanRowsCount);
    if ("rowCount" in $$props2)
      $$invalidate(29, rowCount = $$props2.rowCount);
    if ("rowHeight" in $$props2)
      $$invalidate(30, rowHeight = $$props2.rowHeight);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
    if ("useIsScrolling" in $$props2)
      $$invalidate(31, useIsScrolling = $$props2.useIsScrolling);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("specificFunctionProps" in $$props2)
      $$invalidate(32, specificFunctionProps = $$props2.specificFunctionProps);
    if ("$$scope" in $$props2)
      $$invalidate(47, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, columnCount, columnWidth, direction, height, initialScrollLeft, initialScrollTop, innerElementType, innerTagName, itemData, itemKey, onItemsRendered, onScroll, outerElementType, outerTagName, overscanColumnCount, overscanColumnsCount, overscanCount, overscanRowCount, overscanRowsCount, rowCount, rowHeight, style, width*/
    2147479676 | $$self.$$.dirty[1] & /*useIsScrolling*/
    1) {
      $:
        $$invalidate(37, props = {
          className,
          columnCount,
          columnWidth,
          direction,
          height,
          initialScrollLeft,
          initialScrollTop,
          //innerRef,
          innerElementType,
          innerTagName,
          itemData,
          itemKey,
          onItemsRendered,
          onScroll,
          //outerRef,
          outerElementType,
          outerTagName,
          overscanColumnCount,
          overscanColumnsCount,
          overscanCount,
          overscanRowCount,
          overscanRowsCount,
          rowCount,
          rowHeight,
          style,
          useIsScrolling,
          width
        });
    }
    if ($$self.$$.dirty[1] & /*props*/
    64) {
      $:
        _instanceProps = instance8 && initInstanceProps(props, instance8);
    }
    if ($$self.$$.dirty[0] & /*itemKey*/
    524288) {
      $:
        itemKey_ = itemKey || defaultItemKey;
    }
    if ($$self.$$.dirty[1] & /*props, scrollLeft, horizontalScrollDirection*/
    448) {
      $:
        $$invalidate(42, [columnStartIndex, columnStopIndex] = _getHorizontalRangeToRender(props, scrollLeft, horizontalScrollDirection), columnStartIndex, ($$invalidate(43, columnStopIndex), $$invalidate(37, props), $$invalidate(39, scrollLeft), $$invalidate(38, horizontalScrollDirection), $$invalidate(2, className), $$invalidate(12, columnCount), $$invalidate(13, columnWidth), $$invalidate(3, direction), $$invalidate(4, height), $$invalidate(14, initialScrollLeft), $$invalidate(15, initialScrollTop), $$invalidate(16, innerElementType), $$invalidate(17, innerTagName), $$invalidate(18, itemData), $$invalidate(19, itemKey), $$invalidate(20, onItemsRendered), $$invalidate(21, onScroll), $$invalidate(22, outerElementType), $$invalidate(23, outerTagName), $$invalidate(24, overscanColumnCount), $$invalidate(25, overscanColumnsCount), $$invalidate(26, overscanCount), $$invalidate(27, overscanRowCount), $$invalidate(28, overscanRowsCount), $$invalidate(29, rowCount), $$invalidate(30, rowHeight), $$invalidate(5, style), $$invalidate(31, useIsScrolling), $$invalidate(6, width)));
    }
    if ($$self.$$.dirty[1] & /*props, scrollTop, verticalScrollDirection*/
    1600) {
      $:
        $$invalidate(44, [rowStartIndex, rowStopIndex] = _getVerticalRangeToRender(props, scrollTop, verticalScrollDirection), rowStartIndex, ($$invalidate(45, rowStopIndex), $$invalidate(37, props), $$invalidate(40, scrollTop), $$invalidate(41, verticalScrollDirection), $$invalidate(2, className), $$invalidate(12, columnCount), $$invalidate(13, columnWidth), $$invalidate(3, direction), $$invalidate(4, height), $$invalidate(14, initialScrollLeft), $$invalidate(15, initialScrollTop), $$invalidate(16, innerElementType), $$invalidate(17, innerTagName), $$invalidate(18, itemData), $$invalidate(19, itemKey), $$invalidate(20, onItemsRendered), $$invalidate(21, onScroll), $$invalidate(22, outerElementType), $$invalidate(23, outerTagName), $$invalidate(24, overscanColumnCount), $$invalidate(25, overscanColumnsCount), $$invalidate(26, overscanCount), $$invalidate(27, overscanRowCount), $$invalidate(28, overscanRowsCount), $$invalidate(29, rowCount), $$invalidate(30, rowHeight), $$invalidate(5, style), $$invalidate(31, useIsScrolling), $$invalidate(6, width)));
    }
    if ($$self.$$.dirty[0] & /*isScrolling*/
    128 | $$self.$$.dirty[1] & /*useIsScrolling*/
    1) {
      $:
        $$invalidate(46, isScrollingRender = useIsScrolling ? isScrolling : void 0);
    }
    if ($$self.$$.dirty[0] & /*columnCount, columnWidth, height, innerElementType, innerTagName, itemData, itemKey, outerElementType, outerTagName, rowCount, rowHeight, width*/
    1624191056 | $$self.$$.dirty[1] & /*columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex, useIsScrolling, isScrollingRender*/
    63489) {
      $: {
        render(columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex, columnCount, columnWidth, height, innerElementType, innerTagName, itemData, itemKey, outerElementType, outerTagName, rowCount, rowHeight, useIsScrolling, width, isScrollingRender);
      }
    }
  };
  return [
    innerRef,
    outerRef,
    className,
    direction,
    height,
    style,
    width,
    isScrolling,
    items,
    estimatedTotalHeight,
    estimatedTotalWidth,
    _onScroll,
    columnCount,
    columnWidth,
    initialScrollLeft,
    initialScrollTop,
    innerElementType,
    innerTagName,
    itemData,
    itemKey,
    onItemsRendered,
    onScroll,
    outerElementType,
    outerTagName,
    overscanColumnCount,
    overscanColumnsCount,
    overscanCount,
    overscanRowCount,
    overscanRowsCount,
    rowCount,
    rowHeight,
    useIsScrolling,
    specificFunctionProps,
    _getItemStyleCache,
    instance8,
    scrollTo,
    scrollToItem,
    props,
    horizontalScrollDirection,
    scrollLeft,
    scrollTop,
    verticalScrollDirection,
    columnStartIndex,
    columnStopIndex,
    rowStartIndex,
    rowStopIndex,
    isScrollingRender,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
var GridComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        className: 2,
        columnCount: 12,
        columnWidth: 13,
        direction: 3,
        height: 4,
        initialScrollLeft: 14,
        initialScrollTop: 15,
        innerRef: 0,
        innerElementType: 16,
        innerTagName: 17,
        itemData: 18,
        itemKey: 19,
        onItemsRendered: 20,
        onScroll: 21,
        outerRef: 1,
        outerElementType: 22,
        outerTagName: 23,
        overscanColumnCount: 24,
        overscanColumnsCount: 25,
        overscanCount: 26,
        overscanRowCount: 27,
        overscanRowsCount: 28,
        rowCount: 29,
        rowHeight: 30,
        style: 5,
        useIsScrolling: 31,
        width: 6,
        specificFunctionProps: 32,
        _getItemStyleCache: 33,
        instance: 34,
        scrollTo: 35,
        scrollToItem: 36
      },
      add_css,
      [-1, -1, -1]
    );
  }
  get _getItemStyleCache() {
    return this.$$.ctx[33];
  }
  get instance() {
    return this.$$.ctx[34];
  }
  get scrollTo() {
    return this.$$.ctx[35];
  }
  get scrollToItem() {
    return this.$$.ctx[36];
  }
};
var GridComponent_default = GridComponent;

// node_modules/svelte-window/src/FixedSizeGrid.js
var FixedSizeGridSpecificProps = {
  getColumnOffset: ({ columnWidth }, index) => index * columnWidth,
  getColumnWidth: ({ columnWidth }, index) => columnWidth,
  getRowOffset: ({ rowHeight }, index) => index * rowHeight,
  getRowHeight: ({ rowHeight }, index) => rowHeight,
  getEstimatedTotalHeight: ({ rowCount, rowHeight }) => rowHeight * rowCount,
  getEstimatedTotalWidth: ({ columnCount, columnWidth }) => columnWidth * columnCount,
  getOffsetForColumnAndAlignment: ({ columnCount, columnWidth, width }, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) => {
    const lastColumnOffset = Math.max(
      0,
      columnCount * columnWidth - width
    );
    const maxOffset = Math.min(
      lastColumnOffset,
      columnIndex * columnWidth
    );
    const minOffset = Math.max(
      0,
      columnIndex * columnWidth - width + scrollbarSize + columnWidth
    );
    if (align === "smart") {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        const middleOffset = Math.round(
          minOffset + (maxOffset - minOffset) / 2
        );
        if (middleOffset < Math.ceil(width / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getOffsetForRowAndAlignment: ({ rowHeight, height, rowCount }, rowIndex, align, scrollTop, instanceProps, scrollbarSize) => {
    const lastRowOffset = Math.max(
      0,
      rowCount * rowHeight - height
    );
    const maxOffset = Math.min(
      lastRowOffset,
      rowIndex * rowHeight
    );
    const minOffset = Math.max(
      0,
      rowIndex * rowHeight - height + scrollbarSize + rowHeight
    );
    if (align === "smart") {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        const middleOffset = Math.round(
          minOffset + (maxOffset - minOffset) / 2
        );
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth, columnCount }, scrollLeft) => Math.max(
    0,
    Math.min(
      columnCount - 1,
      Math.floor(scrollLeft / columnWidth)
    )
  ),
  getColumnStopIndexForStartIndex: ({ columnWidth, columnCount, width }, startIndex, scrollLeft) => {
    const left = startIndex * columnWidth;
    const numVisibleColumns = Math.ceil(
      (width + scrollLeft - left) / columnWidth
    );
    return Math.max(
      0,
      Math.min(
        columnCount - 1,
        startIndex + numVisibleColumns - 1
        // -1 is because stop index is inclusive
      )
    );
  },
  getRowStartIndexForOffset: ({ rowHeight, rowCount }, scrollTop) => Math.max(
    0,
    Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight))
  ),
  getRowStopIndexForStartIndex: ({ rowHeight, rowCount, height }, startIndex, scrollTop) => {
    const top = startIndex * rowHeight;
    const numVisibleRows = Math.ceil(
      (height + scrollTop - top) / rowHeight
    );
    return Math.max(
      0,
      Math.min(
        rowCount - 1,
        startIndex + numVisibleRows - 1
        // -1 is because stop index is inclusive
      )
    );
  },
  initInstanceProps(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: ({ columnWidth, rowHeight }) => {
    if (true) {
      if (typeof columnWidth !== "number") {
        throw Error(
          `An invalid "columnWidth" prop has been specified. Value should be a number. "${columnWidth === null ? "null" : typeof columnWidth}" was specified.`
        );
      }
      if (typeof rowHeight !== "number") {
        throw Error(
          `An invalid "rowHeight" prop has been specified. Value should be a number. "${rowHeight === null ? "null" : typeof rowHeight}" was specified.`
        );
      }
    }
  }
};
var FixedSizeGrid_default = FixedSizeGridSpecificProps;

// node_modules/svelte-window/lib/FixedSizeGrid.svelte
var get_default_slot_changes2 = (dirty) => ({ items: dirty & /*items*/
512 });
var get_default_slot_context2 = (ctx) => ({ items: (
  /*items*/
  ctx[9]
) });
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context2
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, items*/
        640)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let gridcomponent;
  let current;
  const gridcomponent_spread_levels = [
    { specificFunctionProps: FixedSizeGrid_default },
    /*$$restProps*/
    ctx[1]
  ];
  let gridcomponent_props = {
    $$slots: {
      default: [
        create_default_slot,
        ({ items }) => ({ 9: items }),
        ({ items }) => items ? 512 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < gridcomponent_spread_levels.length; i += 1) {
    gridcomponent_props = assign(gridcomponent_props, gridcomponent_spread_levels[i]);
  }
  gridcomponent = new GridComponent_default({ props: gridcomponent_props });
  ctx[6](gridcomponent);
  return {
    c() {
      create_component(gridcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcomponent, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcomponent_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(gridcomponent_spread_levels, [
        gridcomponent_spread_levels[0],
        get_spread_object(
          /*$$restProps*/
          ctx2[1]
        )
      ]) : {};
      if (dirty & /*$$scope, items*/
      640) {
        gridcomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcomponent.$set(gridcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[6](null);
      destroy_component(gridcomponent, detaching);
    }
  };
}
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = ["scrollTo", "scrollToItem", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let g;
  const scrollTo = (x) => g == null ? void 0 : g.scrollTo(x);
  const scrollToItem = (x) => g == null ? void 0 : g.scrollToItem(x);
  let inst = {};
  const instance8 = inst;
  function gridcomponent_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      g = $$value;
      $$invalidate(0, g);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*g*/
    1) {
      $:
        if (g) {
          Object.assign(inst, g.instance);
        }
    }
  };
  return [
    g,
    $$restProps,
    scrollTo,
    scrollToItem,
    instance8,
    slots,
    gridcomponent_binding,
    $$scope
  ];
}
var FixedSizeGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      scrollTo: 2,
      scrollToItem: 3,
      instance: 4
    });
  }
  get scrollTo() {
    return this.$$.ctx[2];
  }
  get scrollToItem() {
    return this.$$.ctx[3];
  }
  get instance() {
    return this.$$.ctx[4];
  }
};
var FixedSizeGrid_default2 = FixedSizeGrid;

// node_modules/svelte-window/src/styleString.js
var styleString = (s) => (s.position !== void 0 ? "position: " + s.position + ";" : "") + (s.left !== void 0 ? "left: " + s.left + "px;" : "") + (s.right !== void 0 ? "right: " + s.right + "px;" : "") + (s.top !== void 0 ? "top: " + s.top + "px;" : "") + (s.height !== void 0 ? "height: " + (typeof s.height === "number" ? s.height + "px" : s.height) + ";" : "") + (s.width !== void 0 ? "width: " + (typeof s.width === "number" ? s.width + "px" : s.width) + ";" : "");

// node_modules/svelte-virtualized-auto-sizer/DetectElementResize.js
function createDetectElementResize(nonce) {
  var _window;
  if (typeof window !== "undefined") {
    _window = window;
  } else if (typeof self !== "undefined") {
    _window = self;
  } else {
    _window = global;
  }
  var attachEvent = typeof document !== "undefined" && document.attachEvent;
  if (!attachEvent) {
    var requestFrame = function() {
      var raf2 = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
        return _window.setTimeout(fn, 20);
      };
      return function(fn) {
        return raf2(fn);
      };
    }();
    var cancelFrame = function() {
      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
      return function(id) {
        return cancel(id);
      };
    }();
    var resetTriggers = function resetTriggers2(element2) {
      var triggers = element2.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + "px";
      expandChild.style.height = expand.offsetHeight + 1 + "px";
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };
    var checkTriggers = function checkTriggers2(element2) {
      return element2.offsetWidth != element2.__resizeLast__.width || element2.offsetHeight != element2.__resizeLast__.height;
    };
    var scrollListener = function scrollListener2(e) {
      if (e.target.className && typeof e.target.className.indexOf === "function" && e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0) {
        return;
      }
      var element2 = this;
      resetTriggers(this);
      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }
      this.__resizeRAF__ = requestFrame(function() {
        if (checkTriggers(element2)) {
          element2.__resizeLast__.width = element2.offsetWidth;
          element2.__resizeLast__.height = element2.offsetHeight;
          element2.__resizeListeners__.forEach(function(fn) {
            fn.call(element2, e);
          });
        }
      });
    };
    var animation = false, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "";
    {
      var elm = document.createElement("fakeelement");
      if (elm.style.animationName !== void 0) {
        animation = true;
      }
      if (animation === false) {
        for (var i = 0; i < domPrefixes.length; i++) {
          if (elm.style[domPrefixes[i] + "AnimationName"] !== void 0) {
            pfx = domPrefixes[i];
            keyframeprefix = "-" + pfx.toLowerCase() + "-";
            animationstartevent = startEvents[i];
            animation = true;
            break;
          }
        }
      }
    }
    var animationName = "resizeanim";
    var animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
    var animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  }
  var createStyles = function createStyles2(doc) {
    if (!doc.getElementById("detectElementResize")) {
      var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
      style.id = "detectElementResize";
      style.type = "text/css";
      if (nonce != null) {
        style.setAttribute("nonce", nonce);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(doc.createTextNode(css));
      }
      head.appendChild(style);
    }
  };
  var addResizeListener = function addResizeListener2(element2, fn) {
    if (attachEvent) {
      element2.attachEvent("onresize", fn);
    } else {
      if (!element2.__resizeTriggers__) {
        var doc = element2.ownerDocument;
        var elementStyle = _window.getComputedStyle(element2);
        if (elementStyle && elementStyle.position == "static") {
          element2.style.position = "relative";
        }
        createStyles(doc);
        element2.__resizeLast__ = {};
        element2.__resizeListeners__ = [];
        (element2.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
        var expandTrigger = doc.createElement("div");
        expandTrigger.className = "expand-trigger";
        expandTrigger.appendChild(doc.createElement("div"));
        var contractTrigger = doc.createElement("div");
        contractTrigger.className = "contract-trigger";
        element2.__resizeTriggers__.appendChild(expandTrigger);
        element2.__resizeTriggers__.appendChild(contractTrigger);
        element2.appendChild(element2.__resizeTriggers__);
        resetTriggers(element2);
        element2.addEventListener("scroll", scrollListener, true);
        if (animationstartevent) {
          element2.__resizeTriggers__.__animationListener__ = function animationListener(e) {
            if (e.animationName == animationName) {
              resetTriggers(element2);
            }
          };
          element2.__resizeTriggers__.addEventListener(animationstartevent, element2.__resizeTriggers__.__animationListener__);
        }
      }
      element2.__resizeListeners__.push(fn);
    }
  };
  var removeResizeListener = function removeResizeListener2(element2, fn) {
    if (attachEvent) {
      element2.detachEvent("onresize", fn);
    } else {
      element2.__resizeListeners__.splice(element2.__resizeListeners__.indexOf(fn), 1);
      if (!element2.__resizeListeners__.length) {
        element2.removeEventListener("scroll", scrollListener, true);
        if (element2.__resizeTriggers__.__animationListener__) {
          element2.__resizeTriggers__.removeEventListener(animationstartevent, element2.__resizeTriggers__.__animationListener__);
          element2.__resizeTriggers__.__animationListener__ = null;
        }
        try {
          element2.__resizeTriggers__ = !element2.removeChild(element2.__resizeTriggers__);
        } catch (e) {
        }
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}

// node_modules/svelte-virtualized-auto-sizer/AutoSizer.svelte
function add_css2(target) {
  append_styles(target, "svelte-1fps6z5", "div.svelte-1fps6z5{overflow:visible}.outerstylewidth.svelte-1fps6z5{width:0}.outerstyleheight.svelte-1fps6z5{height:0}");
}
var get_default_slot_changes3 = (dirty) => ({
  width: dirty & /*childParams*/
  4,
  height: dirty & /*childParams*/
  4
});
var get_default_slot_context3 = (ctx) => ({
  width: (
    /*childParams*/
    ctx[2].width
  ),
  height: (
    /*childParams*/
    ctx[2].height
  )
});
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context3
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, childParams*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let current;
  let if_block = !/*bailoutOnChildren*/
  ctx[3] && create_if_block(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = null_to_empty(
        /*className*/
        ctx[0]
      ) + " svelte-1fps6z5");
      toggle_class(
        div,
        "outerstylewidth",
        /*outerstylewidth*/
        ctx[4]
      );
      toggle_class(
        div,
        "outerstyleheight",
        /*outerstyleheight*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*bailoutOnChildren*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*bailoutOnChildren*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*className*/
      1 && div_class_value !== (div_class_value = null_to_empty(
        /*className*/
        ctx2[0]
      ) + " svelte-1fps6z5")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*className, outerstylewidth*/
      17) {
        toggle_class(
          div,
          "outerstylewidth",
          /*outerstylewidth*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className, outerstyleheight*/
      33) {
        toggle_class(
          div,
          "outerstyleheight",
          /*outerstyleheight*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onResize = () => {
  } } = $$props;
  let { disableHeight = false } = $$props;
  let { disableWidth = false } = $$props;
  let { className = "" } = $$props;
  let { defaultHeight = void 0 } = $$props;
  let { defaultWidth = void 0 } = $$props;
  let { nonce = void 0 } = $$props;
  let height = defaultHeight || 0, width = defaultWidth || 0;
  let _parentNode, _autoSizer, _detectElementResize;
  const _onResize = () => {
    if (_parentNode) {
      const height_ = _parentNode.offsetHeight || 0;
      const width_ = _parentNode.offsetWidth || 0;
      const style = window.getComputedStyle(_parentNode) || {};
      const paddingLeft = parseInt(style.paddingLeft, 10) || 0;
      const paddingRight = parseInt(style.paddingRight, 10) || 0;
      const paddingTop = parseInt(style.paddingTop, 10) || 0;
      const paddingBottom = parseInt(style.paddingBottom, 10) || 0;
      const newHeight = height_ - paddingTop - paddingBottom;
      const newWidth = width_ - paddingLeft - paddingRight;
      if (!disableHeight && height !== newHeight || !disableWidth && width !== newWidth) {
        $$invalidate(12, height = height_ - paddingTop - paddingBottom);
        $$invalidate(13, width = width_ - paddingLeft - paddingRight);
        onResize({ height, width });
      }
    }
  };
  onMount(() => {
    if (_autoSizer && _autoSizer.parentNode && _autoSizer.parentNode.ownerDocument && _autoSizer.parentNode.ownerDocument.defaultView && _autoSizer.parentNode instanceof _autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
      _parentNode = _autoSizer.parentNode;
      _detectElementResize = createDetectElementResize(nonce);
      _detectElementResize.addResizeListener(_parentNode, _onResize);
      _onResize();
    }
  });
  onDestroy(() => {
    if (_detectElementResize && _parentNode) {
      _detectElementResize.removeResizeListener(_parentNode, _onResize);
    }
  });
  const childParams = {};
  let bailoutOnChildren = false, outerstylewidth = false, outerstyleheight = false;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _autoSizer = $$value;
      $$invalidate(1, _autoSizer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("onResize" in $$props2)
      $$invalidate(6, onResize = $$props2.onResize);
    if ("disableHeight" in $$props2)
      $$invalidate(7, disableHeight = $$props2.disableHeight);
    if ("disableWidth" in $$props2)
      $$invalidate(8, disableWidth = $$props2.disableWidth);
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("defaultHeight" in $$props2)
      $$invalidate(9, defaultHeight = $$props2.defaultHeight);
    if ("defaultWidth" in $$props2)
      $$invalidate(10, defaultWidth = $$props2.defaultWidth);
    if ("nonce" in $$props2)
      $$invalidate(11, nonce = $$props2.nonce);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disableHeight, height, disableWidth, width*/
    12672) {
      $: {
        $$invalidate(3, bailoutOnChildren = false);
        if (!disableHeight) {
          if (height === 0) {
            $$invalidate(3, bailoutOnChildren = true);
          }
          $$invalidate(5, outerstyleheight = true);
          $$invalidate(2, childParams.height = height, childParams);
        }
        if (!disableWidth) {
          if (width === 0) {
            $$invalidate(3, bailoutOnChildren = true);
          }
          $$invalidate(4, outerstylewidth = true);
          $$invalidate(2, childParams.width = width, childParams);
        }
      }
    }
  };
  return [
    className,
    _autoSizer,
    childParams,
    bailoutOnChildren,
    outerstylewidth,
    outerstyleheight,
    onResize,
    disableHeight,
    disableWidth,
    defaultHeight,
    defaultWidth,
    nonce,
    height,
    width,
    $$scope,
    slots,
    div_binding
  ];
}
var AutoSizer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment3,
      safe_not_equal,
      {
        onResize: 6,
        disableHeight: 7,
        disableWidth: 8,
        className: 0,
        defaultHeight: 9,
        defaultWidth: 10,
        nonce: 11
      },
      add_css2
    );
  }
};
var AutoSizer_default = AutoSizer;

// node_modules/svelte-virtualized-auto-sizer/index.js
var svelte_virtualized_auto_sizer_default = AutoSizer_default;

// src/view/components/DisplayCard.svelte
var import_obsidian5 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-cubfk4", ".showScroll.svelte-cubfk4,.hiddenContent.svelte-cubfk4{border:2px solid;border-radius:15px;padding:10px}.hiddenContent.svelte-cubfk4{overflow:hidden}.showScroll.svelte-cubfk4{overflow:scroll}");
}
function create_else_block(ctx) {
  let h2;
  let t_value = (
    /*file*/
    ctx[0].basename + ""
  );
  let t;
  return {
    c() {
      h2 = element("h2");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*file*/
      1 && t_value !== (t_value = /*file*/
      ctx2[0].basename + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
function create_if_block2(ctx) {
  let h2;
  let t_value = `${/*file*/
  ctx[0].parent.path}/${/*file*/
  ctx[0].basename}`;
  let t;
  return {
    c() {
      h2 = element("h2");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      append(h2, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*file*/
      1 && t_value !== (t_value = `${/*file*/
      ctx2[0].parent.path}/${/*file*/
      ctx2[0].basename}`))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
      }
    }
  };
}
function create_catch_block(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block(ctx) {
  let div;
  let loading_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(loading_action = /*loading*/
        ctx[7].call(
          null,
          div,
          /*cont*/
          ctx[16]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (loading_action && is_function(loading_action.update) && dirty & /*data*/
      4)
        loading_action.update.call(
          null,
          /*cont*/
          ctx[16]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "loading...";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let t;
  let promise;
  let div_style_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*onHover*/
      ctx2[3] && /*file*/
      ctx2[0].parent && /*file*/
      ctx2[0].parent.path !== "/"
    )
      return create_if_block2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 16
  };
  handle_promise(promise = /*data*/
  ctx[2], info);
  return {
    c() {
      div = element("div");
      if_block.c();
      t = space();
      info.block.c();
      attr(div, "style", div_style_value = styleString(
        /*cellStyle*/
        ctx[1]
      ));
      attr(div, "class", div_class_value = null_to_empty(
        /*onHover*/
        ctx[3] ? "showScroll" : "hiddenContent"
      ) + " svelte-cubfk4");
      attr(div, "draggable", "true");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
      append(div, t);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "dragstart",
            /*dragCard*/
            ctx[5]
          ),
          listen(
            div,
            "dragend",
            /*reset*/
            ctx[6]
          ),
          listen(
            div,
            "click",
            /*onOpenFile*/
            ctx[8]
          ),
          listen(
            div,
            "contextmenu",
            /*moveFileToTrashFolder*/
            ctx[4]
          ),
          listen(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[10]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div, t);
        }
      }
      info.ctx = ctx;
      if (dirty & /*data*/
      4 && promise !== (promise = /*data*/
      ctx[2]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (dirty & /*cellStyle*/
      2 && div_style_value !== (div_style_value = styleString(
        /*cellStyle*/
        ctx[1]
      ))) {
        attr(div, "style", div_style_value);
      }
      if (dirty & /*onHover*/
      8 && div_class_value !== (div_class_value = null_to_empty(
        /*onHover*/
        ctx[3] ? "showScroll" : "hiddenContent"
      ) + " svelte-cubfk4")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { file } = $$props;
  let { view } = $$props;
  let { cellStyle } = $$props;
  let { data } = $$props;
  let onHover = false;
  let listener;
  let dragSymbol;
  const moveFileToTrashFolder = (e) => {
    const mn = new import_obsidian5.Menu().addItem((item) => {
      item.setIcon("trash-2").setTitle("delete file").onClick((c) => {
        view.app.vault.trash(file, false);
      });
    });
    mn.showAtMouseEvent(e);
  };
  const dragCard = (dragStart) => {
    var _a;
    const createFileInView = (drop) => {
      var _a2, _b;
      const drawView = view.plugin.getDropView(drop);
      if (isObsidianCanvasView(drawView)) {
        const pos = drawView.canvas.posFromEvt(drop);
        drawView.canvas.createFileNode({ file, pos, save: true });
      }
      if (isExcalidrawView(drawView)) {
        const link = view.app.fileManager.generateMarkdownLink(file, (_b = (_a2 = drawView.file) === null || _a2 === void 0 ? void 0 : _a2.path) !== null && _b !== void 0 ? _b : "");
        insertEmbeddableOnDrawing(drop, drawView, link, file, view.plugin);
      }
    };
    const img = new Image();
    (0, import_obsidian5.setIcon)(img, "file-text");
    dragSymbol = view.containerEl.createDiv();
    const icon = dragSymbol.createDiv(), filInfoEl = dragSymbol.createSpan();
    icon.style.display = "inline-block";
    (0, import_obsidian5.setIcon)(icon, "file-text");
    filInfoEl.textContent = " " + file.path;
    dragSymbol.setCssStyles({
      position: "absolute",
      transform: "translate(-1000px,-1000px)"
    });
    (_a = dragStart.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(dragSymbol, 0, 30);
    setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
      listener = view.plugin.listenDragAndDrop(dragStart, (yield data).content, createFileInView);
    }));
  };
  const reset = (dragEnd) => {
    listener.reset();
    view.containerEl.removeChild(dragSymbol);
  };
  const getContent = (content, section) => {
    const [sectionStart, sectionEnd] = getCacheOffset(section);
    return [content.substring(sectionStart, sectionEnd), sectionStart, sectionEnd];
  };
  const parseMatchContent = (content, section, sr) => {
    const [originContent, sectionStart, sectionEnd] = getContent(content, section);
    if (sr === void 0) {
      return originContent;
    }
    const offset = sectionStart;
    let newContent = "";
    let prevEnd = 0;
    sr.matches.forEach((m) => {
      const [startOffset, endOffset] = m.match;
      const [start, end] = [startOffset - offset, endOffset - offset];
      if (start >= prevEnd) {
        const fragment = originContent.substring(prevEnd, start), cut = originContent.substring(start, end), highlight = (origin) => `==${origin}==`;
        const append2 = m.type === "embeds" ? fragment + highlight(cut.substring(1)) + cut : fragment + highlight(
          cut
        );
        newContent += append2;
        prevEnd = end;
      }
    });
    const residue = originContent.substring(prevEnd);
    return newContent + residue;
  };
  const loading = (ele, da) => {
    var _a;
    if (da.matchCache && da.matchCache.length !== 0) {
      (_a = da.matchCache) === null || _a === void 0 ? void 0 : _a.forEach((noteChache) => __awaiter(void 0, void 0, void 0, function* () {
        const container = ele.createDiv(), section = noteChache.section, sr = noteChache.matchResult;
        if (sr) {
          const openFileOnMatch = (e) => __awaiter(void 0, void 0, void 0, function* () {
            if (e.target instanceof HTMLAnchorElement) {
            } else {
              view.plugin.onClickOpenFile(
                e,
                file,
                {
                  eState: {
                    match: {
                      content: (yield data).content,
                      matches: sr.matches.map((m) => m.match)
                    }
                  }
                }
              );
              e.stopPropagation();
            }
          });
          container.onclick = openFileOnMatch;
          if (section.type === "code") {
            const [renderContent2, sectionStart] = getContent(da.content, section);
            (0, import_obsidian5.renderResults)(
              container,
              renderContent2,
              {
                score: sr.score,
                matches: sr.matches.map((m) => m.match)
              },
              -sectionStart
            );
            return;
          }
        }
        const renderContent = parseMatchContent(da.content, section, sr);
        import_obsidian5.MarkdownRenderer.render(view.app, renderContent, container, file.path, view);
      }));
    } else {
      import_obsidian5.MarkdownRenderer.render(view.app, da.content, ele, file.path, view);
    }
  };
  const onOpenFile = (e) => {
    const target = e.target;
    if (target instanceof HTMLAnchorElement) {
      if (target.classList.contains("internal-link")) {
        const linktext = target.getAttribute("data-href");
        if (linktext) {
          view.app.workspace.openLinkText(linktext, file.path);
        }
      }
      return;
    } else {
      view.plugin.onClickOpenFile(e, file);
    }
  };
  const mouseenter_handler = (e) => $$invalidate(3, onHover = true);
  const mouseleave_handler = (e) => $$invalidate(3, onHover = false);
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
    if ("view" in $$props2)
      $$invalidate(9, view = $$props2.view);
    if ("cellStyle" in $$props2)
      $$invalidate(1, cellStyle = $$props2.cellStyle);
    if ("data" in $$props2)
      $$invalidate(2, data = $$props2.data);
  };
  return [
    file,
    cellStyle,
    data,
    onHover,
    moveFileToTrashFolder,
    dragCard,
    reset,
    loading,
    onOpenFile,
    view,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var DisplayCard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment4, safe_not_equal, { file: 0, view: 9, cellStyle: 1, data: 2 }, add_css3);
  }
};
var DisplayCard_default = DisplayCard;

// src/view/components/ComputeLayout.svelte
var get_default_slot_changes4 = (dirty) => ({
  gridProps: dirty & /*columns, rows, viewHeight, residueSpace*/
  15
});
var get_default_slot_context4 = (ctx) => ({
  gridProps: {
    columns: (
      /*columns*/
      ctx[1]
    ),
    rows: (
      /*rows*/
      ctx[2]
    ),
    viewHeight: (
      /*viewHeight*/
      ctx[0]
    ),
    padding: (
      /*residueSpace*/
      ctx[3] >= 0 ? (
        /*residueSpace*/
        ctx[3]
      ) : 0
    )
  }
});
function create_fragment5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context4
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, columns, rows, viewHeight, residueSpace*/
        271)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { viewHeight } = $$props;
  let { viewWidth } = $$props;
  let { columnWidth } = $$props;
  let { gap } = $$props;
  let { totalCount } = $$props;
  let columns, rows, residueSpace = 0;
  $$self.$$set = ($$props2) => {
    if ("viewHeight" in $$props2)
      $$invalidate(0, viewHeight = $$props2.viewHeight);
    if ("viewWidth" in $$props2)
      $$invalidate(4, viewWidth = $$props2.viewWidth);
    if ("columnWidth" in $$props2)
      $$invalidate(5, columnWidth = $$props2.columnWidth);
    if ("gap" in $$props2)
      $$invalidate(6, gap = $$props2.gap);
    if ("totalCount" in $$props2)
      $$invalidate(7, totalCount = $$props2.totalCount);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*columnWidth, gap, viewWidth, totalCount, columns*/
    242) {
      $: {
        const acutualColumnWidth = columnWidth + gap;
        const col = Math.floor(viewWidth / acutualColumnWidth);
        $$invalidate(1, columns = col === 0 ? 1 : col);
        $$invalidate(2, rows = Math.ceil(totalCount / columns));
        $$invalidate(3, residueSpace = (viewWidth - columns * acutualColumnWidth) / 2);
      }
    }
  };
  return [
    viewHeight,
    columns,
    rows,
    residueSpace,
    viewWidth,
    columnWidth,
    gap,
    totalCount,
    $$scope,
    slots
  ];
}
var ComputeLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment5, safe_not_equal, {
      viewHeight: 0,
      viewWidth: 4,
      columnWidth: 5,
      gap: 6,
      totalCount: 7
    });
  }
};
var ComputeLayout_default = ComputeLayout;

// src/view/components/PrepareLoad.svelte
var get_default_slot_changes5 = (dirty) => ({ item: dirty & /*source*/
1 });
var get_default_slot_context5 = (ctx) => ({
  item: {
    file: (
      /*source*/
      ctx[0].file
    ),
    data: (
      /*loadingContent*/
      ctx[1](
        /*source*/
        ctx[0]
      )
    )
  }
});
function create_fragment6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context5
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, source*/
        9)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
var isFileMatch = (file) => {
  return "content" in file;
};
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { source } = $$props;
  let { view } = $$props;
  const processMatch = (match) => {
    var _a;
    const contentMatch = match.contentMatchResult;
    if (contentMatch === void 0) {
      return;
    }
    const touch = (s) => {
      const [matchStart, matchEnd] = s;
      return (c) => {
        const [start, end] = getCacheOffset(c);
        return matchStart > start && matchStart < end || matchEnd > start && matchEnd < end;
      };
    };
    const inSectionRange = (mt, c) => {
      const [matchStart, matchEnd] = mt.match;
      const [start, end] = getCacheOffset(c);
      return matchStart >= start && matchEnd <= end;
    };
    const caches = view.app.metadataCache.getFileCache(match.file);
    const extendMatchRange = (mtch) => {
      var _a2, _b;
      const [matchStart, matchEnd] = mtch;
      const extendRange = (c) => {
        const [start, end] = getCacheOffset(c);
        return [Math.min(start, matchStart), Math.max(end, matchEnd)];
      };
      const embeded = (_a2 = caches === null || caches === void 0 ? void 0 : caches.embeds) === null || _a2 === void 0 ? void 0 : _a2.find(touch(mtch));
      if (embeded) {
        return {
          match: extendRange(embeded),
          type: "embeds"
        };
      }
      const linked = (_b = caches === null || caches === void 0 ? void 0 : caches.links) === null || _b === void 0 ? void 0 : _b.find(touch(mtch));
      if (linked) {
        return { match: extendRange(linked) };
      }
      return { match: mtch };
    };
    const matches = contentMatch.matches.map(extendMatchRange);
    const sections = (_a = caches === null || caches === void 0 ? void 0 : caches.sections) === null || _a === void 0 ? void 0 : _a.map((section) => {
      const ms = matches.filter((m) => inSectionRange(m, section));
      return ms.length !== 0 ? {
        section,
        matchResult: { score: contentMatch.score, matches: ms }
      } : { section };
    });
    return sections;
  };
  const loadingContent = (source2) => {
    if (isFileMatch(source2)) {
      return new Promise((solve) => {
        const caches = processMatch(source2);
        solve({
          content: source2.content,
          matchCache: caches
        });
      });
    } else {
      return source2.file.vault.cachedRead(source2.file).then((content) => ({ content }));
    }
  };
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("view" in $$props2)
      $$invalidate(2, view = $$props2.view);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [source, loadingContent, view, $$scope, slots];
}
var PrepareLoad = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment6, safe_not_equal, { source: 0, view: 2 });
  }
};
var PrepareLoad_default = PrepareLoad;

// src/view/components/SearchUtil.svelte
var import_obsidian7 = require("obsidian");
var descending = "descending";
var ascending = "ascending";
function sortByModifiedTime(a, b) {
  return a.file.stat.mtime - b.file.stat.mtime;
}
function sortByCreateTime(a, b) {
  return a.file.stat.ctime - b.file.stat.ctime;
}
function sortByRelated(a, b) {
  return computeScore(a) - computeScore(b);
}
function computeScore(value) {
  var _a, _b, _c, _d;
  return ((_b = (_a = value.contentMatchResult) === null || _a === void 0 ? void 0 : _a.score) !== null && _b !== void 0 ? _b : -5) + ((_d = (_c = value.fileNameMatchResult) === null || _c === void 0 ? void 0 : _c.score) !== null && _d !== void 0 ? _d : -5);
}
function search(query, view) {
  const fuzzy = (0, import_obsidian7.prepareSimpleSearch)(query), searching = (cont) => __awaiter(this, void 0, void 0, function* () {
    const content = yield view.app.vault.cachedRead(cont.file), contentResult = fuzzy(content), fileNameResult = fuzzy(cont.file.name);
    if (contentResult || fileNameResult) {
      return {
        file: cont.file,
        content,
        contentMatchResult: contentResult !== null && contentResult !== void 0 ? contentResult : void 0,
        fileNameMatchResult: fileNameResult !== null && fileNameResult !== void 0 ? fileNameResult : void 0
      };
    }
  });
  return searching;
}
function searchFiles(query, origin, view) {
  return __awaiter(this, void 0, void 0, function* () {
    const finds = (yield Promise.all(origin.map(search(query, view)))).filter((file) => file !== void 0);
    return finds;
  });
}
function getDisplayFiles(view, origin, query) {
  return __awaiter(this, void 0, void 0, function* () {
    return query.length !== 0 ? yield searchFiles(query, origin, view) : origin;
  });
}

// src/view/components/ButtonGroups.svelte
var import_obsidian8 = require("obsidian");
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let renderIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(renderIcon_action = /*renderIcon*/
        ctx[1].call(
          null,
          div,
          /*but*/
          ctx[6]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (renderIcon_action && is_function(renderIcon_action.update) && dirty & /*buttons*/
      1)
        renderIcon_action.update.call(
          null,
          /*but*/
          ctx[6]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment7(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*buttons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*buttons*/
      1) {
        each_value = ensure_array_like(
          /*buttons*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { buttons = [] } = $$props;
  let { onclick } = $$props;
  let active = "";
  let unActive = () => {
  };
  const setUnActiveButton = (butt) => {
    unActive = () => {
      butt.removeCta();
    };
  };
  const renderIcon = (el, but) => {
    const b = new import_obsidian8.ButtonComponent(el).setIcon(but.icon).setTooltip(but.toolTip).onClick((e) => {
      if (active !== but.icon) {
        b.setCta();
        unActive();
        onclick(e, but.value);
        active = but.icon;
        setUnActiveButton(b);
      }
    });
    if (but.active) {
      b.setCta();
      active = but.icon;
      setUnActiveButton(b);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("onclick" in $$props2)
      $$invalidate(2, onclick = $$props2.onclick);
  };
  return [buttons, renderIcon, onclick];
}
var ButtonGroups = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment7, safe_not_equal, { buttons: 0, onclick: 2 });
  }
};
var ButtonGroups_default = ButtonGroups;

// src/view/components/SortingFiles.svelte
var get_default_slot_changes6 = (dirty) => ({
  files: dirty & /*files, seq, sortMethod*/
  7
});
var get_default_slot_context6 = (ctx) => ({
  files: (
    /*files*/
    ctx[0].sort(
      /*seq*/
      ctx[2] === descending ? (
        /*func*/
        ctx[5]
      ) : (
        /*sortMethod*/
        ctx[1]
      )
    )
  )
});
function create_fragment8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context6
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, files, seq, sortMethod*/
        15)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { files } = $$props;
  let { sortMethod } = $$props;
  let { seq } = $$props;
  const func = (a, b) => -sortMethod(a, b);
  $$self.$$set = ($$props2) => {
    if ("files" in $$props2)
      $$invalidate(0, files = $$props2.files);
    if ("sortMethod" in $$props2)
      $$invalidate(1, sortMethod = $$props2.sortMethod);
    if ("seq" in $$props2)
      $$invalidate(2, seq = $$props2.seq);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [files, sortMethod, seq, $$scope, slots, func];
}
var SortingFiles = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment8, safe_not_equal, { files: 0, sortMethod: 1, seq: 2 });
  }
};
var SortingFiles_default = SortingFiles;

// src/view/components/Search.svelte
function add_css4(target) {
  append_styles(target, "svelte-yfh3b", ".searchMenuBar.svelte-yfh3b{display:flex;align-items:end}.searchMenuBar.svelte-yfh3b{justify-content:space-between}.buttonBar.svelte-yfh3b{display:flex;align-items:center;justify-content:space-evenly;gap:3px}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function create_catch_block_1(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block_1(ctx) {
  let t0_value = (
    /*f*/
    ctx[27].length + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" results");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*files*/
      256 && t0_value !== (t0_value = /*f*/
      ctx2[27].length + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_pending_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("Search...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let div2;
  let div0;
  let columnWidthSetting_action;
  let t1;
  let div1;
  let rowHeightSetting_action;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "column width";
      t1 = space();
      div1 = element("div");
      div1.textContent = "row height";
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      if (!mounted) {
        dispose = [
          action_destroyer(columnWidthSetting_action = /*columnWidthSetting*/
          ctx[11].call(null, div0)),
          action_destroyer(rowHeightSetting_action = /*rowHeightSetting*/
          ctx[12].call(null, div1))
        ];
        mounted = true;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_catch_block2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block2(ctx) {
  var _a, _b;
  let computelayout;
  let current;
  computelayout = new ComputeLayout_default({
    props: {
      viewHeight: (
        /*childHeight*/
        (_a = ctx[26]) != null ? _a : 1e3
      ),
      viewWidth: (
        /*childWidth*/
        (_b = ctx[25]) != null ? _b : 1e3
      ),
      columnWidth: (
        /*columnWidth*/
        ctx[1]
      ),
      gap: gutter2,
      totalCount: (
        /*f*/
        ctx[27].length
      ),
      $$slots: {
        default: [
          create_default_slot_1,
          ({ gridProps }) => ({ 28: gridProps }),
          ({ gridProps }) => [gridProps ? 268435456 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(computelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(computelayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const computelayout_changes = {};
      if (dirty[0] & /*childHeight*/
      67108864)
        computelayout_changes.viewHeight = /*childHeight*/
        (_a2 = ctx2[26]) != null ? _a2 : 1e3;
      if (dirty[0] & /*childWidth*/
      33554432)
        computelayout_changes.viewWidth = /*childWidth*/
        (_b2 = ctx2[25]) != null ? _b2 : 1e3;
      if (dirty[0] & /*columnWidth*/
      2)
        computelayout_changes.columnWidth = /*columnWidth*/
        ctx2[1];
      if (dirty[0] & /*files*/
      256)
        computelayout_changes.totalCount = /*f*/
        ctx2[27].length;
      if (dirty[0] & /*files, sortMethod, seq, offset, gridProps, columnWidth, childHeight, rowHeight, childWidth, grid, view*/
      369099255 | dirty[1] & /*$$scope*/
      16) {
        computelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      computelayout.$set(computelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(computelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(computelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(computelayout, detaching);
    }
  };
}
function create_if_block3(ctx) {
  var _a;
  let prepareload;
  let t;
  let current;
  prepareload = new PrepareLoad_default({
    props: {
      view: (
        /*view*/
        ctx[0]
      ),
      source: (
        /*sortFiles*/
        ctx[29][
          /*index*/
          (_a = ctx[15](
            /*it*/
            ctx[31],
            /*gridProps*/
            ctx[28].columns,
            /*f*/
            ctx[27].length
          )) != null ? _a : 0
        ]
      ),
      $$slots: {
        default: [
          create_default_slot_4,
          ({ item }) => ({ 34: item }),
          ({ item }) => [0, item ? 8 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(prepareload.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(prepareload, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const prepareload_changes = {};
      if (dirty[0] & /*view*/
      1)
        prepareload_changes.view = /*view*/
        ctx2[0];
      if (dirty[0] & /*sortFiles, items, gridProps, files*/
      1879048448)
        prepareload_changes.source = /*sortFiles*/
        ctx2[29][
          /*index*/
          (_a2 = ctx2[15](
            /*it*/
            ctx2[31],
            /*gridProps*/
            ctx2[28].columns,
            /*f*/
            ctx2[27].length
          )) != null ? _a2 : 0
        ];
      if (dirty[0] & /*view, items, gridProps*/
      1342177281 | dirty[1] & /*$$scope, item*/
      24) {
        prepareload_changes.$$scope = { dirty, ctx: ctx2 };
      }
      prepareload.$set(prepareload_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(prepareload.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prepareload.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(prepareload, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let displaycard;
  let current;
  displaycard = new DisplayCard_default({
    props: {
      file: (
        /*item*/
        ctx[34].file
      ),
      view: (
        /*view*/
        ctx[0]
      ),
      cellStyle: (
        /*computeGapStyle*/
        ctx[16](
          /*it*/
          ctx[31].style,
          /*gridProps*/
          ctx[28].padding
        )
      ),
      data: (
        /*item*/
        ctx[34].data
      )
    }
  });
  return {
    c() {
      create_component(displaycard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(displaycard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const displaycard_changes = {};
      if (dirty[1] & /*item*/
      8)
        displaycard_changes.file = /*item*/
        ctx2[34].file;
      if (dirty[0] & /*view*/
      1)
        displaycard_changes.view = /*view*/
        ctx2[0];
      if (dirty[0] & /*items, gridProps*/
      1342177280)
        displaycard_changes.cellStyle = /*computeGapStyle*/
        ctx2[16](
          /*it*/
          ctx2[31].style,
          /*gridProps*/
          ctx2[28].padding
        );
      if (dirty[1] & /*item*/
      8)
        displaycard_changes.data = /*item*/
        ctx2[34].data;
      displaycard.$set(displaycard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(displaycard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(displaycard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(displaycard, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let show_if = (
    /*index*/
    ctx[15](
      /*it*/
      ctx[31],
      /*gridProps*/
      ctx[28].columns,
      /*f*/
      ctx[27].length
    ) !== null
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*items, gridProps, files*/
      1342177536)
        show_if = /*index*/
        ctx2[15](
          /*it*/
          ctx2[31],
          /*gridProps*/
          ctx2[28].columns,
          /*f*/
          ctx2[27].length
        ) !== null;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*items, gridProps, files*/
          1342177536) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[30]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*view, sortFiles, index, items, gridProps, files, computeGapStyle*/
      1879146753 | dirty[1] & /*item*/
      8) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[30]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  var _a, _b;
  let grid_1;
  let current;
  let grid_1_props = {
    initialScrollTop: (
      /*offset*/
      ctx[6].scrollTop
    ),
    columnCount: (
      /*gridProps*/
      ctx[28].columns
    ),
    columnWidth: (
      /*columnWidth*/
      ctx[1] + gutter2
    ),
    height: (
      /*childHeight*/
      (_a = ctx[26]) != null ? _a : 500
    ),
    rowCount: (
      /*gridProps*/
      ctx[28].rows
    ),
    rowHeight: (
      /*rowHeight*/
      ctx[2] + gutter2
    ),
    width: (
      /*childWidth*/
      (_b = ctx[25]) != null ? _b : 500
    ),
    useIsScrolling: true,
    overscanRowCount: 1,
    onScroll: (
      /*rememberScrollOffsetForFileUpdate*/
      ctx[17]
    ),
    $$slots: {
      default: [
        create_default_slot_3,
        ({ items }) => ({ 30: items }),
        ({ items }) => [items ? 1073741824 : 0]
      ]
    },
    $$scope: { ctx }
  };
  grid_1 = new FixedSizeGrid_default2({ props: grid_1_props });
  ctx[23](grid_1);
  return {
    c() {
      create_component(grid_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(grid_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const grid_1_changes = {};
      if (dirty[0] & /*offset*/
      64)
        grid_1_changes.initialScrollTop = /*offset*/
        ctx2[6].scrollTop;
      if (dirty[0] & /*gridProps*/
      268435456)
        grid_1_changes.columnCount = /*gridProps*/
        ctx2[28].columns;
      if (dirty[0] & /*columnWidth*/
      2)
        grid_1_changes.columnWidth = /*columnWidth*/
        ctx2[1] + gutter2;
      if (dirty[0] & /*childHeight*/
      67108864)
        grid_1_changes.height = /*childHeight*/
        (_a2 = ctx2[26]) != null ? _a2 : 500;
      if (dirty[0] & /*gridProps*/
      268435456)
        grid_1_changes.rowCount = /*gridProps*/
        ctx2[28].rows;
      if (dirty[0] & /*rowHeight*/
      4)
        grid_1_changes.rowHeight = /*rowHeight*/
        ctx2[2] + gutter2;
      if (dirty[0] & /*childWidth*/
      33554432)
        grid_1_changes.width = /*childWidth*/
        (_b2 = ctx2[25]) != null ? _b2 : 500;
      if (dirty[0] & /*items, view, sortFiles, gridProps, files*/
      1879048449 | dirty[1] & /*$$scope*/
      16) {
        grid_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid_1.$set(grid_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(grid_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(grid_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[23](null);
      destroy_component(grid_1, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let sortingfiles;
  let current;
  sortingfiles = new SortingFiles_default({
    props: {
      files: (
        /*f*/
        ctx[27]
      ),
      sortMethod: (
        /*sortMethod*/
        ctx[4]
      ),
      seq: (
        /*seq*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_2,
          ({ files: sortFiles }) => ({ 29: sortFiles }),
          ({ files: sortFiles }) => [sortFiles ? 536870912 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sortingfiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sortingfiles, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sortingfiles_changes = {};
      if (dirty[0] & /*files*/
      256)
        sortingfiles_changes.files = /*f*/
        ctx2[27];
      if (dirty[0] & /*sortMethod*/
      16)
        sortingfiles_changes.sortMethod = /*sortMethod*/
        ctx2[4];
      if (dirty[0] & /*seq*/
      32)
        sortingfiles_changes.seq = /*seq*/
        ctx2[5];
      if (dirty[0] & /*offset, gridProps, columnWidth, childHeight, rowHeight, childWidth, grid, view, sortFiles, files*/
      905970119 | dirty[1] & /*$$scope*/
      16) {
        sortingfiles_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sortingfiles.$set(sortingfiles_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sortingfiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sortingfiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sortingfiles, detaching);
    }
  };
}
function create_pending_block2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_default_slot2(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block2,
    then: create_then_block2,
    catch: create_catch_block2,
    value: 27,
    blocks: [, , ,]
  };
  handle_promise(promise = /*files*/
  ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & /*files*/
      256 && promise !== (promise = /*files*/
      ctx[8]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment9(ctx) {
  let div0;
  let search_action;
  let t0;
  let div1;
  let t1;
  let div5;
  let div2;
  let promise;
  let t2;
  let div4;
  let t3;
  let div3;
  let layoutSetting_action;
  let t4;
  let buttongroups0;
  let t5;
  let buttongroups1;
  let t6;
  let autosizer;
  let current;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 27
  };
  handle_promise(promise = /*files*/
  ctx[8], info);
  let if_block = (
    /*showLayoutMenu*/
    ctx[3] && create_if_block_1(ctx)
  );
  buttongroups0 = new ButtonGroups_default({
    props: {
      buttons: (
        /*sortMethods*/
        ctx[14]
      ),
      onclick: (
        /*func*/
        ctx[21]
      )
    }
  });
  buttongroups1 = new ButtonGroups_default({
    props: {
      buttons: (
        /*sortSeq*/
        ctx[13]
      ),
      onclick: (
        /*func_1*/
        ctx[22]
      )
    }
  });
  autosizer = new svelte_virtualized_auto_sizer_default({
    props: {
      $$slots: {
        default: [
          create_default_slot2,
          ({ width: childWidth, height: childHeight }) => ({ 25: childWidth, 26: childHeight }),
          ({ width: childWidth, height: childHeight }) => [(childWidth ? 33554432 : 0) | (childHeight ? 67108864 : 0)]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      div1.innerHTML = ``;
      t1 = space();
      div5 = element("div");
      div2 = element("div");
      info.block.c();
      t2 = space();
      div4 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      div3 = element("div");
      t4 = space();
      create_component(buttongroups0.$$.fragment);
      t5 = space();
      create_component(buttongroups1.$$.fragment);
      t6 = space();
      create_component(autosizer.$$.fragment);
      attr(div4, "class", "buttonBar svelte-yfh3b");
      attr(div5, "class", "searchMenuBar svelte-yfh3b");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div5, anchor);
      append(div5, div2);
      info.block.m(div2, info.anchor = null);
      info.mount = () => div2;
      info.anchor = null;
      append(div5, t2);
      append(div5, div4);
      if (if_block)
        if_block.m(div4, null);
      append(div4, t3);
      append(div4, div3);
      append(div4, t4);
      mount_component(buttongroups0, div4, null);
      append(div4, t5);
      mount_component(buttongroups1, div4, null);
      insert(target, t6, anchor);
      mount_component(autosizer, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(search_action = /*search*/
          ctx[9].call(null, div0)),
          listen(
            div1,
            "click",
            /*click_handler*/
            ctx[20]
          ),
          action_destroyer(layoutSetting_action = /*layoutSetting*/
          ctx[10].call(null, div3))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & /*files*/
      256 && promise !== (promise = /*files*/
      ctx[8]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (
        /*showLayoutMenu*/
        ctx[3]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          if_block.m(div4, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const buttongroups0_changes = {};
      if (dirty[0] & /*sortMethod*/
      16)
        buttongroups0_changes.onclick = /*func*/
        ctx[21];
      buttongroups0.$set(buttongroups0_changes);
      const buttongroups1_changes = {};
      if (dirty[0] & /*seq*/
      32)
        buttongroups1_changes.onclick = /*func_1*/
        ctx[22];
      buttongroups1.$set(buttongroups1_changes);
      const autosizer_changes = {};
      if (dirty[0] & /*files, childHeight, childWidth, columnWidth, sortMethod, seq, offset, rowHeight, grid, view*/
      100663799 | dirty[1] & /*$$scope*/
      16) {
        autosizer_changes.$$scope = { dirty, ctx };
      }
      autosizer.$set(autosizer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(buttongroups0.$$.fragment, local);
      transition_in(buttongroups1.$$.fragment, local);
      transition_in(autosizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttongroups0.$$.fragment, local);
      transition_out(buttongroups1.$$.fragment, local);
      transition_out(autosizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t1);
        detach(div5);
        detach(t6);
      }
      info.block.d();
      info.token = null;
      info = null;
      if (if_block)
        if_block.d();
      destroy_component(buttongroups0);
      destroy_component(buttongroups1);
      destroy_component(autosizer, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
var gutter2 = 30;
function instance7($$self, $$props, $$invalidate) {
  let files;
  let { view } = $$props;
  let columnWidth = view.plugin.settings.columnWidth;
  let rowHeight = view.plugin.settings.rowHeight;
  let showLayoutMenu = false;
  let originFiles = [];
  let query = "";
  let sortMethod = sortByModifiedTime;
  let seq = descending;
  let offset = {
    scrollLeft: 0,
    scrollTop: 0,
    verticalScrollDirection: "forward",
    scrollUpdateWasRequested: false,
    horizontalScrollDirection: "forward"
  };
  let rowCount;
  onMount(() => {
    $$invalidate(18, originFiles = view.app.vault.getMarkdownFiles().map((file) => ({ file })));
    const vault = view.app.vault;
    const registerVaultEvent = (callback) => {
      return (tf) => {
        if (tf instanceof import_obsidian9.TFile && tf.extension === "md") {
          callback(tf);
        }
      };
    };
    const create = view.app.vault.on("create", registerVaultEvent((newF) => {
      $$invalidate(18, originFiles = [{ file: newF }, ...originFiles]);
    }));
    const del = view.app.vault.on("delete", registerVaultEvent((delF) => {
      $$invalidate(18, originFiles = originFiles.filter((of) => of.file !== delF));
    }));
    const modify = view.app.vault.on("modify", registerVaultEvent((mf) => __awaiter(void 0, void 0, void 0, function* () {
      const inMatchFile = () => __awaiter(void 0, void 0, void 0, function* () {
        const fs = yield files;
        return fs.find((f) => f.file === mf);
      });
      if (query.length === 0 || (yield inMatchFile()) || (yield search(query, view)({ file: mf })))
        $$invalidate(18, originFiles = originFiles.map((of) => of.file === mf ? { file: mf } : of));
    })));
    const rename = view.app.vault.on("rename", (tf, oldPath) => registerVaultEvent((renameFile) => {
      $$invalidate(18, originFiles = originFiles.map((of) => of.file.path === oldPath ? { file: renameFile } : of));
    })(tf));
    const leafChange = view.app.workspace.on("active-leaf-change", (leaf) => __awaiter(void 0, void 0, void 0, function* () {
      if ((leaf === null || leaf === void 0 ? void 0 : leaf.view.getViewType()) === view.getViewType() && grid) {
        grid.scrollTo({ scrollLeft: 0, scrollTop: 0 });
        grid.scrollTo({
          scrollLeft: offset.scrollLeft,
          scrollTop: offset.scrollTop
        });
      }
    }));
    return () => {
      vault.offref(create);
      vault.offref(modify);
      vault.offref(del);
      vault.offref(rename);
      view.app.workspace.offref(leafChange);
    };
  });
  const search2 = (ele) => {
    new import_obsidian9.SearchComponent(ele).onChange((0, import_obsidian9.debounce)(
      (value) => {
        $$invalidate(19, query = value);
      },
      1e3
    ));
  };
  const layoutSetting = (ele) => {
    const b = new import_obsidian9.ButtonComponent(ele).setIcon("layout-grid").onClick((e) => {
      if (showLayoutMenu) {
        b.removeCta();
      } else {
        b.setCta();
      }
      $$invalidate(3, showLayoutMenu = !showLayoutMenu);
    });
  };
  const columnWidthSetting = (ele) => {
    new import_obsidian9.SliderComponent(ele).setLimits(200, 1e3, 10).setValue(columnWidth).setDynamicTooltip().onChange((value) => {
      $$invalidate(0, view.plugin.settings.columnWidth = value, view);
      view.plugin.saveSettings();
      $$invalidate(1, columnWidth = value);
    });
  };
  const rowHeightSetting = (ele) => {
    new import_obsidian9.SliderComponent(ele).setLimits(200, 1e3, 10).setValue(rowHeight).setDynamicTooltip().onChange((value) => {
      $$invalidate(0, view.plugin.settings.rowHeight = value, view);
      view.plugin.saveSettings();
      $$invalidate(2, rowHeight = value);
    });
  };
  const sortSeq = [
    {
      icon: "arrow-down-narrow-wide",
      toolTip: "asc",
      value: ascending
    },
    {
      icon: "arrow-up-narrow-wide",
      toolTip: "desc",
      value: descending,
      active: true
    }
  ];
  const sortMethods = [
    {
      icon: "file-plus-2",
      toolTip: "last created",
      value: sortByCreateTime
    },
    {
      icon: "file-clock",
      toolTip: "last modified",
      value: sortByModifiedTime,
      active: true
    },
    {
      icon: "file-search",
      toolTip: "related",
      value: sortByRelated
    }
  ];
  const index = (com, columnCount, totalCount) => {
    const dataBefore = com.rowIndex * columnCount, columOffest = com.columnIndex + 1, dataCount = dataBefore + columOffest;
    return dataCount <= totalCount ? dataCount - 1 : null;
  };
  const computeGapStyle = (style, padding) => {
    var _a, _b;
    const top = ((_a = style.top) !== null && _a !== void 0 ? _a : 0) + gutter2, left = ((_b = style.left) !== null && _b !== void 0 ? _b : 0) + gutter2 + padding, width = typeof style.width === "number" ? style.width - gutter2 : style.width, height = typeof style.height === "number" ? style.height - gutter2 : style.height;
    return Object.assign(Object.assign({}, style), { top, left, width, height });
  };
  const rememberScrollOffsetForFileUpdate = (0, import_obsidian9.debounce)(
    (props) => {
      $$invalidate(6, offset = props);
    },
    2e3
  );
  let grid;
  const click_handler = (e) => {
    grid.scrollTo({ scrollLeft: 0, scrollTop: 1600 });
  };
  const func = (e, value) => {
    $$invalidate(4, sortMethod = value);
  };
  const func_1 = (e, value) => {
    $$invalidate(5, seq = value);
  };
  function grid_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      grid = $$value;
      $$invalidate(7, grid);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*view, originFiles, query*/
    786433) {
      $:
        $$invalidate(8, files = getDisplayFiles(view, originFiles, query));
    }
  };
  return [
    view,
    columnWidth,
    rowHeight,
    showLayoutMenu,
    sortMethod,
    seq,
    offset,
    grid,
    files,
    search2,
    layoutSetting,
    columnWidthSetting,
    rowHeightSetting,
    sortSeq,
    sortMethods,
    index,
    computeGapStyle,
    rememberScrollOffsetForFileUpdate,
    originFiles,
    query,
    click_handler,
    func,
    func_1,
    grid_1_binding
  ];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment9, safe_not_equal, { view: 0 }, add_css4, [-1, -1]);
  }
};
var Search_default = Search;

// src/view/cardSearchView.ts
var VIEW_TYPE_CARDNOTESEARCH = "card-notes-view";
var CardSearchView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CARDNOTESEARCH;
  }
  getDisplayText() {
    return "Notes";
  }
  async onOpen() {
    this.component = new Search_default({
      target: this.containerEl.children[1],
      props: {
        view: this
      }
    });
  }
};

// src/ui/linkSettings.ts
var import_obsidian11 = require("obsidian");
var LinkSettingModel = class extends import_obsidian11.Modal {
  constructor(plugin, onSubmit) {
    super(plugin.app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    const setting = new import_obsidian11.Setting(contentEl).setName("Set your label").setDesc("Enter empty could disable adding a label on the link edge automatically").addText((text2) => {
      var _a;
      text2.setValue((_a = this.plugin.settings.defaultLinkLabel) != null ? _a : "");
      text2.onChange((value) => {
        this.label = value.length !== 0 ? value : void 0;
      });
    }).addButton((btn) => {
      btn.setIcon("check").onClick(() => {
        this.onSubmit(this.label);
        this.close();
      }).setCta();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  dragSymbol: "\u{1F494}",
  dragSymbolSize: 18,
  defaultFolder: "",
  columnWidth: 250,
  rowHeight: 250,
  autoLink: false,
  arrowTo: "end"
};
var CardNote = class extends import_obsidian12.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.registerEditorExtension(dragExtension(this));
    this.registerView(
      VIEW_TYPE_CARDNOTESEARCH,
      (leaf) => new CardSearchView(leaf, this)
    );
    this.addRibbonIcon(
      "scan-search",
      "Search Notes",
      () => this.activateView()
    );
    this.addCommands();
    this.addSettingTab(new CardNoteTab(this.app, this));
  }
  addCommands() {
    this.addCommand({
      id: "set-label",
      name: "Set Default Label",
      callback: () => {
        new LinkSettingModel(this, (value) => {
          this.settings.defaultLinkLabel = value;
          this.saveSettings();
        }).open();
      }
    });
    this.addCommand({
      id: "auto-link",
      name: "Enable Auto Link",
      checkCallback: this.changeAutoLinkSettings(
        () => !this.settings.autoLink,
        () => {
          this.settings.autoLink = true;
        }
      )
    });
    this.addCommand({
      id: "cancel-auto-link",
      name: "Disable Auto Link",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.autoLink,
        () => {
          this.settings.autoLink = false;
        }
      )
    });
    this.addCommand({
      id: "arrow-to-from",
      name: "Arrow to From",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "from",
        () => {
          this.settings.arrowTo = "from";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-end",
      name: "Arrow to End",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "end",
        () => {
          this.settings.arrowTo = "end";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-both",
      name: "Arrow to Both",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "both",
        () => {
          this.settings.arrowTo = "both";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-none",
      name: "Arrow to None",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "none",
        () => {
          this.settings.arrowTo = "none";
        }
      )
    });
  }
  changeAutoLinkSettings(check, action) {
    return (checking) => {
      if (check()) {
        if (!checking) {
          action();
          this.saveSettings();
        }
        return true;
      }
      return false;
    };
  }
  async activateView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CARDNOTESEARCH), createNewLeaf = async () => {
      const newLeaf = workspace.getLeaf("split");
      await (newLeaf == null ? void 0 : newLeaf.setViewState({
        type: VIEW_TYPE_CARDNOTESEARCH,
        active: true
      }));
      return newLeaf;
    };
    let leaf = leaves.length > 0 ? leaves[0] : await createNewLeaf();
    workspace.revealLeaf(leaf);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createPath(file, subpath, displayText) {
    return this.app.metadataCache.fileToLinktext(
      file,
      file.path,
      file.extension === "md"
    );
  }
  createLinkText(file, subpath, displayText) {
    const fileLinkPath = this.createPath(file);
    const sub = subpath != null ? subpath : "";
    const fullLinkPath = `${fileLinkPath}${sub}`;
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    const markdownLink = () => {
      const display = displayText != null ? displayText : fullLinkPath;
      return `[${display}](${fullLinkPath.replace(" ", "%20")})`;
    };
    const wikiLink = () => {
      const display = displayText ? `|${displayText}` : "";
      return `[[${fullLinkPath}${display}]]`;
    };
    const linkText = useMarkdownLink ? markdownLink() : wikiLink();
    return {
      path: fileLinkPath,
      subpath,
      file,
      text: linkText,
      displayText
    };
  }
  getActiveEditorFile() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian12.TextFileView);
    if (view) {
      if (isObsidianCanvasView(view)) {
        const [selectNode] = view.canvas.selection;
        return isCanvasEditorNode(selectNode) ? { fileEditor: selectNode, offset: getOffset(selectNode) } : void 0;
      }
      if (isExcalidrawView(view)) {
        const excalidrawShape = view.getViewSelectedElements().first();
        const embeddable = view.getActiveEmbeddable();
        return isCanvasEditorNode(embeddable == null ? void 0 : embeddable.node) ? {
          fileEditor: {
            ...embeddable.node,
            id: (_a = excalidrawShape == null ? void 0 : excalidrawShape.id) != null ? _a : embeddable.node.id
          },
          offset: getOffset(embeddable.node)
        } : void 0;
      }
    }
    return { fileEditor: this.app.workspace.activeEditor, offset: 0 };
  }
  async checkFileName(file) {
    const fileName = file.fileName;
    if (fileName.length === 0) {
      return new Error("File Name can not be empty!");
    } else if (fileName.endsWith(" ")) {
      return new Error("File Name can not end with white space!");
    } else {
      const matchInvalidSymbol = FILENAMEREPLACE().exec(fileName);
      if (matchInvalidSymbol) {
        return new Error(`File Name can not contains symbols [!"#$%&()*+,.:;<=>?@^\`{|}~/[]\r
]`);
      }
    }
    const filePathUncheck = createFullPath(file);
    const normalFilePath = (0, import_obsidian12.normalizePath)(filePathUncheck);
    this.app.vault.checkPath(normalFilePath);
    if (await this.app.vault.adapter.exists(normalFilePath)) {
      return new Error("File exist!");
    }
    return { ...file, fileName: normalFilePath };
  }
  updateInternalLinks(linkMap, newPath) {
    const changes = LinkToChanges(linkMap, newPath);
    this.app.fileManager.updateInternalLinks(changes);
  }
  renameCanvasSubpath(origin, newFile) {
    var _a, _b;
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    if (origin.file.path === newFile.file.path && origin.subpath !== newFile.subpath) {
      canvasUpdater.renameSubpath(origin.file, (_a = origin.subpath) != null ? _a : "", (_b = newFile.subpath) != null ? _b : "");
    }
  }
  getCanvas(filter) {
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    const canvases = canvasUpdater.canvas.index.getAll();
    const queue = [];
    for (const canvasFilePath in canvases) {
      const canvasCache = canvases[canvasFilePath];
      const find = canvasCache.embeds.find((embed) => {
        var _a;
        return (_a = filter == null ? void 0 : filter(canvasFilePath, embed)) != null ? _a : true;
      });
      if (find) {
        queue.push(canvasFilePath);
      }
    }
    return queue;
  }
  updateCanvasNodes(canvasPath, newNode) {
    const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
    if (canvasFile instanceof import_obsidian12.TFile && canvasFile.extension === "canvas") {
      return this.app.vault.process(canvasFile, (data) => {
        const canvasData = JSON.parse(data);
        const nodeUpdate = canvasData.nodes.map(newNode);
        const newData = {
          edges: canvasData.edges,
          nodes: nodeUpdate
        };
        return JSON.stringify(newData);
      });
    }
  }
  updateCanvasLinks(canvasPathSet, map) {
    const result = canvasPathSet.map((canvasPath) => this.updateCanvasNodes(canvasPath, (node) => {
      if (node.type === "file") {
        return map(node);
      }
      return node;
    }));
    return Promise.all(result);
  }
  findLinkBlocks(file, from, to) {
    var _a, _b;
    const cache = this.app.metadataCache.getFileCache(file);
    const blocks = cache == null ? void 0 : cache.blocks;
    const inRange = (item) => {
      const end = item.position.end;
      return end.offset > from && end.offset <= to;
    };
    const blocksInRange = [];
    for (const blockName in blocks) {
      const blockInfo = blocks[blockName];
      if (inRange(blockInfo)) {
        blocksInRange.push(blockInfo);
      }
    }
    const headingInRange = (_b = (_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.filter(inRange)) != null ? _b : [];
    return [blocksInRange, headingInRange];
  }
  createLinkInfo(cache) {
    const normalizeLink = cache.link.replace(/\u00A0/, "").normalize();
    const path = normalizeLink.split("#")[0];
    const subpath = normalizeLink.substring(path.length);
    return {
      path,
      subpath,
      link: cache
    };
  }
  findLinks(targetFile, match) {
    return new Promise((res) => {
      const cache = this.app.metadataCache;
      const fileManger = this.app.fileManager;
      const linkMap = /* @__PURE__ */ new Map();
      fileManger.iterateAllRefs((fileName, linkCache) => {
        var _a;
        fileName.normalize();
        const linkInfo = this.createLinkInfo(linkCache);
        const { path, subpath } = linkInfo;
        if (match({ path, subpath, file: (_a = cache.getFirstLinkpathDest(path, fileName)) != null ? _a : void 0 })) {
          const links = linkMap.get(fileName);
          if (links) {
            links.push(linkInfo);
          } else {
            linkMap.set(fileName, [linkInfo]);
          }
        }
      });
      const selfLink = linkMap.get(targetFile.path);
      linkMap.delete(targetFile.path);
      res([selfLink, linkMap]);
    });
  }
  normalizeHeadingToLinkText(heading) {
    const path = heading.replace(HEADINGREPLACE(), " ").replace(/\s+/g, " ");
    return path;
  }
  replaceSpaceInLinkText(link) {
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    return useMarkdownLink ? link.replace(" ", "%20") : link;
  }
  createRandomHexString(length = 6) {
    const id = [...Array(length).keys()].map((_) => (16 * Math.random() | 0).toString(16)).join("");
    return id;
  }
  listenDragAndDrop(e, content, dropEvent) {
    const trim = content.trim(), display = trim.length > 600 ? trim.substring(0, 600).concat(" ...") : trim;
    const floatingSplits = this.app.workspace.floatingSplit, popoutWindows = floatingSplits.children.map((win) => win.containerEl), allWindows = [this.app.workspace.containerEl].concat(popoutWindows), eventListeners = allWindows.map((container) => this.createDraggingAndDropEvent(e, container, display, dropEvent));
    return {
      reset: () => eventListeners.forEach((listen2) => listen2.reset())
    };
  }
  createDraggingAndDropEvent(e, container, content, dropEvent) {
    const dragContentEle = document.createElement("div");
    dragContentEle.hide();
    dragContentEle.style.transform = `translate(${e.clientX}px,${e.clientY}px)`;
    dragContentEle.style.width = "300px";
    dragContentEle.style.height = "min-content";
    dragContentEle.style.position = "absolute";
    dragContentEle.style.padding = "5px 25px";
    dragContentEle.style.borderWidth = "3px";
    dragContentEle.style.borderRadius = "10px";
    dragContentEle.style.border = "solid";
    dragContentEle.style.pointerEvents = "none";
    const dragoverBackground = document.createElement("div");
    dragoverBackground.setCssStyles({
      opacity: "0",
      width: "100%",
      height: "100%",
      position: "fixed"
    });
    import_obsidian12.MarkdownRenderer.render(
      this.app,
      content,
      dragContentEle,
      "",
      this
    );
    container.appendChild(dragoverBackground);
    container.appendChild(dragContentEle);
    const showDragContent = (e2) => {
      dragContentEle.show();
    };
    const moveDragContent = (e2) => {
      const x = e2.clientX, y = e2.clientY;
      dragContentEle.style.transform = `translate(${x}px,${y}px)`;
      e2.preventDefault();
    };
    const hideDragContent = (e2) => {
      if (e2.target === dragoverBackground) {
        dragContentEle.hide();
      }
    };
    container.addEventListener("dragenter", showDragContent);
    container.addEventListener("dragover", moveDragContent);
    container.addEventListener("dragleave", hideDragContent);
    container.addEventListener("drop", dropEvent);
    return {
      reset: () => {
        container.removeChild(dragContentEle);
        container.removeChild(dragoverBackground);
        container.removeEventListener("drop", dropEvent);
        container.removeEventListener("dragover", moveDragContent);
        container.removeEventListener("dragenter", showDragContent);
        container.removeEventListener("dragleave", hideDragContent);
      }
    };
  }
  getDropView(e) {
    const locate = this.app.workspace.getDropLocation(e), target = locate.children.find((child) => child.tabHeaderEl.className.contains("active")), drawView = target == null ? void 0 : target.view;
    return drawView;
  }
  onClickOpenFile(e, file, openState) {
    const isFnKey = () => e.ctrlKey || e.metaKey;
    this.app.workspace.getLeaf(
      isFnKey() && e.shiftKey && e.altKey ? "window" : isFnKey() && e.altKey ? "split" : isFnKey() ? "tab" : false
    ).openFile(file, openState);
  }
  arrowToFrom() {
    return this.settings.arrowTo == "both" || this.settings.arrowTo == "from";
  }
  arrowToEnd() {
    return this.settings.arrowTo == "both" || this.settings.arrowTo == "end";
  }
};
var CardNoteTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian12.Setting(containerEl).setName("Drag symbol").setDesc("You can set your prefer drag symbol here").addText(
      (text2) => text2.setPlaceholder("Enter your drag symbol here").setValue(this.plugin.settings.dragSymbol).onChange(async (value) => {
        this.plugin.settings.dragSymbol = value;
        await this.plugin.saveSettings();
      })
    );
    this.addSizeSetting();
    new import_obsidian12.Setting(containerEl).setName("Default folder").setDesc("Default loction for new note. if empty, new note will be created in the vault root.").addText(
      (text2) => text2.setPlaceholder("/sub folder name").setValue(this.plugin.settings.defaultFolder).onChange(async (value) => {
        this.plugin.settings.defaultFolder = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addSizeSetting() {
    const desc = (value) => {
      return `Change your symbol size. Current size is ${value != null ? value : this.plugin.settings.dragSymbolSize}.(min=1 max=100)`;
    };
    const sizeSetting = new import_obsidian12.Setting(this.containerEl).setName("Symbol size (px)").setDesc(desc()).addSlider(
      (slider) => {
        var _a;
        slider.setLimits(1, 100, 1).setValue((_a = this.plugin.settings.dragSymbolSize) != null ? _a : 18).onChange(async (value) => {
          sizeSetting.setDesc(desc(value));
          this.plugin.settings.dragSymbolSize = value;
          await this.plugin.saveSettings();
        }).setDynamicTooltip();
      }
    );
  }
};
