/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/logger.ts
var Logger = class {
  constructor() {
    this.logLevel = 0 /* Error */;
  }
  log(message, level) {
    let _message;
    if (typeof message === "string") {
      _message = `GitHub Link: ${message}`;
    } else {
      _message = message;
    }
    if (level <= this.logLevel) {
      switch (level) {
        case 0 /* Error */:
          console.error(_message);
          break;
        case 1 /* Warn */:
          console.warn(_message);
          break;
        case 2 /* Info */:
          console.info(_message);
          break;
        case 3 /* Debug */:
          console.debug(_message);
          break;
      }
    }
  }
  error(message) {
    this.log(message, 0 /* Error */);
  }
  warn(message) {
    this.log(message, 1 /* Warn */);
  }
  info(message) {
    this.log(message, 2 /* Info */);
  }
  debug(message) {
    this.log(message, 3 /* Debug */);
  }
};

// src/settings/types.ts
var DEFAULT_SETTINGS = {
  accounts: [],
  defaultPageSize: 10,
  logLevel: 0 /* Error */,
  tagTooltips: false,
  tagShowPRMergeable: false,
  cacheIntervalSeconds: 60,
  maxCacheAgeHours: 120,
  minRequestSeconds: 60
};

// src/settings/settings-tab.ts
var import_obsidian4 = require("obsidian");

// src/settings/account.ts
var import_obsidian3 = require("obsidian");

// src/auth-modal.ts
var import_obsidian = require("obsidian");
var AuthModal = class extends import_obsidian.Modal {
  constructor(app, verification) {
    super(app);
    this.verification = verification;
  }
  onOpen() {
    this.titleEl.setText("Generate GitHub token");
    this.contentEl.empty();
    const wrapper = this.contentEl.createDiv({ cls: "gh-auth-modal" });
    wrapper.createEl("p", {
      text: "Copy the following code and paste it at the GitHub link below."
    });
    const codeEl = wrapper.createDiv({
      cls: "gh-auth-code-section"
    });
    codeEl.createSpan({
      cls: "auth-code",
      text: this.verification.user_code
    });
    const button = codeEl.createEl("button", {
      attr: { type: "button", "aria-label": "Copy Code" }
    });
    (0, import_obsidian.setIcon)(button, "copy");
    button.addEventListener("click", this.copyToClipboard.bind(this));
    wrapper.createEl("a", {
      href: this.verification.verification_uri,
      text: this.verification.verification_uri
    });
  }
  copyToClipboard() {
    window.navigator.clipboard.writeText(this.verification.user_code);
  }
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-web/index.js
var VERSION = "9.0.4";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toESM(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION2 = "8.2.0";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
});

// node_modules/@octokit/oauth-methods/dist-src/utils.js
function requestToOAuthBaseUrl(request2) {
  const endpointDefaults = request2.endpoint.DEFAULTS;
  return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request2, route, parameters) {
  const withOAuthParameters = {
    baseUrl: requestToOAuthBaseUrl(request2),
    headers: {
      accept: "application/json"
    },
    ...parameters
  };
  const response = await request2(route, withOAuthParameters);
  if ("error" in response.data) {
    const error = new RequestError(
      `${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`,
      400,
      {
        request: request2.endpoint.merge(
          route,
          withOAuthParameters
        ),
        headers: response.headers
      }
    );
    error.response = response;
    throw error;
  }
  return response;
}

// node_modules/@octokit/oauth-methods/dist-src/create-device-code.js
async function createDeviceCode(options) {
  const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const parameters = {
    client_id: options.clientId
  };
  if ("scopes" in options && Array.isArray(options.scopes)) {
    parameters.scope = options.scopes.join(" ");
  }
  return oauthRequest(request2, "POST /login/device/code", parameters);
}

// node_modules/@octokit/oauth-methods/dist-src/exchange-device-code.js
async function exchangeDeviceCode(options) {
  const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await oauthRequest(
    request2,
    "POST /login/oauth/access_token",
    {
      client_id: options.clientId,
      device_code: options.code,
      grant_type: "urn:ietf:params:oauth:grant-type:device_code"
    }
  );
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if ("clientSecret" in options) {
    authentication.clientSecret = options.clientSecret;
  }
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(
        apiTimeInMs,
        response.data.expires_in
      ), authentication.refreshTokenExpiresAt = toTimestamp(
        apiTimeInMs,
        response.data.refresh_token_expires_in
      );
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}

// node_modules/@octokit/auth-oauth-device/dist-web/index.js
async function getOAuthAccessToken(state, options) {
  const cachedAuthentication = getCachedAuthentication(state, options.auth);
  if (cachedAuthentication)
    return cachedAuthentication;
  const { data: verification } = await createDeviceCode({
    clientType: state.clientType,
    clientId: state.clientId,
    request: options.request || state.request,
    // @ts-expect-error the extra code to make TS happy is not worth it
    scopes: options.auth.scopes || state.scopes
  });
  await state.onVerification(verification);
  const authentication = await waitForAccessToken(
    options.request || state.request,
    state.clientId,
    state.clientType,
    verification
  );
  state.authentication = authentication;
  return authentication;
}
function getCachedAuthentication(state, auth22) {
  if (auth22.refresh === true)
    return false;
  if (!state.authentication)
    return false;
  if (state.clientType === "github-app") {
    return state.authentication;
  }
  const authentication = state.authentication;
  const newScope = ("scopes" in auth22 && auth22.scopes || state.scopes).join(
    " "
  );
  const currentScope = authentication.scopes.join(" ");
  return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
  await new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
}
async function waitForAccessToken(request2, clientId, clientType, verification) {
  try {
    const options = {
      clientId,
      request: request2,
      code: verification.device_code
    };
    const { authentication } = clientType === "oauth-app" ? await exchangeDeviceCode({
      ...options,
      clientType: "oauth-app"
    }) : await exchangeDeviceCode({
      ...options,
      clientType: "github-app"
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  } catch (error) {
    if (!error.response)
      throw error;
    const errorType = error.response.data.error;
    if (errorType === "authorization_pending") {
      await wait(verification.interval);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    if (errorType === "slow_down") {
      await wait(verification.interval + 5);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    throw error;
  }
}
async function auth(state, authOptions) {
  return getOAuthAccessToken(state, {
    auth: authOptions
  });
}
async function hook(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  const { token } = await getOAuthAccessToken(state, {
    request: request2,
    auth: { type: "oauth" }
  });
  endpoint2.headers.authorization = `token ${token}`;
  return request2(endpoint2);
}
var VERSION3 = "6.0.1";
function createOAuthDeviceAuth(options) {
  const requestWithDefaults = options.request || request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-device.js/${VERSION3} ${getUserAgent()}`
    }
  });
  const { request: request2 = requestWithDefaults, ...otherOptions } = options;
  const state = options.clientType === "github-app" ? {
    ...otherOptions,
    clientType: "github-app",
    request: request2
  } : {
    ...otherOptions,
    clientType: "oauth-app",
    request: request2,
    scopes: options.scopes || []
  };
  if (!options.clientId) {
    throw new Error(
      '[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  if (!options.onVerification) {
    throw new Error(
      '[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  return Object.assign(auth.bind(null, state), {
    hook: hook.bind(null, state)
  });
}

// src/github/auth.ts
var import_obsidian2 = require("obsidian");
var defaultClientId = "baf0370cb98e1387d244";
function getHeaders(headers) {
  if (!headers) {
    return void 0;
  }
  if (headers instanceof Headers) {
    const result = {};
    headers.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  if (Array.isArray(headers)) {
    throw new Error("Got array headers, we don't know what to do with this yet.");
  }
  return headers;
}
function getBody(body) {
  if (!body) {
    return void 0;
  }
  if (body instanceof ArrayBuffer || typeof body === "string") {
    return body;
  }
  console.warn(`Got an unknown body parameter type, trying to stringify it.`);
  console.warn(body);
  try {
    return JSON.stringify(body);
  } catch (e) {
    console.error("Could not stringify body parameter.");
    return void 0;
  }
}
async function doFetch(url, options) {
  if (typeof url !== "string") {
    throw new Error("Something has gone horribly wrong and fetch has received unexpected arguments.");
  }
  if (options === void 0) {
    throw new Error("No options given to fetch.");
  }
  const headers = getHeaders(options.headers);
  const contentType = headers == null ? void 0 : headers["Content-Type"];
  const params = {
    url,
    headers,
    method: options.method,
    body: getBody(options.body),
    contentType
  };
  const result = await (0, import_obsidian2.requestUrl)(params);
  const partialResult = {
    ...result,
    url,
    headers: new Headers(result.headers),
    arrayBuffer: () => Promise.resolve(result.arrayBuffer),
    text: () => Promise.resolve(result.text),
    json: () => Promise.resolve(result.json)
  };
  return partialResult;
}
var auth2 = (verificationHandler, clientId = defaultClientId) => createOAuthDeviceAuth({
  clientType: "oauth-app",
  clientId,
  scopes: ["repo"],
  onVerification: verificationHandler,
  request: request.defaults({
    request: { fetch: doFetch }
  })
});

// src/settings/account.ts
var AccountSettings = class {
  constructor(app, container, saveCallback, displayCallback, removeCallback) {
    this.app = app;
    this.container = container;
    this.saveCallback = saveCallback;
    this.displayCallback = displayCallback;
    this.removeCallback = removeCallback;
    this.authModal = null;
    this.newAccount = null;
  }
  render(accounts) {
    for (const account of accounts) {
      this.renderAccountSetting(account);
    }
  }
  renderNewAccount(container, saveNewAccountCallback) {
    if (!this.newAccount) {
      this.newAccount = { id: crypto.randomUUID(), name: "", orgs: [], token: "", customOAuth: false };
    }
    const accountContainer = container.createDiv();
    const header = accountContainer.createEl("h3", { text: "New account" });
    new import_obsidian3.Setting(accountContainer).setName("Account name").setDesc("Required.").addText((text) => {
      text.setValue(this.newAccount.name);
      text.onChange((value) => {
        this.newAccount.name = value;
        header.setText(value != null ? value : "New account");
      });
    }).addButton((button) => {
      button.setIcon("trash");
      button.setTooltip("Delete account");
      button.onClick(() => {
        this.newAccount = null;
        this.displayCallback();
      });
    });
    new import_obsidian3.Setting(accountContainer).setName("Orgs and users").setDesc(
      "A comma separated list of the GitHub organizations and users this account should be used for. Optional."
    ).addTextArea((text) => {
      text.setValue(this.newAccount.orgs.join(", "));
      text.onChange((value) => {
        this.newAccount.orgs = value.split(",").map((acc) => acc.trim());
      });
    });
    const oauthDesc = createFragment((fragment) => {
      fragment.appendText(
        "You can optionally provide your own OAuth app for more control and a larger request rate limit. See the "
      );
      fragment.createEl("a", {
        text: "plugin documentation",
        href: "https://github.com/nathonius/obsidian-github-link/wiki/Authentication#custom-oauth-app"
      });
      fragment.appendText(" for instructions.");
    });
    const customOAuthSetting = new import_obsidian3.Setting(accountContainer).setName("Use custom OAuth app").setDesc(oauthDesc).addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.newAccount.customOAuth) != null ? _a : false);
      toggle.onChange((value) => {
        this.newAccount.customOAuth = value;
        this.displayCallback();
      });
    });
    if (this.newAccount.customOAuth) {
      customOAuthSetting.addText((text) => {
        var _a;
        text.setValue((_a = this.newAccount.clientId) != null ? _a : "");
        text.setPlaceholder("Client ID");
        text.onChange((value) => {
          this.newAccount.clientId = value;
        });
      });
    }
    new import_obsidian3.Setting(accountContainer).setName("Token").setDesc(
      "A GitHub token, which can be generated automatically (recommended) or by creating a personal access token (not recommended unless org does not allow OAuth tokens). Required."
    ).addButton((button) => {
      button.setButtonText("Generate Token");
      button.onClick(async () => {
        var _a;
        const authResult = await auth2(this.tokenVerification.bind(this))({
          type: "oauth"
        });
        (_a = this.authModal) == null ? void 0 : _a.close();
        this.authModal = null;
        this.newAccount.token = authResult.token;
        this.displayCallback();
      });
    }).addText((text) => {
      text.setPlaceholder("Personal Access Token / OAuth Token");
      text.setValue(this.newAccount.token);
      text.onChange((value) => {
        this.newAccount.token = value;
      });
    });
    new import_obsidian3.Setting(accountContainer).addButton((button) => {
      button.setButtonText("Save account");
      button.setTooltip("Save account");
      button.setIcon("save");
      button.onClick(async () => {
        var _a;
        if (!((_a = this.newAccount) == null ? void 0 : _a.name)) {
          return;
        }
        await saveNewAccountCallback(this.newAccount);
        this.newAccount = null;
        this.displayCallback();
      });
    });
  }
  renderAccountSetting(account, parent = this.container) {
    const accountContainer = parent.createDiv();
    accountContainer.createEl("h3", { text: account.name });
    new import_obsidian3.Setting(accountContainer).setName("Account name").addText((text) => {
      text.setValue(account.name);
      text.onChange((value) => {
        account.name = value;
        this.saveCallback();
      });
    }).addButton((button) => {
      button.setIcon("trash");
      button.setTooltip("Delete account");
      button.onClick(async () => {
        this.removeCallback(account);
        await this.saveCallback();
        this.displayCallback();
      });
    });
    new import_obsidian3.Setting(accountContainer).setName("Orgs and users").setDesc("A comma separated list of the GitHub organizations and users this account should be used for.").addTextArea((text) => {
      text.setValue(account.orgs.join(", "));
      text.onChange((value) => {
        account.orgs = value.split(",").map((org) => org.trim());
        this.saveCallback();
      });
    });
    const oauthDesc = createFragment((fragment) => {
      fragment.appendText(
        "You can optionally provide your own OAuth app for more control and a larger request rate limit. See the "
      );
      fragment.createEl("a", { text: "plugin documentation", href: "#" });
      fragment.appendText(" for instructions.");
    });
    const customOAuthSetting = new import_obsidian3.Setting(accountContainer).setName("Use custom OAuth app").setDesc(oauthDesc).addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = account.customOAuth) != null ? _a : false);
      toggle.onChange((value) => {
        account.customOAuth = value;
        this.displayCallback();
      });
    });
    if (account.customOAuth) {
      customOAuthSetting.addText((text) => {
        var _a;
        text.setValue((_a = account.clientId) != null ? _a : "");
        text.setPlaceholder("Client ID");
        text.onChange((value) => {
          account.clientId = value;
          this.saveCallback();
        });
      });
    }
    new import_obsidian3.Setting(accountContainer).setName("Token").setDesc(
      "A GitHub token, which can be generated automatically (recommended) or by creating a personal access token (not recommended unless org does not allow OAuth tokens)."
    ).addButton((button) => {
      button.setButtonText("Generate Token");
      button.onClick(async () => {
        var _a;
        const customClientId = account.customOAuth ? account.clientId : void 0;
        const authResult = await auth2(
          this.tokenVerification.bind(this),
          customClientId
        )({
          type: "oauth"
        });
        (_a = this.authModal) == null ? void 0 : _a.close();
        this.authModal = null;
        account.token = authResult.token;
        await this.saveCallback();
        this.displayCallback();
      });
    }).addText((text) => {
      text.setPlaceholder("Personal Access Token / OAuth Token");
      text.setValue(account.token);
      text.onChange((value) => {
        account.token = value;
        this.saveCallback();
      });
    });
  }
  tokenVerification(verification) {
    this.authModal = new AuthModal(this.app, verification);
    this.authModal.open();
  }
};

// src/settings/settings-tab.ts
var GithubLinkPluginSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
    this.accountSettings = new AccountSettings(
      this.app,
      this.containerEl,
      this.saveSettings.bind(this),
      this.display.bind(this),
      this.removeAccount.bind(this)
    );
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GitHub authentication" });
    containerEl.createEl("p", {
      text: "No authentication is required to reference public repositories. Providing a token allows referencing private repos, but the token is stored in plain text. You can create multiple accounts for multiple tokens."
    });
    const newAccountSection = containerEl.createDiv();
    new import_obsidian4.Setting(newAccountSection).setName("Add account").addButton((button) => {
      button.setButtonText("");
      button.setIcon("plus");
      button.setTooltip("Add Account");
      button.onClick(() => {
        this.accountSettings.renderNewAccount(newAccountSection, this.saveNewAccount.bind(this));
      });
    });
    if (this.accountSettings.newAccount) {
      this.accountSettings.renderNewAccount(newAccountSection, this.saveNewAccount.bind(this));
    }
    new import_obsidian4.Setting(containerEl).setName("Default account").setDesc("The account that will be used if no other users or organizations match.").addDropdown((dropdown) => {
      var _a;
      const options = PluginSettings.accounts.reduce((acc, account) => {
        acc[account.id] = account.name;
        return acc;
      }, {});
      dropdown.addOptions(options);
      dropdown.setValue((_a = PluginSettings.defaultAccount) != null ? _a : "");
      dropdown.onChange(async (value) => {
        const selectedAccount = PluginSettings.accounts.find((acc) => acc.id === value);
        if (selectedAccount) {
          PluginSettings.defaultAccount = selectedAccount.id;
          await this.saveSettings();
        }
      });
    });
    this.accountSettings.render(PluginSettings.accounts);
    containerEl.createEl("h2", { text: "Other settings" });
    new import_obsidian4.Setting(containerEl).setName("Default result size").setDesc("The maximum number of results that will be included in a table unless specified otherwise.").addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        PluginSettings.defaultPageSize = DEFAULT_SETTINGS.defaultPageSize;
        await this.saveSettings();
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const displayValue = createSpan({ text: PluginSettings.defaultPageSize.toString() });
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(displayValue);
      slider.setLimits(0, 30, 1);
      slider.setDynamicTooltip();
      slider.setValue(PluginSettings.defaultPageSize);
      slider.onChange((value) => {
        displayValue.setText(value.toString());
        PluginSettings.defaultPageSize = value;
        this.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Status tooltips").setDesc("Add a tooltip to issue and pull request status icons with status text").addToggle((toggle) => {
      toggle.setValue(PluginSettings.tagTooltips);
      toggle.onChange((value) => {
        PluginSettings.tagTooltips = value;
        this.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Pull request mergeability").setDesc("Add an icon to pull request tags to show whether or not the PR is mergeable").addToggle((toggle) => {
      toggle.setValue(PluginSettings.tagShowPRMergeable);
      toggle.onChange((value) => {
        PluginSettings.tagShowPRMergeable = value;
        this.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Cache settings" });
    new import_obsidian4.Setting(containerEl).setClass("github-link-sub-setting").setName("Cache save interval (seconds)").setDesc(
      "If it has been updated, cache will be saved to disk after this number of seconds while Obsidian is open."
    ).addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        PluginSettings.cacheIntervalSeconds = DEFAULT_SETTINGS.cacheIntervalSeconds;
        await this.saveSettings();
        this.plugin.setCacheInterval();
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const displayValue = createSpan({ text: PluginSettings.cacheIntervalSeconds.toString() });
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(displayValue);
      slider.setValue(PluginSettings.cacheIntervalSeconds);
      slider.setLimits(10, 1200, 10);
      slider.setDynamicTooltip();
      slider.onChange(async (value) => {
        PluginSettings.cacheIntervalSeconds = value;
        displayValue.setText(value.toString());
        await this.saveSettings();
        this.plugin.setCacheInterval();
      });
    });
    new import_obsidian4.Setting(containerEl).setClass("github-link-sub-setting").setName("Max cache age (hours)").setDesc("Upon Obsidian startup, cache entries older than this many hours will be removed.").addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        PluginSettings.maxCacheAgeHours = DEFAULT_SETTINGS.maxCacheAgeHours;
        await this.saveSettings();
        this.plugin.setCacheInterval();
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const displayValue = createSpan({ text: PluginSettings.maxCacheAgeHours.toString() });
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(displayValue);
      slider.setValue(PluginSettings.maxCacheAgeHours);
      slider.setLimits(0, 170, 10);
      slider.setDynamicTooltip();
      slider.onChange(async (value) => {
        PluginSettings.maxCacheAgeHours = value;
        displayValue.setText(value.toString());
        await this.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setClass("github-link-sub-setting").setName("Minimum time between same request (seconds)").setDesc(
      "If a request is made within this time frame for a value that is already cached, the cached value will be used without checking if it has changed."
    ).addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        PluginSettings.minRequestSeconds = DEFAULT_SETTINGS.minRequestSeconds;
        await this.saveSettings();
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const displayValue = createSpan({ text: PluginSettings.minRequestSeconds.toString() });
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(displayValue);
      slider.setValue(PluginSettings.minRequestSeconds);
      slider.setLimits(10, 1200, 10);
      slider.setDynamicTooltip();
      slider.onChange(async (value) => {
        PluginSettings.minRequestSeconds = value;
        displayValue.setText(value.toString());
        await this.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setClass("github-link-sub-setting").setName("Clear cache").setDesc("Seeing strange cache behavior? Clicking this will delete all cached responses.").addButton((button) => {
      button.setIcon("trash");
      button.setButtonText("Clear cache");
      button.onClick(async () => {
        const itemsDeleted = getCache().clean(/* @__PURE__ */ new Date());
        PluginData.cache = null;
        await this.saveSettings();
        new import_obsidian4.Notice(`Removed ${itemsDeleted} stored items from GitHub Link cache.`, 3e3);
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Log level").setDesc("Enable debug logging.").addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        PluginSettings.logLevel = DEFAULT_SETTINGS.logLevel;
        await this.saveSettings();
        this.display();
      });
    }).addDropdown((dropdown) => {
      dropdown.addOptions({
        [0 /* Error */]: "Error",
        [1 /* Warn */]: "Warn",
        [2 /* Info */]: "Info",
        [3 /* Debug */]: "Debug"
      });
      dropdown.setValue(PluginSettings.logLevel.toString());
      dropdown.onChange((value) => {
        PluginSettings.logLevel = Number(value);
        this.saveSettings();
      });
    });
  }
  saveSettings() {
    const newData = {
      cache: PluginData.cache,
      settings: PluginSettings
    };
    return this.plugin.saveData(newData);
  }
  async removeAccount(account) {
    PluginSettings.accounts.remove(account);
    await this.saveSettings();
  }
  async saveNewAccount(account) {
    PluginSettings.accounts.unshift(account);
    await this.saveSettings();
  }
};

// src/github/response.ts
function getSearchResultIssueStatus(issue) {
  var _a;
  if (((_a = issue.pull_request) == null ? void 0 : _a.merged_at) || issue.state_reason === "completed") {
    return "done" /* Done */;
  } else if (issue.closed_at || issue.state === "closed") {
    return "closed" /* Closed */;
  } else {
    return "open" /* Open */;
  }
}
function getIssueStatus(issue) {
  if (issue.state === "open") {
    return "open" /* Open */;
  } else if (issue.state_reason === "completed") {
    return "done" /* Done */;
  } else {
    return "closed" /* Closed */;
  }
}
function getPRStatus(pr) {
  if (pr.merged) {
    return "done" /* Done */;
  } else if (pr.closed_at) {
    return "closed" /* Closed */;
  } else {
    return "open" /* Open */;
  }
}

// src/util.ts
function titleCase(value) {
  const words = value.split(/[-_]/);
  return words.map((w) => {
    var _a;
    return ((_a = w.charAt(0)) == null ? void 0 : _a.toUpperCase()) + w.slice(1);
  }).join(" ");
}
function sanitizeObject(params, usableFieldMap) {
  const usableFields = Object.entries(usableFieldMap).filter(([_, value]) => value).map(([key, _]) => key);
  const result = {};
  for (const field of usableFields) {
    if (params[field] !== void 0) {
      result[field] = params[field];
    }
  }
  return result;
}
function getProp(value, prop) {
  var _a;
  if (!prop.includes(".")) {
    return (_a = value[prop]) != null ? _a : null;
  }
  const parts = prop.split(".");
  let val = value;
  for (const part of parts) {
    try {
      val = val[part];
    } catch (err) {
      return null;
    }
  }
  return val != null ? val : null;
}
var n = "numeric";
var DateFormat = {
  DATE_SHORT: new Intl.DateTimeFormat(void 0, {
    year: n,
    month: n,
    day: n
  })
};
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { resolve, reject, promise };
}
function isSuccessResponse(code) {
  return code >= 200 && code <= 208;
}
var RequestError2 = class {
  constructor(originalError) {
    this.originalError = originalError;
    this.name = originalError.name;
    this.stack = originalError.stack;
    this.message = originalError.message;
    this.headers = originalError.headers;
    this.status = originalError.status;
  }
};

// src/github/api.ts
var import_obsidian5 = require("obsidian");

// node_modules/queue/index.js
var has = Object.prototype.hasOwnProperty;
var QueueEvent = class extends Event {
  constructor(name, detail) {
    super(name);
    this.detail = detail;
  }
};
var Queue = class extends EventTarget {
  constructor(options = {}) {
    super();
    const { concurrency = Infinity, timeout = 0, autostart = false, results = null } = options;
    this.concurrency = concurrency;
    this.timeout = timeout;
    this.autostart = autostart;
    this.results = results;
    this.pending = 0;
    this.session = 0;
    this.running = false;
    this.jobs = [];
    this.timers = [];
    this.addEventListener("error", this._errorHandler);
  }
  _errorHandler(evt) {
    this.end(evt.detail.error);
  }
  pop() {
    return this.jobs.pop();
  }
  shift() {
    return this.jobs.shift();
  }
  indexOf(searchElement, fromIndex) {
    return this.jobs.indexOf(searchElement, fromIndex);
  }
  lastIndexOf(searchElement, fromIndex) {
    if (fromIndex !== void 0)
      return this.jobs.lastIndexOf(searchElement, fromIndex);
    return this.jobs.lastIndexOf(searchElement);
  }
  slice(start, end) {
    this.jobs = this.jobs.slice(start, end);
    return this;
  }
  reverse() {
    this.jobs.reverse();
    return this;
  }
  push(...workers) {
    const methodResult = this.jobs.push(...workers);
    if (this.autostart)
      this._start();
    return methodResult;
  }
  unshift(...workers) {
    const methodResult = this.jobs.unshift(...workers);
    if (this.autostart)
      this._start();
    return methodResult;
  }
  splice(start, deleteCount, ...workers) {
    this.jobs.splice(start, deleteCount, ...workers);
    if (this.autostart)
      this._start();
    return this;
  }
  get length() {
    return this.pending + this.jobs.length;
  }
  start(callback) {
    if (this.running)
      throw new Error("already started");
    let awaiter;
    if (callback) {
      this._addCallbackToEndEvent(callback);
    } else {
      awaiter = this._createPromiseToEndEvent();
    }
    this._start();
    return awaiter;
  }
  _start() {
    this.running = true;
    if (this.pending >= this.concurrency) {
      return;
    }
    if (this.jobs.length === 0) {
      if (this.pending === 0) {
        this.done();
      }
      return;
    }
    const job = this.jobs.shift();
    const session = this.session;
    const timeout = job !== void 0 && has.call(job, "timeout") ? job.timeout : this.timeout;
    let once2 = true;
    let timeoutId = null;
    let didTimeout = false;
    let resultIndex = null;
    const next = (error, ...result) => {
      if (once2 && this.session === session) {
        once2 = false;
        this.pending--;
        if (timeoutId !== null) {
          this.timers = this.timers.filter((tID) => tID !== timeoutId);
          clearTimeout(timeoutId);
        }
        if (error) {
          this.dispatchEvent(new QueueEvent("error", { error, job }));
        } else if (!didTimeout) {
          if (resultIndex !== null && this.results !== null) {
            this.results[resultIndex] = [...result];
          }
          this.dispatchEvent(new QueueEvent("success", { result: [...result], job }));
        }
        if (this.session === session) {
          if (this.pending === 0 && this.jobs.length === 0) {
            this.done();
          } else if (this.running) {
            this._start();
          }
        }
      }
    };
    if (timeout) {
      timeoutId = setTimeout(() => {
        didTimeout = true;
        this.dispatchEvent(new QueueEvent("timeout", { next, job }));
        next();
      }, timeout);
      this.timers.push(timeoutId);
    }
    if (this.results != null) {
      resultIndex = this.results.length;
      this.results[resultIndex] = null;
    }
    this.pending++;
    this.dispatchEvent(new QueueEvent("start", { job }));
    job.promise = job(next);
    if (job.promise !== void 0 && typeof job.promise.then === "function") {
      job.promise.then(function(result) {
        return next(void 0, result);
      }).catch(function(err) {
        return next(err || true);
      });
    }
    if (this.running && this.jobs.length > 0) {
      this._start();
    }
  }
  stop() {
    this.running = false;
  }
  end(error) {
    this.clearTimers();
    this.jobs.length = 0;
    this.pending = 0;
    this.done(error);
  }
  clearTimers() {
    this.timers.forEach((timer) => {
      clearTimeout(timer);
    });
    this.timers = [];
  }
  _addCallbackToEndEvent(cb) {
    const onend = (evt) => {
      this.removeEventListener("end", onend);
      cb(evt.detail.error, this.results);
    };
    this.addEventListener("end", onend);
  }
  _createPromiseToEndEvent() {
    return new Promise((resolve, reject) => {
      this._addCallbackToEndEvent((error, results) => {
        if (error)
          reject(error);
        else
          resolve(results);
      });
    });
  }
  done(error) {
    this.session++;
    this.running = false;
    this.dispatchEvent(new QueueEvent("end", { error }));
  }
};

// src/github/api.ts
var _GitHubApi = class _GitHubApi {
  async queueRequest(config, token) {
    if (getCache().get(config)) {
      return this.githubRequest(config, token);
    }
    const { resolve, promise } = promiseWithResolvers();
    _GitHubApi.q.push(() => {
      return this.githubRequest(config, token).then((result) => {
        resolve(result);
      });
    });
    return promise;
  }
  async getIssue(org, repo, issue, token) {
    const result = await this.queueRequest({ url: `${_GitHubApi.baseApi}/repos/${org}/${repo}/issues/${issue}` }, token);
    return result.json;
  }
  async listIssuesForToken(params, token) {
    const url = this.addParams(`${_GitHubApi.baseApi}/issues`, params);
    const result = await this.queueRequest({ url }, token);
    return result.json;
  }
  async listIssuesForRepo(org, repo, params = {}, token) {
    const url = this.addParams(`${_GitHubApi.baseApi}/repos/${org}/${repo}/issues`, params);
    const result = await this.queueRequest({ url }, token);
    return result.json;
  }
  async getPullRequest(org, repo, pr, token) {
    const result = await this.queueRequest(
      {
        url: `${_GitHubApi.baseApi}/repos/${org}/${repo}/pulls/${pr}`
      },
      token
    );
    return result.json;
  }
  async listPullRequestsForRepo(org, repo, params = {}, token) {
    const url = this.addParams(`${_GitHubApi.baseApi}/repos/${org}/${repo}/pulls`, params);
    const result = await this.queueRequest({ url }, token);
    return result.json;
  }
  async getCode(org, repo, path, branch, token) {
    const result = await this.queueRequest(
      {
        url: `${_GitHubApi.baseApi}/repos/${org}/${repo}/contents/${path}?ref=${branch}`
      },
      token
    );
    return result.json;
  }
  async searchIssues(params, token) {
    const url = this.addParams(`${_GitHubApi.baseApi}/search/issues`, params);
    const result = await this.githubRequest({ url }, token);
    return result.json;
  }
  async listCheckRunsForRef(org, repo, ref, token) {
    const result = await this.githubRequest(
      { url: `${_GitHubApi.baseApi}/${org}/${repo}/commits/${ref}/check-runs` },
      token
    );
    return result.json;
  }
  async githubRequest(_config, token, skipCache = false) {
    if (_GitHubApi.rateLimitReset !== null && _GitHubApi.rateLimitReset > /* @__PURE__ */ new Date()) {
      logger.warn(
        `GitHub rate limit exceeded. No more requests will be made until ${_GitHubApi.rateLimitReset.toLocaleTimeString()}`
      );
      throw new Error("GitHub rate limit exceeded.");
    } else if (_GitHubApi.rateLimitReset !== null) {
      _GitHubApi.rateLimitReset = null;
    }
    const config = this.initHeaders(_config, token);
    const cachedValue = getCache().get(config);
    if (this.cachedRequestIsRecent(cachedValue, skipCache)) {
      logger.debug(`Request was too recent. Returning cached value for: ${cachedValue == null ? void 0 : cachedValue.request.url}`);
      logger.debug(cachedValue == null ? void 0 : cachedValue.response);
      return cachedValue.response;
    }
    this.setCacheHeaders(config, cachedValue);
    try {
      logger.debug(`Request: ${config.url}`);
      logger.debug(config);
      const response = await (0, import_obsidian5.requestUrl)(config);
      logger.debug(`Response (${config.url}):`);
      logger.debug(response);
      if ((cachedValue == null ? void 0 : cachedValue.response) && response.status === 304) {
        getCache().update(config);
        return cachedValue.response;
      } else if (isSuccessResponse(response.status)) {
        getCache().set(config, response);
      }
      const retryAfterSeconds = parseInt(response.headers["retry-after"]);
      const rateLimitRemaining = parseInt(response.headers["x-ratelimit-remaining"]);
      const rateLimitResetSeconds = parseInt(response.headers["x-ratelimit-reset"]);
      if (!isNaN(retryAfterSeconds)) {
        logger.warn(`Got retry-after header with value ${retryAfterSeconds}`);
        await sleep(retryAfterSeconds * 1e3);
        return this.githubRequest(config, token);
      } else if (!isNaN(rateLimitRemaining) && rateLimitRemaining === 0 && !isNaN(rateLimitResetSeconds)) {
        _GitHubApi.rateLimitReset = new Date(rateLimitResetSeconds * 1e3);
        let message = `GitHub rate limit exceeded. No more requests will be made until after ${_GitHubApi.rateLimitReset.toLocaleTimeString()}`;
        if (!token) {
          message += " Consider adding an authentication token for a significantly higher rate limit.";
        }
        new import_obsidian5.Notice(message);
      } else if (!isNaN(rateLimitRemaining) && rateLimitRemaining <= 5) {
        logger.warn("GitHub rate limit approaching.");
      }
      return response;
    } catch (err) {
      throw new RequestError2(err);
    }
  }
  /**
   * Ensure headers object is initialized and common headers are added
   */
  initHeaders(config, token) {
    if (!config.headers) {
      config.headers = {};
    }
    config.headers.Accept = "application/vnd.github+json";
    config.headers["X-GitHub-Api-Version"] = "2022-11-28";
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  }
  /**
   * Add available cache headers
   */
  setCacheHeaders(config, cachedValue) {
    if (cachedValue == null ? void 0 : cachedValue.etag) {
      config.headers["if-none-match"] = cachedValue.etag;
    }
    if (cachedValue == null ? void 0 : cachedValue.lastModified) {
      config.headers["if-modified-since"] = cachedValue.lastModified;
    }
  }
  addParams(href, params) {
    const url = new URL(href);
    for (const [key, value] of Object.entries(params)) {
      url.searchParams.set(key, `${value}`);
    }
    return url.toString();
  }
  /**
   * Returns true if we can skip calling the API due to request age
   */
  cachedRequestIsRecent(cachedValue, skipCache) {
    if (skipCache || !cachedValue) {
      return false;
    }
    const minCacheAge = new Date((/* @__PURE__ */ new Date()).getTime() - PluginSettings.minRequestSeconds * 1e3);
    return cachedValue.retrieved > minCacheAge;
  }
};
_GitHubApi.baseApi = "https://api.github.com";
_GitHubApi.rateLimitReset = null;
_GitHubApi.q = new Queue({ autostart: true, concurrency: 1 });
var GitHubApi = _GitHubApi;

// src/github/cache.ts
var CacheEntry = class _CacheEntry {
  constructor(request2, response, retrieved, etag, lastModified) {
    this.request = request2;
    this.response = response;
    this.retrieved = retrieved;
    this.etag = etag;
    this.lastModified = lastModified;
  }
  static fromJSON(json) {
    let result = null;
    try {
      const parsed = JSON.parse(json);
      result = new _CacheEntry(
        parsed.request,
        parsed.response,
        new Date(parsed.retrieved),
        parsed.etag,
        parsed.lastModified
      );
    } catch (err) {
      logger.error("Failure reconstructing cache!");
      logger.error(err);
    }
    return result;
  }
  toJSON() {
    const params = {
      request: this.request,
      response: this.response,
      retrieved: this.retrieved.getTime(),
      etag: this.etag,
      lastModified: this.lastModified
    };
    return JSON.stringify(params);
  }
};
var RequestCache = class {
  constructor(storedCache) {
    this.cacheUpdated = false;
    this.entries = {};
    if (storedCache) {
      try {
        for (const entryString of storedCache) {
          const entry = CacheEntry.fromJSON(entryString);
          if (!entry) {
            return;
          }
          this.entries[this.getCacheKey(entry.request)] = entry;
        }
      } catch (err) {
        logger.warn("Could not read stored cache data, cache will be cleared.");
        logger.warn(err);
      }
    }
  }
  get(request2) {
    var _a;
    return (_a = this.entries[this.getCacheKey(request2)]) != null ? _a : null;
  }
  set(request2, response) {
    var _a, _b;
    if (!isSuccessResponse(response.status)) {
      logger.warn(`Attempted to cache a non-successful request: ${request2.url}`);
      return;
    }
    const etag = (_a = response.headers.etag) != null ? _a : null;
    const lastModified = (_b = response.headers["last-modified"]) != null ? _b : null;
    const _request = { url: request2.url, body: request2.body };
    const _response = { json: response.json, status: response.status };
    const entry = new CacheEntry(
      _request,
      _response,
      /* @__PURE__ */ new Date(),
      etag,
      lastModified
    );
    this.entries[this.getCacheKey(request2)] = entry;
    this.cacheUpdated = true;
  }
  remove(request2) {
    if (typeof request2 === "string") {
      delete this.entries[request2];
    } else {
      delete this.entries[this.getCacheKey(request2)];
    }
    this.cacheUpdated = true;
  }
  clean(maxAge) {
    let entriesDeleted = 0;
    for (const [k, v] of Object.entries(this.entries)) {
      if (v.retrieved < maxAge) {
        delete this.entries[k];
        entriesDeleted += 1;
      }
    }
    return entriesDeleted;
  }
  update(request2) {
    let entry = null;
    if (typeof request2 === "string") {
      entry = this.entries[request2];
    } else {
      entry = this.entries[this.getCacheKey(request2)];
    }
    if (entry) {
      entry.retrieved = /* @__PURE__ */ new Date();
    }
    this.cacheUpdated = true;
  }
  toJSON() {
    return Object.values(this.entries).map((e) => e.toJSON());
  }
  getCacheKey(request2) {
    return request2.url;
  }
};
var OldCacheEntry = class {
  constructor(value, created = /* @__PURE__ */ new Date(), ttl = 20) {
    this.value = value;
    this.created = created;
    this.ttl = ttl;
  }
  get expired() {
    const expiry = this.created.getTime() + this.ttl * 60 * 1e3;
    return (/* @__PURE__ */ new Date()).getTime() > expiry;
  }
};
var OldQueryCache = class {
  constructor() {
    this.issueCache = {};
    this.repoCache = {};
  }
};
var OldRepoCache = class {
  constructor() {
    this.issueCache = {};
    this.issueListForRepoCache = {};
    this.pullCache = {};
    this.pullListForRepoCache = {};
  }
};
var OldOrgCache = class {
  constructor() {
    this.repos = {};
    this.issueList = {};
  }
};
var OldCache = class {
  constructor() {
    this.generic = {};
    this.orgs = {};
    this.queries = new OldQueryCache();
  }
  getGeneric(url) {
    var _a;
    return this.getCacheValue((_a = this.generic[url]) != null ? _a : null);
  }
  setGeneric(url, value) {
    this.generic[url] = new OldCacheEntry(value);
  }
  getIssue(org, repo, issue) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.issueCache[issue]) != null ? _a : null);
  }
  setIssue(org, repo, issue) {
    const issueCache = this.getRepoCache(org, repo).issueCache;
    const existingCache = issueCache[issue.number];
    if (existingCache) {
      const now = /* @__PURE__ */ new Date();
      existingCache.created = now;
      existingCache.value = issue;
    } else {
      issueCache[issue.number] = new OldCacheEntry(issue);
    }
  }
  getIssueList(org, params) {
    var _a;
    const orgCache = this.getOrgCache(org);
    return this.getCacheValue((_a = orgCache.issueList[JSON.stringify(params)]) != null ? _a : null);
  }
  setIssueList(org, params, value) {
    const orgCache = this.getOrgCache(org);
    orgCache.issueList[JSON.stringify(params)] = new OldCacheEntry(value);
  }
  getIssueListForRepo(org, repo, params) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.issueListForRepoCache[JSON.stringify(params)]) != null ? _a : null);
  }
  setIssueListForRepo(org, repo, params, value) {
    const repoCache = this.getRepoCache(org, repo);
    repoCache.issueListForRepoCache[JSON.stringify(params)] = new OldCacheEntry(value);
  }
  getPullRequest(org, repo, pullRequest) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.pullCache[pullRequest]) != null ? _a : null);
  }
  getPullListForRepo(org, repo, params) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.pullListForRepoCache[JSON.stringify(params)]) != null ? _a : null);
  }
  setPullListForRepo(org, repo, params, value) {
    const repoCache = this.getRepoCache(org, repo);
    repoCache.pullListForRepoCache[JSON.stringify(params)] = new OldCacheEntry(value);
  }
  setPullRequest(org, repo, pullRequest) {
    const pullCache = this.getRepoCache(org, repo).pullCache;
    const existingCache = pullCache[pullRequest.number];
    if (existingCache) {
      const now = /* @__PURE__ */ new Date();
      existingCache.created = now;
      existingCache.value = pullRequest;
    } else {
      pullCache[pullRequest.number] = new OldCacheEntry(pullRequest);
    }
  }
  getIssueQuery(query) {
    var _a;
    return this.getCacheValue((_a = this.queries.issueCache[query]) != null ? _a : null);
  }
  setIssueQuery(query, result) {
    this.queries.issueCache[query] = new OldCacheEntry(result);
  }
  getRepoQuery(query) {
    var _a;
    return this.getCacheValue((_a = this.queries.repoCache[query]) != null ? _a : null);
  }
  setRepoQuery(query, result) {
    this.queries.repoCache[query] = new OldCacheEntry(result);
  }
  getOrgCache(org) {
    let orgCache = this.orgs[org];
    if (!orgCache) {
      orgCache = this.orgs[org] = new OldOrgCache();
    }
    return orgCache;
  }
  getRepoCache(org, repo) {
    const orgCache = this.getOrgCache(org);
    let repoCache = orgCache.repos[repo];
    if (!repoCache) {
      repoCache = orgCache.repos[repo] = new OldRepoCache();
    }
    return repoCache;
  }
  getCacheValue(cacheEntry) {
    if (!cacheEntry || cacheEntry.expired) {
      return null;
    } else {
      return cacheEntry.value;
    }
  }
};

// src/github/github.ts
var cache = new OldCache();
var tokenMatchRegex = /repo:(.+)\//;
var api = new GitHubApi();
function getAccount(org) {
  var _a;
  const account = (_a = PluginSettings.accounts.find((acc) => acc.orgs.some((savedOrg) => savedOrg === org))) != null ? _a : PluginSettings.accounts.find((acc) => acc.id === PluginSettings.defaultAccount);
  return account;
}
function getToken(org, query) {
  let _org = org;
  if (!org && query) {
    const match = tokenMatchRegex.exec(query);
    if ((match == null ? void 0 : match[0]) !== null) {
      _org = match == null ? void 0 : match[1];
    }
  }
  const account = getAccount(_org);
  return account == null ? void 0 : account.token;
}
function getIssue(org, repo, issue) {
  return api.getIssue(org, repo, issue, getToken(org));
}
function getMyIssues(params, org, skipCache = false) {
  const account = getAccount(org);
  if (!(account == null ? void 0 : account.token)) {
    return Promise.resolve([]);
  }
  const _params = sanitizeObject(params, {
    assignee: false,
    creator: false,
    direction: true,
    labels: true,
    mentioned: false,
    milestone: false,
    page: true,
    per_page: true,
    since: true,
    sort: true,
    state: true,
    filter: true,
    org: false,
    repo: false
  });
  setPageSize(_params);
  if (Array.isArray(_params.labels)) {
    _params.labels = _params.labels.join(",");
  }
  return api.listIssuesForToken(_params, account.token);
}
function getIssuesForRepo(params, org, repo, skipCache = false) {
  const _params = sanitizeObject(params, {
    assignee: true,
    creator: true,
    direction: true,
    labels: true,
    mentioned: true,
    milestone: true,
    page: true,
    per_page: true,
    since: true,
    sort: true,
    state: true,
    org: false,
    repo: false,
    filter: false
  });
  setPageSize(_params);
  if (Array.isArray(_params.labels)) {
    _params.labels = _params.labels.join(",");
  }
  return api.listIssuesForRepo(org, repo, _params, getToken(org));
}
function getPullRequest(org, repo, pullRequest) {
  return api.getPullRequest(org, repo, pullRequest, getToken(org));
}
function getPullRequestsForRepo(params, org, repo) {
  const _params = sanitizeObject(params, {
    org: false,
    repo: false,
    base: true,
    direction: true,
    head: true,
    page: true,
    per_page: true,
    sort: true,
    state: true
  });
  setPageSize(_params);
  return api.listPullRequestsForRepo(org, repo, _params, getToken(org));
}
async function searchIssues(params, query, org, skipCache = false) {
  const _params = sanitizeObject(params, {
    q: false,
    baseUrl: false,
    headers: false,
    mediaType: false,
    order: true,
    page: true,
    per_page: true,
    request: false,
    sort: true
  });
  setPageSize(_params);
  _params.q = query;
  const cachedResponse = cache.getIssueQuery(query);
  if (cachedResponse && !skipCache) {
    return Promise.resolve(cachedResponse);
  }
  const response = await api.searchIssues(_params, getToken(org, query));
  cache.setIssueQuery(query, response);
  return response;
}
async function getPRForIssue(timelineUrl, org) {
  var _a, _b, _c;
  let response = null;
  try {
    response = (await api.queueRequest({ url: timelineUrl }, getToken(org))).json;
  } catch (err) {
    if (err instanceof RequestError2 && err.status === 404) {
      return null;
    } else {
      throw err;
    }
  }
  if (!response) {
    return null;
  }
  const crossRefEvent = response.find((_evt) => {
    var _a2, _b2, _c2;
    const evt = _evt;
    return evt.event === "cross-referenced" && ((_c2 = (_b2 = (_a2 = evt.source) == null ? void 0 : _a2.issue) == null ? void 0 : _b2.pull_request) == null ? void 0 : _c2.html_url);
  });
  return (_c = (_b = (_a = crossRefEvent == null ? void 0 : crossRefEvent.source.issue) == null ? void 0 : _a.pull_request) == null ? void 0 : _b.html_url) != null ? _c : null;
}
function setPageSize(params) {
  var _a;
  params.per_page = (_a = params.per_page) != null ? _a : PluginSettings.defaultPageSize;
}

// src/github/url-parse.ts
var apiRegex = /(https:\/\/)?api\.github\.com\/repos\//;
function repoAPIToBrowserUrl(urlString) {
  return urlString.replace(apiRegex, "https://github.com/");
}
function parseUrl2(urlString) {
  const url = new URL(urlString);
  const parsedUrl = { url: urlString, host: url.hostname };
  const urlParts = url.pathname.split("/");
  if (urlParts.length > 4) {
    const issueNumber = parseInt(urlParts[4], 10);
    switch (urlParts[3].toLowerCase()) {
      case "issues":
        if (!isNaN(issueNumber)) {
          parsedUrl.issue = issueNumber;
        }
        break;
      case "pull":
        if (!isNaN(issueNumber)) {
          parsedUrl.pr = issueNumber;
        }
        break;
      case "blob":
        parsedUrl.code = {};
        parsedUrl.code.branch = urlParts[4];
        if (urlParts[5]) {
          const pathParts = urlParts.slice(5);
          parsedUrl.code.path = pathParts.join("/");
        }
        break;
      case "commit":
        parsedUrl.commit = urlParts.slice(4).join("/");
        break;
    }
  }
  if (urlParts.length > 2) {
    parsedUrl.repo = urlParts[2];
  }
  if (urlParts.length > 1) {
    parsedUrl.org = urlParts[1];
  }
  return parsedUrl;
}

// src/inline/inline.ts
var import_obsidian7 = require("obsidian");

// src/icon.ts
var import_obsidian6 = require("obsidian");
var PRIcon = {
  ["open" /* Open */]: "lucide-git-pull-request-arrow",
  ["closed" /* Closed */]: "lucide-git-pull-request-closed",
  ["done" /* Done */]: "lucide-git-merge"
};
var PRStatusText = {
  ["open" /* Open */]: "Pull request open",
  ["closed" /* Closed */]: "Pull request closed",
  ["done" /* Done */]: "Pull request merged"
};
var PRMergeableIcon = {
  true: "lucide-check",
  false: "lucide-x"
};
var PRMergeableText = {
  true: "Mergeable",
  false: "Not mergeable"
};
var IssueIcon = {
  ["open" /* Open */]: "lucide-circle-dot",
  ["closed" /* Closed */]: "lucide-circle-slash",
  ["done" /* Done */]: "lucide-check-circle"
};
var IssueStatusText = {
  ["open" /* Open */]: "Issue open",
  ["closed" /* Closed */]: "Issue closed as not planned",
  ["done" /* Done */]: "Issue closed as completed"
};
function setPRIcon(icon, status) {
  if (PluginSettings.tagTooltips) {
    icon.setAttribute("aria-label", PRStatusText[status]);
  }
  (0, import_obsidian6.setIcon)(icon, PRIcon[status]);
  icon.classList.add("pull-request");
  icon.dataset.status = status;
}
function setIssueIcon(icon, status) {
  if (PluginSettings.tagTooltips) {
    icon.setAttribute("aria-label", IssueStatusText[status]);
  }
  (0, import_obsidian6.setIcon)(icon, IssueIcon[status]);
  icon.classList.add("issue");
  icon.dataset.status = status;
}
function setPRMergeableIcon(icon, mergeable) {
  if (PluginSettings.tagTooltips) {
    icon.setAttribute("aria-label", PRMergeableText[`${mergeable}`]);
  }
  (0, import_obsidian6.setIcon)(icon, PRMergeableIcon[`${mergeable}`]);
  icon.classList.add("pull-request-mergeable");
  icon.dataset.status = `${mergeable}`;
}

// src/inline/inline.ts
function createTag(href) {
  const parsedUrl = parseUrl2(href);
  const container = createEl("a", { cls: "github-link-inline", href });
  const config = {
    icon: createSpan({ cls: ["github-link-status-icon", "github-link-inline-icon"] }),
    sections: []
  };
  createIconSection(config);
  createOrgSection(config, parsedUrl);
  createRepoSection(config, parsedUrl);
  if (parsedUrl.issue !== void 0 || parsedUrl.pr !== void 0) {
    const orgIndex = config.sections.findIndex((section) => section.classList.contains("github-link-inline-org"));
    if (orgIndex !== -1) {
      config.sections.splice(orgIndex, 1);
    }
    if (parsedUrl.issue !== void 0) {
      createIssueSection(config, parsedUrl);
    } else if (parsedUrl.pr !== void 0) {
      createPullRequestSection(config, parsedUrl, container);
    }
  }
  for (const section of config.sections) {
    container.appendChild(createTagSection(section));
  }
  return container;
}
function createTagSection(...children) {
  const section = createDiv({ cls: "github-link-inline-section" });
  section.append(...children);
  return section;
}
function createIconSection(config) {
  config.sections.push(config.icon);
  (0, import_obsidian7.setIcon)(config.icon, "github");
}
function createOrgSection(config, parsedUrl) {
  if (parsedUrl.org) {
    config.sections.push(
      createSpan({
        cls: "github-link-inline-org",
        text: parsedUrl.org
      })
    );
  }
}
function createRepoSection(config, parsedUrl) {
  if (parsedUrl.repo) {
    config.sections.push(
      createSpan({
        cls: "github-link-inline-repo",
        text: parsedUrl.repo
      })
    );
  }
}
function createIssueSection(config, parsedUrl) {
  if (parsedUrl.issue === void 0) {
    return;
  }
  setIssueIcon(config.icon, "open" /* Open */);
  const issueContainer = createSpan({
    cls: "github-link-inline-issue-title",
    text: `${parsedUrl.issue}`
  });
  config.sections.push(issueContainer);
  if (parsedUrl.org && parsedUrl.repo) {
    getIssue(parsedUrl.org, parsedUrl.repo, parsedUrl.issue).then((issue) => {
      if (issue.title) {
        const status = getIssueStatus(issue);
        setIssueIcon(config.icon, status);
        issueContainer.setText(issue.title);
      }
    });
  }
}
function createPullRequestSection(config, parsedUrl, tag) {
  if (parsedUrl.pr === void 0) {
    return;
  }
  setPRIcon(config.icon, "open" /* Open */);
  const prContainer = createSpan({
    cls: "github-link-inline-pr-title",
    text: `${parsedUrl.pr}`
  });
  config.sections.push(prContainer);
  if (parsedUrl.org && parsedUrl.repo) {
    getPullRequest(parsedUrl.org, parsedUrl.repo, parsedUrl.pr).then((pr) => {
      if (pr.title) {
        const status = getPRStatus(pr);
        setPRIcon(config.icon, status);
        prContainer.setText(pr.title);
      }
      createPullRequestMergeableSection(config, pr, tag);
    });
  }
}
function createPullRequestMergeableSection(config, pullRequest, tag) {
  if (!PluginSettings.tagShowPRMergeable || pullRequest.mergeable === null) {
    return;
  }
  const mergeableIcon = createSpan({ cls: ["github-link-inline-pr-mergeable-icon", "github-link-inline-icon"] });
  setPRMergeableIcon(mergeableIcon, pullRequest.mergeable);
  config.sections.push(mergeableIcon);
  tag.appendChild(createTagSection(mergeableIcon));
}
async function InlineRenderer(el) {
  const githubLinks = el.querySelectorAll(`a.external-link[href^="https://github.com"]`);
  for (const anchor of Array.from(githubLinks)) {
    if (anchor.href === anchor.innerText) {
      const container = createTag(anchor.href);
      anchor.replaceWith(container);
    }
  }
}

// src/plugin.ts
var import_obsidian11 = require("obsidian");

// src/query/params.ts
var import_obsidian8 = require("obsidian");
function processParams(source) {
  var _a;
  let params;
  try {
    params = (0, import_obsidian8.parseYaml)(source);
  } catch (e) {
    console.error(`Github Link: YAML Parsing failed, attempting simplistic parsing
${e}`);
    params = Object.fromEntries(source.split("\n").map((l) => l.split(/:\s?/)));
  }
  params.refresh = (_a = params.refresh) != null ? _a : true;
  return params != null ? params : null;
}
function isTableQueryParams(params) {
  return params.outputType === "table" /* Table */ && Boolean(params.query);
}
function isTableParams(params) {
  return params.outputType === "table" /* Table */ && !params.query;
}

// src/query/column/defaults.ts
var DEFAULT_COLUMNS = {
  ["issue" /* Issue */]: ["number", "title", "author", "created", "status"],
  ["pull-request" /* PullRequest */]: ["number", "title", "author", "created", "status"],
  ["repo" /* Repo */]: []
};

// src/query/column/base.ts
function DateCell(value, el) {
  el.classList.add("github-link-table-date");
  if (!value) {
    return;
  }
  const asDate = new Date(value);
  if (isNaN(asDate.valueOf())) {
    el.setText(value);
    return;
  }
  el.setText(DateFormat.DATE_SHORT.format(asDate));
}
var CommonIssuePRColumns = {
  number: {
    header: "Number",
    cell: (row, el) => {
      el.classList.add("github-link-table-issue-number");
      el.createEl("a", { text: `#${row.number}`, href: row.html_url });
    }
  },
  repo: {
    header: "Repo",
    cell: (row, el) => {
      el.classList.add("github-link-table-repo");
      const url = repoAPIToBrowserUrl(row.repository_url);
      const parsed = parseUrl2(url);
      el.createEl("a", { text: parsed.repo, href: url });
    }
  },
  author: {
    header: "Author",
    cell: (row, el) => {
      var _a, _b;
      const anchor = el.createEl("a", { cls: "github-link-table-author" });
      if ((_a = row.user) == null ? void 0 : _a.avatar_url) {
        anchor.createEl("img", { cls: "github-link-table-avatar", attr: { src: row.user.avatar_url } });
      }
      anchor.createSpan({ text: (_b = row.user) == null ? void 0 : _b.login });
    }
  },
  created: {
    header: "Created",
    cell: (row, el) => {
      DateCell(row.created_at, el);
    }
  },
  updated: {
    header: "Updated",
    cell: (row, el) => {
      DateCell(row.updated_at, el);
    }
  },
  closed: {
    header: "Closed",
    cell: (row, el) => {
      DateCell(row.closed_at, el);
    }
  }
};

// src/query/column/issue.ts
var IssueColumns = {
  ...CommonIssuePRColumns,
  status: {
    header: "Status",
    cell: (row, el) => {
      const wrapper = el.createDiv({ cls: "github-link-table-status" });
      const status = getSearchResultIssueStatus(row);
      const icon = wrapper.createSpan({ cls: "github-link-status-icon" });
      setIssueIcon(icon, status);
      wrapper.createSpan({ text: row.state_reason === "not_planned" ? "Not Planned" : titleCase(status) });
    }
  },
  pr: {
    header: "PR",
    cell: async (row, el) => {
      if (!row.timeline_url) {
        return;
      }
      const pullRequestUrl = await getPRForIssue(row.timeline_url);
      if (!pullRequestUrl) {
        return;
      }
      const tag = createTag(pullRequestUrl);
      el.appendChild(tag);
    }
  }
};

// src/query/column/pull-request.ts
var PullRequestColumns = {
  ...CommonIssuePRColumns,
  status: {
    header: "Status",
    cell: (row, el) => {
      const wrapper = el.createDiv({ cls: "github-link-table-status" });
      const status = getSearchResultIssueStatus(row);
      const icon = wrapper.createSpan({ cls: "github-link-status-icon" });
      setPRIcon(icon, status);
      wrapper.createSpan({ text: status === "done" /* Done */ ? "Merged" : titleCase(status) });
    }
  }
};

// src/query/column/repo.ts
var RepoColumns = {};

// src/query/output.ts
var import_obsidian9 = require("obsidian");
var ALL_COLUMNS = {
  ["pull-request" /* PullRequest */]: PullRequestColumns,
  ["issue" /* Issue */]: IssueColumns,
  ["repo" /* Repo */]: RepoColumns
};
async function renderTable(params, result, el, renderFn, externalLink) {
  var _a, _b;
  el.empty();
  const tableWrapper = el.createDiv({ cls: "github-link-table-wrapper" });
  const tableScrollWrapper = tableWrapper.createDiv({ cls: "github-link-table-scroll-wrapper" });
  const table = tableScrollWrapper.createEl("table", { cls: "github-link-table" });
  if (params.refresh) {
    const refresh = tableWrapper.createDiv({ cls: "github-link-table-refresh" });
    if (externalLink) {
      refresh.createEl("a", {
        cls: "github-link-table-refresh-external-link",
        text: "View on GitHub",
        href: externalLink
      });
    }
    const refreshButton = refresh.createEl("button", {
      cls: "clickable-icon",
      attr: { "aria-label": "Refresh Results" }
    });
    refreshButton.addEventListener("click", () => renderFn(el, true));
    (0, import_obsidian9.setIcon)(refreshButton, "refresh-cw");
  }
  const thead = table.createEl("thead");
  let columns = params.columns;
  if (!columns || columns.length === 0) {
    columns = DEFAULT_COLUMNS[params.queryType];
  }
  columns = columns.map((c) => c.toLowerCase());
  for (const col of columns) {
    const th = thead.createEl("th");
    th.setText((_b = (_a = ALL_COLUMNS[params.queryType][col]) == null ? void 0 : _a.header) != null ? _b : titleCase(col));
  }
  const tbody = table.createEl("tbody");
  const items = Array.isArray(result) ? result : result.items;
  for (const row of items) {
    const tr = tbody.createEl("tr");
    for (const col of columns) {
      const cell = tr.createEl("td");
      const renderer = ALL_COLUMNS[params.queryType][col];
      if (renderer) {
        renderer.cell(row, cell);
      } else {
        const cellVal = getProp(row, col);
        if (cellVal !== null) {
          cell.setText(typeof cellVal === "string" ? cellVal : JSON.stringify(cellVal));
        } else {
          cell.setText("");
        }
      }
    }
  }
}

// src/query/processor.ts
async function QueryProcessor(source, el, _ctx) {
  const params = processParams(source);
  if (!params) {
    el.setText(source);
    return;
  }
  const renderFn = async (element, skipCache = false) => {
    let response = void 0;
    let externalLink;
    if (isTableQueryParams(params)) {
      if (params.queryType === "issue" /* Issue */ || params.queryType === "pull-request" /* PullRequest */) {
        const queryParams = params;
        response = await searchIssues(params, params.query, queryParams.org, skipCache);
        externalLink = `https://github.com/search?q=${encodeURIComponent(params.query)}`;
      }
    } else if (isTableParams(params)) {
      if (params.queryType === "issue" /* Issue */) {
        const issueParams = params;
        if (issueParams.org && issueParams.repo) {
          response = await getIssuesForRepo(issueParams, issueParams.org, issueParams.repo, skipCache);
        } else {
          response = await getMyIssues(issueParams, issueParams.org, skipCache);
        }
      } else if (params.queryType === "pull-request" /* PullRequest */) {
        const pullParams = params;
        if (pullParams.org && pullParams.repo) {
          response = await getPullRequestsForRepo(pullParams, pullParams.org, pullParams.repo);
        }
      }
    }
    if (response) {
      renderTable(params, response, element, renderFn, externalLink);
    }
  };
  await renderFn(el);
}

// src/inline/view-plugin.ts
var import_obsidian10 = require("obsidian");
var import_view = require("@codemirror/view");
var InlineTagWidget = class extends import_view.WidgetType {
  constructor(href, dispatch) {
    super();
    this.href = href;
    this.error = false;
    this.container = createSpan();
    const tag = createTag(href);
    this.container.appendChild(tag);
  }
  eq(widget) {
    return widget.href === this.href;
  }
  toDOM() {
    return this.container;
  }
};
function createInlineViewPlugin(_plugin) {
  class InlineViewPluginValue {
    constructor(view) {
      this.match = new import_view.MatchDecorator({
        regexp: /(https:\/\/)?github\.com\S+/g,
        decorate: (add, from, to, match, view) => {
          const shouldRender = this.shouldRender(view, from, to, match);
          if (shouldRender) {
            add(
              from,
              to,
              import_view.Decoration.replace({
                widget: new InlineTagWidget(match[0], view.dispatch)
              })
            );
          }
        }
      });
      this.decorations = import_view.Decoration.none;
      this.view = view;
      this.updateDecorations(view);
    }
    update(update) {
      this.updateDecorations(update.view, update);
    }
    destroy() {
      this.decorations = import_view.Decoration.none;
    }
    updateDecorations(view, update) {
      if (!update || this.decorations.size === 0) {
        this.decorations = this.match.createDeco(view);
      } else {
        this.decorations = this.match.updateDeco(update, this.decorations);
      }
    }
    isLivePreview(state) {
      return state.field(import_obsidian10.editorLivePreviewField);
    }
    shouldRender(view, decorationFrom, decorationTo, match) {
      var _a, _b;
      const input = (_a = match.input) != null ? _a : "";
      const index = (_b = match.index) != null ? _b : 0;
      const matchValue = match[0];
      const endIndex = index + matchValue.length;
      if (input[index - 1] === "(" && matchValue.endsWith(")")) {
        return false;
      }
      const overlap = view.state.selection.ranges.some((r) => {
        if (r.from <= decorationFrom) {
          return r.to >= decorationFrom;
        } else {
          return r.from <= decorationTo;
        }
      });
      return !overlap && this.isLivePreview(view.state);
    }
  }
  const InlineViewPluginSpec = {
    decorations: (plugin) => {
      return plugin.decorations.update({
        filter: (rangeFrom, rangeTo, deco) => {
          const widget = deco.spec.widget;
          if (widget && widget.error) {
            return false;
          }
          return rangeFrom === rangeTo || // Check if there are no overlapping selection ranges
          !plugin.view.state.selection.ranges.filter((selectionRange) => {
            const selectionStart = selectionRange.from;
            const selectionEnd = selectionRange.to;
            if (selectionStart <= rangeFrom) {
              return selectionEnd >= rangeFrom;
            } else {
              return selectionStart <= rangeTo;
            }
          }).length;
        }
      });
    }
  };
  return import_view.ViewPlugin.fromClass(InlineViewPluginValue, InlineViewPluginSpec);
}

// src/plugin.ts
var PluginSettings = { ...DEFAULT_SETTINGS };
var PluginData = { cache: null, settings: PluginSettings };
var logger = new Logger();
var cache2;
function getCache() {
  return cache2;
}
var GithubLinkPlugin = class extends import_obsidian11.Plugin {
  async onload() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let data = await this.loadData() || {};
    if (data.accounts) {
      const newSettings = {
        accounts: (_a = data.accounts) != null ? _a : PluginSettings.accounts,
        cacheIntervalSeconds: (_b = data.cacheIntervalSeconds) != null ? _b : PluginSettings.cacheIntervalSeconds,
        defaultPageSize: (_c = data.defaultPageSize) != null ? _c : PluginSettings.defaultPageSize,
        logLevel: (_d = data.logLevel) != null ? _d : PluginSettings.logLevel,
        maxCacheAgeHours: (_e = data.maxCacheAgeHours) != null ? _e : PluginSettings.maxCacheAgeHours,
        minRequestSeconds: (_f = data.minRequestSeconds) != null ? _f : PluginSettings.minRequestSeconds,
        tagShowPRMergeable: (_g = data.tagShowPRMergeable) != null ? _g : PluginSettings.tagShowPRMergeable,
        tagTooltips: (_h = data.tagTooltips) != null ? _h : PluginSettings.tagTooltips,
        defaultAccount: (_i = data.defaultAccount) != null ? _i : PluginSettings.defaultAccount
      };
      const newData = {
        cache: (_j = data.cache) != null ? _j : PluginData.cache,
        settings: newSettings
      };
      await this.saveData(newData);
      data = newData;
    }
    Object.assign(PluginSettings, data.settings);
    Object.assign(PluginData, data);
    logger.logLevel = PluginSettings.logLevel;
    cache2 = new RequestCache(PluginData.cache);
    const maxAge = new Date((/* @__PURE__ */ new Date()).getTime() - PluginSettings.maxCacheAgeHours * 60 * 60 * 1e3);
    const entriesDeleted = cache2.clean(maxAge);
    if (entriesDeleted > 0) {
      PluginData.cache = cache2.toJSON();
      await this.saveData(PluginSettings);
      logger.info(`Cleaned ${entriesDeleted} entries from request cache.`);
    }
    this.addSettingTab(new GithubLinkPluginSettingsTab(this.app, this));
    this.registerMarkdownPostProcessor(InlineRenderer);
    this.registerEditorExtension(createInlineViewPlugin(this));
    this.registerMarkdownCodeBlockProcessor("github-query", QueryProcessor);
    this.setCacheInterval();
  }
  /**
   * Save cache at regular interval
   */
  setCacheInterval() {
    window.clearInterval(this.cacheInterval);
    this.cacheInterval = this.registerInterval(
      window.setInterval(async () => {
        var _a;
        logger.debug("Checking if cache needs a save.");
        if (cache2.cacheUpdated) {
          PluginData.cache = cache2.toJSON();
          await this.saveData(PluginData);
          cache2.cacheUpdated = false;
          logger.info(`Saved request cache with ${(_a = PluginData.cache) == null ? void 0 : _a.length} items.`);
        }
      }, PluginSettings.cacheIntervalSeconds * 1e3)
    );
  }
};

// main.ts
var main_default = GithubLinkPlugin;
