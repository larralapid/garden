/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FitPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// node_modules/@octokit/core/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook2 = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook2 = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}

// node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}

// node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(
    null,
    name ? [state, name] : [state]
  );
  hook2.api = { remove: removeHookRef };
  hook2.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state, kind, name] : [state, kind];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/index.js
function getUserAgent2() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent2()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/request/node_modules/universal-user-agent/index.js
function getUserAgent3() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
var RequestError = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    __publicField(this, "name");
    /**
     * http status code
     */
    __publicField(this, "status");
    /**
     * Request options that lead to the error.
     */
    __publicField(this, "request");
    /**
     * Response object if a response was received
     */
    __publicField(this, "response");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
};

// node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "0.0.0-development";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    // Header values must be `string`
    headers: Object.fromEntries(
      Object.entries(requestOptions.headers).map(([name, value]) => [
        name,
        String(value)
      ])
    ),
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent3()}`
  }
});

// node_modules/@octokit/graphql/node_modules/universal-user-agent/index.js
function getUserAgent4() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    __publicField(this, "name", "GraphqlResponseError");
    __publicField(this, "errors");
    __publicField(this, "data");
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent4()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/auth-token/dist-bundle/index.js
var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
var REGEX_IS_INSTALLATION = /^ghs_/;
var REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "6.0.1";

// node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
var Octokit = class {
  constructor(options = {}) {
    // assigned during constructor
    __publicField(this, "request");
    __publicField(this, "graphql");
    __publicField(this, "log");
    __publicField(this, "hook");
    // TODO: type `octokit.auth` based on passed options.authStrategy
    __publicField(this, "auth");
    const hook2 = new before_after_hook_default.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    var _a;
    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {
    }, __publicField(_a, "plugins", currentPlugins.concat(
      newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
    )), _a);
    return NewOctokit;
  }
};
__publicField(Octokit, "VERSION", VERSION4);
__publicField(Octokit, "plugins", []);

// src/utils.ts
function getValueOrNull(obj, key) {
  return obj.hasOwnProperty(key) ? obj[key] : null;
}
function compareSha(currentShaMap, storedShaMap, env) {
  const determineStatus = (currentSha, storedSha) => {
    if (currentSha && storedSha && currentSha !== storedSha) {
      return env === "local" ? "changed" : "MODIFIED";
    } else if (currentSha && !storedSha) {
      return env === "local" ? "created" : "ADDED";
    } else if (!currentSha && storedSha) {
      return env === "local" ? "deleted" : "REMOVED";
    }
    return null;
  };
  return Object.keys({ ...currentShaMap, ...storedShaMap }).flatMap((path) => {
    const [currentSha, storedSha] = [getValueOrNull(currentShaMap, path), getValueOrNull(storedShaMap, path)];
    const status = determineStatus(currentSha, storedSha);
    if (status) {
      return [{
        path,
        status,
        currentSha: currentSha != null ? currentSha : void 0,
        extension: extractExtension(path)
      }];
    }
    return [];
  });
}
var RECOGNIZED_BINARY_EXT = ["png", "jpg", "jpeg", "pdf"];
function extractExtension(path) {
  var _a;
  return (_a = path.match(/[^.]+$/)) == null ? void 0 : _a[0];
}
function setEqual(arr1, arr2) {
  const set1 = new Set(arr1);
  const set2 = new Set(arr2);
  const isEqual = set1.size === set2.size && [...set1].every((value) => set2.has(value));
  return isEqual;
}

// src/fit.ts
var OctokitHttpError = class extends Error {
  constructor(message, status, source) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.source = source;
  }
};
var Fit = class {
  constructor(setting, localStores, vault) {
    this.loadSettings(setting);
    this.loadLocalStore(localStores);
    this.vault = vault;
    this.headers = {
      // Hack to disable caching which leads to inconsistency for
      // read after write https://github.com/octokit/octokit.js/issues/890
      "If-None-Match": "",
      "X-GitHub-Api-Version": "2022-11-28"
    };
  }
  loadSettings(setting) {
    this.owner = setting.owner;
    this.repo = setting.repo;
    this.branch = setting.branch;
    this.deviceName = setting.deviceName;
    this.octokit = new Octokit({ auth: setting.pat });
  }
  loadLocalStore(localStore) {
    this.localSha = localStore.localSha;
    this.lastFetchedCommitSha = localStore.lastFetchedCommitSha;
    this.lastFetchedRemoteSha = localStore.lastFetchedRemoteSha;
  }
  async fileSha1(fileContent) {
    const enc = new TextEncoder();
    const hashBuf = await crypto.subtle.digest("SHA-1", enc.encode(fileContent));
    const hashArray = Array.from(new Uint8Array(hashBuf));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex;
  }
  async computeFileLocalSha(path) {
    if (!await this.vault.adapter.exists(path)) {
      throw new Error(`Attempting to compute local sha for ${path}, but file not found.`);
    }
    const localFile = await this.vault.adapter.read(path);
    return await this.fileSha1(path + localFile);
  }
  async computeLocalSha() {
    const paths = this.vault.getFiles().map((f) => f.path);
    return Object.fromEntries(
      await Promise.all(
        paths.map(async (p) => {
          return [p, await this.computeFileLocalSha(p)];
        })
      )
    );
  }
  async getLocalChanges(currentLocalSha) {
    if (!this.localSha) {
      return this.vault.getFiles().map((f) => {
        return { path: f.path, status: "created" };
      });
    }
    if (!currentLocalSha) {
      currentLocalSha = await this.computeLocalSha();
    }
    const localChanges = compareSha(currentLocalSha, this.localSha, "local");
    return localChanges;
  }
  async getUser() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /user`,
        {
          headers: this.headers
        }
      );
      return { owner: response.login, avatarUrl: response.avatar_url };
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getUser");
    }
  }
  async getRepos() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /user/repos`,
        {
          affiliation: "owner",
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getBranches() {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/branches`,
        {
          owner: this.owner,
          repo: this.repo,
          headers: this.headers
        }
      );
      return response.map((r) => r.name);
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRepos");
    }
  }
  async getRef(ref) {
    try {
      const { data: response } = await this.octokit.request(
        `GET /repos/{owner}/{repo}/git/ref/{ref}`,
        {
          owner: this.owner,
          repo: this.repo,
          ref,
          headers: this.headers
        }
      );
      return response.object.sha;
    } catch (error) {
      throw new OctokitHttpError(error.message, error.status, "getRef");
    }
  }
  // Get the sha of the latest commit in the default branch (set by user in setting)
  async getLatestRemoteCommitSha(ref = `heads/${this.branch}`) {
    return await this.getRef(ref);
  }
  // ref Can be a commit SHA, branch name (heads/BRANCH_NAME), or tag name (tags/TAG_NAME), 
  // refers to https://git-scm.com/book/en/v2/Git-Internals-Git-References
  async getCommitTreeSha(ref) {
    const { data: commit } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/commits/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        headers: this.headers
      }
    );
    return commit.commit.tree.sha;
  }
  async getTree(tree_sha) {
    const { data: tree } = await this.octokit.request(
      `GET /repos/${this.owner}/${this.repo}/git/trees/${tree_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        tree_sha,
        recursive: "true",
        headers: this.headers
      }
    );
    return tree.tree;
  }
  // get the remote tree sha in the format compatible with local store
  async getRemoteTreeSha(tree_sha) {
    const remoteTree = await this.getTree(tree_sha);
    const remoteSha = Object.fromEntries(remoteTree.map((node) => {
      if (node.type == "blob") {
        if (!node.path || !node.sha) {
          throw new Error("Path or sha not found for blob node in remote");
        }
        return [node.path, node.sha];
      }
      return null;
    }).filter(Boolean));
    return remoteSha;
  }
  async createBlob(content, encoding) {
    const { data: blob } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/blobs`,
      {
        owner: this.owner,
        repo: this.repo,
        content,
        encoding,
        headers: this.headers
      }
    );
    return blob.sha;
  }
  async createTreeNodeFromFile({ path, status, extension }) {
    if (status === "deleted") {
      return {
        path,
        mode: "100644",
        type: "blob",
        sha: null
      };
    }
    if (!this.vault.adapter.exists(path)) {
      throw new Error(
        `Unexpected error: attempting to createBlob for non-existent file, 
                please file an issue on github with info to reproduce the issue.`
      );
    }
    let encoding;
    let content;
    if (extension && RECOGNIZED_BINARY_EXT.includes(extension)) {
      encoding = "base64";
      const fileArrayBuf = await this.vault.adapter.readBinary(path);
      const uint8Array = new Uint8Array(fileArrayBuf);
      let binaryString = "";
      for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
      }
      content = btoa(binaryString);
    } else {
      encoding = "utf-8";
      content = await this.vault.adapter.read(path);
    }
    const blobSha = await this.createBlob(content, encoding);
    return {
      path,
      mode: "100644",
      type: "blob",
      sha: blobSha
    };
  }
  async createTree(treeNodes, base_tree_sha) {
    const { data: newTree } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/trees`,
      {
        owner: this.owner,
        repo: this.repo,
        tree: treeNodes,
        base_tree: base_tree_sha,
        headers: this.headers
      }
    );
    return newTree.sha;
  }
  async createCommit(treeSha, parentSha) {
    const message = `Commit from {deviceName} on ${new Date().toLocaleString()}`;
    const { data: createdCommit } = await this.octokit.request(
      `POST /repos/{owner}/{repo}/git/commits`,
      {
        owner: this.owner,
        repo: this.repo,
        message,
        tree: treeSha,
        parents: [parentSha],
        headers: this.headers
      }
    );
    return createdCommit.sha;
  }
  async updateRef(sha, ref = `heads/${this.branch}`) {
    const { data: updatedRef } = await this.octokit.request(
      `PATCH /repos/{owner}/{repo}/git/refs/{ref}`,
      {
        owner: this.owner,
        repo: this.repo,
        ref,
        sha,
        headers: this.headers
      }
    );
    return updatedRef.object.sha;
  }
  async getBlob(file_sha) {
    const { data: blob } = await this.octokit.request(
      `GET /repos/{owner}/{repo}/git/blobs/{file_sha}`,
      {
        owner: this.owner,
        repo: this.repo,
        file_sha,
        headers: this.headers
      }
    );
    return blob.content;
  }
};

// src/fitPull.ts
var FitPull = class {
  constructor(fit, vaultOps) {
    this.vaultOps = vaultOps;
    this.fit = fit;
  }
  async getRemoteChanges(remoteTreeSha) {
    if (!this.fit.lastFetchedRemoteSha) {
      Object.keys(remoteTreeSha).map((path) => {
        return { path, status: "ADDED" };
      });
    }
    const remoteChanges = compareSha(
      remoteTreeSha,
      this.fit.lastFetchedRemoteSha,
      "remote"
    );
    return remoteChanges;
  }
  getClashedChanges(localChanges, remoteChanges) {
    const localChangePaths = localChanges.map((c) => c.path);
    const remoteChangePaths = remoteChanges.map((c) => c.path);
    const clashedFiles = localChangePaths.filter(
      (path) => remoteChangePaths.includes(path)
    );
    return clashedFiles;
  }
  // return null if remote doesn't have updates otherwise, return the latestRemoteCommitSha
  async remoteHasUpdates() {
    const latestRemoteCommitSha = await this.fit.getLatestRemoteCommitSha();
    if (latestRemoteCommitSha == this.fit.lastFetchedCommitSha) {
      return null;
    }
    return latestRemoteCommitSha;
  }
  async performPrePullChecks(localChanges) {
    const latestRemoteCommitSha = await this.remoteHasUpdates();
    if (!latestRemoteCommitSha) {
      return { status: "localCopyUpToDate", remoteUpdate: null };
    }
    if (!localChanges) {
      localChanges = await this.fit.getLocalChanges();
    }
    const remoteTreeSha = await this.fit.getRemoteTreeSha(latestRemoteCommitSha);
    const remoteChanges = await this.getRemoteChanges(remoteTreeSha);
    const clashedFiles = this.getClashedChanges(localChanges, remoteChanges);
    const prePullCheckStatus = remoteChanges.length > 0 ? clashedFiles.length > 0 ? "localChangesClashWithRemoteChanges" : "remoteChangesCanBeMerged" : "noRemoteChangesDetected";
    return {
      status: prePullCheckStatus,
      remoteUpdate: {
        remoteChanges,
        remoteTreeSha,
        latestRemoteCommitSha,
        clashedFiles
      }
    };
  }
  // Get changes from remote, pathShaMap is coupled to the Fit plugin design
  async getRemoteNonDeletionChangesContent(pathShaMap) {
    const remoteChanges = Object.entries(pathShaMap).map(async ([path, file_sha]) => {
      const content = await this.fit.getBlob(file_sha);
      return { path, content };
    });
    return await Promise.all(remoteChanges);
  }
  async prepareChangesToExecute(remoteChanges) {
    const deleteFromLocal = remoteChanges.filter((c) => c.status == "REMOVED").map((c) => c.path);
    const changesToProcess = remoteChanges.filter((c) => c.status != "REMOVED").reduce(
      (acc, change) => {
        acc[change.path] = change.currentSha;
        return acc;
      },
      {}
    );
    const addToLocal = await this.getRemoteNonDeletionChangesContent(changesToProcess);
    return { addToLocal, deleteFromLocal };
  }
  async pullRemoteToLocal(remoteUpdate, saveLocalStoreCallback) {
    const { remoteChanges, remoteTreeSha, latestRemoteCommitSha } = remoteUpdate;
    const { addToLocal, deleteFromLocal } = await this.prepareChangesToExecute(remoteChanges);
    await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
    await saveLocalStoreCallback({
      lastFetchedRemoteSha: remoteTreeSha,
      lastFetchedCommitSha: latestRemoteCommitSha,
      localSha: await this.fit.computeLocalSha()
    });
  }
};

// src/fitPush.ts
var import_obsidian = require("obsidian");
var FitPush = class {
  constructor(fit, vaultOps) {
    this.vaultOps = vaultOps;
    this.fit = fit;
  }
  async performPrePushChecks() {
    const localTreeSha = await this.fit.computeLocalSha();
    const localChanges = await this.fit.getLocalChanges(localTreeSha);
    if (localChanges.length == 0) {
      return { status: "noLocalChangesDetected", localUpdate: null };
    }
    const latestRemoteCommitSha = await this.fit.getLatestRemoteCommitSha();
    const status = latestRemoteCommitSha != this.fit.lastFetchedCommitSha ? "remoteChanged" : "localChangesCanBePushed";
    return {
      status,
      localUpdate: { localChanges, localTreeSha, parentCommitSha: latestRemoteCommitSha }
    };
  }
  async createCommitFromLocalUpdate(localUpdate) {
    const { localChanges, parentCommitSha } = localUpdate;
    const treeNodes = await Promise.all(localChanges.map((f) => {
      return this.fit.createTreeNodeFromFile(f);
    }));
    const latestRemoteCommitTreeSha = await this.fit.getCommitTreeSha(parentCommitSha);
    const createdTreeSha = await this.fit.createTree(treeNodes, latestRemoteCommitTreeSha);
    const createdCommitSha = await this.fit.createCommit(createdTreeSha, parentCommitSha);
    return createdCommitSha;
  }
  async pushChangedFilesToRemote(localUpdate, saveLocalStoreCallback) {
    const { localChanges, localTreeSha } = localUpdate;
    const createdCommitSha = await this.createCommitFromLocalUpdate(localUpdate);
    const updatedRefSha = await this.fit.updateRef(createdCommitSha);
    const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
    await saveLocalStoreCallback({
      lastFetchedRemoteSha: updatedRemoteTreeSha,
      lastFetchedCommitSha: createdCommitSha,
      localSha: localTreeSha
    });
    localChanges.map(({ path, status }) => {
      const statusToAction = { deleted: "deleted from", created: "added to", changed: "modified on" };
      new import_obsidian.Notice(`${path} ${statusToAction[status]} remote.`, 1e4);
    });
  }
};

// src/fitSetting.ts
var import_obsidian2 = require("obsidian");
var import_console = require("console");
var FitSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.getLatestLink = () => {
      const { owner, repo, branch } = this.plugin.settings;
      if (owner.length > 0 && repo.length > 0 && branch.length > 0) {
        return `https://github.com/${owner}/${repo}/tree/${branch}`;
      }
      return "";
    };
    this.handleUserFetch = async () => {
      this.authenticating = true;
      this.authUserAvatar.removeClass("error");
      this.authUserAvatar.empty();
      this.authUserAvatar.removeClass("empty");
      this.authUserAvatar.addClass("cat");
      try {
        const { owner, avatarUrl } = await this.plugin.fit.getUser();
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.createEl("img", { attr: { src: avatarUrl } });
        this.authUserHandle.setText(owner);
        if (owner !== this.plugin.settings.owner) {
          this.plugin.settings.owner = owner;
          this.plugin.settings.avatarUrl = avatarUrl;
          this.plugin.settings.repo = "";
          this.plugin.settings.branch = "";
          this.existingBranches = [];
          this.existingRepos = [];
          await this.plugin.saveSettings();
          await this.refreshFields("repo(0)");
        }
        this.authenticating = false;
      } catch (error) {
        this.authUserAvatar.removeClass("cat");
        this.authUserAvatar.addClass("error");
        this.authUserHandle.setText("Authentication failed, make sure your token has not expired.");
        this.plugin.settings.owner = "";
        this.plugin.settings.avatarUrl = "";
        this.plugin.settings.repo = "";
        this.plugin.settings.branch = "";
        this.existingBranches = [];
        this.existingRepos = [];
        await this.plugin.saveSettings();
        this.refreshFields("initialize");
        this.authenticating = false;
      }
    };
    this.githubUserInfoBlock = () => {
      const { containerEl } = this;
      new import_obsidian2.Setting(containerEl).setHeading().setName("GitHub user info").addButton((button) => button.setCta().setButtonText("Authenticate user").setDisabled(this.authenticating).onClick(async () => {
        if (this.authenticating)
          return;
        await this.handleUserFetch();
      }));
      this.ownerSetting = new import_obsidian2.Setting(containerEl).setDesc("Input your personal access token below to get authenticated. Create a GitHub account here if you don't have one yet.").addExtraButton((button) => button.setIcon("github").setTooltip("Sign up on github.com").onClick(async () => {
        window.open("https://github.com/signup", "_blank");
      }));
      this.ownerSetting.nameEl.addClass("fit-avatar-container");
      if (this.plugin.settings.owner === "") {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container empty" }
        );
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText("Unauthenticated");
      } else {
        this.authUserAvatar = this.ownerSetting.nameEl.createDiv(
          { cls: "fit-avatar-container" }
        );
        this.authUserAvatar.createEl("img", { attr: { src: this.plugin.settings.avatarUrl } });
        this.authUserHandle = this.ownerSetting.nameEl.createEl("span", { cls: "fit-github-handle" });
        this.authUserHandle.setText(this.plugin.settings.owner);
      }
      this.ownerSetting.controlEl.addClass("fit-avatar-display-text");
      this.patSetting = new import_obsidian2.Setting(containerEl).setName("Github personal access token").setDesc("Remember to give it access for reading and writing to the storage repo.").addText((text) => text.setPlaceholder("GitHub personal access token").setValue(this.plugin.settings.pat).onChange(async (value) => {
        this.plugin.settings.pat = value;
        await this.plugin.saveSettings();
      })).addExtraButton((button) => button.setIcon("external-link").setTooltip("Create a token").onClick(async () => {
        window.open("https://github.com/settings/tokens/new", "_blank");
      }));
    };
    this.repoInfoBlock = async () => {
      const { containerEl } = this;
      new import_obsidian2.Setting(containerEl).setHeading().setName("Repository info").setDesc("Refresh to retrieve the latest list of repos and branches.").addExtraButton((button) => button.setTooltip("Refresh repos and branches list").setDisabled(this.plugin.settings.owner === "").setIcon("refresh-cw").onClick(async () => {
        await this.refreshFields("repo(0)");
      }));
      new import_obsidian2.Setting(containerEl).setDesc("Select 'Add a README file' if creating a new repo. Make sure you are logged in to github on your browser.").addExtraButton((button) => button.setIcon("github").setTooltip("Create a new repository").onClick(() => {
        window.open(`https://github.com/new`, "_blank");
      }));
      this.repoSetting = new import_obsidian2.Setting(containerEl).setName("Github repository name").setDesc("Select a repo to sync your vault.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("repo-dropdown");
        this.existingRepos.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setDisabled(this.existingRepos.length === 0);
        dropdown.setValue(this.plugin.settings.repo);
        dropdown.onChange(async (value) => {
          const repoChanged = value !== this.plugin.settings.repo;
          if (repoChanged) {
            this.plugin.settings.repo = value;
            await this.plugin.saveSettings();
            await this.refreshFields("branch(1)");
          }
        });
      });
      this.branchSetting = new import_obsidian2.Setting(containerEl).setName("Branch name").setDesc("Select a repo above to view existing branches.").addDropdown((dropdown) => {
        dropdown.selectEl.addClass("branch-dropdown");
        dropdown.setDisabled(this.existingBranches.length === 0);
        this.existingBranches.map((repo) => dropdown.addOption(repo, repo));
        dropdown.setValue(this.plugin.settings.branch);
        dropdown.onChange(async (value) => {
          const branchChanged = value !== this.plugin.settings.branch;
          if (branchChanged) {
            this.plugin.settings.branch = value;
            await this.plugin.saveSettings();
            await this.refreshFields("link(2)");
          }
        });
      });
    };
    this.viewLinkBlock = () => {
      const { containerEl } = this;
      this.repoLink = this.getLatestLink();
      new import_obsidian2.Setting(containerEl).setHeading().setName("Link");
      const linkDisplay = new import_obsidian2.Setting(containerEl).setName("View your vault on GitHub").setDesc(this.repoLink).addExtraButton((button) => button.setIcon("refresh-cw").onClick(async () => {
        console.log(this.getLatestLink());
        await this.refreshFields("link(2)");
      })).addExtraButton(
        (button) => button.setDisabled(this.repoLink.length === 0).setTooltip("Open on GitHub").setIcon("external-link").onClick(() => {
          console.log(`opening ${this.repoLink}`);
          window.open(this.repoLink, "_blank");
        })
      );
      linkDisplay.descEl.addClass("link-desc");
    };
    this.localConfigBlock = () => {
      const { containerEl } = this;
      new import_obsidian2.Setting(containerEl).setHeading().setName("Local configurations");
      new import_obsidian2.Setting(containerEl).setName("Device name").setDesc("Sign commit message with this device name.").addText((text) => text.setPlaceholder("Device name").setValue(this.plugin.settings.deviceName).onChange(async (value) => {
        this.plugin.settings.deviceName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian2.Setting(containerEl).setName("Single button mode").setDesc("Single button to sync your repo to github (In early alpha, please file an issue if you encounter error with steps to reproduce).").addToggle(
        (selected) => selected.setValue(this.plugin.settings.singleButtonMode).onChange(async (selected2) => {
          this.plugin.settings.singleButtonMode = selected2;
          await this.plugin.saveSettings();
        })
      );
      const checkIntervalSlider = new import_obsidian2.Setting(containerEl).setName("Remote check interval").setDesc(`Automatically check for remote changes in the background every ${this.plugin.settings.checkEveryXMinutes} minutes.`).addSlider(
        (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.checkEveryXMinutes).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.checkEveryXMinutes = value;
          await this.plugin.saveSettings();
          checkIntervalSlider.setDesc(`Automatically check for remote changes in the background every ${value} minutes.`);
        })
      );
    };
    this.refreshFields = async (refreshFrom) => {
      const { containerEl } = this;
      const repo_dropdown = containerEl.querySelector(".repo-dropdown");
      const branch_dropdown = containerEl.querySelector(".branch-dropdown");
      const link_el = containerEl.querySelector(".link-desc");
      if (refreshFrom === "repo(0)") {
        repo_dropdown.disabled = true;
        branch_dropdown.disabled = true;
        this.existingRepos = await this.plugin.fit.getRepos();
        const repoOptions = Array.from(repo_dropdown.options).map((option) => option.value);
        if (!setEqual(this.existingRepos, repoOptions)) {
          repo_dropdown.empty();
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          const selectedRepoIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
          repo_dropdown.selectedIndex = selectedRepoIndex;
          if (selectedRepoIndex === -1) {
            this.plugin.settings.repo = "";
          }
        }
        repo_dropdown.disabled = false;
      }
      if (refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        if (this.plugin.settings.repo === "") {
          branch_dropdown.empty();
        } else {
          const latestBranches = await this.plugin.fit.getBranches();
          if (!setEqual(this.existingBranches, latestBranches)) {
            branch_dropdown.empty();
            this.existingBranches = latestBranches;
            this.existingBranches.map((branch) => {
              branch_dropdown.add(new Option(branch, branch));
            });
            const selectedBranchIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            branch_dropdown.selectedIndex = selectedBranchIndex;
            if (selectedBranchIndex === -1) {
              this.plugin.settings.branch = "";
            }
          }
        }
        branch_dropdown.disabled = false;
      }
      if (refreshFrom === "link(2)" || refreshFrom === "branch(1)" || refreshFrom === "repo(0)") {
        this.repoLink = this.getLatestLink();
        link_el.innerText = this.repoLink;
      }
      if (refreshFrom === "initialize") {
        const { repo, branch } = this.plugin.settings;
        repo_dropdown.empty();
        branch_dropdown.empty();
        repo_dropdown.add(new Option(repo, repo));
        branch_dropdown.add(new Option(branch, branch));
        link_el.innerText = this.getLatestLink();
      }
      if (refreshFrom === "withCache") {
        repo_dropdown.empty();
        branch_dropdown.empty();
        if (this.existingRepos.length > 0) {
          this.existingRepos.map((repo) => {
            repo_dropdown.add(new Option(repo, repo));
          });
          repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
        }
        if (this.existingBranches.length > 0) {
          this.existingBranches.map((branch) => {
            branch_dropdown.add(new Option(branch, branch));
          });
          if (this.plugin.settings.branch === "") {
            branch_dropdown.selectedIndex = -1;
          }
          branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
        }
        if (this.plugin.settings.repo !== "") {
          if (this.existingRepos.length === 0) {
            repo_dropdown.add(new Option(this.plugin.settings.repo, this.plugin.settings.repo));
          } else {
            repo_dropdown.selectedIndex = this.existingRepos.indexOf(this.plugin.settings.repo);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
        if (this.plugin.settings.branch !== "") {
          if (this.existingBranches.length === 0) {
            branch_dropdown.add(new Option(this.plugin.settings.branch, this.plugin.settings.branch));
          } else {
            branch_dropdown.selectedIndex = this.existingBranches.indexOf(this.plugin.settings.branch);
            if (branch_dropdown.selectedIndex === -1) {
              (0, import_console.warn)(`warning: selected branch ${this.plugin.settings.branch} not found, existing branches: ${this.existingBranches}`);
            }
          }
        }
      }
    };
    this.plugin = plugin;
    this.repoLink = this.getLatestLink();
    this.authenticating = false;
    this.existingRepos = [];
    this.existingBranches = [];
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    this.githubUserInfoBlock();
    this.repoInfoBlock();
    this.viewLinkBlock();
    this.localConfigBlock();
    this.refreshFields("withCache");
  }
};

// src/vaultOps.ts
var import_console2 = require("console");
var import_obsidian3 = require("obsidian");
var VaultOperations = class {
  constructor(vault) {
    this.vault = vault;
    this.noticeDuration = 1e4;
  }
  async deleteFromLocal(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian3.TFile) {
      await this.vault.delete(file);
      new import_obsidian3.Notice(`${path} deleted from local drive.`, this.noticeDuration);
      return;
    }
    (0, import_console2.warn)(`Attempting to delete ${path} from local but not successful, file is of type ${typeof file}.`);
  }
  async ensureFolderExists(path) {
    var _a;
    const folderPath = ((_a = path.match(/^(.*)\//)) == null ? void 0 : _a[1]) || "";
    if (folderPath != "" && !this.vault.getFolderByPath(folderPath)) {
      await this.vault.createFolder(folderPath);
    }
  }
  async writeToLocal(path, content) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian3.TFile) {
      await this.vault.modifyBinary(file, (0, import_obsidian3.base64ToArrayBuffer)(content));
    } else if (!file) {
      this.ensureFolderExists(path);
      await this.vault.createBinary(path, (0, import_obsidian3.base64ToArrayBuffer)(content));
    } else {
      (0, import_console2.warn)(`${path} writeToLocal operation unsuccessful, vault abstractFile on ${path} is of type ${typeof file}`);
    }
    new import_obsidian3.Notice(`${path} ${file ? "updated" : "copied"} to local drive.`, this.noticeDuration);
    return;
  }
  async updateLocalFiles(addToLocal, deleteFromLocal) {
    const writeOperations = addToLocal.map(async ({ path, content }) => {
      await this.writeToLocal(path, content);
    });
    const deletionOperations = deleteFromLocal.map(async (path) => {
      await this.deleteFromLocal(path);
    });
    await Promise.all([...writeOperations, ...deletionOperations]);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  pat: "",
  owner: "",
  avatarUrl: "",
  repo: "",
  branch: "",
  deviceName: "",
  singleButtonMode: true,
  checkEveryXMinutes: 5
};
var DEFAULT_LOCAL_STORE = {
  localSha: {},
  lastFetchedCommitSha: null,
  lastFetchedRemoteSha: {}
};
var FitPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    // use of arrow functions to ensure this refers to the FitPlugin class
    this.saveLocalStoreCallback = async (localStore) => {
      await this.loadLocalStore();
      this.localStore = { ...this.localStore, ...localStore };
      await this.saveLocalStore();
    };
    this.sync = async (syncNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      await this.loadLocalStore();
      syncNotice.setMessage("Performing pre sync checks.");
      const localChanges = await this.fit.getLocalChanges();
      const preSyncChecks = await this.fitPull.performPrePullChecks(localChanges);
      if (preSyncChecks.status === "localCopyUpToDate" && localChanges.length === 0) {
        syncNotice.setMessage("Local and remote in sync, no file operations performed.");
      } else if (preSyncChecks.status === "localCopyUpToDate" && localChanges.length > 0) {
        const localUpdate = {
          localChanges,
          localTreeSha: await this.fit.computeLocalSha(),
          // localStore must have value for localCopyUpToDate status to be returned
          parentCommitSha: this.localStore.lastFetchedCommitSha
        };
        await this.fitPush.pushChangedFilesToRemote(localUpdate, this.saveLocalStoreCallback);
        syncNotice.setMessage("Local copy up to date, pushed detected changes to remote.");
      } else if (preSyncChecks.status === "noRemoteChangesDetected" && localChanges.length === 0) {
        const { latestRemoteCommitSha } = preSyncChecks.remoteUpdate;
        await this.saveLocalStoreCallback({ lastFetchedCommitSha: latestRemoteCommitSha });
        syncNotice.setMessage("Local and remote in sync, tracking latest remote commit.");
      } else if (preSyncChecks.status === "noRemoteChangesDetected" && localChanges.length > 0) {
        const { latestRemoteCommitSha } = preSyncChecks.remoteUpdate;
        const localUpdate = {
          localChanges,
          localTreeSha: await this.fit.computeLocalSha(),
          parentCommitSha: latestRemoteCommitSha
        };
        await this.fitPush.pushChangedFilesToRemote(localUpdate, this.saveLocalStoreCallback);
        syncNotice.setMessage("No remote changes detected, local changes pushed to remote.");
      } else if (preSyncChecks.status === "localChangesClashWithRemoteChanges") {
        syncNotice.setMessage("Local changes clash with remote changes, aborting sync, files are unmodified.");
      } else if (preSyncChecks.status === "remoteChangesCanBeMerged" && localChanges.length === 0) {
        await this.fitPull.pullRemoteToLocal(preSyncChecks.remoteUpdate, this.saveLocalStoreCallback);
        syncNotice.setMessage("Sync complete, remote changes pulled to local copy.");
      } else if (preSyncChecks.status === "remoteChangesCanBeMerged" && localChanges.length > 0) {
        const { remoteUpdate } = preSyncChecks;
        const localUpdate = {
          localChanges,
          localTreeSha: await this.fit.computeLocalSha(),
          parentCommitSha: remoteUpdate.latestRemoteCommitSha
        };
        const { addToLocal, deleteFromLocal } = await this.fitPull.prepareChangesToExecute(
          remoteUpdate.remoteChanges
        );
        const createdCommitSha = await this.fitPush.createCommitFromLocalUpdate(localUpdate);
        const updatedRefSha = await this.fit.updateRef(createdCommitSha);
        syncNotice.setMessage("Local changes pushed to remote.");
        const updatedRemoteTreeSha = await this.fit.getRemoteTreeSha(updatedRefSha);
        await this.vaultOps.updateLocalFiles(addToLocal, deleteFromLocal);
        syncNotice.setMessage("Remote changes written to local drive.");
        await this.saveLocalStoreCallback({
          lastFetchedRemoteSha: updatedRemoteTreeSha,
          lastFetchedCommitSha: createdCommitSha,
          localSha: await this.fit.computeLocalSha()
        });
        syncNotice.setMessage("Local and remote now in sync.");
      }
    };
    this.pull = async (pullNotice) => {
      if (!this.checkSettingsConfigured()) {
        return;
      }
      await this.loadLocalStore();
      pullNotice.setMessage("Performing pre pull checks.");
      const prePullCheckResult = await this.fitPull.performPrePullChecks();
      if (prePullCheckResult.status === "localCopyUpToDate") {
        pullNotice.setMessage("Local copy already up to date");
      } else if (prePullCheckResult.status === "localChangesClashWithRemoteChanges") {
        pullNotice.setMessage("Local changes clashed with remote changes, please resolve and try again.");
      } else if (prePullCheckResult.status === "remoteChangesCanBeMerged") {
        pullNotice.setMessage("Pre pull checks successful, pulling changes from remote.");
        const remoteUpdate = prePullCheckResult.remoteUpdate;
        await this.fitPull.pullRemoteToLocal(remoteUpdate, this.saveLocalStoreCallback);
        pullNotice.setMessage("Pull complete, local copy up to date.");
      } else if (prePullCheckResult.status === "noRemoteChangesDetected") {
        const { latestRemoteCommitSha: lastFetchedCommitSha } = prePullCheckResult.remoteUpdate;
        this.saveLocalStoreCallback({ lastFetchedCommitSha });
        pullNotice.setMessage("No remote changes detected, local copy set to track latest commit.");
      }
      return;
    };
    this.push = async (pushNotice) => {
      pushNotice.setMessage("Performing pre push checks.");
      if (!this.checkSettingsConfigured()) {
        this.pushing = false;
        return;
      }
      await this.loadLocalStore();
      const prePushCheckResult = await this.fitPush.performPrePushChecks();
      if (prePushCheckResult.status === "noLocalChangesDetected") {
        pushNotice.setMessage("No local changes detected.");
      } else if (prePushCheckResult.status === "remoteChanged") {
        pushNotice.setMessage("Remote changed after last pull/write, please pull again.");
      } else if (prePushCheckResult.status === "localChangesCanBePushed") {
        const localUpdate = prePushCheckResult.localUpdate;
        pushNotice.setMessage("Pre push checks successful, pushing local changes to remote.");
        await this.fitPush.pushChangedFilesToRemote(localUpdate, this.saveLocalStoreCallback);
        pushNotice.setMessage(`Successful pushed to ${this.fit.repo}`);
      }
      return;
    };
    // wrapper to convert error to notice, return true if error is caught
    this.catchErrorAndNotify = async (func, notice, ...args) => {
      try {
        const result = await func(notice, ...args);
        return result;
      } catch (error) {
        if (error instanceof OctokitHttpError) {
          switch (error.source) {
            case "getTree":
            case "getRef":
              console.error("Caught error from getRef: ", error.message);
              if (error.status === 404) {
                notice.setMessage("Failed to get ref, make sure your repo name and branch name are set correctly.");
                return true;
              }
              notice.setMessage("Unknown error in getting ref, refers to console for details.");
              return true;
            case "getCommitTreeSha":
            case "getRemoteTreeSha":
            case "createBlob":
            case "createTreeNodeFromFile":
            case "createCommit":
            case "updateRef":
            case "getBlob":
          }
          return true;
        }
        notice.setMessage("Encountered unknown error during sync, view console log for details");
        return true;
      }
    };
  }
  // if settings not configured, open settings to let user quickly setup
  // Note: this is not a stable feature and might be disabled at any point in the future
  openPluginSettings() {
    const appWithSetting = this.app;
    appWithSetting.setting.open();
    appWithSetting.setting.openTabById("fit");
  }
  checkSettingsConfigured() {
    const actionItems = [];
    if (this.settings.pat === "") {
      actionItems.push("provide GitHub personal access token");
    }
    if (this.settings.owner === "") {
      actionItems.push("authenticate with personal access token");
    }
    if (this.settings.repo === "") {
      actionItems.push("select a repository to sync to");
    }
    if (this.settings.branch === "") {
      actionItems.push("select a branch to sync to");
    }
    if (actionItems.length > 0) {
      const settingsNotice = this.initializeFitNotice(["static"]);
      settingsNotice.setMessage("Settings not configured, please complete the following action items:\n" + actionItems.join("\n"));
      this.openPluginSettings();
      this.removeFitNotice(settingsNotice, "static");
      return false;
    }
    this.fit.loadSettings(this.settings);
    return true;
  }
  initializeFitNotice(addClasses = ["loading"]) {
    const notice = new import_obsidian4.Notice(" ", 0);
    notice.noticeEl.addClass("fit-notice");
    addClasses.map((cls) => notice.noticeEl.addClass(cls));
    return notice;
  }
  removeFitNotice(notice, finalClass) {
    notice.noticeEl.removeClass("loading");
    if (finalClass) {
      notice.noticeEl.addClass(finalClass);
    } else {
      notice.noticeEl.addClass("done");
    }
    setTimeout(() => notice.hide(), 4e3);
  }
  updateRibbonIcons() {
    if (this.settings.singleButtonMode) {
      this.fitSyncRibbonIconEl.removeClass("hide");
      this.fitPullRibbonIconEl.addClass("hide");
      this.fitPushRibbonIconEl.addClass("hide");
    } else {
      this.fitSyncRibbonIconEl.addClass("hide");
      this.fitPullRibbonIconEl.removeClass("hide");
      this.fitPushRibbonIconEl.removeClass("hide");
    }
  }
  loadRibbonIcons() {
    this.fitSyncRibbonIconEl = this.addRibbonIcon("github", "Fit Sync", async (evt) => {
      if (this.syncing || this.pulling || this.pushing) {
        return;
      }
      this.syncing = true;
      this.fitSyncRibbonIconEl.addClass("animate-icon");
      const syncNotice = this.initializeFitNotice();
      const errorCaught = await this.catchErrorAndNotify(this.sync, syncNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        this.removeFitNotice(syncNotice, "error");
        this.syncing = false;
        return;
      }
      this.removeFitNotice(syncNotice);
      this.syncing = false;
    });
    this.fitSyncRibbonIconEl.addClass("fit-sync-ribbon-el");
    this.fitPullRibbonIconEl = this.addRibbonIcon("github", "Fit pull", async (evt) => {
      if (this.syncing || this.pulling || this.pushing) {
        return;
      }
      this.pulling = true;
      this.fitPullRibbonIconEl.addClass("animate-icon");
      const pullNotice = this.initializeFitNotice();
      const errorCaught = await this.catchErrorAndNotify(this.pull, pullNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        this.removeFitNotice(pullNotice, "error");
        this.pulling = false;
        return;
      }
      this.removeFitNotice(pullNotice);
      this.pulling = false;
      this.fitPullRibbonIconEl.removeClass("animate-icon");
    });
    this.fitPullRibbonIconEl.addClass("fit-pull-ribbon-el");
    this.fitPushRibbonIconEl = this.addRibbonIcon("github", "Fit push", async (evt) => {
      if (this.syncing || this.pulling || this.pushing) {
        return;
      }
      this.fitPushRibbonIconEl.addClass("animate-icon");
      this.pushing = true;
      const pushNotice = this.initializeFitNotice();
      const errorCaught = await this.catchErrorAndNotify(this.push, pushNotice);
      this.fitSyncRibbonIconEl.removeClass("animate-icon");
      if (errorCaught === true) {
        this.removeFitNotice(pushNotice, "error");
        this.pushing = false;
        return;
      }
      this.removeFitNotice(pushNotice);
      this.pushing = false;
      this.fitPushRibbonIconEl.removeClass("animate-icon");
    });
    this.fitPushRibbonIconEl.addClass("fit-push-ribbon-el");
    this.updateRibbonIcons();
  }
  async onload() {
    await this.loadSettings();
    await this.loadLocalStore();
    this.fit = new Fit(this.settings, this.localStore, this.app.vault);
    this.vaultOps = new VaultOperations(this.app.vault);
    this.fitPull = new FitPull(this.fit, this.vaultOps);
    this.fitPush = new FitPush(this.fit, this.vaultOps);
    this.pulling = false;
    this.pushing = false;
    this.syncing = false;
    this.settingTab = new FitSettingTab(this.app, this);
    this.loadRibbonIcons();
    this.addCommand({
      id: "recompute-local-sha",
      name: `Update local store with new local sha, to unblock pulling when local clashes are detected (Dangerous!
				Running pull after this command will discard local changes, please backup vault before running this.)`,
      callback: async () => {
        this.localStore.localSha = await this.fit.computeLocalSha();
        this.saveLocalStore();
        new import_obsidian4.Notice(`Stored local sha recomputation, recent local changes will not be considered in future push/pull.`);
      }
    });
    this.addSettingTab(new FitSettingTab(this.app, this));
    this.registerInterval(window.setInterval(async () => {
      if (this.checkSettingsConfigured()) {
        const updatedRemoteCommitSha = await this.fitPull.remoteHasUpdates();
        if (updatedRemoteCommitSha) {
          const intervalNotice = this.initializeFitNotice(["static"]);
          intervalNotice.setMessage("Remote update detected, please pull the latest changes.");
        }
      }
    }, this.settings.checkEveryXMinutes * 60 * 1e3));
  }
  onunload() {
  }
  async loadSettings() {
    const userSetting = await this.loadData();
    const settings = Object.assign({}, DEFAULT_SETTINGS, userSetting);
    const settingsObj = Object.keys(DEFAULT_SETTINGS).reduce(
      (obj, key) => {
        if (settings.hasOwnProperty(key)) {
          if (key == "singleButtonMode") {
            obj[key] = Boolean(settings[key]);
          } else if (key == "checkEveryXMinutes") {
            obj[key] = Number(settings[key]);
          } else {
            obj[key] = settings[key];
          }
        }
        return obj;
      },
      {}
    );
    this.settings = settingsObj;
  }
  async loadLocalStore() {
    const localStore = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    const localStoreObj = Object.keys(DEFAULT_LOCAL_STORE).reduce(
      (obj, key) => {
        if (localStore.hasOwnProperty(key)) {
          obj[key] = localStore[key];
        }
        return obj;
      },
      {}
    );
    this.localStore = localStoreObj;
  }
  // allow saving of local stores property, passed in properties will override existing stored value
  async saveLocalStore() {
    const data = Object.assign({}, DEFAULT_LOCAL_STORE, await this.loadData());
    await this.saveData({ ...data, ...this.localStore });
    this.fit.loadLocalStore(this.localStore);
  }
  async saveSettings() {
    const data = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    await this.saveData({ ...data, ...this.settings });
    this.fit.loadSettings(this.settings);
    this.updateRibbonIcons();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9ub2RlX21vZHVsZXMvdW5pdmVyc2FsLXVzZXItYWdlbnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2JlZm9yZS1hZnRlci1ob29rL2xpYi9yZWdpc3Rlci5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL2FkZC5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svbGliL3JlbW92ZS5qcyIsICJub2RlX21vZHVsZXMvYmVmb3JlLWFmdGVyLWhvb2svaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L2VuZHBvaW50L25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZW5kcG9pbnQvZGlzdC1idW5kbGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BvY3Rva2l0L3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbC11c2VyLWFnZW50L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L25vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0LWVycm9yL2Rpc3Qtc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9yZXF1ZXN0L2Rpc3QtYnVuZGxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9ncmFwaHFsL25vZGVfbW9kdWxlcy91bml2ZXJzYWwtdXNlci1hZ2VudC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvZ3JhcGhxbC9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvYXV0aC10b2tlbi9kaXN0LWJ1bmRsZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQG9jdG9raXQvY29yZS9kaXN0LXNyYy92ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9Ab2N0b2tpdC9jb3JlL2Rpc3Qtc3JjL2luZGV4LmpzIiwgInNyYy91dGlscy50cyIsICJzcmMvZml0LnRzIiwgInNyYy9maXRQdWxsLnRzIiwgInNyYy9maXRQdXNoLnRzIiwgInNyYy9maXRTZXR0aW5nLnRzIiwgInNyYy92YXVsdE9wcy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4sIFNldHRpbmdUYWIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBGaXQsIE9jdG9raXRIdHRwRXJyb3IgfSBmcm9tICdzcmMvZml0JztcbmltcG9ydCB7IEZpdFB1bGwgfSBmcm9tICdzcmMvZml0UHVsbCc7XG5pbXBvcnQgeyBGaXRQdXNoIH0gZnJvbSAnc3JjL2ZpdFB1c2gnO1xuaW1wb3J0IEZpdFNldHRpbmdUYWIgZnJvbSAnc3JjL2ZpdFNldHRpbmcnO1xuaW1wb3J0IHsgVmF1bHRPcGVyYXRpb25zIH0gZnJvbSAnc3JjL3ZhdWx0T3BzJztcblxuZXhwb3J0IGludGVyZmFjZSBGaXRTZXR0aW5ncyB7XG5cdHBhdDogc3RyaW5nO1xuXHRvd25lcjogc3RyaW5nO1xuXHRhdmF0YXJVcmw6IHN0cmluZztcblx0cmVwbzogc3RyaW5nO1xuXHRicmFuY2g6IHN0cmluZztcblx0ZGV2aWNlTmFtZTogc3RyaW5nO1xuXHRzaW5nbGVCdXR0b25Nb2RlOiBib29sZWFuXG5cdGNoZWNrRXZlcnlYTWludXRlczogbnVtYmVyXG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEZpdFNldHRpbmdzID0ge1xuXHRwYXQ6IFwiXCIsXG5cdG93bmVyOiBcIlwiLFxuXHRhdmF0YXJVcmw6IFwiXCIsXG5cdHJlcG86IFwiXCIsXG5cdGJyYW5jaDogXCJcIixcblx0ZGV2aWNlTmFtZTogXCJcIixcblx0c2luZ2xlQnV0dG9uTW9kZTogdHJ1ZSxcblx0Y2hlY2tFdmVyeVhNaW51dGVzOiA1XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0b3JlcyB7XG5cdGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG59XG5cbmNvbnN0IERFRkFVTFRfTE9DQUxfU1RPUkU6IExvY2FsU3RvcmVzID0ge1xuXHRsb2NhbFNoYToge30sXG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBudWxsLFxuXHRsYXN0RmV0Y2hlZFJlbW90ZVNoYToge31cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXRQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogRml0U2V0dGluZ3M7XG5cdHNldHRpbmdUYWI6IEZpdFNldHRpbmdUYWJcblx0bG9jYWxTdG9yZTogTG9jYWxTdG9yZXNcblx0Zml0OiBGaXQ7XG5cdHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnM7XG5cdGZpdFB1bGw6IEZpdFB1bGxcblx0Zml0UHVzaDogRml0UHVzaFxuXHRwdWxsaW5nOiBib29sZWFuXG5cdHB1c2hpbmc6IGJvb2xlYW5cblx0c3luY2luZzogYm9vbGVhblxuXHRmaXRQdWxsUmliYm9uSWNvbkVsOiBIVE1MRWxlbWVudFxuXHRmaXRQdXNoUmliYm9uSWNvbkVsOiBIVE1MRWxlbWVudFxuXHRmaXRTeW5jUmliYm9uSWNvbkVsOiBIVE1MRWxlbWVudFxuXG5cdC8vIGlmIHNldHRpbmdzIG5vdCBjb25maWd1cmVkLCBvcGVuIHNldHRpbmdzIHRvIGxldCB1c2VyIHF1aWNrbHkgc2V0dXBcblx0Ly8gTm90ZTogdGhpcyBpcyBub3QgYSBzdGFibGUgZmVhdHVyZSBhbmQgbWlnaHQgYmUgZGlzYWJsZWQgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b3BlblBsdWdpblNldHRpbmdzKCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cdFx0Y29uc3QgYXBwV2l0aFNldHRpbmcgPSB0aGlzLmFwcCBhcyBhbnkgYXMge1xuXHRcdFx0c2V0dGluZzoge1xuXHRcdFx0XHRvcGVuKCk6IHZvaWQ7XG5cdFx0XHRcdG9wZW5UYWJCeUlkKGlkOiBzdHJpbmcpOiBTZXR0aW5nVGFiIHwgbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuKClcblx0XHRhcHBXaXRoU2V0dGluZy5zZXR0aW5nLm9wZW5UYWJCeUlkKFwiZml0XCIpXG5cdH1cblxuXHRjaGVja1NldHRpbmdzQ29uZmlndXJlZCgpOiBib29sZWFuIHtcblx0XHRjb25zdCBhY3Rpb25JdGVtczogQXJyYXk8c3RyaW5nPiA9IFtdXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MucGF0ID09PSBcIlwiKSB7XG5cdFx0XHRhY3Rpb25JdGVtcy5wdXNoKFwicHJvdmlkZSBHaXRIdWIgcGVyc29uYWwgYWNjZXNzIHRva2VuXCIpXG5cdFx0fVxuXHRcdGlmICh0aGlzLnNldHRpbmdzLm93bmVyID09PSBcIlwiKSB7XG5cdFx0XHRhY3Rpb25JdGVtcy5wdXNoKFwiYXV0aGVudGljYXRlIHdpdGggcGVyc29uYWwgYWNjZXNzIHRva2VuXCIpXG5cdFx0fVxuXHRcdGlmICh0aGlzLnNldHRpbmdzLnJlcG8gPT09IFwiXCIpIHtcblx0XHRcdGFjdGlvbkl0ZW1zLnB1c2goXCJzZWxlY3QgYSByZXBvc2l0b3J5IHRvIHN5bmMgdG9cIilcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuYnJhbmNoID09PSBcIlwiKSB7XG5cdFx0XHRhY3Rpb25JdGVtcy5wdXNoKFwic2VsZWN0IGEgYnJhbmNoIHRvIHN5bmMgdG9cIilcdFxuXHRcdH1cblxuXHRcdGlmIChhY3Rpb25JdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBzZXR0aW5nc05vdGljZSA9IHRoaXMuaW5pdGlhbGl6ZUZpdE5vdGljZShbXCJzdGF0aWNcIl0pXG5cdFx0XHRzZXR0aW5nc05vdGljZS5zZXRNZXNzYWdlKFwiU2V0dGluZ3Mgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBjb21wbGV0ZSB0aGUgZm9sbG93aW5nIGFjdGlvbiBpdGVtczpcXG5cIiArIGFjdGlvbkl0ZW1zLmpvaW4oXCJcXG5cIikpXG5cdFx0XHR0aGlzLm9wZW5QbHVnaW5TZXR0aW5ncygpXG5cdFx0XHR0aGlzLnJlbW92ZUZpdE5vdGljZShzZXR0aW5nc05vdGljZSwgXCJzdGF0aWNcIilcblx0XHRcdHJldHVybiBmYWxzZVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5maXQubG9hZFNldHRpbmdzKHRoaXMuc2V0dGluZ3MpXG5cdFx0cmV0dXJuIHRydWVcblx0fVxuXG5cdC8vIHVzZSBvZiBhcnJvdyBmdW5jdGlvbnMgdG8gZW5zdXJlIHRoaXMgcmVmZXJzIHRvIHRoZSBGaXRQbHVnaW4gY2xhc3Ncblx0c2F2ZUxvY2FsU3RvcmVDYWxsYmFjayA9IGFzeW5jIChsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPik6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdGF3YWl0IHRoaXMubG9hZExvY2FsU3RvcmUoKVxuXHRcdHRoaXMubG9jYWxTdG9yZSA9IHsuLi50aGlzLmxvY2FsU3RvcmUsIC4uLmxvY2FsU3RvcmV9XG5cdFx0YXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZSgpXG5cdH1cblxuXHRzeW5jID0gYXN5bmMgKHN5bmNOb3RpY2U6IE5vdGljZSk6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdGlmICghdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7IHJldHVybiB9XG5cdFx0YXdhaXQgdGhpcy5sb2FkTG9jYWxTdG9yZSgpXG5cdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiUGVyZm9ybWluZyBwcmUgc3luYyBjaGVja3MuXCIpXG5cdFx0Y29uc3QgbG9jYWxDaGFuZ2VzID0gYXdhaXQgdGhpcy5maXQuZ2V0TG9jYWxDaGFuZ2VzKClcblx0XHRjb25zdCBwcmVTeW5jQ2hlY2tzID0gYXdhaXQgdGhpcy5maXRQdWxsLnBlcmZvcm1QcmVQdWxsQ2hlY2tzKGxvY2FsQ2hhbmdlcylcblx0XHRpZiAocHJlU3luY0NoZWNrcy5zdGF0dXMgPT09IFwibG9jYWxDb3B5VXBUb0RhdGVcIiAmJiBsb2NhbENoYW5nZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJMb2NhbCBhbmQgcmVtb3RlIGluIHN5bmMsIG5vIGZpbGUgb3BlcmF0aW9ucyBwZXJmb3JtZWQuXCIpXG5cdFx0fSBcblx0XHRlbHNlIGlmIChwcmVTeW5jQ2hlY2tzLnN0YXR1cyA9PT0gXCJsb2NhbENvcHlVcFRvRGF0ZVwiICYmIGxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBwdXNoIGxvY2FsIGNoYW5nZXMgdG8gcmVtb3RlXG5cdFx0XHRjb25zdCBsb2NhbFVwZGF0ZSA9IHtcblx0XHRcdFx0bG9jYWxDaGFuZ2VzLFxuXHRcdFx0XHRsb2NhbFRyZWVTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpLFxuXHRcdFx0XHQvLyBsb2NhbFN0b3JlIG11c3QgaGF2ZSB2YWx1ZSBmb3IgbG9jYWxDb3B5VXBUb0RhdGUgc3RhdHVzIHRvIGJlIHJldHVybmVkXG5cdFx0XHRcdHBhcmVudENvbW1pdFNoYTogdGhpcy5sb2NhbFN0b3JlLmxhc3RGZXRjaGVkQ29tbWl0U2hhIGFzIHN0cmluZ1xuXHRcdFx0fVxuXHRcdFx0YXdhaXQgdGhpcy5maXRQdXNoLnB1c2hDaGFuZ2VkRmlsZXNUb1JlbW90ZShsb2NhbFVwZGF0ZSwgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiTG9jYWwgY29weSB1cCB0byBkYXRlLCBwdXNoZWQgZGV0ZWN0ZWQgY2hhbmdlcyB0byByZW1vdGUuXCIpXG5cdFx0fSBcblx0XHRlbHNlIGlmIChwcmVTeW5jQ2hlY2tzLnN0YXR1cyA9PT0gXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiICYmIGxvY2FsQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnN0IHsgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhIH0gPSBwcmVTeW5jQ2hlY2tzLnJlbW90ZVVwZGF0ZVxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKHtsYXN0RmV0Y2hlZENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhfSlcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIkxvY2FsIGFuZCByZW1vdGUgaW4gc3luYywgdHJhY2tpbmcgbGF0ZXN0IHJlbW90ZSBjb21taXQuXCIpXG5cdFx0fSBcblx0XHRlbHNlIGlmIChwcmVTeW5jQ2hlY2tzLnN0YXR1cyA9PT0gXCJub1JlbW90ZUNoYW5nZXNEZXRlY3RlZFwiICYmIGxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCB7IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSB9ID0gcHJlU3luY0NoZWNrcy5yZW1vdGVVcGRhdGVcblx0XHRcdGNvbnN0IGxvY2FsVXBkYXRlID0ge1xuXHRcdFx0XHRsb2NhbENoYW5nZXMsXG5cdFx0XHRcdGxvY2FsVHJlZVNoYTogYXdhaXQgdGhpcy5maXQuY29tcHV0ZUxvY2FsU2hhKCksXG5cdFx0XHRcdHBhcmVudENvbW1pdFNoYTogbGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG5cdFx0XHR9XG5cdFx0XHRhd2FpdCB0aGlzLmZpdFB1c2gucHVzaENoYW5nZWRGaWxlc1RvUmVtb3RlKGxvY2FsVXBkYXRlLCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2spXG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJObyByZW1vdGUgY2hhbmdlcyBkZXRlY3RlZCwgbG9jYWwgY2hhbmdlcyBwdXNoZWQgdG8gcmVtb3RlLlwiKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwcmVTeW5jQ2hlY2tzLnN0YXR1cyA9PT0gXCJsb2NhbENoYW5nZXNDbGFzaFdpdGhSZW1vdGVDaGFuZ2VzXCIpIHtcblx0XHRcdHN5bmNOb3RpY2Uuc2V0TWVzc2FnZShcIkxvY2FsIGNoYW5nZXMgY2xhc2ggd2l0aCByZW1vdGUgY2hhbmdlcywgYWJvcnRpbmcgc3luYywgZmlsZXMgYXJlIHVubW9kaWZpZWQuXCIpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHByZVN5bmNDaGVja3Muc3RhdHVzID09PSBcInJlbW90ZUNoYW5nZXNDYW5CZU1lcmdlZFwiICYmIGxvY2FsQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdGF3YWl0IHRoaXMuZml0UHVsbC5wdWxsUmVtb3RlVG9Mb2NhbChwcmVTeW5jQ2hlY2tzLnJlbW90ZVVwZGF0ZSwgdGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiU3luYyBjb21wbGV0ZSwgcmVtb3RlIGNoYW5nZXMgcHVsbGVkIHRvIGxvY2FsIGNvcHkuXCIpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHByZVN5bmNDaGVja3Muc3RhdHVzID09PSBcInJlbW90ZUNoYW5nZXNDYW5CZU1lcmdlZFwiICYmIGxvY2FsQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBkbyBib3RoIHB1bGwgYW5kIHB1c2hcblx0XHRcdC8vIChvcmRlcnMgb2YgZXhlY3V0aW9uIGRpZmZlcmVudCBmcm9tIHB1bGxSZW1vdGVUb0xvY2FsIGFuZCBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUgdG8gXG5cdFx0XHQvLyBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbiBsaWtlLCBpLmUuIG1haW50YWluIG9yaWdpbmFsIHN0YXRlIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQpXG5cdFx0XHQvLyBJZiB5b3UgaGF2ZSBhbiBpZGVhIG9uIGhvdyB0byBtYWtlIHRoaXMgbW9yZSB0cmFuc2FjdGlvbi1saWtlLCBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSBvbiBcblx0XHRcdC8vIHRoZSBmaXQgcmVwb1xuXHRcdFx0Y29uc3Qge3JlbW90ZVVwZGF0ZX0gPSBwcmVTeW5jQ2hlY2tzXG5cdFx0XHRjb25zdCBsb2NhbFVwZGF0ZSA9IHtcblx0XHRcdFx0bG9jYWxDaGFuZ2VzLFxuXHRcdFx0XHRsb2NhbFRyZWVTaGE6IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpLFxuXHRcdFx0XHRwYXJlbnRDb21taXRTaGE6IHJlbW90ZVVwZGF0ZS5sYXRlc3RSZW1vdGVDb21taXRTaGFcblx0XHRcdH1cblx0XHRcdGNvbnN0IHthZGRUb0xvY2FsLCBkZWxldGVGcm9tTG9jYWx9ID0gYXdhaXQgdGhpcy5maXRQdWxsLnByZXBhcmVDaGFuZ2VzVG9FeGVjdXRlKFxuXHRcdFx0XHRyZW1vdGVVcGRhdGUucmVtb3RlQ2hhbmdlcylcblx0XHRcdGNvbnN0IGNyZWF0ZWRDb21taXRTaGEgPSBhd2FpdCB0aGlzLmZpdFB1c2guY3JlYXRlQ29tbWl0RnJvbUxvY2FsVXBkYXRlKGxvY2FsVXBkYXRlKVxuXHRcdFx0Y29uc3QgdXBkYXRlZFJlZlNoYSA9IGF3YWl0IHRoaXMuZml0LnVwZGF0ZVJlZihjcmVhdGVkQ29tbWl0U2hhKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiTG9jYWwgY2hhbmdlcyBwdXNoZWQgdG8gcmVtb3RlLlwiKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFJlbW90ZVRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRSZW1vdGVUcmVlU2hhKHVwZGF0ZWRSZWZTaGEpXG5cdFx0XHRhd2FpdCB0aGlzLnZhdWx0T3BzLnVwZGF0ZUxvY2FsRmlsZXMoYWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsKVxuXHRcdFx0c3luY05vdGljZS5zZXRNZXNzYWdlKFwiUmVtb3RlIGNoYW5nZXMgd3JpdHRlbiB0byBsb2NhbCBkcml2ZS5cIilcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayh7XG5cdFx0XHRcdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiB1cGRhdGVkUmVtb3RlVHJlZVNoYSwgXG5cdFx0XHRcdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBjcmVhdGVkQ29tbWl0U2hhLFxuXHRcdFx0XHRsb2NhbFNoYTogYXdhaXQgdGhpcy5maXQuY29tcHV0ZUxvY2FsU2hhKClcblx0XHRcdH0pXG5cdFx0XHRzeW5jTm90aWNlLnNldE1lc3NhZ2UoXCJMb2NhbCBhbmQgcmVtb3RlIG5vdyBpbiBzeW5jLlwiKVxuXHRcdH1cblx0fVxuXG5cdHB1bGwgPSBhc3luYyAocHVsbE5vdGljZTogTm90aWNlKTogUHJvbWlzZTx2b2lkPiA9PiB7XG5cdFx0aWYgKCF0aGlzLmNoZWNrU2V0dGluZ3NDb25maWd1cmVkKCkpIHsgcmV0dXJuIH1cblx0XHRhd2FpdCB0aGlzLmxvYWRMb2NhbFN0b3JlKClcblx0XHRwdWxsTm90aWNlLnNldE1lc3NhZ2UoXCJQZXJmb3JtaW5nIHByZSBwdWxsIGNoZWNrcy5cIilcblx0XHRjb25zdCBwcmVQdWxsQ2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1bGwucGVyZm9ybVByZVB1bGxDaGVja3MoKVxuXHRcdGlmIChwcmVQdWxsQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImxvY2FsQ29weVVwVG9EYXRlXCIpIHtcblx0XHRcdHB1bGxOb3RpY2Uuc2V0TWVzc2FnZShcIkxvY2FsIGNvcHkgYWxyZWFkeSB1cCB0byBkYXRlXCIpXG5cdFx0fSBlbHNlIGlmIChwcmVQdWxsQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIikge1xuXHRcdFx0Ly8gVE9ETyBwcm92aWRlIGEgd2F5IGZvciB1c2VycyB0byByZXNvbHZlIGNsYXNoZXNcblx0XHRcdHB1bGxOb3RpY2Uuc2V0TWVzc2FnZShcIkxvY2FsIGNoYW5nZXMgY2xhc2hlZCB3aXRoIHJlbW90ZSBjaGFuZ2VzLCBwbGVhc2UgcmVzb2x2ZSBhbmQgdHJ5IGFnYWluLlwiKVxuXHRcdH0gZWxzZSBpZiAocHJlUHVsbENoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJyZW1vdGVDaGFuZ2VzQ2FuQmVNZXJnZWRcIikge1xuXHRcdFx0cHVsbE5vdGljZS5zZXRNZXNzYWdlKFwiUHJlIHB1bGwgY2hlY2tzIHN1Y2Nlc3NmdWwsIHB1bGxpbmcgY2hhbmdlcyBmcm9tIHJlbW90ZS5cIilcblx0XHRcdGNvbnN0IHJlbW90ZVVwZGF0ZSA9IHByZVB1bGxDaGVja1Jlc3VsdC5yZW1vdGVVcGRhdGVcblx0XHRcdGF3YWl0IHRoaXMuZml0UHVsbC5wdWxsUmVtb3RlVG9Mb2NhbChyZW1vdGVVcGRhdGUsIHRoaXMuc2F2ZUxvY2FsU3RvcmVDYWxsYmFjaylcblx0XHRcdHB1bGxOb3RpY2Uuc2V0TWVzc2FnZShcIlB1bGwgY29tcGxldGUsIGxvY2FsIGNvcHkgdXAgdG8gZGF0ZS5cIilcblx0XHR9IGVsc2UgaWYgKHByZVB1bGxDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwibm9SZW1vdGVDaGFuZ2VzRGV0ZWN0ZWRcIikge1xuXHRcdFx0Y29uc3Qge2xhdGVzdFJlbW90ZUNvbW1pdFNoYTogbGFzdEZldGNoZWRDb21taXRTaGF9ID0gcHJlUHVsbENoZWNrUmVzdWx0LnJlbW90ZVVwZGF0ZVxuXHRcdFx0dGhpcy5zYXZlTG9jYWxTdG9yZUNhbGxiYWNrKHtsYXN0RmV0Y2hlZENvbW1pdFNoYX0pXG5cdFx0XHRwdWxsTm90aWNlLnNldE1lc3NhZ2UoXCJObyByZW1vdGUgY2hhbmdlcyBkZXRlY3RlZCwgbG9jYWwgY29weSBzZXQgdG8gdHJhY2sgbGF0ZXN0IGNvbW1pdC5cIilcblx0XHR9XG5cdFx0cmV0dXJuXG5cdH1cblxuXHRwdXNoID0gYXN5bmMgKHB1c2hOb3RpY2U6IE5vdGljZSk6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdHB1c2hOb3RpY2Uuc2V0TWVzc2FnZShcIlBlcmZvcm1pbmcgcHJlIHB1c2ggY2hlY2tzLlwiKVxuXHRcdGlmICghdGhpcy5jaGVja1NldHRpbmdzQ29uZmlndXJlZCgpKSB7IFxuXHRcdFx0dGhpcy5wdXNoaW5nID0gZmFsc2Vcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRhd2FpdCB0aGlzLmxvYWRMb2NhbFN0b3JlKClcblx0XHRjb25zdCBwcmVQdXNoQ2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmZpdFB1c2gucGVyZm9ybVByZVB1c2hDaGVja3MoKVxuXHRcdGlmIChwcmVQdXNoQ2hlY2tSZXN1bHQuc3RhdHVzID09PSBcIm5vTG9jYWxDaGFuZ2VzRGV0ZWN0ZWRcIikge1xuXHRcdFx0cHVzaE5vdGljZS5zZXRNZXNzYWdlKFwiTm8gbG9jYWwgY2hhbmdlcyBkZXRlY3RlZC5cIilcblx0XHR9IGVsc2UgaWYgKHByZVB1c2hDaGVja1Jlc3VsdC5zdGF0dXMgPT09IFwicmVtb3RlQ2hhbmdlZFwiKSB7XG5cdFx0XHRwdXNoTm90aWNlLnNldE1lc3NhZ2UoXCJSZW1vdGUgY2hhbmdlZCBhZnRlciBsYXN0IHB1bGwvd3JpdGUsIHBsZWFzZSBwdWxsIGFnYWluLlwiKVxuXHRcdH0gZWxzZSBpZiAocHJlUHVzaENoZWNrUmVzdWx0LnN0YXR1cyA9PT0gXCJsb2NhbENoYW5nZXNDYW5CZVB1c2hlZFwiKSB7XG5cdFx0XHRjb25zdCBsb2NhbFVwZGF0ZSA9IHByZVB1c2hDaGVja1Jlc3VsdC5sb2NhbFVwZGF0ZVxuXHRcdFx0cHVzaE5vdGljZS5zZXRNZXNzYWdlKFwiUHJlIHB1c2ggY2hlY2tzIHN1Y2Nlc3NmdWwsIHB1c2hpbmcgbG9jYWwgY2hhbmdlcyB0byByZW1vdGUuXCIpXG5cdFx0XHRhd2FpdCB0aGlzLmZpdFB1c2gucHVzaENoYW5nZWRGaWxlc1RvUmVtb3RlKGxvY2FsVXBkYXRlLCB0aGlzLnNhdmVMb2NhbFN0b3JlQ2FsbGJhY2spXG5cdFx0XHRwdXNoTm90aWNlLnNldE1lc3NhZ2UoYFN1Y2Nlc3NmdWwgcHVzaGVkIHRvICR7dGhpcy5maXQucmVwb31gKVxuXHRcdH1cblx0XHRyZXR1cm5cblx0fVxuXG5cdC8vIHdyYXBwZXIgdG8gY29udmVydCBlcnJvciB0byBub3RpY2UsIHJldHVybiB0cnVlIGlmIGVycm9yIGlzIGNhdWdodFxuXHRjYXRjaEVycm9yQW5kTm90aWZ5ID0gYXN5bmMgPFAgZXh0ZW5kcyB1bmtub3duW10sIFI+KGZ1bmM6IChub3RpY2U6IE5vdGljZSwgLi4uYXJnczogUCkgPT4gUHJvbWlzZTxSPiwgbm90aWNlOiBOb3RpY2UsIC4uLmFyZ3M6IFApOiBQcm9taXNlPFJ8dHJ1ZT4gPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBmdW5jKG5vdGljZSwgLi4uYXJncylcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgT2N0b2tpdEh0dHBFcnJvcikge1xuXHRcdFx0XHRzd2l0Y2ggKGVycm9yLnNvdXJjZSkge1xuXHRcdFx0XHRcdGNhc2UgJ2dldFRyZWUnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldFJlZic6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiQ2F1Z2h0IGVycm9yIGZyb20gZ2V0UmVmOiBcIiwgZXJyb3IubWVzc2FnZSlcblx0XHRcdFx0XHRcdGlmIChlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuXHRcdFx0XHRcdFx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIkZhaWxlZCB0byBnZXQgcmVmLCBtYWtlIHN1cmUgeW91ciByZXBvIG5hbWUgYW5kIGJyYW5jaCBuYW1lIGFyZSBzZXQgY29ycmVjdGx5LlwiKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bm90aWNlLnNldE1lc3NhZ2UoXCJVbmtub3duIGVycm9yIGluIGdldHRpbmcgcmVmLCByZWZlcnMgdG8gY29uc29sZSBmb3IgZGV0YWlscy5cIilcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdFx0Y2FzZSAnZ2V0Q29tbWl0VHJlZVNoYSc6XG5cdFx0XHRcdFx0Y2FzZSAnZ2V0UmVtb3RlVHJlZVNoYSc6XG5cdFx0XHRcdFx0Y2FzZSAnY3JlYXRlQmxvYic6XG5cdFx0XHRcdFx0Y2FzZSAnY3JlYXRlVHJlZU5vZGVGcm9tRmlsZSc6XG5cdFx0XHRcdFx0Y2FzZSAnY3JlYXRlQ29tbWl0Jzpcblx0XHRcdFx0XHRjYXNlICd1cGRhdGVSZWYnOlxuXHRcdFx0XHRcdGNhc2UgJ2dldEJsb2InOlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRub3RpY2Uuc2V0TWVzc2FnZShcIkVuY291bnRlcmVkIHVua25vd24gZXJyb3IgZHVyaW5nIHN5bmMsIHZpZXcgY29uc29sZSBsb2cgZm9yIGRldGFpbHNcIilcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHR9XG5cblx0aW5pdGlhbGl6ZUZpdE5vdGljZShhZGRDbGFzc2VzID0gW1wibG9hZGluZ1wiXSk6IE5vdGljZSB7XG5cdFx0Y29uc3Qgbm90aWNlID0gbmV3IE5vdGljZShcIiBcIiwgMCkgLy8ga2VlcCBhdCBsZWFzdCBvbmUgZW1wdHkgc3BhY2UgdG8gbWFrZSB0aGUgaGVpZ2h0IGNvbnNpc3RlbnRcblx0XHRub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3MoXCJmaXQtbm90aWNlXCIpXHRcblx0XHRhZGRDbGFzc2VzLm1hcChjbHMgPT4gbm90aWNlLm5vdGljZUVsLmFkZENsYXNzKGNscykpXG5cdFx0cmV0dXJuIG5vdGljZVxuXHR9XG5cblx0cmVtb3ZlRml0Tm90aWNlKG5vdGljZTogTm90aWNlLCBmaW5hbENsYXNzPzogc3RyaW5nKTogdm9pZCB7XG5cdFx0bm90aWNlLm5vdGljZUVsLnJlbW92ZUNsYXNzKFwibG9hZGluZ1wiKVxuXHRcdGlmIChmaW5hbENsYXNzKSB7XG5cdFx0XHRub3RpY2Uubm90aWNlRWwuYWRkQ2xhc3MoZmluYWxDbGFzcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm90aWNlLm5vdGljZUVsLmFkZENsYXNzKFwiZG9uZVwiKVxuXHRcdH1cblx0XHRzZXRUaW1lb3V0KCgpID0+IG5vdGljZS5oaWRlKCksIDQwMDApXG5cdH1cblxuXHR1cGRhdGVSaWJib25JY29ucygpIHtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5zaW5nbGVCdXR0b25Nb2RlKSB7XG5cdFx0XHR0aGlzLmZpdFN5bmNSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoXCJoaWRlXCIpO1xuXHRcdFx0dGhpcy5maXRQdWxsUmliYm9uSWNvbkVsLmFkZENsYXNzKFwiaGlkZVwiKTtcblx0XHRcdHRoaXMuZml0UHVzaFJpYmJvbkljb25FbC5hZGRDbGFzcyhcImhpZGVcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcyhcImhpZGVcIik7XG5cdFx0XHR0aGlzLmZpdFB1bGxSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoXCJoaWRlXCIpO1xuXHRcdFx0dGhpcy5maXRQdXNoUmliYm9uSWNvbkVsLnJlbW92ZUNsYXNzKFwiaGlkZVwiKTtcblx0XHR9XG5cdH1cblx0XG5cblx0bG9hZFJpYmJvbkljb25zKCkge1xuXHRcdC8vIFB1bGwgZnJvbSByZW1vdGUgdGhlbiBQdXNoIHRvIHJlbW90ZSBpZiBubyBjbGFzaGluZyBjaGFuZ2VzIGRldGVjdGVkIGR1cmluZyBwdWxsXG5cdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsID0gdGhpcy5hZGRSaWJib25JY29uKCdnaXRodWInLCAnRml0IFN5bmMnLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHRpZiAodGhpcy5zeW5jaW5nIHx8IHRoaXMucHVsbGluZyB8fCB0aGlzLnB1c2hpbmcpIHsgcmV0dXJuIH1cblx0XHRcdHRoaXMuc3luY2luZyA9IHRydWVcblx0XHRcdHRoaXMuZml0U3luY1JpYmJvbkljb25FbC5hZGRDbGFzcygnYW5pbWF0ZS1pY29uJyk7XG5cdFx0XHRjb25zdCBzeW5jTm90aWNlID0gdGhpcy5pbml0aWFsaXplRml0Tm90aWNlKCk7XG5cdFx0XHRjb25zdCBlcnJvckNhdWdodCA9IGF3YWl0IHRoaXMuY2F0Y2hFcnJvckFuZE5vdGlmeSh0aGlzLnN5bmMsIHN5bmNOb3RpY2UpO1xuXHRcdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsLnJlbW92ZUNsYXNzKCdhbmltYXRlLWljb24nKTtcblx0XHRcdGlmIChlcnJvckNhdWdodCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZUZpdE5vdGljZShzeW5jTm90aWNlLCBcImVycm9yXCIpXG5cdFx0XHRcdHRoaXMuc3luY2luZyA9IGZhbHNlXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW1vdmVGaXROb3RpY2Uoc3luY05vdGljZSlcblx0XHRcdHRoaXMuc3luY2luZyA9IGZhbHNlXG5cdFx0fSk7XG5cdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsLmFkZENsYXNzKCdmaXQtc3luYy1yaWJib24tZWwnKTtcblx0XHRcblx0XHQvLyBQdWxsIHJlbW90ZSB0byBsb2NhbFxuXHRcdHRoaXMuZml0UHVsbFJpYmJvbkljb25FbCA9IHRoaXMuYWRkUmliYm9uSWNvbihcImdpdGh1YlwiLCAnRml0IHB1bGwnLCBhc3luYyAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHRpZiAodGhpcy5zeW5jaW5nIHx8IHRoaXMucHVsbGluZyB8fCB0aGlzLnB1c2hpbmcpIHsgcmV0dXJuIH1cblx0XHRcdHRoaXMucHVsbGluZyA9IHRydWVcblx0XHRcdHRoaXMuZml0UHVsbFJpYmJvbkljb25FbC5hZGRDbGFzcygnYW5pbWF0ZS1pY29uJylcblx0XHRcdGNvbnN0IHB1bGxOb3RpY2UgPSB0aGlzLmluaXRpYWxpemVGaXROb3RpY2UoKTtcblx0XHRcdGNvbnN0IGVycm9yQ2F1Z2h0ID0gYXdhaXQgdGhpcy5jYXRjaEVycm9yQW5kTm90aWZ5KHRoaXMucHVsbCwgcHVsbE5vdGljZSk7XG5cdFx0XHR0aGlzLmZpdFN5bmNSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoJ2FuaW1hdGUtaWNvbicpO1xuXHRcdFx0aWYgKGVycm9yQ2F1Z2h0ID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlRml0Tm90aWNlKHB1bGxOb3RpY2UsIFwiZXJyb3JcIilcblx0XHRcdFx0dGhpcy5wdWxsaW5nID0gZmFsc2Vcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlbW92ZUZpdE5vdGljZShwdWxsTm90aWNlKVxuXHRcdFx0dGhpcy5wdWxsaW5nID0gZmFsc2Vcblx0XHRcdHRoaXMuZml0UHVsbFJpYmJvbkljb25FbC5yZW1vdmVDbGFzcygnYW5pbWF0ZS1pY29uJylcblx0XHR9KTtcblx0XHR0aGlzLmZpdFB1bGxSaWJib25JY29uRWwuYWRkQ2xhc3MoXCJmaXQtcHVsbC1yaWJib24tZWxcIilcblx0XHRcblx0XHQvLyBQdXNoIGxvY2FsIHRvIHJlbW90ZVxuXHRcdHRoaXMuZml0UHVzaFJpYmJvbkljb25FbCA9IHRoaXMuYWRkUmliYm9uSWNvbignZ2l0aHViJywgJ0ZpdCBwdXNoJywgYXN5bmMgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuc3luY2luZyB8fCB0aGlzLnB1bGxpbmcgfHwgdGhpcy5wdXNoaW5nKSB7IHJldHVybiB9XG5cdFx0XHR0aGlzLmZpdFB1c2hSaWJib25JY29uRWwuYWRkQ2xhc3MoJ2FuaW1hdGUtaWNvbicpXG5cdFx0XHR0aGlzLnB1c2hpbmcgPSB0cnVlXG5cdFx0XHRjb25zdCBwdXNoTm90aWNlID0gdGhpcy5pbml0aWFsaXplRml0Tm90aWNlKCk7XG5cdFx0XHRjb25zdCBlcnJvckNhdWdodCA9IGF3YWl0IHRoaXMuY2F0Y2hFcnJvckFuZE5vdGlmeSh0aGlzLnB1c2gsIHB1c2hOb3RpY2UpO1xuXHRcdFx0dGhpcy5maXRTeW5jUmliYm9uSWNvbkVsLnJlbW92ZUNsYXNzKCdhbmltYXRlLWljb24nKTtcblx0XHRcdGlmIChlcnJvckNhdWdodCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZUZpdE5vdGljZShwdXNoTm90aWNlLCBcImVycm9yXCIpXG5cdFx0XHRcdHRoaXMucHVzaGluZyA9IGZhbHNlXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW1vdmVGaXROb3RpY2UocHVzaE5vdGljZSlcblx0XHRcdHRoaXMucHVzaGluZyA9IGZhbHNlXG5cdFx0XHR0aGlzLmZpdFB1c2hSaWJib25JY29uRWwucmVtb3ZlQ2xhc3MoJ2FuaW1hdGUtaWNvbicpXG5cdFx0fSk7XG5cdFx0dGhpcy5maXRQdXNoUmliYm9uSWNvbkVsLmFkZENsYXNzKCdmaXQtcHVzaC1yaWJib24tZWwnKTtcblx0XHR0aGlzLnVwZGF0ZVJpYmJvbkljb25zKCk7XG5cdH1cblxuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXHRcdGF3YWl0IHRoaXMubG9hZExvY2FsU3RvcmUoKTtcblx0XHR0aGlzLmZpdCA9IG5ldyBGaXQodGhpcy5zZXR0aW5ncywgdGhpcy5sb2NhbFN0b3JlLCB0aGlzLmFwcC52YXVsdClcblx0XHR0aGlzLnZhdWx0T3BzID0gbmV3IFZhdWx0T3BlcmF0aW9ucyh0aGlzLmFwcC52YXVsdClcblx0XHR0aGlzLmZpdFB1bGwgPSBuZXcgRml0UHVsbCh0aGlzLmZpdCwgdGhpcy52YXVsdE9wcylcblx0XHR0aGlzLmZpdFB1c2ggPSBuZXcgRml0UHVzaCh0aGlzLmZpdCwgdGhpcy52YXVsdE9wcylcblx0XHR0aGlzLnB1bGxpbmcgPSBmYWxzZVxuXHRcdHRoaXMucHVzaGluZyA9IGZhbHNlXG5cdFx0dGhpcy5zeW5jaW5nID0gZmFsc2Vcblx0XHR0aGlzLnNldHRpbmdUYWIgPSBuZXcgRml0U2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcylcblx0XHR0aGlzLmxvYWRSaWJib25JY29ucygpO1xuXG5cblx0XHQvLyByZWNvbXB1dGUgbG9jYWwgc2hhIHRvIHVuYmxvY2sgcHVsbGluZ1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3JlY29tcHV0ZS1sb2NhbC1zaGEnLFxuXHRcdFx0bmFtZTogYFVwZGF0ZSBsb2NhbCBzdG9yZSB3aXRoIG5ldyBsb2NhbCBzaGEsIHRvIHVuYmxvY2sgcHVsbGluZyB3aGVuIGxvY2FsIGNsYXNoZXMgYXJlIGRldGVjdGVkIChEYW5nZXJvdXMhXG5cdFx0XHRcdFJ1bm5pbmcgcHVsbCBhZnRlciB0aGlzIGNvbW1hbmQgd2lsbCBkaXNjYXJkIGxvY2FsIGNoYW5nZXMsIHBsZWFzZSBiYWNrdXAgdmF1bHQgYmVmb3JlIHJ1bm5pbmcgdGhpcy4pYCxcblx0XHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmxvY2FsU3RvcmUubG9jYWxTaGEgPSBhd2FpdCB0aGlzLmZpdC5jb21wdXRlTG9jYWxTaGEoKVxuXHRcdFx0XHRcdHRoaXMuc2F2ZUxvY2FsU3RvcmUoKVxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFN0b3JlZCBsb2NhbCBzaGEgcmVjb21wdXRhdGlvbiwgcmVjZW50IGxvY2FsIGNoYW5nZXMgd2lsbCBub3QgYmUgY29uc2lkZXJlZCBpbiBmdXR1cmUgcHVzaC9wdWxsLmApXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IEZpdFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuXHRcdC8vIENoZWNrIHJlbW90ZSBldmVyeSA1IG1pbnV0ZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBuZXcgY29tbWl0c1xuXHRcdHRoaXMucmVnaXN0ZXJJbnRlcnZhbCh3aW5kb3cuc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuY2hlY2tTZXR0aW5nc0NvbmZpZ3VyZWQoKSkge1xuXHRcdFx0XHRjb25zdCB1cGRhdGVkUmVtb3RlQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5maXRQdWxsLnJlbW90ZUhhc1VwZGF0ZXMoKVxuXHRcdFx0XHRpZiAodXBkYXRlZFJlbW90ZUNvbW1pdFNoYSkge1xuXHRcdFx0XHRcdGNvbnN0IGludGVydmFsTm90aWNlID0gdGhpcy5pbml0aWFsaXplRml0Tm90aWNlKFtcInN0YXRpY1wiXSk7XG5cdFx0XHRcdFx0aW50ZXJ2YWxOb3RpY2Uuc2V0TWVzc2FnZShcIlJlbW90ZSB1cGRhdGUgZGV0ZWN0ZWQsIHBsZWFzZSBwdWxsIHRoZSBsYXRlc3QgY2hhbmdlcy5cIilcblx0XHRcdFx0fSBcblx0XHRcdH1cblx0XHR9LCB0aGlzLnNldHRpbmdzLmNoZWNrRXZlcnlYTWludXRlcyAqIDYwICogMTAwMCkpO1xuXHR9XG5cblx0b251bmxvYWQoKSB7fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHRjb25zdCB1c2VyU2V0dGluZyA9IGF3YWl0IHRoaXMubG9hZERhdGEoKVxuXHRcdGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgdXNlclNldHRpbmcpO1xuXHRcdGNvbnN0IHNldHRpbmdzT2JqOiBGaXRTZXR0aW5ncyA9IE9iamVjdC5rZXlzKERFRkFVTFRfU0VUVElOR1MpLnJlZHVjZShcblx0XHRcdChvYmosIGtleToga2V5b2YgRml0U2V0dGluZ3MpID0+IHtcblx0XHRcdFx0aWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRpZiAoa2V5ID09IFwic2luZ2xlQnV0dG9uTW9kZVwiKSB7XG5cdFx0XHRcdFx0XHRvYmpba2V5XSA9IEJvb2xlYW4oc2V0dGluZ3Nba2V5XSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChrZXkgPT0gXCJjaGVja0V2ZXJ5WE1pbnV0ZXNcIikge1xuXHRcdFx0XHRcdFx0b2JqW2tleV0gPSBOdW1iZXIoc2V0dGluZ3Nba2V5XSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG9ialtrZXldID0gc2V0dGluZ3Nba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sIHt9IGFzIEZpdFNldHRpbmdzKTtcblx0XHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3NPYmpcblx0fVxuXG5cdGFzeW5jIGxvYWRMb2NhbFN0b3JlKCkge1xuXHRcdGNvbnN0IGxvY2FsU3RvcmUgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0xPQ0FMX1NUT1JFLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHRcdGNvbnN0IGxvY2FsU3RvcmVPYmo6IExvY2FsU3RvcmVzID0gT2JqZWN0LmtleXMoREVGQVVMVF9MT0NBTF9TVE9SRSkucmVkdWNlKFxuXHRcdFx0KG9iaiwga2V5OiBrZXlvZiBMb2NhbFN0b3JlcykgPT4ge1xuXHRcdFx0XHRpZiAobG9jYWxTdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0b2JqW2tleV0gPSBsb2NhbFN0b3JlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sIHt9IGFzIExvY2FsU3RvcmVzKTtcblx0XHR0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlT2JqXG5cdH1cblxuXHQvLyBhbGxvdyBzYXZpbmcgb2YgbG9jYWwgc3RvcmVzIHByb3BlcnR5LCBwYXNzZWQgaW4gcHJvcGVydGllcyB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHN0b3JlZCB2YWx1ZVxuXHRhc3luYyBzYXZlTG9jYWxTdG9yZSgpIHtcblx0XHRjb25zdCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MT0NBTF9TVE9SRSwgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHsuLi5kYXRhLCAuLi50aGlzLmxvY2FsU3RvcmV9KVxuXHRcdC8vIHN5bmMgbG9jYWwgc3RvcmUgdG8gRml0IGNsYXNzIGFzIHdlbGwgdXBvbiBzYXZpbmdcblx0XHR0aGlzLmZpdC5sb2FkTG9jYWxTdG9yZSh0aGlzLmxvY2FsU3RvcmUpXG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0Y29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh7Li4uZGF0YSwgLi4udGhpcy5zZXR0aW5nc30pO1xuXHRcdC8vIHN5bmMgc2V0dGluZ3MgdG8gRml0IGNsYXNzIGFzIHdlbGwgdXBvbiBzYXZpbmdcblx0XHR0aGlzLmZpdC5sb2FkU2V0dGluZ3ModGhpcy5zZXR0aW5ncylcblx0XHR0aGlzLnVwZGF0ZVJpYmJvbkljb25zKCk7XG5cdH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIG5hbWUsIG1ldGhvZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGZvciBiZWZvcmUgaG9vayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lLnJldmVyc2UoKS5yZWR1Y2UoKGNhbGxiYWNrLCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXIuYmluZChudWxsLCBzdGF0ZSwgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sIG1ldGhvZCkoKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5yZWR1Y2UoKG1ldGhvZCwgcmVnaXN0ZXJlZCkgPT4ge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQuaG9vay5iaW5kKG51bGwsIG1ldGhvZCwgb3B0aW9ucyk7XG4gICAgfSwgbWV0aG9kKSgpO1xuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhvb2soc3RhdGUsIGtpbmQsIG5hbWUsIGhvb2spIHtcbiAgY29uc3Qgb3JpZyA9IGhvb2s7XG4gIGlmICghc3RhdGUucmVnaXN0cnlbbmFtZV0pIHtcbiAgICBzdGF0ZS5yZWdpc3RyeVtuYW1lXSA9IFtdO1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IFwiYmVmb3JlXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG9yaWcuYmluZChudWxsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gXCJhZnRlclwiKSB7XG4gICAgaG9vayA9IChtZXRob2QsIG9wdGlvbnMpID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgLnRoZW4obWV0aG9kLmJpbmQobnVsbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChyZXN1bHRfKSA9PiB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0XztcbiAgICAgICAgICByZXR1cm4gb3JpZyhyZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChraW5kID09PSBcImVycm9yXCIpIHtcbiAgICBob29rID0gKG1ldGhvZCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKG1ldGhvZC5iaW5kKG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcoZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUucmVnaXN0cnlbbmFtZV0ucHVzaCh7XG4gICAgaG9vazogaG9vayxcbiAgICBvcmlnOiBvcmlnLFxuICB9KTtcbn1cbiIsICIvLyBAdHMtY2hlY2tcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUhvb2soc3RhdGUsIG5hbWUsIG1ldGhvZCkge1xuICBpZiAoIXN0YXRlLnJlZ2lzdHJ5W25hbWVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaW5kZXggPSBzdGF0ZS5yZWdpc3RyeVtuYW1lXVxuICAgIC5tYXAoKHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkLm9yaWc7XG4gICAgfSlcbiAgICAuaW5kZXhPZihtZXRob2QpO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5yZWdpc3RyeVtuYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuIiwgIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gXCIuL2xpYi9yZWdpc3Rlci5qc1wiO1xuaW1wb3J0IHsgYWRkSG9vayB9IGZyb20gXCIuL2xpYi9hZGQuanNcIjtcbmltcG9ydCB7IHJlbW92ZUhvb2sgfSBmcm9tIFwiLi9saWIvcmVtb3ZlLmpzXCI7XG5cbi8vIGJpbmQgd2l0aCBhcnJheSBvZiBhcmd1bWVudHM6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTc5MjkxM1xuY29uc3QgYmluZCA9IEZ1bmN0aW9uLmJpbmQ7XG5jb25zdCBiaW5kYWJsZSA9IGJpbmQuYmluZChiaW5kKTtcblxuZnVuY3Rpb24gYmluZEFwaShob29rLCBzdGF0ZSwgbmFtZSkge1xuICBjb25zdCByZW1vdmVIb29rUmVmID0gYmluZGFibGUocmVtb3ZlSG9vaywgbnVsbCkuYXBwbHkoXG4gICAgbnVsbCxcbiAgICBuYW1lID8gW3N0YXRlLCBuYW1lXSA6IFtzdGF0ZV1cbiAgKTtcbiAgaG9vay5hcGkgPSB7IHJlbW92ZTogcmVtb3ZlSG9va1JlZiB9O1xuICBob29rLnJlbW92ZSA9IHJlbW92ZUhvb2tSZWY7XG4gIFtcImJlZm9yZVwiLCBcImVycm9yXCIsIFwiYWZ0ZXJcIiwgXCJ3cmFwXCJdLmZvckVhY2goKGtpbmQpID0+IHtcbiAgICBjb25zdCBhcmdzID0gbmFtZSA/IFtzdGF0ZSwga2luZCwgbmFtZV0gOiBbc3RhdGUsIGtpbmRdO1xuICAgIGhvb2tba2luZF0gPSBob29rLmFwaVtraW5kXSA9IGJpbmRhYmxlKGFkZEhvb2ssIG51bGwpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gU2luZ3VsYXIoKSB7XG4gIGNvbnN0IHNpbmd1bGFySG9va05hbWUgPSBTeW1ib2woXCJTaW5ndWxhclwiKTtcbiAgY29uc3Qgc2luZ3VsYXJIb29rU3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuICBjb25zdCBzaW5ndWxhckhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgYmluZEFwaShzaW5ndWxhckhvb2ssIHNpbmd1bGFySG9va1N0YXRlLCBzaW5ndWxhckhvb2tOYW1lKTtcbiAgcmV0dXJuIHNpbmd1bGFySG9vaztcbn1cblxuZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgcmVnaXN0cnk6IHt9LFxuICB9O1xuXG4gIGNvbnN0IGhvb2sgPSByZWdpc3Rlci5iaW5kKG51bGwsIHN0YXRlKTtcbiAgYmluZEFwaShob29rLCBzdGF0ZSk7XG5cbiAgcmV0dXJuIGhvb2s7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgU2luZ3VsYXIsIENvbGxlY3Rpb24gfTtcbiIsICJleHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJvYmplY3RcIiAmJiBcInVzZXJBZ2VudFwiIGluIG5hdmlnYXRvcikge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGBOb2RlLmpzLyR7cHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigxKX0gKCR7cHJvY2Vzcy5wbGF0Zm9ybX07ICR7XG4gICAgICBwcm9jZXNzLmFyY2hcbiAgICB9KWA7XG4gIH1cblxuICByZXR1cm4gXCI8ZW52aXJvbm1lbnQgdW5kZXRlY3RhYmxlPlwiO1xufVxuIiwgIi8vIHBrZy9kaXN0LXNyYy9kZWZhdWx0cy5qc1xuaW1wb3J0IHsgZ2V0VXNlckFnZW50IH0gZnJvbSBcInVuaXZlcnNhbC11c2VyLWFnZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy92ZXJzaW9uLmpzXG52YXIgVkVSU0lPTiA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2RlZmF1bHRzLmpzXG52YXIgdXNlckFnZW50ID0gYG9jdG9raXQtZW5kcG9pbnQuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWA7XG52YXIgREVGQVVMVFMgPSB7XG4gIG1ldGhvZDogXCJHRVRcIixcbiAgYmFzZVVybDogXCJodHRwczovL2FwaS5naXRodWIuY29tXCIsXG4gIGhlYWRlcnM6IHtcbiAgICBhY2NlcHQ6IFwiYXBwbGljYXRpb24vdm5kLmdpdGh1Yi52Mytqc29uXCIsXG4gICAgXCJ1c2VyLWFnZW50XCI6IHVzZXJBZ2VudFxuICB9LFxuICBtZWRpYVR5cGU6IHtcbiAgICBmb3JtYXQ6IFwiXCJcbiAgfVxufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvbG93ZXJjYXNlLWtleXMuanNcbmZ1bmN0aW9uIGxvd2VyY2FzZUtleXMob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICBuZXdPYmpba2V5LnRvTG93ZXJDYXNlKCldID0gb2JqZWN0W2tleV07XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfSwge30pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy91dGlsL21lcmdlLWRlZXAuanNcbmZ1bmN0aW9uIG1lcmdlRGVlcChkZWZhdWx0cywgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnNba2V5XSkpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZWZhdWx0cykpXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VEZWVwKGRlZmF1bHRzW2tleV0sIG9wdGlvbnNba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvcHRpb25zW2tleV0gfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvcmVtb3ZlLXVuZGVmaW5lZC1wcm9wZXJ0aWVzLmpzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRQcm9wZXJ0aWVzKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvbWVyZ2UuanNcbmZ1bmN0aW9uIG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHJvdXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgbGV0IFttZXRob2QsIHVybF0gPSByb3V0ZS5zcGxpdChcIiBcIik7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odXJsID8geyBtZXRob2QsIHVybCB9IDogeyB1cmw6IG1ldGhvZCB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGUpO1xuICB9XG4gIG9wdGlvbnMuaGVhZGVycyA9IGxvd2VyY2FzZUtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zKTtcbiAgcmVtb3ZlVW5kZWZpbmVkUHJvcGVydGllcyhvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gbWVyZ2VEZWVwKGRlZmF1bHRzIHx8IHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMudXJsID09PSBcIi9ncmFwaHFsXCIpIHtcbiAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzPy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZE9wdGlvbnMubWVkaWFUeXBlLnByZXZpZXdzID0gZGVmYXVsdHMubWVkaWFUeXBlLnByZXZpZXdzLmZpbHRlcihcbiAgICAgICAgKHByZXZpZXcpID0+ICFtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cy5pbmNsdWRlcyhwcmV2aWV3KVxuICAgICAgKS5jb25jYXQobWVyZ2VkT3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpO1xuICAgIH1cbiAgICBtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyA9IChtZXJnZWRPcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cyB8fCBbXSkubWFwKChwcmV2aWV3KSA9PiBwcmV2aWV3LnJlcGxhY2UoLy1wcmV2aWV3LywgXCJcIikpO1xuICB9XG4gIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9hZGQtcXVlcnktcGFyYW1ldGVycy5qc1xuZnVuY3Rpb24gYWRkUXVlcnlQYXJhbWV0ZXJzKHVybCwgcGFyYW1ldGVycykge1xuICBjb25zdCBzZXBhcmF0b3IgPSAvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiO1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICByZXR1cm4gdXJsICsgc2VwYXJhdG9yICsgbmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgaWYgKG5hbWUgPT09IFwicVwiKSB7XG4gICAgICByZXR1cm4gXCJxPVwiICsgcGFyYW1ldGVycy5xLnNwbGl0KFwiK1wiKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiK1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25hbWV9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtZXRlcnNbbmFtZV0pfWA7XG4gIH0pLmpvaW4oXCImXCIpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9leHRyYWN0LXVybC12YXJpYWJsZS1uYW1lcy5qc1xudmFyIHVybFZhcmlhYmxlUmVnZXggPSAvXFx7W159XStcXH0vZztcbmZ1bmN0aW9uIHJlbW92ZU5vbkNoYXJzKHZhcmlhYmxlTmFtZSkge1xuICByZXR1cm4gdmFyaWFibGVOYW1lLnJlcGxhY2UoL15cXFcrfFxcVyskL2csIFwiXCIpLnNwbGl0KC8sLyk7XG59XG5mdW5jdGlvbiBleHRyYWN0VXJsVmFyaWFibGVOYW1lcyh1cmwpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaCh1cmxWYXJpYWJsZVJlZ2V4KTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLm1hcChyZW1vdmVOb25DaGFycykucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvdXRpbC9vbWl0LmpzXG5mdW5jdGlvbiBvbWl0KG9iamVjdCwga2V5c1RvT21pdCkge1xuICBjb25zdCByZXN1bHQgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgaWYgKGtleXNUb09taXQuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL3V0aWwvdXJsLXRlbXBsYXRlLmpzXG5mdW5jdGlvbiBlbmNvZGVSZXNlcnZlZChzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvKCVbMC05QS1GYS1mXXsyfSkvZykubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBpZiAoIS8lWzAtOUEtRmEtZl0vLnRlc3QocGFydCkpIHtcbiAgICAgIHBhcnQgPSBlbmNvZGVVUkkocGFydCkucmVwbGFjZSgvJTVCL2csIFwiW1wiKS5yZXBsYWNlKC8lNUQvZywgXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydDtcbiAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlLCBrZXkpIHtcbiAgdmFsdWUgPSBvcGVyYXRvciA9PT0gXCIrXCIgfHwgb3BlcmF0b3IgPT09IFwiI1wiID8gZW5jb2RlUmVzZXJ2ZWQodmFsdWUpIDogZW5jb2RlVW5yZXNlcnZlZCh2YWx1ZSk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIgKyB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSBcIjtcIiB8fCBvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbnRleHQsIG9wZXJhdG9yLCBrZXksIG1vZGlmaWVyKSB7XG4gIHZhciB2YWx1ZSA9IGNvbnRleHRba2V5XSwgcmVzdWx0ID0gW107XG4gIGlmIChpc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSBcIlwiKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgaWYgKG1vZGlmaWVyICYmIG1vZGlmaWVyICE9PSBcIipcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBwYXJzZUludChtb2RpZmllciwgMTApKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUsIGlzS2V5T3BlcmF0b3Iob3BlcmF0b3IpID8ga2V5IDogXCJcIilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtb2RpZmllciA9PT0gXCIqXCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBlbmNvZGVWYWx1ZShvcGVyYXRvciwgdmFsdWUyLCBpc0tleU9wZXJhdG9yKG9wZXJhdG9yKSA/IGtleSA6IFwiXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodmFsdWVba10pKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZVtrXSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0bXAgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUuZmlsdGVyKGlzRGVmaW5lZCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZTIpIHtcbiAgICAgICAgICAgIHRtcC5wdXNoKGVuY29kZVZhbHVlKG9wZXJhdG9yLCB2YWx1ZTIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlW2tdKSkge1xuICAgICAgICAgICAgICB0bXAucHVzaChlbmNvZGVVbnJlc2VydmVkKGspKTtcbiAgICAgICAgICAgICAgdG1wLnB1c2goZW5jb2RlVmFsdWUob3BlcmF0b3IsIHZhbHVlW2tdLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNLZXlPcGVyYXRvcihvcGVyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGVVbnJlc2VydmVkKGtleSkgKyBcIj1cIiArIHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wZXJhdG9yID09PSBcIjtcIikge1xuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIlwiICYmIChvcGVyYXRvciA9PT0gXCImXCIgfHwgb3BlcmF0b3IgPT09IFwiP1wiKSkge1xuICAgICAgcmVzdWx0LnB1c2goZW5jb2RlVW5yZXNlcnZlZChrZXkpICsgXCI9XCIpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFwiXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmwodGVtcGxhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBhbmQ6IGV4cGFuZC5iaW5kKG51bGwsIHRlbXBsYXRlKVxuICB9O1xufVxuZnVuY3Rpb24gZXhwYW5kKHRlbXBsYXRlLCBjb250ZXh0KSB7XG4gIHZhciBvcGVyYXRvcnMgPSBbXCIrXCIsIFwiI1wiLCBcIi5cIiwgXCIvXCIsIFwiO1wiLCBcIj9cIiwgXCImXCJdO1xuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoXG4gICAgL1xceyhbXlxce1xcfV0rKVxcfXwoW15cXHtcXH1dKykvZyxcbiAgICBmdW5jdGlvbihfLCBleHByZXNzaW9uLCBsaXRlcmFsKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICBsZXQgb3BlcmF0b3IgPSBcIlwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wZXJhdG9ycy5pbmRleE9mKGV4cHJlc3Npb24uY2hhckF0KDApKSAhPT0gLTEpIHtcbiAgICAgICAgICBvcGVyYXRvciA9IGV4cHJlc3Npb24uY2hhckF0KDApO1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBleHByZXNzaW9uLnNwbGl0KC8sL2cpLmZvckVhY2goZnVuY3Rpb24odmFyaWFibGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gLyhbXjpcXCpdKikoPzo6KFxcZCspfChcXCopKT8vLmV4ZWModmFyaWFibGUpO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGdldFZhbHVlcyhjb250ZXh0LCBvcGVyYXRvciwgdG1wWzFdLCB0bXBbMl0gfHwgdG1wWzNdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3BlcmF0b3IgJiYgb3BlcmF0b3IgIT09IFwiK1wiKSB7XG4gICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwiLFwiO1xuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiJlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09IFwiI1wiKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICh2YWx1ZXMubGVuZ3RoICE9PSAwID8gb3BlcmF0b3IgOiBcIlwiKSArIHZhbHVlcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVJlc2VydmVkKGxpdGVyYWwpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKHRlbXBsYXRlID09PSBcIi9cIikge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9wYXJzZS5qc1xuZnVuY3Rpb24gcGFyc2Uob3B0aW9ucykge1xuICBsZXQgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgbGV0IHVybCA9IChvcHRpb25zLnVybCB8fCBcIi9cIikucmVwbGFjZSgvOihbYS16XVxcdyspL2csIFwieyQxfVwiKTtcbiAgbGV0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBsZXQgYm9keTtcbiAgbGV0IHBhcmFtZXRlcnMgPSBvbWl0KG9wdGlvbnMsIFtcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwiYmFzZVVybFwiLFxuICAgIFwidXJsXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJyZXF1ZXN0XCIsXG4gICAgXCJtZWRpYVR5cGVcIlxuICBdKTtcbiAgY29uc3QgdXJsVmFyaWFibGVOYW1lcyA9IGV4dHJhY3RVcmxWYXJpYWJsZU5hbWVzKHVybCk7XG4gIHVybCA9IHBhcnNlVXJsKHVybCkuZXhwYW5kKHBhcmFtZXRlcnMpO1xuICBpZiAoIS9eaHR0cC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gb3B0aW9ucy5iYXNlVXJsICsgdXJsO1xuICB9XG4gIGNvbnN0IG9taXR0ZWRQYXJhbWV0ZXJzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChvcHRpb24pID0+IHVybFZhcmlhYmxlTmFtZXMuaW5jbHVkZXMob3B0aW9uKSkuY29uY2F0KFwiYmFzZVVybFwiKTtcbiAgY29uc3QgcmVtYWluaW5nUGFyYW1ldGVycyA9IG9taXQocGFyYW1ldGVycywgb21pdHRlZFBhcmFtZXRlcnMpO1xuICBjb25zdCBpc0JpbmFyeVJlcXVlc3QgPSAvYXBwbGljYXRpb25cXC9vY3RldC1zdHJlYW0vaS50ZXN0KGhlYWRlcnMuYWNjZXB0KTtcbiAgaWYgKCFpc0JpbmFyeVJlcXVlc3QpIHtcbiAgICBpZiAob3B0aW9ucy5tZWRpYVR5cGUuZm9ybWF0KSB7XG4gICAgICBoZWFkZXJzLmFjY2VwdCA9IGhlYWRlcnMuYWNjZXB0LnNwbGl0KC8sLykubWFwKFxuICAgICAgICAoZm9ybWF0KSA9PiBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAvYXBwbGljYXRpb25cXC92bmQoXFwuXFx3KykoXFwudjMpPyhcXC5cXHcrKT8oXFwranNvbik/JC8sXG4gICAgICAgICAgYGFwcGxpY2F0aW9uL3ZuZCQxJDIuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YFxuICAgICAgICApXG4gICAgICApLmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICBpZiAodXJsLmVuZHNXaXRoKFwiL2dyYXBocWxcIikpIHtcbiAgICAgIGlmIChvcHRpb25zLm1lZGlhVHlwZS5wcmV2aWV3cz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlciA9IGhlYWRlcnMuYWNjZXB0Lm1hdGNoKC9bXFx3LV0rKD89LXByZXZpZXcpL2cpIHx8IFtdO1xuICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IHByZXZpZXdzRnJvbUFjY2VwdEhlYWRlci5jb25jYXQob3B0aW9ucy5tZWRpYVR5cGUucHJldmlld3MpLm1hcCgocHJldmlldykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMubWVkaWFUeXBlLmZvcm1hdCA/IGAuJHtvcHRpb25zLm1lZGlhVHlwZS5mb3JtYXR9YCA6IFwiK2pzb25cIjtcbiAgICAgICAgICByZXR1cm4gYGFwcGxpY2F0aW9uL3ZuZC5naXRodWIuJHtwcmV2aWV3fS1wcmV2aWV3JHtmb3JtYXR9YDtcbiAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChbXCJHRVRcIiwgXCJIRUFEXCJdLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICB1cmwgPSBhZGRRdWVyeVBhcmFtZXRlcnModXJsLCByZW1haW5pbmdQYXJhbWV0ZXJzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoXCJkYXRhXCIgaW4gcmVtYWluaW5nUGFyYW1ldGVycykge1xuICAgICAgYm9keSA9IHJlbWFpbmluZ1BhcmFtZXRlcnMuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHJlbWFpbmluZ1BhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgICAgICBib2R5ID0gcmVtYWluaW5nUGFyYW1ldGVycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFoZWFkZXJzW1wiY29udGVudC10eXBlXCJdICYmIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiO1xuICB9XG4gIGlmIChbXCJQQVRDSFwiLCBcIlBVVFwiXS5pbmNsdWRlcyhtZXRob2QpICYmIHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgYm9keSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgeyBtZXRob2QsIHVybCwgaGVhZGVycyB9LFxuICAgIHR5cGVvZiBib2R5ICE9PSBcInVuZGVmaW5lZFwiID8geyBib2R5IH0gOiBudWxsLFxuICAgIG9wdGlvbnMucmVxdWVzdCA/IHsgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0IH0gOiBudWxsXG4gICk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9lbmRwb2ludC13aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiBlbmRwb2ludFdpdGhEZWZhdWx0cyhkZWZhdWx0cywgcm91dGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhcnNlKG1lcmdlKGRlZmF1bHRzLCByb3V0ZSwgb3B0aW9ucykpO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZERlZmF1bHRzLCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBERUZBVUxUUzIgPSBtZXJnZShvbGREZWZhdWx0cywgbmV3RGVmYXVsdHMpO1xuICBjb25zdCBlbmRwb2ludDIgPSBlbmRwb2ludFdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGVuZHBvaW50Miwge1xuICAgIERFRkFVTFRTOiBERUZBVUxUUzIsXG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIERFRkFVTFRTMiksXG4gICAgbWVyZ2U6IG1lcmdlLmJpbmQobnVsbCwgREVGQVVMVFMyKSxcbiAgICBwYXJzZVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgZW5kcG9pbnQgPSB3aXRoRGVmYXVsdHMobnVsbCwgREVGQVVMVFMpO1xuZXhwb3J0IHtcbiAgZW5kcG9pbnRcbn07XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIgJiYgXCJ1c2VyQWdlbnRcIiBpbiBuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgTm9kZS5qcy8ke3Byb2Nlc3MudmVyc2lvbi5zdWJzdHIoMSl9ICgke3Byb2Nlc3MucGxhdGZvcm19OyAke1xuICAgICAgcHJvY2Vzcy5hcmNoXG4gICAgfSlgO1xuICB9XG5cbiAgcmV0dXJuIFwiPGVudmlyb25tZW50IHVuZGV0ZWN0YWJsZT5cIjtcbn1cbiIsICJjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWU7XG4gIC8qKlxuICAgKiBodHRwIHN0YXR1cyBjb2RlXG4gICAqL1xuICBzdGF0dXM7XG4gIC8qKlxuICAgKiBSZXF1ZXN0IG9wdGlvbnMgdGhhdCBsZWFkIHRvIHRoZSBlcnJvci5cbiAgICovXG4gIHJlcXVlc3Q7XG4gIC8qKlxuICAgKiBSZXNwb25zZSBvYmplY3QgaWYgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWRcbiAgICovXG4gIHJlc3BvbnNlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gXCJIdHRwRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgaWYgKFwicmVzcG9uc2VcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3QpO1xuICAgIGlmIChvcHRpb25zLnJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uKSB7XG4gICAgICByZXF1ZXN0Q29weS5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMsIHtcbiAgICAgICAgYXV0aG9yaXphdGlvbjogb3B0aW9ucy5yZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbi5yZXBsYWNlKFxuICAgICAgICAgIC8gLiokLyxcbiAgICAgICAgICBcIiBbUkVEQUNURURdXCJcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RDb3B5LnVybCA9IHJlcXVlc3RDb3B5LnVybC5yZXBsYWNlKC9cXGJjbGllbnRfc2VjcmV0PVxcdysvZywgXCJjbGllbnRfc2VjcmV0PVtSRURBQ1RFRF1cIikucmVwbGFjZSgvXFxiYWNjZXNzX3Rva2VuPVxcdysvZywgXCJhY2Nlc3NfdG9rZW49W1JFREFDVEVEXVwiKTtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0Q29weTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUmVxdWVzdEVycm9yXG59O1xuIiwgIi8vIHBrZy9kaXN0LXNyYy9pbmRleC5qc1xuaW1wb3J0IHsgZW5kcG9pbnQgfSBmcm9tIFwiQG9jdG9raXQvZW5kcG9pbnRcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9pcy1wbGFpbi1vYmplY3QuanNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKEN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5pbXBvcnQgeyBSZXF1ZXN0RXJyb3IgfSBmcm9tIFwiQG9jdG9raXQvcmVxdWVzdC1lcnJvclwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvZ2V0LWJ1ZmZlci1yZXNwb25zZS5qc1xuZnVuY3Rpb24gZ2V0QnVmZmVyUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9mZXRjaC13cmFwcGVyLmpzXG5mdW5jdGlvbiBmZXRjaFdyYXBwZXIocmVxdWVzdE9wdGlvbnMpIHtcbiAgY29uc3QgbG9nID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdCAmJiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmxvZyA/IHJlcXVlc3RPcHRpb25zLnJlcXVlc3QubG9nIDogY29uc29sZTtcbiAgY29uc3QgcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID0gcmVxdWVzdE9wdGlvbnMucmVxdWVzdD8ucGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ICE9PSBmYWxzZTtcbiAgaWYgKGlzUGxhaW5PYmplY3QocmVxdWVzdE9wdGlvbnMuYm9keSkgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0T3B0aW9ucy5ib2R5KSkge1xuICAgIHJlcXVlc3RPcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0T3B0aW9ucy5ib2R5KTtcbiAgfVxuICBsZXQgaGVhZGVycyA9IHt9O1xuICBsZXQgc3RhdHVzO1xuICBsZXQgdXJsO1xuICBsZXQgeyBmZXRjaCB9ID0gZ2xvYmFsVGhpcztcbiAgaWYgKHJlcXVlc3RPcHRpb25zLnJlcXVlc3Q/LmZldGNoKSB7XG4gICAgZmV0Y2ggPSByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0LmZldGNoO1xuICB9XG4gIGlmICghZmV0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImZldGNoIGlzIG5vdCBzZXQuIFBsZWFzZSBwYXNzIGEgZmV0Y2ggaW1wbGVtZW50YXRpb24gYXMgbmV3IE9jdG9raXQoeyByZXF1ZXN0OiB7IGZldGNoIH19KS4gTGVhcm4gbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9vY3Rva2l0LmpzLyNmZXRjaC1taXNzaW5nXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBmZXRjaChyZXF1ZXN0T3B0aW9ucy51cmwsIHtcbiAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0T3B0aW9ucy5ib2R5LFxuICAgIC8vIEhlYWRlciB2YWx1ZXMgbXVzdCBiZSBgc3RyaW5nYFxuICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW1xuICAgICAgICBuYW1lLFxuICAgICAgICBTdHJpbmcodmFsdWUpXG4gICAgICBdKVxuICAgICksXG4gICAgc2lnbmFsOiByZXF1ZXN0T3B0aW9ucy5yZXF1ZXN0Py5zaWduYWwsXG4gICAgLy8gZHVwbGV4IG11c3QgYmUgc2V0IGlmIHJlcXVlc3QuYm9keSBpcyBSZWFkYWJsZVN0cmVhbSBvciBBc3luYyBJdGVyYWJsZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdGluaXQtZHVwbGV4LlxuICAgIC4uLnJlcXVlc3RPcHRpb25zLmJvZHkgJiYgeyBkdXBsZXg6IFwiaGFsZlwiIH1cbiAgfSkudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICB1cmwgPSByZXNwb25zZS51cmw7XG4gICAgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGZvciAoY29uc3Qga2V5QW5kVmFsdWUgb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXlBbmRWYWx1ZVswXV0gPSBrZXlBbmRWYWx1ZVsxXTtcbiAgICB9XG4gICAgaWYgKFwiZGVwcmVjYXRpb25cIiBpbiBoZWFkZXJzKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gaGVhZGVycy5saW5rICYmIGhlYWRlcnMubGluay5tYXRjaCgvPChbXj5dKyk+OyByZWw9XCJkZXByZWNhdGlvblwiLyk7XG4gICAgICBjb25zdCBkZXByZWNhdGlvbkxpbmsgPSBtYXRjaGVzICYmIG1hdGNoZXMucG9wKCk7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgYFtAb2N0b2tpdC9yZXF1ZXN0XSBcIiR7cmVxdWVzdE9wdGlvbnMubWV0aG9kfSAke3JlcXVlc3RPcHRpb25zLnVybH1cIiBpcyBkZXByZWNhdGVkLiBJdCBpcyBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBvbiAke2hlYWRlcnMuc3Vuc2V0fSR7ZGVwcmVjYXRpb25MaW5rID8gYC4gU2VlICR7ZGVwcmVjYXRpb25MaW5rfWAgOiBcIlwifWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzdGF0dXMgPT09IDIwNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdE9wdGlvbnMubWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgaWYgKHN0YXR1cyA8IDQwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0RXJyb3IoXCJOb3QgbW9kaWZpZWRcIiwgc3RhdHVzLCB7XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID49IDQwMCkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBSZXF1ZXN0RXJyb3IodG9FcnJvck1lc3NhZ2UoZGF0YSksIHN0YXR1cywge1xuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VTdWNjZXNzUmVzcG9uc2VCb2R5ID8gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKSA6IHJlc3BvbnNlLmJvZHk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IpXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIilcbiAgICAgIHRocm93IGVycm9yO1xuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJiBcImNhdXNlXCIgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5jYXVzZS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IuY2F1c2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmNhdXNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgUmVxdWVzdEVycm9yKG1lc3NhZ2UsIDUwMCwge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdE9wdGlvbnNcbiAgICB9KTtcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgaWYgKC9hcHBsaWNhdGlvblxcL2pzb24vLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiByZXNwb25zZS50ZXh0KCkpLmNhdGNoKCgpID0+IFwiXCIpO1xuICB9XG4gIGlmICghY29udGVudFR5cGUgfHwgL150ZXh0XFwvfGNoYXJzZXQ9dXRmLTgkLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgcmV0dXJuIGdldEJ1ZmZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbn1cbmZ1bmN0aW9uIHRvRXJyb3JNZXNzYWdlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBkYXRhO1xuICBsZXQgc3VmZml4O1xuICBpZiAoXCJkb2N1bWVudGF0aW9uX3VybFwiIGluIGRhdGEpIHtcbiAgICBzdWZmaXggPSBgIC0gJHtkYXRhLmRvY3VtZW50YXRpb25fdXJsfWA7XG4gIH0gZWxzZSB7XG4gICAgc3VmZml4ID0gXCJcIjtcbiAgfVxuICBpZiAoXCJtZXNzYWdlXCIgaW4gZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZXJyb3JzKSkge1xuICAgICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX06ICR7ZGF0YS5lcnJvcnMubWFwKEpTT04uc3RyaW5naWZ5KS5qb2luKFwiLCBcIil9JHtzdWZmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2RhdGEubWVzc2FnZX0ke3N1ZmZpeH1gO1xuICB9XG4gIHJldHVybiBgVW5rbm93biBlcnJvcjogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1kZWZhdWx0cy5qc1xuZnVuY3Rpb24gd2l0aERlZmF1bHRzKG9sZEVuZHBvaW50LCBuZXdEZWZhdWx0cykge1xuICBjb25zdCBlbmRwb2ludDIgPSBvbGRFbmRwb2ludC5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgZW5kcG9pbnRPcHRpb25zID0gZW5kcG9pbnQyLm1lcmdlKHJvdXRlLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIWVuZHBvaW50T3B0aW9ucy5yZXF1ZXN0IHx8ICFlbmRwb2ludE9wdGlvbnMucmVxdWVzdC5ob29rKSB7XG4gICAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKGVuZHBvaW50Mi5wYXJzZShlbmRwb2ludE9wdGlvbnMpKTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSAocm91dGUyLCBwYXJhbWV0ZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIGZldGNoV3JhcHBlcihcbiAgICAgICAgZW5kcG9pbnQyLnBhcnNlKGVuZHBvaW50Mi5tZXJnZShyb3V0ZTIsIHBhcmFtZXRlcnMyKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHJlcXVlc3QyLCB7XG4gICAgICBlbmRwb2ludDogZW5kcG9pbnQyLFxuICAgICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIGVuZHBvaW50MilcbiAgICB9KTtcbiAgICByZXR1cm4gZW5kcG9pbnRPcHRpb25zLnJlcXVlc3QuaG9vayhyZXF1ZXN0MiwgZW5kcG9pbnRPcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZW5kcG9pbnQ6IGVuZHBvaW50MixcbiAgICBkZWZhdWx0czogd2l0aERlZmF1bHRzLmJpbmQobnVsbCwgZW5kcG9pbnQyKVxuICB9KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgcmVxdWVzdCA9IHdpdGhEZWZhdWx0cyhlbmRwb2ludCwge1xuICBoZWFkZXJzOiB7XG4gICAgXCJ1c2VyLWFnZW50XCI6IGBvY3Rva2l0LXJlcXVlc3QuanMvJHtWRVJTSU9OfSAke2dldFVzZXJBZ2VudCgpfWBcbiAgfVxufSk7XG5leHBvcnQge1xuICByZXF1ZXN0XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcIm9iamVjdFwiICYmIFwidXNlckFnZW50XCIgaW4gbmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfSAoJHtwcm9jZXNzLnBsYXRmb3JtfTsgJHtcbiAgICAgIHByb2Nlc3MuYXJjaFxuICAgIH0pYDtcbiAgfVxuXG4gIHJldHVybiBcIjxlbnZpcm9ubWVudCB1bmRldGVjdGFibGU+XCI7XG59XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG5pbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcbmltcG9ydCB7IGdldFVzZXJBZ2VudCB9IGZyb20gXCJ1bml2ZXJzYWwtdXNlci1hZ2VudFwiO1xuXG4vLyBwa2cvZGlzdC1zcmMvdmVyc2lvbi5qc1xudmFyIFZFUlNJT04gPSBcIjAuMC4wLWRldmVsb3BtZW50XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5pbXBvcnQgeyByZXF1ZXN0IGFzIFJlcXVlc3QyIH0gZnJvbSBcIkBvY3Rva2l0L3JlcXVlc3RcIjtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbmltcG9ydCB7IHJlcXVlc3QgYXMgUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5cbi8vIHBrZy9kaXN0LXNyYy9lcnJvci5qc1xuZnVuY3Rpb24gX2J1aWxkTWVzc2FnZUZvclJlc3BvbnNlRXJyb3JzKGRhdGEpIHtcbiAgcmV0dXJuIGBSZXF1ZXN0IGZhaWxlZCBkdWUgdG8gZm9sbG93aW5nIHJlc3BvbnNlIGVycm9yczpcbmAgKyBkYXRhLmVycm9ycy5tYXAoKGUpID0+IGAgLSAke2UubWVzc2FnZX1gKS5qb2luKFwiXFxuXCIpO1xufVxudmFyIEdyYXBocWxSZXNwb25zZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlcXVlc3QyLCBoZWFkZXJzLCByZXNwb25zZSkge1xuICAgIHN1cGVyKF9idWlsZE1lc3NhZ2VGb3JSZXNwb25zZUVycm9ycyhyZXNwb25zZSkpO1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3QyO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZXJyb3JzID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgIHRoaXMuZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gIH1cbiAgbmFtZSA9IFwiR3JhcGhxbFJlc3BvbnNlRXJyb3JcIjtcbiAgZXJyb3JzO1xuICBkYXRhO1xufTtcblxuLy8gcGtnL2Rpc3Qtc3JjL2dyYXBocWwuanNcbnZhciBOT05fVkFSSUFCTEVfT1BUSU9OUyA9IFtcbiAgXCJtZXRob2RcIixcbiAgXCJiYXNlVXJsXCIsXG4gIFwidXJsXCIsXG4gIFwiaGVhZGVyc1wiLFxuICBcInJlcXVlc3RcIixcbiAgXCJxdWVyeVwiLFxuICBcIm1lZGlhVHlwZVwiXG5dO1xudmFyIEZPUkJJRERFTl9WQVJJQUJMRV9PUFRJT05TID0gW1wicXVlcnlcIiwgXCJtZXRob2RcIiwgXCJ1cmxcIl07XG52YXIgR0hFU19WM19TVUZGSVhfUkVHRVggPSAvXFwvYXBpXFwvdjNcXC8/JC87XG5mdW5jdGlvbiBncmFwaHFsKHJlcXVlc3QyLCBxdWVyeSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgJiYgXCJxdWVyeVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKGBbQG9jdG9raXQvZ3JhcGhxbF0gXCJxdWVyeVwiIGNhbm5vdCBiZSB1c2VkIGFzIHZhcmlhYmxlIG5hbWVgKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKCFGT1JCSURERU5fVkFSSUFCTEVfT1BUSU9OUy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgIGBbQG9jdG9raXQvZ3JhcGhxbF0gXCIke2tleX1cIiBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZSBuYW1lYFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJzZWRPcHRpb25zID0gdHlwZW9mIHF1ZXJ5ID09PSBcInN0cmluZ1wiID8gT2JqZWN0LmFzc2lnbih7IHF1ZXJ5IH0sIG9wdGlvbnMpIDogcXVlcnk7XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmtleXMoXG4gICAgcGFyc2VkT3B0aW9uc1xuICApLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICBpZiAoTk9OX1ZBUklBQkxFX09QVElPTlMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBwYXJzZWRPcHRpb25zW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC52YXJpYWJsZXMpIHtcbiAgICAgIHJlc3VsdC52YXJpYWJsZXMgPSB7fTtcbiAgICB9XG4gICAgcmVzdWx0LnZhcmlhYmxlc1trZXldID0gcGFyc2VkT3B0aW9uc1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIHt9KTtcbiAgY29uc3QgYmFzZVVybCA9IHBhcnNlZE9wdGlvbnMuYmFzZVVybCB8fCByZXF1ZXN0Mi5lbmRwb2ludC5ERUZBVUxUUy5iYXNlVXJsO1xuICBpZiAoR0hFU19WM19TVUZGSVhfUkVHRVgudGVzdChiYXNlVXJsKSkge1xuICAgIHJlcXVlc3RPcHRpb25zLnVybCA9IGJhc2VVcmwucmVwbGFjZShHSEVTX1YzX1NVRkZJWF9SRUdFWCwgXCIvYXBpL2dyYXBocWxcIik7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QyKHJlcXVlc3RPcHRpb25zKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9ycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gcmVzcG9uc2UuaGVhZGVyc1trZXldO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEdyYXBocWxSZXNwb25zZUVycm9yKFxuICAgICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2UuZGF0YVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgfSk7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy93aXRoLWRlZmF1bHRzLmpzXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocmVxdWVzdDIsIG5ld0RlZmF1bHRzKSB7XG4gIGNvbnN0IG5ld1JlcXVlc3QgPSByZXF1ZXN0Mi5kZWZhdWx0cyhuZXdEZWZhdWx0cyk7XG4gIGNvbnN0IG5ld0FwaSA9IChxdWVyeSwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBncmFwaHFsKG5ld1JlcXVlc3QsIHF1ZXJ5LCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXBpLCB7XG4gICAgZGVmYXVsdHM6IHdpdGhEZWZhdWx0cy5iaW5kKG51bGwsIG5ld1JlcXVlc3QpLFxuICAgIGVuZHBvaW50OiBuZXdSZXF1ZXN0LmVuZHBvaW50XG4gIH0pO1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvaW5kZXguanNcbnZhciBncmFwaHFsMiA9IHdpdGhEZWZhdWx0cyhyZXF1ZXN0LCB7XG4gIGhlYWRlcnM6IHtcbiAgICBcInVzZXItYWdlbnRcIjogYG9jdG9raXQtZ3JhcGhxbC5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YFxuICB9LFxuICBtZXRob2Q6IFwiUE9TVFwiLFxuICB1cmw6IFwiL2dyYXBocWxcIlxufSk7XG5mdW5jdGlvbiB3aXRoQ3VzdG9tUmVxdWVzdChjdXN0b21SZXF1ZXN0KSB7XG4gIHJldHVybiB3aXRoRGVmYXVsdHMoY3VzdG9tUmVxdWVzdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdXJsOiBcIi9ncmFwaHFsXCJcbiAgfSk7XG59XG5leHBvcnQge1xuICBHcmFwaHFsUmVzcG9uc2VFcnJvcixcbiAgZ3JhcGhxbDIgYXMgZ3JhcGhxbCxcbiAgd2l0aEN1c3RvbVJlcXVlc3Rcbn07XG4iLCAiLy8gcGtnL2Rpc3Qtc3JjL2F1dGguanNcbnZhciBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZID0gL152MVxcLi87XG52YXIgUkVHRVhfSVNfSU5TVEFMTEFUSU9OID0gL15naHNfLztcbnZhciBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUiA9IC9eZ2h1Xy87XG5hc3luYyBmdW5jdGlvbiBhdXRoKHRva2VuKSB7XG4gIGNvbnN0IGlzQXBwID0gdG9rZW4uc3BsaXQoL1xcLi8pLmxlbmd0aCA9PT0gMztcbiAgY29uc3QgaXNJbnN0YWxsYXRpb24gPSBSRUdFWF9JU19JTlNUQUxMQVRJT05fTEVHQUNZLnRlc3QodG9rZW4pIHx8IFJFR0VYX0lTX0lOU1RBTExBVElPTi50ZXN0KHRva2VuKTtcbiAgY29uc3QgaXNVc2VyVG9TZXJ2ZXIgPSBSRUdFWF9JU19VU0VSX1RPX1NFUlZFUi50ZXN0KHRva2VuKTtcbiAgY29uc3QgdG9rZW5UeXBlID0gaXNBcHAgPyBcImFwcFwiIDogaXNJbnN0YWxsYXRpb24gPyBcImluc3RhbGxhdGlvblwiIDogaXNVc2VyVG9TZXJ2ZXIgPyBcInVzZXItdG8tc2VydmVyXCIgOiBcIm9hdXRoXCI7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b2tlblwiLFxuICAgIHRva2VuLFxuICAgIHRva2VuVHlwZVxuICB9O1xufVxuXG4vLyBwa2cvZGlzdC1zcmMvd2l0aC1hdXRob3JpemF0aW9uLXByZWZpeC5qc1xuZnVuY3Rpb24gd2l0aEF1dGhvcml6YXRpb25QcmVmaXgodG9rZW4pIHtcbiAgaWYgKHRva2VuLnNwbGl0KC9cXC4vKS5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYGJlYXJlciAke3Rva2VufWA7XG4gIH1cbiAgcmV0dXJuIGB0b2tlbiAke3Rva2VufWA7XG59XG5cbi8vIHBrZy9kaXN0LXNyYy9ob29rLmpzXG5hc3luYyBmdW5jdGlvbiBob29rKHRva2VuLCByZXF1ZXN0LCByb3V0ZSwgcGFyYW1ldGVycykge1xuICBjb25zdCBlbmRwb2ludCA9IHJlcXVlc3QuZW5kcG9pbnQubWVyZ2UoXG4gICAgcm91dGUsXG4gICAgcGFyYW1ldGVyc1xuICApO1xuICBlbmRwb2ludC5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSB3aXRoQXV0aG9yaXphdGlvblByZWZpeCh0b2tlbik7XG4gIHJldHVybiByZXF1ZXN0KGVuZHBvaW50KTtcbn1cblxuLy8gcGtnL2Rpc3Qtc3JjL2luZGV4LmpzXG52YXIgY3JlYXRlVG9rZW5BdXRoID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5BdXRoMih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIE5vIHRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGhcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiW0BvY3Rva2l0L2F1dGgtdG9rZW5dIFRva2VuIHBhc3NlZCB0byBjcmVhdGVUb2tlbkF1dGggaXMgbm90IGEgc3RyaW5nXCJcbiAgICApO1xuICB9XG4gIHRva2VuID0gdG9rZW4ucmVwbGFjZSgvXih0b2tlbnxiZWFyZXIpICsvaSwgXCJcIik7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGF1dGguYmluZChudWxsLCB0b2tlbiksIHtcbiAgICBob29rOiBob29rLmJpbmQobnVsbCwgdG9rZW4pXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIGNyZWF0ZVRva2VuQXV0aFxufTtcbiIsICJjb25zdCBWRVJTSU9OID0gXCI2LjAuMVwiO1xuZXhwb3J0IHtcbiAgVkVSU0lPTlxufTtcbiIsICJpbXBvcnQgeyBnZXRVc2VyQWdlbnQgfSBmcm9tIFwidW5pdmVyc2FsLXVzZXItYWdlbnRcIjtcbmltcG9ydCBIb29rIGZyb20gXCJiZWZvcmUtYWZ0ZXItaG9va1wiO1xuaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9yZXF1ZXN0XCI7XG5pbXBvcnQgeyBncmFwaHFsLCB3aXRoQ3VzdG9tUmVxdWVzdCB9IGZyb20gXCJAb2N0b2tpdC9ncmFwaHFsXCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkF1dGggfSBmcm9tIFwiQG9jdG9raXQvYXV0aC10b2tlblwiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb24uanNcIjtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7XG59O1xuY29uc3QgY29uc29sZVdhcm4gPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcbmNvbnN0IGNvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcbmNvbnN0IHVzZXJBZ2VudFRyYWlsID0gYG9jdG9raXQtY29yZS5qcy8ke1ZFUlNJT059ICR7Z2V0VXNlckFnZW50KCl9YDtcbmNsYXNzIE9jdG9raXQge1xuICBzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG4gIHN0YXRpYyBkZWZhdWx0cyhkZWZhdWx0cykge1xuICAgIGNvbnN0IE9jdG9raXRXaXRoRGVmYXVsdHMgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXJnc1swXSB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgc3VwZXIoZGVmYXVsdHMob3B0aW9ucykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJBZ2VudCAmJiBkZWZhdWx0cy51c2VyQWdlbnQgPyB7XG4gICAgICAgICAgICAgIHVzZXJBZ2VudDogYCR7b3B0aW9ucy51c2VyQWdlbnR9ICR7ZGVmYXVsdHMudXNlckFnZW50fWBcbiAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9jdG9raXRXaXRoRGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIHBsdWdpbnMgPSBbXTtcbiAgLyoqXG4gICAqIEF0dGFjaCBhIHBsdWdpbiAob3IgbWFueSkgdG8geW91ciBPY3Rva2l0IGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBBUEkgPSBPY3Rva2l0LnBsdWdpbihwbHVnaW4xLCBwbHVnaW4yLCBwbHVnaW4zLCAuLi4pXG4gICAqL1xuICBzdGF0aWMgcGx1Z2luKC4uLm5ld1BsdWdpbnMpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBjb25zdCBOZXdPY3Rva2l0ID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICAgIHN0YXRpYyBwbHVnaW5zID0gY3VycmVudFBsdWdpbnMuY29uY2F0KFxuICAgICAgICBuZXdQbHVnaW5zLmZpbHRlcigocGx1Z2luKSA9PiAhY3VycmVudFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSlcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gTmV3T2N0b2tpdDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBob29rID0gbmV3IEhvb2suQ29sbGVjdGlvbigpO1xuICAgIGNvbnN0IHJlcXVlc3REZWZhdWx0cyA9IHtcbiAgICAgIGJhc2VVcmw6IHJlcXVlc3QuZW5kcG9pbnQuREVGQVVMVFMuYmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgcmVxdWVzdDogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0LCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdXNhZ2Ugb25seSwgbm8gbmVlZCB0byB0eXBlXG4gICAgICAgIGhvb2s6IGhvb2suYmluZChudWxsLCBcInJlcXVlc3RcIilcbiAgICAgIH0pLFxuICAgICAgbWVkaWFUeXBlOiB7XG4gICAgICAgIHByZXZpZXdzOiBbXSxcbiAgICAgICAgZm9ybWF0OiBcIlwiXG4gICAgICB9XG4gICAgfTtcbiAgICByZXF1ZXN0RGVmYXVsdHMuaGVhZGVyc1tcInVzZXItYWdlbnRcIl0gPSBvcHRpb25zLnVzZXJBZ2VudCA/IGAke29wdGlvbnMudXNlckFnZW50fSAke3VzZXJBZ2VudFRyYWlsfWAgOiB1c2VyQWdlbnRUcmFpbDtcbiAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICByZXF1ZXN0RGVmYXVsdHMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJldmlld3MpIHtcbiAgICAgIHJlcXVlc3REZWZhdWx0cy5tZWRpYVR5cGUucHJldmlld3MgPSBvcHRpb25zLnByZXZpZXdzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgcmVxdWVzdERlZmF1bHRzLmhlYWRlcnNbXCJ0aW1lLXpvbmVcIl0gPSBvcHRpb25zLnRpbWVab25lO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0LmRlZmF1bHRzKHJlcXVlc3REZWZhdWx0cyk7XG4gICAgdGhpcy5ncmFwaHFsID0gd2l0aEN1c3RvbVJlcXVlc3QodGhpcy5yZXF1ZXN0KS5kZWZhdWx0cyhyZXF1ZXN0RGVmYXVsdHMpO1xuICAgIHRoaXMubG9nID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgZGVidWc6IG5vb3AsXG4gICAgICAgIGluZm86IG5vb3AsXG4gICAgICAgIHdhcm46IGNvbnNvbGVXYXJuLFxuICAgICAgICBlcnJvcjogY29uc29sZUVycm9yXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5sb2dcbiAgICApO1xuICAgIHRoaXMuaG9vayA9IGhvb2s7XG4gICAgaWYgKCFvcHRpb25zLmF1dGhTdHJhdGVneSkge1xuICAgICAgaWYgKCFvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcInVuYXV0aGVudGljYXRlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IGNyZWF0ZVRva2VuQXV0aChvcHRpb25zLmF1dGgpO1xuICAgICAgICBob29rLndyYXAoXCJyZXF1ZXN0XCIsIGF1dGguaG9vayk7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgYXV0aFN0cmF0ZWd5LCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBhdXRoID0gYXV0aFN0cmF0ZWd5KFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMucmVxdWVzdCxcbiAgICAgICAgICAgIGxvZzogdGhpcy5sb2csXG4gICAgICAgICAgICAvLyB3ZSBwYXNzIHRoZSBjdXJyZW50IG9jdG9raXQgaW5zdGFuY2UgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3Igb3B0aW9uc1xuICAgICAgICAgICAgLy8gdG8gYWxsb3cgZm9yIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWdpZXMgdGhhdCByZXR1cm4gYSBuZXcgb2N0b2tpdCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBzaGFyZXMgdGhlIHNhbWUgaW50ZXJuYWwgc3RhdGUgYXMgdGhlIGN1cnJlbnQgb25lLiBUaGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIHJlcXVpcmVtZW50IGZvciB0aGlzIHdhcyB0aGUgXCJldmVudC1vY3Rva2l0XCIgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAgICAgICAgICAgIC8vIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9ib3Qvb2N0b2tpdC1hdXRoLXByb2JvdC5cbiAgICAgICAgICAgIG9jdG9raXQ6IHRoaXMsXG4gICAgICAgICAgICBvY3Rva2l0T3B0aW9uczogb3RoZXJPcHRpb25zXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zLmF1dGhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGhvb2sud3JhcChcInJlcXVlc3RcIiwgYXV0aC5ob29rKTtcbiAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzQ29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NDb25zdHJ1Y3Rvci5wbHVnaW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNsYXNzQ29uc3RydWN0b3IucGx1Z2luc1tpXSh0aGlzLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIC8vIGFzc2lnbmVkIGR1cmluZyBjb25zdHJ1Y3RvclxuICByZXF1ZXN0O1xuICBncmFwaHFsO1xuICBsb2c7XG4gIGhvb2s7XG4gIC8vIFRPRE86IHR5cGUgYG9jdG9raXQuYXV0aGAgYmFzZWQgb24gcGFzc2VkIG9wdGlvbnMuYXV0aFN0cmF0ZWd5XG4gIGF1dGg7XG59XG5leHBvcnQge1xuICBPY3Rva2l0XG59O1xuIiwgImltcG9ydCB7IExvY2FsRmlsZVN0YXR1cyB9IGZyb20gXCIuL2ZpdFB1c2hcIjtcblxuZXhwb3J0IHR5cGUgUmVtb3RlQ2hhbmdlVHlwZSA9IFwiQURERURcIiB8IFwiTU9ESUZJRURcIiB8IFwiUkVNT1ZFRFwiXG5cbnR5cGUgU3RhdHVzID0gUmVtb3RlQ2hhbmdlVHlwZSB8IExvY2FsRmlsZVN0YXR1c1xuXG50eXBlIEZpbGVMb2NhdGlvbiA9IFwicmVtb3RlXCIgfCBcImxvY2FsXCJcblxudHlwZSBDb21wYXJpc29uUmVzdWx0PEVudiBleHRlbmRzIEZpbGVMb2NhdGlvbj4gPSB7XG4gICAgcGF0aDogc3RyaW5nLCBcbiAgICBzdGF0dXM6IEVudiBleHRlbmRzIFwibG9jYWxcIiA/IExvY2FsRmlsZVN0YXR1czogUmVtb3RlQ2hhbmdlVHlwZVxuICAgIGN1cnJlbnRTaGE/OiBzdHJpbmdcbiAgICBleHRlbnNpb24/OiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVPck51bGwob2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KSA/IG9ialtrZXldIDogbnVsbDtcbn1cblxuXG4vLyBjb21wYXJlIGN1cnJlbnRTaGEgd2l0aCBzdG9yZWRTaGEgYW5kIGNoZWNrIGZvciBkaWZmZXJlbmNlcywgZmlsZXMgb25seSBpbiBjdXJyZW50U2hhXG4vLyAgYXJlIGNvbnNpZGVyZCBhZGRlZCwgd2hpbGUgZmlsZXMgb25seSBpbiBzdG9yZWRTaGEgYXJlIGNvbnNpZGVyZWQgcmVtb3ZlZFxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTaGE8RW52IGV4dGVuZHMgXCJyZW1vdGVcIiB8IFwibG9jYWxcIj4oXG4gICAgY3VycmVudFNoYU1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgXG4gICAgc3RvcmVkU2hhTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGVudjogRW52KTogQ29tcGFyaXNvblJlc3VsdDxFbnY+W10ge1xuICAgICAgICBjb25zdCBkZXRlcm1pbmVTdGF0dXMgPSAoY3VycmVudFNoYTogc3RyaW5nIHwgbnVsbCwgc3RvcmVkU2hhOiBzdHJpbmcgfCBudWxsKTogU3RhdHVzIHwgbnVsbCAgPT4gXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2hhICYmIHN0b3JlZFNoYSAmJiBjdXJyZW50U2hhICE9PSBzdG9yZWRTaGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52ID09PSBcImxvY2FsXCIgPyBcImNoYW5nZWRcIiA6IFwiTU9ESUZJRURcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFNoYSAmJiAhc3RvcmVkU2hhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudiA9PT0gXCJsb2NhbFwiID8gXCJjcmVhdGVkXCIgOiBcIkFEREVEXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50U2hhICYmIHN0b3JlZFNoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnYgPT09IFwibG9jYWxcIiA/IFwiZGVsZXRlZFwiIDogXCJSRU1PVkVEXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHsgLi4uY3VycmVudFNoYU1hcCwgLi4uc3RvcmVkU2hhTWFwIH0pLmZsYXRNYXAoKHBhdGgpOiBDb21wYXJpc29uUmVzdWx0PEVudj5bXSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY3VycmVudFNoYSwgc3RvcmVkU2hhXSA9IFtnZXRWYWx1ZU9yTnVsbChjdXJyZW50U2hhTWFwLCBwYXRoKSwgZ2V0VmFsdWVPck51bGwoc3RvcmVkU2hhTWFwLCBwYXRoKV07XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBkZXRlcm1pbmVTdGF0dXMoY3VycmVudFNoYSwgc3RvcmVkU2hhKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMgYXMgRW52IGV4dGVuZHMgXCJsb2NhbFwiID8gTG9jYWxGaWxlU3RhdHVzIDogUmVtb3RlQ2hhbmdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNoYTogY3VycmVudFNoYSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogZXh0cmFjdEV4dGVuc2lvbihwYXRoKVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09HTklaRURfQklOQVJZX0VYVCA9IFtcInBuZ1wiLCBcImpwZ1wiLCBcImpwZWdcIiwgXCJwZGZcIl1cblxuZnVuY3Rpb24gZXh0cmFjdEV4dGVuc2lvbihwYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBwYXRoLm1hdGNoKC9bXi5dKyQvKT8uWzBdO1xufVxuXG4vLyBVc2luZyBmaWxlIGV4dGVuc2lvbiB0byBkZXRlcm1pbmUgZW5jb2Rpbmcgb2YgZmlsZXMgKHdvcmtzIGluIG1vc3QgY2FzZXMpXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZUVuY29kaW5nKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gcGF0aC5tYXRjaCgvW14uXSskLyk/LlswXTtcbiAgICBjb25zdCBpc0JpbmFyeSA9IGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKTtcbiAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFzZTY0XCJcbiAgICB9IFxuICAgIHJldHVybiBcInV0Zi04XCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEVxdWFsPFQ+KGFycjE6IEFycmF5PFQ+LCBhcnIyOiBBcnJheTxUPikge1xuICAgIGNvbnN0IHNldDEgPSBuZXcgU2V0KGFycjEpO1xuICAgIGNvbnN0IHNldDIgPSBuZXcgU2V0KGFycjIpO1xuICAgIGNvbnN0IGlzRXF1YWwgPSBzZXQxLnNpemUgPT09IHNldDIuc2l6ZSAmJiBbLi4uc2V0MV0uZXZlcnkodmFsdWUgPT4gc2V0Mi5oYXModmFsdWUpKTtcbiAgICByZXR1cm4gaXNFcXVhbFxufSIsICJpbXBvcnQgeyBMb2NhbFN0b3JlcywgRml0U2V0dGluZ3MgfSBmcm9tIFwibWFpblwiXG5pbXBvcnQgeyBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBPY3Rva2l0IH0gZnJvbSBcIkBvY3Rva2l0L2NvcmVcIlxuaW1wb3J0IHsgTG9jYWxDaGFuZ2UgfSBmcm9tIFwiLi9maXRQdXNoXCJcbmltcG9ydCB7IFJFQ09HTklaRURfQklOQVJZX0VYVCwgY29tcGFyZVNoYSB9IGZyb20gXCIuL3V0aWxzXCJcblxudHlwZSBUcmVlTm9kZSA9IHtcbiAgICBwYXRoOiBzdHJpbmcsIFxuICAgIG1vZGU6IFwiMTAwNjQ0XCIgfCBcIjEwMDc1NVwiIHwgXCIwNDAwMDBcIiB8IFwiMTYwMDAwXCIgfCBcIjEyMDAwMFwiIHwgdW5kZWZpbmVkLCBcbiAgICB0eXBlOiBcImNvbW1pdFwiIHwgXCJibG9iXCIgfCBcInRyZWVcIiB8IHVuZGVmaW5lZCwgXG4gICAgc2hhOiBzdHJpbmcgfCBudWxsfVxuXG50eXBlIE9jdG9raXRDYWxsTWV0aG9kcyA9IHtcbiAgICBnZXRVc2VyOiAoKSA9PiBQcm9taXNlPHtvd25lcjogc3RyaW5nLCBhdmF0YXJVcmw6IHN0cmluZ30+XG4gICAgZ2V0UmVwb3M6ICgpID0+IFByb21pc2U8c3RyaW5nW10+XG4gICAgZ2V0UmVmOiAocmVmOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPlxuICAgIGdldFRyZWU6ICh0cmVlX3NoYTogc3RyaW5nKSA9PiBQcm9taXNlPFRyZWVOb2RlW10+XG4gICAgZ2V0Q29tbWl0VHJlZVNoYTogKHJlZjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbiAgICBnZXRSZW1vdGVUcmVlU2hhOiAodHJlZV9zaGE6IHN0cmluZykgPT4gUHJvbWlzZTx7W2s6c3RyaW5nXTogc3RyaW5nfT5cbiAgICBjcmVhdGVCbG9iOiAoY29udGVudDogc3RyaW5nLCBlbmNvZGluZzogc3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxuICAgIGNyZWF0ZVRyZWVOb2RlRnJvbUZpbGU6ICh7cGF0aCwgc3RhdHVzLCBleHRlbnNpb259OiBMb2NhbENoYW5nZSkgPT4gUHJvbWlzZTxUcmVlTm9kZT5cbiAgICBjcmVhdGVDb21taXQ6ICh0cmVlU2hhOiBzdHJpbmcsIHBhcmVudFNoYTogc3RyaW5nKSA9PlByb21pc2U8c3RyaW5nPlxuICAgIHVwZGF0ZVJlZjogKHNoYTogc3RyaW5nLCByZWY6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+XG4gICAgZ2V0QmxvYjogKGZpbGVfc2hhOnN0cmluZykgPT5Qcm9taXNlPHN0cmluZz5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRml0IGV4dGVuZHMgT2N0b2tpdENhbGxNZXRob2Rze1xuICAgIG93bmVyOiBzdHJpbmdcbiAgICByZXBvOiBzdHJpbmdcbiAgICBicmFuY2g6IHN0cmluZ1xuICAgIGhlYWRlcnM6IHtbazogc3RyaW5nXTogc3RyaW5nfVxuICAgIGRldmljZU5hbWU6IHN0cmluZ1xuICAgIGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0OiBWYXVsdFxuICAgIGZpbGVTaGExOiAocGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz5cbn1cblxuLy8gRGVmaW5lIGEgY3VzdG9tIEh0dHBFcnJvciBjbGFzcyB0aGF0IGV4dGVuZHMgRXJyb3JcbmV4cG9ydCBjbGFzcyBPY3Rva2l0SHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHNvdXJjZToga2V5b2YgT2N0b2tpdENhbGxNZXRob2RzXG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBzb3VyY2U6IGtleW9mIE9jdG9raXRDYWxsTWV0aG9kcykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZpdCBpbXBsZW1lbnRzIElGaXQge1xuICAgIG93bmVyOiBzdHJpbmdcbiAgICByZXBvOiBzdHJpbmdcbiAgICBhdXRoOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBicmFuY2g6IHN0cmluZ1xuICAgIGhlYWRlcnM6IHtbazogc3RyaW5nXTogc3RyaW5nfVxuICAgIGRldmljZU5hbWU6IHN0cmluZ1xuICAgIGxvY2FsU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdGxhc3RGZXRjaGVkQ29tbWl0U2hhOiBzdHJpbmcgfCBudWxsXG5cdGxhc3RGZXRjaGVkUmVtb3RlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gICAgb2N0b2tpdDogT2N0b2tpdFxuICAgIHZhdWx0OiBWYXVsdFxuXG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nOiBGaXRTZXR0aW5ncywgbG9jYWxTdG9yZXM6IExvY2FsU3RvcmVzLCB2YXVsdDogVmF1bHQpIHtcbiAgICAgICAgdGhpcy5sb2FkU2V0dGluZ3Moc2V0dGluZylcbiAgICAgICAgdGhpcy5sb2FkTG9jYWxTdG9yZShsb2NhbFN0b3JlcylcbiAgICAgICAgdGhpcy52YXVsdCA9IHZhdWx0XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIEhhY2sgdG8gZGlzYWJsZSBjYWNoaW5nIHdoaWNoIGxlYWRzIHRvIGluY29uc2lzdGVuY3kgZm9yXG4gICAgICAgICAgICAvLyByZWFkIGFmdGVyIHdyaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3Rva2l0L29jdG9raXQuanMvaXNzdWVzLzg5MFxuICAgICAgICAgICAgXCJJZi1Ob25lLU1hdGNoXCI6ICcnLCBcbiAgICAgICAgICAgICdYLUdpdEh1Yi1BcGktVmVyc2lvbic6ICcyMDIyLTExLTI4J1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGxvYWRTZXR0aW5ncyhzZXR0aW5nOiBGaXRTZXR0aW5ncykge1xuICAgICAgICB0aGlzLm93bmVyID0gc2V0dGluZy5vd25lclxuICAgICAgICB0aGlzLnJlcG8gPSBzZXR0aW5nLnJlcG9cbiAgICAgICAgdGhpcy5icmFuY2ggPSBzZXR0aW5nLmJyYW5jaFxuICAgICAgICB0aGlzLmRldmljZU5hbWUgPSBzZXR0aW5nLmRldmljZU5hbWVcbiAgICAgICAgdGhpcy5vY3Rva2l0ID0gbmV3IE9jdG9raXQoe2F1dGg6IHNldHRpbmcucGF0fSlcbiAgICB9XG4gICAgXG4gICAgbG9hZExvY2FsU3RvcmUobG9jYWxTdG9yZTogTG9jYWxTdG9yZXMpIHtcbiAgICAgICAgdGhpcy5sb2NhbFNoYSA9IGxvY2FsU3RvcmUubG9jYWxTaGFcbiAgICAgICAgdGhpcy5sYXN0RmV0Y2hlZENvbW1pdFNoYSA9IGxvY2FsU3RvcmUubGFzdEZldGNoZWRDb21taXRTaGFcbiAgICAgICAgdGhpcy5sYXN0RmV0Y2hlZFJlbW90ZVNoYSA9IGxvY2FsU3RvcmUubGFzdEZldGNoZWRSZW1vdGVTaGFcbiAgICB9XG4gICAgXG4gICAgYXN5bmMgZmlsZVNoYTEoZmlsZUNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBoYXNoQnVmID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0xJywgZW5jLmVuY29kZShmaWxlQ29udGVudCkpXG4gICAgICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZikpO1xuICAgICAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gaGFzaEhleDtcbiAgICB9XG5cbiAgICBhc3luYyBjb21wdXRlRmlsZUxvY2FsU2hhKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0aWYgKCFhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKHBhdGgpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRpbmcgdG8gY29tcHV0ZSBsb2NhbCBzaGEgZm9yICR7cGF0aH0sIGJ1dCBmaWxlIG5vdCBmb3VuZC5gKTtcblx0XHR9XG5cdFx0Ly8gY29tcHV0ZSBzaGExIGJhc2VkIG9uIHBhdGggYW5kIGZpbGUgY29udGVudFxuXHRcdGNvbnN0IGxvY2FsRmlsZSA9IGF3YWl0IHRoaXMudmF1bHQuYWRhcHRlci5yZWFkKHBhdGgpXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuZmlsZVNoYTEocGF0aCArIGxvY2FsRmlsZSlcblx0fVxuXG5cdGFzeW5jIGNvbXB1dGVMb2NhbFNoYSgpOiBQcm9taXNlPHtbazpzdHJpbmddOnN0cmluZ30+IHtcblx0XHRjb25zdCBwYXRocyA9IHRoaXMudmF1bHQuZ2V0RmlsZXMoKS5tYXAoZj0+Zi5wYXRoKVxuXHRcdHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG5cdFx0XHRhd2FpdCBQcm9taXNlLmFsbChcblx0XHRcdFx0cGF0aHMubWFwKGFzeW5jIChwOiBzdHJpbmcpOiBQcm9taXNlPFtzdHJpbmcsIHN0cmluZ10+ID0+e1xuXHRcdFx0XHRcdHJldHVybiBbcCwgYXdhaXQgdGhpcy5jb21wdXRlRmlsZUxvY2FsU2hhKHApXVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdClcblx0fVxuXG4gICAgYXN5bmMgZ2V0TG9jYWxDaGFuZ2VzKGN1cnJlbnRMb2NhbFNoYT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBQcm9taXNlPExvY2FsQ2hhbmdlW10+IHtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsU2hhKSB7XG4gICAgICAgICAgICAvLyBhc3N1bWVzIGV2ZXJ5IGxvY2FsIGZpbGVzIGFyZSBjcmVhdGVkIGlmIG5vIGxvY2FsU2hhIGlzIGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YXVsdC5nZXRGaWxlcygpLm1hcChmID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge3BhdGg6IGYucGF0aCwgc3RhdHVzOiBcImNyZWF0ZWRcIn19KVxuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudExvY2FsU2hhKSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxTaGEgPSBhd2FpdCB0aGlzLmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VzID0gY29tcGFyZVNoYShjdXJyZW50TG9jYWxTaGEsIHRoaXMubG9jYWxTaGEsIFwibG9jYWxcIilcbiAgICAgICAgcmV0dXJuIGxvY2FsQ2hhbmdlc1xuICAgIH1cblxuICAgIGFzeW5jIGdldFVzZXIoKTogUHJvbWlzZTx7b3duZXI6IHN0cmluZywgYXZhdGFyVXJsOiBzdHJpbmd9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHtvd25lcjogcmVzcG9uc2UubG9naW4sIGF2YXRhclVybDpyZXNwb25zZS5hdmF0YXJfdXJsfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9jdG9raXRIdHRwRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhdHVzLCBcImdldFVzZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRSZXBvcygpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvdXNlci9yZXBvc2AsIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmaWxpYXRpb246IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChyID0+IHIubmFtZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEJyYW5jaGVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHtkYXRhOiByZXNwb25zZX0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICBgR0VUIC9yZXBvcy97b3duZXJ9L3tyZXBvfS9icmFuY2hlc2AsIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChyID0+IHIubmFtZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPY3Rva2l0SHR0cEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YXR1cywgXCJnZXRSZXBvc1wiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFJlZihyZWY6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogcmVzcG9uc2V9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZi97cmVmfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiByZWYsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vYmplY3Quc2hhXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2N0b2tpdEh0dHBFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGF0dXMsIFwiZ2V0UmVmXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBzaGEgb2YgdGhlIGxhdGVzdCBjb21taXQgaW4gdGhlIGRlZmF1bHQgYnJhbmNoIChzZXQgYnkgdXNlciBpbiBzZXR0aW5nKVxuICAgIGFzeW5jIGdldExhdGVzdFJlbW90ZUNvbW1pdFNoYShyZWYgPSBgaGVhZHMvJHt0aGlzLmJyYW5jaH1gKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVmKHJlZilcbiAgICB9XG5cbiAgICAvLyByZWYgQ2FuIGJlIGEgY29tbWl0IFNIQSwgYnJhbmNoIG5hbWUgKGhlYWRzL0JSQU5DSF9OQU1FKSwgb3IgdGFnIG5hbWUgKHRhZ3MvVEFHX05BTUUpLCBcbiAgICAvLyByZWZlcnMgdG8gaHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL2VuL3YyL0dpdC1JbnRlcm5hbHMtR2l0LVJlZmVyZW5jZXNcbiAgICBhc3luYyBnZXRDb21taXRUcmVlU2hhKHJlZjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3Qge2RhdGE6IGNvbW1pdH0gPSAgYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoIFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vY29tbWl0cy97cmVmfWAsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjb21taXQuY29tbWl0LnRyZWUuc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VHJlZSh0cmVlX3NoYTogc3RyaW5nKTogUHJvbWlzZTxUcmVlTm9kZVtdPiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogdHJlZSB9ID0gIGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3MvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vZ2l0L3RyZWVzLyR7dHJlZV9zaGF9YCwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICB0cmVlX3NoYSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZTogJ3RydWUnLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiB0cmVlLnRyZWVcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHJlbW90ZSB0cmVlIHNoYSBpbiB0aGUgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBsb2NhbCBzdG9yZVxuICAgIGFzeW5jIGdldFJlbW90ZVRyZWVTaGEodHJlZV9zaGE6IHN0cmluZyk6IFByb21pc2U8e1trOnN0cmluZ106IHN0cmluZ30+IHtcbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZSA9IGF3YWl0IHRoaXMuZ2V0VHJlZSh0cmVlX3NoYSlcbiAgICAgICAgY29uc3QgcmVtb3RlU2hhID0gT2JqZWN0LmZyb21FbnRyaWVzKHJlbW90ZVRyZWUubWFwKChub2RlOiBUcmVlTm9kZSkgOiBbc3RyaW5nLCBzdHJpbmddIHwgbnVsbD0+e1xuICAgICAgICAgICAgLy8gY3VycmVudGx5IGlnbm9yaW5nIGRpcmVjdG9yeSBjaGFuZ2VzLCBpZiB5b3UnZCBsaWtlIHRvIHVwbG9hZCBhIG5ldyBkaXJlY3RvcnksIFxuICAgICAgICAgICAgLy8gYSBxdWljayBoYWNrIHdvdWxkIGJlIGNyZWF0aW5nIGFuIGVtcHR5IGZpbGUgaW5zaWRlXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlPT1cImJsb2JcIikge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5wYXRoIHx8ICFub2RlLnNoYSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIG9yIHNoYSBub3QgZm91bmQgZm9yIGJsb2Igbm9kZSBpbiByZW1vdGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbbm9kZS5wYXRoLCBub2RlLnNoYV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBbc3RyaW5nLCBzdHJpbmddW10pXG4gICAgICAgIHJldHVybiByZW1vdGVTaGFcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVCbG9iKGNvbnRlbnQ6IHN0cmluZywgZW5jb2Rpbmc6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHtkYXRhOiBibG9ifSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYFBPU1QgL3JlcG9zL3tvd25lcn0ve3JlcG99L2dpdC9ibG9ic2AsIHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgY29udGVudCwgXG4gICAgICAgICAgICBlbmNvZGluZyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyAgICAgXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBibG9iLnNoYVxuICAgIH1cblxuXG4gICAgYXN5bmMgY3JlYXRlVHJlZU5vZGVGcm9tRmlsZSh7cGF0aCwgc3RhdHVzLCBleHRlbnNpb259OiBMb2NhbENoYW5nZSk6IFByb21pc2U8VHJlZU5vZGU+IHtcblx0XHRpZiAoc3RhdHVzID09PSBcImRlbGV0ZWRcIikge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0bW9kZTogJzEwMDY0NCcsXG5cdFx0XHRcdHR5cGU6ICdibG9iJyxcblx0XHRcdFx0c2hhOiBudWxsXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghdGhpcy52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBVbmV4cGVjdGVkIGVycm9yOiBhdHRlbXB0aW5nIHRvIGNyZWF0ZUJsb2IgZm9yIG5vbi1leGlzdGVudCBmaWxlLCBcbiAgICAgICAgICAgICAgICBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBvbiBnaXRodWIgd2l0aCBpbmZvIHRvIHJlcHJvZHVjZSB0aGUgaXNzdWUuYCk7XG5cdFx0fVxuXHRcdGxldCBlbmNvZGluZzogc3RyaW5nO1xuXHRcdGxldCBjb250ZW50OiBzdHJpbmcgXG4gICAgICAgIC8vIFRPRE8gY2hlY2sgd2hldGhlciBldmVyeSBmaWxlcyBpbmNsdWRpbmcgbWQgY2FuIGJlIHJlYWQgdXNpbmcgcmVhZEJpbmFyeSB0byByZWR1Y2UgY29kZSBjb21wbGV4aXR5XG5cdFx0aWYgKGV4dGVuc2lvbiAmJiBSRUNPR05JWkVEX0JJTkFSWV9FWFQuaW5jbHVkZXMoZXh0ZW5zaW9uKSkge1xuXHRcdFx0ZW5jb2RpbmcgPSBcImJhc2U2NFwiXG5cdFx0XHRjb25zdCBmaWxlQXJyYXlCdWYgPSBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIucmVhZEJpbmFyeShwYXRoKVxuXHRcdFx0Y29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGZpbGVBcnJheUJ1Zik7XG5cdFx0XHRsZXQgYmluYXJ5U3RyaW5nID0gJyc7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhBcnJheVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZW50ID0gYnRvYShiaW5hcnlTdHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbmNvZGluZyA9ICd1dGYtOCdcblx0XHRcdGNvbnRlbnQgPSBhd2FpdCB0aGlzLnZhdWx0LmFkYXB0ZXIucmVhZChwYXRoKVxuXHRcdH1cblx0XHRjb25zdCBibG9iU2hhID0gYXdhaXQgdGhpcy5jcmVhdGVCbG9iKGNvbnRlbnQsIGVuY29kaW5nKVxuXHRcdHJldHVybiB7XG5cdFx0XHRwYXRoOiBwYXRoLFxuXHRcdFx0bW9kZTogJzEwMDY0NCcsXG5cdFx0XHR0eXBlOiAnYmxvYicsXG5cdFx0XHRzaGE6IGJsb2JTaGEsXG5cdFx0fVxuXHR9XG5cbiAgICBhc3luYyBjcmVhdGVUcmVlKFxuICAgICAgICB0cmVlTm9kZXM6IEFycmF5PFRyZWVOb2RlPixcbiAgICAgICAgYmFzZV90cmVlX3NoYTogc3RyaW5nKTogXG4gICAgICAgIFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgICAgICBjb25zdCB7ZGF0YTogbmV3VHJlZX0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgICAgICBgUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3RyZWVzYCwgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgICAgICAgICAgcmVwbzogdGhpcy5yZXBvLFxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VfdHJlZTogYmFzZV90cmVlX3NoYSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyZWUuc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0KHRyZWVTaGE6IHN0cmluZywgcGFyZW50U2hhOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvbW1pdCBmcm9tIHtkZXZpY2VOYW1lfSBvbiAke25ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKX1gXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY3JlYXRlZENvbW1pdCB9ID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoXG4gICAgICAgICAgICBgUE9TVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2NvbW1pdHNgICwge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMub3duZXIsXG4gICAgICAgICAgICByZXBvOiB0aGlzLnJlcG8sXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdHJlZTogdHJlZVNoYSxcbiAgICAgICAgICAgIHBhcmVudHM6IFtwYXJlbnRTaGFdLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBjcmVhdGVkQ29tbWl0LnNoYVxuICAgIH1cblxuICAgIGFzeW5jIHVwZGF0ZVJlZihzaGE6IHN0cmluZywgcmVmID0gYGhlYWRzLyR7dGhpcy5icmFuY2h9YCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTp1cGRhdGVkUmVmIH0gPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChcbiAgICAgICAgICAgIGBQQVRDSCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L3JlZnMve3JlZn1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHNoYSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdXBkYXRlZFJlZi5vYmplY3Quc2hhXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvYihmaWxlX3NoYTpzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGJsb2IgfSA9IGF3YWl0IHRoaXMub2N0b2tpdC5yZXF1ZXN0KFxuICAgICAgICAgICAgYEdFVCAvcmVwb3Mve293bmVyfS97cmVwb30vZ2l0L2Jsb2JzL3tmaWxlX3NoYX1gLCB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgICAgICAgICAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAgICAgICAgIGZpbGVfc2hhLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBibG9iLmNvbnRlbnRcbiAgICB9XG59IiwgImltcG9ydCB7IFZhdWx0T3BlcmF0aW9ucyB9IGZyb20gXCIuL3ZhdWx0T3BzXCI7XG5pbXBvcnQgeyBSZW1vdGVDaGFuZ2VUeXBlLCBjb21wYXJlU2hhIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEZpdCB9IGZyb20gXCIuL2ZpdFwiO1xuaW1wb3J0IHsgTG9jYWxTdG9yZXMgfSBmcm9tIFwibWFpblwiO1xuaW1wb3J0IHsgTG9jYWxDaGFuZ2UgfSBmcm9tIFwiLi9maXRQdXNoXCI7XG5cbnR5cGUgUHJlUHVsbENoZWNrUmVzdWx0VHlwZSA9IChcbiAgICBcImxvY2FsQ29weVVwVG9EYXRlXCIgfCBcbiAgICBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIiB8IFxuICAgIFwicmVtb3RlQ2hhbmdlc0NhbkJlTWVyZ2VkXCIgfCBcbiAgICBcIm5vUmVtb3RlQ2hhbmdlc0RldGVjdGVkXCJcbilcblxudHlwZSBQcmVQdWxsQ2hlY2tSZXN1bHQgPSAoXG4gICAgeyBzdGF0dXM6IFwibG9jYWxDb3B5VXBUb0RhdGVcIiwgcmVtb3RlVXBkYXRlOiBudWxsIH0gfCBcbiAgICB7IHN0YXR1czogRXhjbHVkZTxQcmVQdWxsQ2hlY2tSZXN1bHRUeXBlLCBcImxvY2FsQ29weVVwVG9EYXRlXCI+LCByZW1vdGVVcGRhdGU6IFJlbW90ZVVwZGF0ZSB9XG4pO1xuXG5leHBvcnQgdHlwZSBSZW1vdGVDaGFuZ2UgPSB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHN0YXR1czogUmVtb3RlQ2hhbmdlVHlwZSxcbiAgICBjdXJyZW50U2hhPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFJlbW90ZVVwZGF0ZSA9IHtcbiAgICByZW1vdGVDaGFuZ2VzOiBSZW1vdGVDaGFuZ2VbXSxcbiAgICByZW1vdGVUcmVlU2hhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBcbiAgICBsYXRlc3RSZW1vdGVDb21taXRTaGE6IHN0cmluZyxcbiAgICBjbGFzaGVkRmlsZXM6IEFycmF5PHN0cmluZz5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRml0UHVsbCB7XG4gICAgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9uc1xuICAgIGZpdDogRml0XG59XG5cbmV4cG9ydCBjbGFzcyBGaXRQdWxsIGltcGxlbWVudHMgSUZpdFB1bGwge1xuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnM7XG4gICAgZml0OiBGaXRcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGZpdDogRml0LCB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zKSB7XG4gICAgICAgIHRoaXMudmF1bHRPcHMgPSB2YXVsdE9wc1xuICAgICAgICB0aGlzLmZpdCA9IGZpdFxuICAgIH1cblxuICAgIGFzeW5jIGdldFJlbW90ZUNoYW5nZXMocmVtb3RlVHJlZVNoYToge1trOiBzdHJpbmddOiBzdHJpbmd9KTogUHJvbWlzZTxSZW1vdGVDaGFuZ2VbXT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpdC5sYXN0RmV0Y2hlZFJlbW90ZVNoYSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlbW90ZVRyZWVTaGEpLm1hcChwYXRoPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7cGF0aCwgc3RhdHVzOiBcIkFEREVEXCIgYXMgUmVtb3RlQ2hhbmdlVHlwZX1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IGNvbXBhcmVTaGEoXG4gICAgICAgICAgICAgICAgcmVtb3RlVHJlZVNoYSwgdGhpcy5maXQubGFzdEZldGNoZWRSZW1vdGVTaGEsIFwicmVtb3RlXCIpXG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlQ2hhbmdlc1xuICAgIH1cblxuICAgIGdldENsYXNoZWRDaGFuZ2VzKGxvY2FsQ2hhbmdlczogTG9jYWxDaGFuZ2VbXSwgcmVtb3RlQ2hhbmdlczpSZW1vdGVDaGFuZ2VbXSk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgbG9jYWxDaGFuZ2VQYXRocyA9IGxvY2FsQ2hhbmdlcy5tYXAoYz0+Yy5wYXRoKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VQYXRocyA9IHJlbW90ZUNoYW5nZXMubWFwKGM9PmMucGF0aClcbiAgICAgICAgY29uc3QgY2xhc2hlZEZpbGVzOiBzdHJpbmdbXSA9IGxvY2FsQ2hhbmdlUGF0aHMuZmlsdGVyKFxuICAgICAgICAgICAgcGF0aCA9PiByZW1vdGVDaGFuZ2VQYXRocy5pbmNsdWRlcyhwYXRoKSlcbiAgICAgICAgcmV0dXJuIGNsYXNoZWRGaWxlc1xuICAgIH1cblxuICAgIC8vIHJldHVybiBudWxsIGlmIHJlbW90ZSBkb2Vzbid0IGhhdmUgdXBkYXRlcyBvdGhlcndpc2UsIHJldHVybiB0aGUgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG4gICAgYXN5bmMgcmVtb3RlSGFzVXBkYXRlcygpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0TGF0ZXN0UmVtb3RlQ29tbWl0U2hhKClcbiAgICAgICAgaWYgKGxhdGVzdFJlbW90ZUNvbW1pdFNoYSA9PSB0aGlzLmZpdC5sYXN0RmV0Y2hlZENvbW1pdFNoYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0ZXN0UmVtb3RlQ29tbWl0U2hhXG4gICAgfVxuXG4gICAgYXN5bmMgcGVyZm9ybVByZVB1bGxDaGVja3MobG9jYWxDaGFuZ2VzPzogTG9jYWxDaGFuZ2VbXSk6IFByb21pc2U8UHJlUHVsbENoZWNrUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSA9IGF3YWl0IHRoaXMucmVtb3RlSGFzVXBkYXRlcygpXG4gICAgICAgIGlmICghbGF0ZXN0UmVtb3RlQ29tbWl0U2hhKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXR1czogXCJsb2NhbENvcHlVcFRvRGF0ZVwiLCByZW1vdGVVcGRhdGU6IG51bGx9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2NhbENoYW5nZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldExvY2FsQ2hhbmdlcygpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEobGF0ZXN0UmVtb3RlQ29tbWl0U2hhKVxuICAgICAgICBjb25zdCByZW1vdGVDaGFuZ2VzID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVDaGFuZ2VzKHJlbW90ZVRyZWVTaGEpXG4gICAgICAgIGNvbnN0IGNsYXNoZWRGaWxlcyA9IHRoaXMuZ2V0Q2xhc2hlZENoYW5nZXMobG9jYWxDaGFuZ2VzLCByZW1vdGVDaGFuZ2VzKVxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBjbGFzaGVzIHdpdGhvdXQgY29tcGxldGVseSBibG9ja2luZyBwdWxsXG4gICAgICAgIGNvbnN0IHByZVB1bGxDaGVja1N0YXR1cyA9IChcbiAgICAgICAgICAgIChyZW1vdGVDaGFuZ2VzLmxlbmd0aCA+IDApID8gKFxuICAgICAgICAgICAgICAgIChjbGFzaGVkRmlsZXMubGVuZ3RoID4gMCkgPyBcImxvY2FsQ2hhbmdlc0NsYXNoV2l0aFJlbW90ZUNoYW5nZXNcIiA6IFwicmVtb3RlQ2hhbmdlc0NhbkJlTWVyZ2VkXCIpOlxuICAgICAgICAgICAgICAgIFwibm9SZW1vdGVDaGFuZ2VzRGV0ZWN0ZWRcIilcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHByZVB1bGxDaGVja1N0YXR1cywgXG4gICAgICAgICAgICByZW1vdGVVcGRhdGU6IHtcbiAgICAgICAgICAgICAgICByZW1vdGVDaGFuZ2VzLCByZW1vdGVUcmVlU2hhLCBsYXRlc3RSZW1vdGVDb21taXRTaGEsIGNsYXNoZWRGaWxlc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGNoYW5nZXMgZnJvbSByZW1vdGUsIHBhdGhTaGFNYXAgaXMgY291cGxlZCB0byB0aGUgRml0IHBsdWdpbiBkZXNpZ25cbiAgICBhc3luYyBnZXRSZW1vdGVOb25EZWxldGlvbkNoYW5nZXNDb250ZW50KHBhdGhTaGFNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgICAgICAgY29uc3QgcmVtb3RlQ2hhbmdlcyA9IE9iamVjdC5lbnRyaWVzKHBhdGhTaGFNYXApLm1hcChhc3luYyAoW3BhdGgsIGZpbGVfc2hhXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuZml0LmdldEJsb2IoZmlsZV9zaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHtwYXRoLCBjb250ZW50fTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHJlbW90ZUNoYW5nZXMpXG4gICAgfVxuXG4gICAgYXN5bmMgcHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUocmVtb3RlQ2hhbmdlczogUmVtb3RlQ2hhbmdlW10pIHtcbiAgICAgICAgY29uc3QgZGVsZXRlRnJvbUxvY2FsID0gcmVtb3RlQ2hhbmdlcy5maWx0ZXIoYz0+Yy5zdGF0dXM9PVwiUkVNT1ZFRFwiKS5tYXAoYz0+Yy5wYXRoKVxuXHRcdFx0Y29uc3QgY2hhbmdlc1RvUHJvY2VzcyA9IHJlbW90ZUNoYW5nZXMuZmlsdGVyKGM9PmMuc3RhdHVzIT1cIlJFTU9WRURcIikucmVkdWNlKFxuXHRcdFx0XHQoYWNjLCBjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2NoYW5nZS5wYXRoXSA9IGNoYW5nZS5jdXJyZW50U2hhIGFzIHN0cmluZztcblx0XHRcdFx0XHRyZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pO1xuXG5cdFx0Y29uc3QgYWRkVG9Mb2NhbCA9IGF3YWl0IHRoaXMuZ2V0UmVtb3RlTm9uRGVsZXRpb25DaGFuZ2VzQ29udGVudChjaGFuZ2VzVG9Qcm9jZXNzKVxuICAgICAgICByZXR1cm4ge2FkZFRvTG9jYWwsIGRlbGV0ZUZyb21Mb2NhbH1cbiAgICB9XG5cbiAgICBhc3luYyBwdWxsUmVtb3RlVG9Mb2NhbChcbiAgICAgICAgcmVtb3RlVXBkYXRlOiBSZW1vdGVVcGRhdGUsXG4gICAgICAgIHNhdmVMb2NhbFN0b3JlQ2FsbGJhY2s6IChsb2NhbFN0b3JlOiBQYXJ0aWFsPExvY2FsU3RvcmVzPikgPT4gUHJvbWlzZTx2b2lkPik6IFxuICAgICAgICBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgICAgIGNvbnN0IHtyZW1vdGVDaGFuZ2VzLCByZW1vdGVUcmVlU2hhLCBsYXRlc3RSZW1vdGVDb21taXRTaGF9ID0gcmVtb3RlVXBkYXRlXG4gICAgICAgICAgICBjb25zdCB7YWRkVG9Mb2NhbCwgZGVsZXRlRnJvbUxvY2FsfSA9IGF3YWl0IHRoaXMucHJlcGFyZUNoYW5nZXNUb0V4ZWN1dGUocmVtb3RlQ2hhbmdlcylcblx0XHRcdFxuXHRcdFx0Ly8gVE9ETzogd2hlbiB0aGVyZSBhcmUgY2xhc2hpbmcgbG9jYWwgY2hhbmdlcywgcHJvbXB0IHVzZXIgZm9yIGNvbmZpcm1hdGlvbiBiZWZvcmUgcHJvY2VlZGluZ1xuXHRcdFx0YXdhaXQgdGhpcy52YXVsdE9wcy51cGRhdGVMb2NhbEZpbGVzKGFkZFRvTG9jYWwsIGRlbGV0ZUZyb21Mb2NhbCk7XG5cdFx0XHRhd2FpdCBzYXZlTG9jYWxTdG9yZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZFJlbW90ZVNoYTogcmVtb3RlVHJlZVNoYSwgXG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRDb21taXRTaGE6IGxhdGVzdFJlbW90ZUNvbW1pdFNoYSxcbiAgICAgICAgICAgICAgICBsb2NhbFNoYTogYXdhaXQgdGhpcy5maXQuY29tcHV0ZUxvY2FsU2hhKClcbiAgICAgICAgICAgIH0pXG4gICAgfVxufSIsICJpbXBvcnQgeyBWYXVsdE9wZXJhdGlvbnMgfSBmcm9tIFwiLi92YXVsdE9wc1wiO1xuaW1wb3J0IHsgRml0IH0gZnJvbSBcIi4vZml0XCI7XG5pbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IExvY2FsU3RvcmVzIH0gZnJvbSBcIm1haW5cIjtcblxuZXhwb3J0IHR5cGUgTG9jYWxGaWxlU3RhdHVzID0gXCJkZWxldGVkXCIgfCBcImNyZWF0ZWRcIiB8IFwiY2hhbmdlZFwiXG5cbnR5cGUgUHJlUHVzaENoZWNrUmVzdWx0VHlwZSA9IChcbiAgICBcIm5vTG9jYWxDaGFuZ2VzRGV0ZWN0ZWRcIiB8IFxuICAgIFwicmVtb3RlQ2hhbmdlZFwiIHwgXG4gICAgXCJsb2NhbENoYW5nZXNDYW5CZVB1c2hlZFwiXG4pXG5cbnR5cGUgUHJlUHVzaENoZWNrUmVzdWx0ID0gKFxuICAgIHsgc3RhdHVzOiBcIm5vTG9jYWxDaGFuZ2VzRGV0ZWN0ZWRcIiwgbG9jYWxVcGRhdGU6IG51bGwgfSB8IFxuICAgIHsgc3RhdHVzOiBFeGNsdWRlPFByZVB1c2hDaGVja1Jlc3VsdFR5cGUsIFwibm9Mb2NhbENoYW5nZXNEZXRlY3RlZFwiPiwgbG9jYWxVcGRhdGU6IExvY2FsVXBkYXRlIH1cbik7XG5cbmV4cG9ydCB0eXBlIExvY2FsQ2hhbmdlID0ge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBzdGF0dXM6IExvY2FsRmlsZVN0YXR1cyxcbiAgICBleHRlbnNpb24/IDogc3RyaW5nXG59XG5cbnR5cGUgTG9jYWxVcGRhdGUgPSB7XG4gICAgbG9jYWxDaGFuZ2VzOiBMb2NhbENoYW5nZVtdLFxuICAgIGxvY2FsVHJlZVNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBwYXJlbnRDb21taXRTaGE6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICAgIHZhdWx0T3BzOiBWYXVsdE9wZXJhdGlvbnNcbiAgICBmaXQ6IEZpdFxufVxuXG5leHBvcnQgY2xhc3MgRml0UHVzaCBpbXBsZW1lbnRzIElGaXRQdXNoIHtcbiAgICBsb2NhbFNoYTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB2YXVsdE9wczogVmF1bHRPcGVyYXRpb25zO1xuICAgIGZpdDogRml0XG4gICAgXG5cbiAgICBjb25zdHJ1Y3RvcihmaXQ6IEZpdCwgdmF1bHRPcHM6IFZhdWx0T3BlcmF0aW9ucykge1xuICAgICAgICB0aGlzLnZhdWx0T3BzID0gdmF1bHRPcHNcbiAgICAgICAgdGhpcy5maXQgPSBmaXRcbiAgICB9XG5cblxuICAgIGFzeW5jIHBlcmZvcm1QcmVQdXNoQ2hlY2tzKCk6IFByb21pc2U8UHJlUHVzaENoZWNrUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IGxvY2FsVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmNvbXB1dGVMb2NhbFNoYSgpXG4gICAgICAgIGNvbnN0IGxvY2FsQ2hhbmdlcyA9IGF3YWl0IHRoaXMuZml0LmdldExvY2FsQ2hhbmdlcyhsb2NhbFRyZWVTaGEpXG4gICAgICAgIGlmIChsb2NhbENoYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdHVzOiBcIm5vTG9jYWxDaGFuZ2VzRGV0ZWN0ZWRcIiwgbG9jYWxVcGRhdGU6IG51bGx9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF0ZXN0UmVtb3RlQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5maXQuZ2V0TGF0ZXN0UmVtb3RlQ29tbWl0U2hhKCk7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IChcbiAgICAgICAgICAgIChsYXRlc3RSZW1vdGVDb21taXRTaGEgIT0gdGhpcy5maXQubGFzdEZldGNoZWRDb21taXRTaGEpID8gXG4gICAgICAgICAgICBcInJlbW90ZUNoYW5nZWRcIiA6IFwibG9jYWxDaGFuZ2VzQ2FuQmVQdXNoZWRcIlxuICAgICAgICApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBsb2NhbFVwZGF0ZToge2xvY2FsQ2hhbmdlcywgbG9jYWxUcmVlU2hhLCBwYXJlbnRDb21taXRTaGE6IGxhdGVzdFJlbW90ZUNvbW1pdFNoYX1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZUNvbW1pdEZyb21Mb2NhbFVwZGF0ZShsb2NhbFVwZGF0ZTogTG9jYWxVcGRhdGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB7bG9jYWxDaGFuZ2VzLCBwYXJlbnRDb21taXRTaGF9ID0gbG9jYWxVcGRhdGVcbiAgICAgICAgY29uc3QgdHJlZU5vZGVzID0gYXdhaXQgUHJvbWlzZS5hbGwobG9jYWxDaGFuZ2VzLm1hcCgoZikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZml0LmNyZWF0ZVRyZWVOb2RlRnJvbUZpbGUoZilcbiAgICAgICAgfSkpXG4gICAgICAgIGNvbnN0IGxhdGVzdFJlbW90ZUNvbW1pdFRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5nZXRDb21taXRUcmVlU2hhKHBhcmVudENvbW1pdFNoYSlcbiAgICAgICAgY29uc3QgY3JlYXRlZFRyZWVTaGEgPSBhd2FpdCB0aGlzLmZpdC5jcmVhdGVUcmVlKHRyZWVOb2RlcywgbGF0ZXN0UmVtb3RlQ29tbWl0VHJlZVNoYSlcbiAgICAgICAgY29uc3QgY3JlYXRlZENvbW1pdFNoYSA9IGF3YWl0IHRoaXMuZml0LmNyZWF0ZUNvbW1pdChjcmVhdGVkVHJlZVNoYSwgcGFyZW50Q29tbWl0U2hhKVxuICAgICAgICByZXR1cm4gY3JlYXRlZENvbW1pdFNoYVxuICAgIH1cblxuXG5cbiAgICBhc3luYyBwdXNoQ2hhbmdlZEZpbGVzVG9SZW1vdGUoXG4gICAgICAgIGxvY2FsVXBkYXRlOiBMb2NhbFVwZGF0ZSxcbiAgICAgICAgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjazogKGxvY2FsU3RvcmU6IFBhcnRpYWw8TG9jYWxTdG9yZXM+KSA9PiBQcm9taXNlPHZvaWQ+KTpcbiAgICAgICAgUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgICAgICBjb25zdCB7bG9jYWxDaGFuZ2VzLCBsb2NhbFRyZWVTaGF9ID0gbG9jYWxVcGRhdGU7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVkQ29tbWl0U2hhID0gYXdhaXQgdGhpcy5jcmVhdGVDb21taXRGcm9tTG9jYWxVcGRhdGUobG9jYWxVcGRhdGUpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVmU2hhID0gYXdhaXQgdGhpcy5maXQudXBkYXRlUmVmKGNyZWF0ZWRDb21taXRTaGEpXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmVtb3RlVHJlZVNoYSA9IGF3YWl0IHRoaXMuZml0LmdldFJlbW90ZVRyZWVTaGEodXBkYXRlZFJlZlNoYSlcblxuICAgICAgICAgICAgYXdhaXQgc2F2ZUxvY2FsU3RvcmVDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgbGFzdEZldGNoZWRSZW1vdGVTaGE6IHVwZGF0ZWRSZW1vdGVUcmVlU2hhLCBcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2hlZENvbW1pdFNoYTogY3JlYXRlZENvbW1pdFNoYSxcbiAgICAgICAgICAgICAgICBsb2NhbFNoYTogbG9jYWxUcmVlU2hhXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBsb2NhbENoYW5nZXMubWFwKCh7cGF0aCwgc3RhdHVzfSk6IHZvaWQ9PntcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNUb0FjdGlvbiA9IHtkZWxldGVkOiBcImRlbGV0ZWQgZnJvbVwiLCBjcmVhdGVkOiBcImFkZGVkIHRvXCIsIGNoYW5nZWQ6IFwibW9kaWZpZWQgb25cIn1cbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGAke3BhdGh9ICR7c3RhdHVzVG9BY3Rpb25bc3RhdHVzXX0gcmVtb3RlLmAsIDEwMDAwKVxuICAgICAgICAgICAgfSlcbiAgICB9XG59IiwgImltcG9ydCBGaXRQbHVnaW4gZnJvbSBcIm1haW5cIjtcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgc2V0RXF1YWwgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gXCJjb25zb2xlXCI7XG5cbnR5cGUgUmVmcmVzaENoZWNrUG9pbnQgPSBcInJlcG8oMClcIiB8IFwiYnJhbmNoKDEpXCIgfCBcImxpbmsoMilcIiB8IFwiaW5pdGlhbGl6ZVwiIHwgXCJ3aXRoQ2FjaGVcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXRTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG5cdHBsdWdpbjogRml0UGx1Z2luO1xuXHRhdXRoZW50aWNhdGluZzogYm9vbGVhbjtcblx0YXV0aFVzZXJBdmF0YXI6IEhUTUxEaXZFbGVtZW50O1xuXHRhdXRoVXNlckhhbmRsZTogSFRNTFNwYW5FbGVtZW50O1xuXHRwYXRTZXR0aW5nOiBTZXR0aW5nXG5cdG93bmVyU2V0dGluZzogU2V0dGluZ1xuXHRyZXBvU2V0dGluZzogU2V0dGluZ1xuXHRicmFuY2hTZXR0aW5nOiBTZXR0aW5nXG5cdGV4aXN0aW5nUmVwb3M6IEFycmF5PHN0cmluZz47XG5cdGV4aXN0aW5nQnJhbmNoZXM6IEFycmF5PHN0cmluZz47XG5cdHJlcG9MaW5rOiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRml0UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdHRoaXMucmVwb0xpbmsgPSB0aGlzLmdldExhdGVzdExpbmsoKTtcblx0XHR0aGlzLmF1dGhlbnRpY2F0aW5nID0gZmFsc2Vcblx0XHR0aGlzLmV4aXN0aW5nUmVwb3MgPSBbXVxuXHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcyA9IFtdXG5cdH1cblxuXHRnZXRMYXRlc3RMaW5rID0gKCk6IHN0cmluZyA9PiB7XG5cdFx0Y29uc3Qge293bmVyLCByZXBvLCBicmFuY2h9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3M7XG5cdFx0aWYgKG93bmVyLmxlbmd0aCA+IDAgJiYgcmVwby5sZW5ndGggPiAwICYmIGJyYW5jaC5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4gYGh0dHBzOi8vZ2l0aHViLmNvbS8ke293bmVyfS8ke3JlcG99L3RyZWUvJHticmFuY2h9YFxuXHRcdH1cblx0XHRyZXR1cm4gXCJcIlxuXHR9XG5cblx0aGFuZGxlVXNlckZldGNoID0gYXN5bmMgKCkgPT4ge1xuXHRcdHRoaXMuYXV0aGVudGljYXRpbmcgPSB0cnVlXG5cdFx0dGhpcy5hdXRoVXNlckF2YXRhci5yZW1vdmVDbGFzcygnZXJyb3InKVxuXHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIuZW1wdHkoKVxuXHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIucmVtb3ZlQ2xhc3MoJ2VtcHR5Jylcblx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLmFkZENsYXNzKCdjYXQnKVxuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCB7b3duZXIsIGF2YXRhclVybH0gPSBhd2FpdCB0aGlzLnBsdWdpbi5maXQuZ2V0VXNlcigpO1xuXHRcdFx0dGhpcy5hdXRoVXNlckF2YXRhci5yZW1vdmVDbGFzcygnY2F0Jylcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIuY3JlYXRlRWwoJ2ltZycsIHsgYXR0cjogeyBzcmM6IGF2YXRhclVybCB9IH0pO1xuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZS5zZXRUZXh0KG93bmVyKVxuXHRcdFx0aWYgKG93bmVyICE9PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lcikge1xuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lciA9IG93bmVyXG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmF2YXRhclVybCA9IGF2YXRhclVybFxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvID0gXCJcIlxuXHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2ggPSBcIlwiXG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcyA9IFtdXG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdSZXBvcyA9IFtdXG5cdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hGaWVsZHMoJ3JlcG8oMCknKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYXV0aGVudGljYXRpbmcgPSBmYWxzZVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmF1dGhVc2VyQXZhdGFyLnJlbW92ZUNsYXNzKCdjYXQnKVxuXHRcdFx0dGhpcy5hdXRoVXNlckF2YXRhci5hZGRDbGFzcygnZXJyb3InKVxuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZS5zZXRUZXh0KFwiQXV0aGVudGljYXRpb24gZmFpbGVkLCBtYWtlIHN1cmUgeW91ciB0b2tlbiBoYXMgbm90IGV4cGlyZWQuXCIpXG5cdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lciA9IFwiXCJcblx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmF2YXRhclVybCA9IFwiXCJcblx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8gPSBcIlwiXG5cdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2ggPSBcIlwiXG5cdFx0XHR0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBbXVxuXHRcdFx0dGhpcy5leGlzdGluZ1JlcG9zID0gW11cblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0dGhpcy5yZWZyZXNoRmllbGRzKCdpbml0aWFsaXplJyk7XG5cdFx0XHR0aGlzLmF1dGhlbnRpY2F0aW5nID0gZmFsc2Vcblx0XHR9XG5cdH1cblxuXHRnaXRodWJVc2VySW5mb0Jsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuXHRcdC5zZXROYW1lKFwiR2l0SHViIHVzZXIgaW5mb1wiKVxuXHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0LnNldEN0YSgpXG5cdFx0XHQuc2V0QnV0dG9uVGV4dChcIkF1dGhlbnRpY2F0ZSB1c2VyXCIpXG5cdFx0XHQuc2V0RGlzYWJsZWQodGhpcy5hdXRoZW50aWNhdGluZylcblx0XHRcdC5vbkNsaWNrKGFzeW5jICgpPT57XG5cdFx0XHRcdGlmICh0aGlzLmF1dGhlbnRpY2F0aW5nKSByZXR1cm5cblx0XHRcdFx0YXdhaXQgdGhpcy5oYW5kbGVVc2VyRmV0Y2goKVxuXHRcdFx0fSkpXG5cdFx0dGhpcy5vd25lclNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXREZXNjKFwiSW5wdXQgeW91ciBwZXJzb25hbCBhY2Nlc3MgdG9rZW4gYmVsb3cgdG8gZ2V0IGF1dGhlbnRpY2F0ZWQuIENyZWF0ZSBhIEdpdEh1YiBhY2NvdW50IGhlcmUgaWYgeW91IGRvbid0IGhhdmUgb25lIHlldC5cIilcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b249PmJ1dHRvblxuXHRcdFx0XHQuc2V0SWNvbignZ2l0aHViJylcblx0XHRcdFx0LnNldFRvb2x0aXAoXCJTaWduIHVwIG9uIGdpdGh1Yi5jb21cIilcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCk9Pntcblx0XHRcdFx0XHR3aW5kb3cub3BlbihcImh0dHBzOi8vZ2l0aHViLmNvbS9zaWdudXBcIiwgXCJfYmxhbmtcIilcblx0XHRcdFx0fSkpXG5cdFx0dGhpcy5vd25lclNldHRpbmcubmFtZUVsLmFkZENsYXNzKCdmaXQtYXZhdGFyLWNvbnRhaW5lcicpO1xuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lciA9PT0gXCJcIikge1xuXHRcdFx0dGhpcy5hdXRoVXNlckF2YXRhciA9IHRoaXMub3duZXJTZXR0aW5nLm5hbWVFbC5jcmVhdGVEaXYoXG5cdFx0XHRcdHtjbHM6ICdmaXQtYXZhdGFyLWNvbnRhaW5lciBlbXB0eSd9KVxuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZSA9IHRoaXMub3duZXJTZXR0aW5nLm5hbWVFbC5jcmVhdGVFbCgnc3BhbicsIHtjbHM6ICdmaXQtZ2l0aHViLWhhbmRsZSd9KVxuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZS5zZXRUZXh0KFwiVW5hdXRoZW50aWNhdGVkXCIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIgPSB0aGlzLm93bmVyU2V0dGluZy5uYW1lRWwuY3JlYXRlRGl2KFxuXHRcdFx0XHR7Y2xzOiAnZml0LWF2YXRhci1jb250YWluZXInfSlcblx0XHRcdHRoaXMuYXV0aFVzZXJBdmF0YXIuY3JlYXRlRWwoJ2ltZycsIHsgYXR0cjogeyBzcmM6IHRoaXMucGx1Z2luLnNldHRpbmdzLmF2YXRhclVybCB9IH0pO1xuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZSA9IHRoaXMub3duZXJTZXR0aW5nLm5hbWVFbC5jcmVhdGVFbCgnc3BhbicsIHtjbHM6ICdmaXQtZ2l0aHViLWhhbmRsZSd9KVxuXHRcdFx0dGhpcy5hdXRoVXNlckhhbmRsZS5zZXRUZXh0KHRoaXMucGx1Z2luLnNldHRpbmdzLm93bmVyKVxuXHRcdH1cblx0XHQvLyBoaWRlIHRoZSBjb250cm9sIGVsZW1lbnQgdG8gbWFrZSBzcGFjZSBmb3IgYXV0aFVzZXJcblx0XHR0aGlzLm93bmVyU2V0dGluZy5jb250cm9sRWwuYWRkQ2xhc3MoJ2ZpdC1hdmF0YXItZGlzcGxheS10ZXh0Jyk7XG5cblx0XHR0aGlzLnBhdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdHaXRodWIgcGVyc29uYWwgYWNjZXNzIHRva2VuJylcblx0XHRcdC5zZXREZXNjKCdSZW1lbWJlciB0byBnaXZlIGl0IGFjY2VzcyBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgc3RvcmFnZSByZXBvLicpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdHaXRIdWIgcGVyc29uYWwgYWNjZXNzIHRva2VuJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBhdClcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnBhdCA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSlcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b249PmJ1dHRvblxuXHRcdFx0XHQuc2V0SWNvbignZXh0ZXJuYWwtbGluaycpXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiQ3JlYXRlIGEgdG9rZW5cIilcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCk9Pntcblx0XHRcdFx0XHR3aW5kb3cub3BlbihcImh0dHBzOi8vZ2l0aHViLmNvbS9zZXR0aW5ncy90b2tlbnMvbmV3XCIsICdfYmxhbmsnKTtcblx0XHRcdFx0fSkpXG5cdH1cblxuXHRyZXBvSW5mb0Jsb2NrID0gYXN5bmMgKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiUmVwb3NpdG9yeSBpbmZvXCIpXG5cdFx0LnNldERlc2MoXCJSZWZyZXNoIHRvIHJldHJpZXZlIHRoZSBsYXRlc3QgbGlzdCBvZiByZXBvcyBhbmQgYnJhbmNoZXMuXCIpXG5cdFx0LmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdC5zZXRUb29sdGlwKFwiUmVmcmVzaCByZXBvcyBhbmQgYnJhbmNoZXMgbGlzdFwiKVxuXHRcdFx0LnNldERpc2FibGVkKHRoaXMucGx1Z2luLnNldHRpbmdzLm93bmVyID09PSBcIlwiKVxuXHRcdFx0LnNldEljb24oJ3JlZnJlc2gtY3cnKVxuXHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnJlZnJlc2hGaWVsZHMoJ3JlcG8oMCknKTtcblx0XHRcdH0pKVxuXHRcdFx0XG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0RGVzYyhcIlNlbGVjdCAnQWRkIGEgUkVBRE1FIGZpbGUnIGlmIGNyZWF0aW5nIGEgbmV3IHJlcG8uIE1ha2Ugc3VyZSB5b3UgYXJlIGxvZ2dlZCBpbiB0byBnaXRodWIgb24geW91ciBicm93c2VyLlwiKVxuXHRcdFx0LmFkZEV4dHJhQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEljb24oJ2dpdGh1YicpXG5cdFx0XHRcdC5zZXRUb29sdGlwKFwiQ3JlYXRlIGEgbmV3IHJlcG9zaXRvcnlcIilcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdHdpbmRvdy5vcGVuKGBodHRwczovL2dpdGh1Yi5jb20vbmV3YCwgJ19ibGFuaycpO1xuXHRcdFx0XHR9KSlcblx0XHRcdFx0XG5cdFx0Ly8gdGhpcy5leGlzdGluZ0JyYW5jaGVzID0gYXdhaXQgdGhpcy5wbHVnaW4uZml0LmdldEJyYW5jaGVzKCk7XG5cdFx0Ly8gdGhpcy5leGlzdGluZ1JlcG9zID0gYXdhaXQgdGhpcy5wbHVnaW4uZml0LmdldFJlcG9zKCk7XG5cdFx0dGhpcy5yZXBvU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0dpdGh1YiByZXBvc2l0b3J5IG5hbWUnKVxuXHRcdFx0LnNldERlc2MoXCJTZWxlY3QgYSByZXBvIHRvIHN5bmMgeW91ciB2YXVsdC5cIilcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG5cdFx0XHRcdGRyb3Bkb3duLnNlbGVjdEVsLmFkZENsYXNzKCdyZXBvLWRyb3Bkb3duJyk7XG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdSZXBvcy5tYXAocmVwbz0+ZHJvcGRvd24uYWRkT3B0aW9uKHJlcG8sIHJlcG8pKVxuXHRcdFx0XHRkcm9wZG93bi5zZXREaXNhYmxlZCh0aGlzLmV4aXN0aW5nUmVwb3MubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKVxuXHRcdFx0XHRkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjb25zdCByZXBvQ2hhbmdlZCA9IHZhbHVlICE9PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvXG5cdFx0XHRcdFx0aWYgKHJlcG9DaGFuZ2VkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaEZpZWxkcygnYnJhbmNoKDEpJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fSlcblxuXHRcdHRoaXMuYnJhbmNoU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0JyYW5jaCBuYW1lJylcblx0XHRcdC5zZXREZXNjKCdTZWxlY3QgYSByZXBvIGFib3ZlIHRvIHZpZXcgZXhpc3RpbmcgYnJhbmNoZXMuJylcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XG5cdFx0XHRcdGRyb3Bkb3duLnNlbGVjdEVsLmFkZENsYXNzKCdicmFuY2gtZHJvcGRvd24nKTtcblx0XHRcdFx0ZHJvcGRvd24uc2V0RGlzYWJsZWQodGhpcy5leGlzdGluZ0JyYW5jaGVzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5leGlzdGluZ0JyYW5jaGVzLm1hcChyZXBvPT5kcm9wZG93bi5hZGRPcHRpb24ocmVwbywgcmVwbykpXG5cdFx0XHRcdGRyb3Bkb3duLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaClcblx0XHRcdFx0ZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYnJhbmNoQ2hhbmdlZCA9IHZhbHVlICE9PSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2hcblx0XHRcdFx0XHRpZiAoYnJhbmNoQ2hhbmdlZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaEZpZWxkcygnbGluaygyKScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0pXG5cdH1cblxuXHR2aWV3TGlua0Jsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXHRcdHRoaXMucmVwb0xpbmsgPSB0aGlzLmdldExhdGVzdExpbmsoKVxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKCkuc2V0TmFtZShcIkxpbmtcIik7XG5cdFx0Y29uc3QgbGlua0Rpc3BsYXkgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiVmlldyB5b3VyIHZhdWx0IG9uIEdpdEh1YlwiKVxuXHRcdFx0LnNldERlc2ModGhpcy5yZXBvTGluaylcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXRJY29uKCdyZWZyZXNoLWN3Jylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHRoaXMuZ2V0TGF0ZXN0TGluaygpKVxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucmVmcmVzaEZpZWxkcygnbGluaygyKScpO1xuXHRcdFx0XHR9KSlcblx0XHRcdC5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG5cdFx0XHRcdC5zZXREaXNhYmxlZCh0aGlzLnJlcG9MaW5rLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0LnNldFRvb2x0aXAoXCJPcGVuIG9uIEdpdEh1YlwiKVxuXHRcdFx0XHQuc2V0SWNvbignZXh0ZXJuYWwtbGluaycpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhgb3BlbmluZyAke3RoaXMucmVwb0xpbmt9YClcblx0XHRcdFx0XHR3aW5kb3cub3Blbih0aGlzLnJlcG9MaW5rLCAnX2JsYW5rJyk7XG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0bGlua0Rpc3BsYXkuZGVzY0VsLmFkZENsYXNzKFwibGluay1kZXNjXCIpXG5cdH1cblxuXHRsb2NhbENvbmZpZ0Jsb2NrID0gKCkgPT4ge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTG9jYWwgY29uZmlndXJhdGlvbnNcIik7XHRcdFxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ0RldmljZSBuYW1lJylcblx0XHRcdC5zZXREZXNjKCdTaWduIGNvbW1pdCBtZXNzYWdlIHdpdGggdGhpcyBkZXZpY2UgbmFtZS4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRGV2aWNlIG5hbWUnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGV2aWNlTmFtZSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmRldmljZU5hbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU2luZ2xlIGJ1dHRvbiBtb2RlJylcblx0XHRcdC5zZXREZXNjKCdTaW5nbGUgYnV0dG9uIHRvIHN5bmMgeW91ciByZXBvIHRvIGdpdGh1YiAoSW4gZWFybHkgYWxwaGEsIHBsZWFzZSBmaWxlIGFuIGlzc3VlIGlmIHlvdSBlbmNvdW50ZXIgZXJyb3Igd2l0aCBzdGVwcyB0byByZXByb2R1Y2UpLicpXG5cdFx0XHQuYWRkVG9nZ2xlKHNlbGVjdGVkPT5zZWxlY3RlZFxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2luZ2xlQnV0dG9uTW9kZSlcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jIChzZWxlY3RlZCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnNpbmdsZUJ1dHRvbk1vZGUgPSBzZWxlY3RlZDtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSlcblx0XHRcdClcblxuXHRcdGNvbnN0IGNoZWNrSW50ZXJ2YWxTbGlkZXIgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdSZW1vdGUgY2hlY2sgaW50ZXJ2YWwnKVxuXHRcdFx0LnNldERlc2MoYEF1dG9tYXRpY2FsbHkgY2hlY2sgZm9yIHJlbW90ZSBjaGFuZ2VzIGluIHRoZSBiYWNrZ3JvdW5kIGV2ZXJ5ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MuY2hlY2tFdmVyeVhNaW51dGVzfSBtaW51dGVzLmApXG5cdFx0XHQuYWRkU2xpZGVyKHNsaWRlciA9PiBzbGlkZXJcblx0XHRcdFx0LnNldExpbWl0cygxLCA2MCwgMSlcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNoZWNrRXZlcnlYTWludXRlcylcblx0XHRcdFx0LnNldER5bmFtaWNUb29sdGlwKClcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmNoZWNrRXZlcnlYTWludXRlcyA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdGNoZWNrSW50ZXJ2YWxTbGlkZXIuc2V0RGVzYyhgQXV0b21hdGljYWxseSBjaGVjayBmb3IgcmVtb3RlIGNoYW5nZXMgaW4gdGhlIGJhY2tncm91bmQgZXZlcnkgJHt2YWx1ZX0gbWludXRlcy5gKVxuXHRcdFx0XHR9KVxuXHRcdFx0KVxuXHR9XG5cblx0cmVmcmVzaEZpZWxkcyA9IGFzeW5jIChyZWZyZXNoRnJvbTogUmVmcmVzaENoZWNrUG9pbnQpID0+IHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpc1xuXHRcdGNvbnN0IHJlcG9fZHJvcGRvd24gPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcucmVwby1kcm9wZG93bicpIGFzIEhUTUxTZWxlY3RFbGVtZW50XG5cdFx0Y29uc3QgYnJhbmNoX2Ryb3Bkb3duID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmJyYW5jaC1kcm9wZG93bicpIGFzIEhUTUxTZWxlY3RFbGVtZW50XG5cdFx0Y29uc3QgbGlua19lbCA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5saW5rLWRlc2MnKSBhcyBIVE1MRWxlbWVudFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJyZXBvKDApXCIpIHtcblx0XHRcdHJlcG9fZHJvcGRvd24uZGlzYWJsZWQgPSB0cnVlXG5cdFx0XHRicmFuY2hfZHJvcGRvd24uZGlzYWJsZWQgPSB0cnVlXG5cdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MgPSBhd2FpdCB0aGlzLnBsdWdpbi5maXQuZ2V0UmVwb3MoKTtcblx0XHRcdGNvbnN0IHJlcG9PcHRpb25zID0gQXJyYXkuZnJvbShyZXBvX2Ryb3Bkb3duLm9wdGlvbnMpLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblx0XHRcdGlmICghc2V0RXF1YWw8c3RyaW5nPih0aGlzLmV4aXN0aW5nUmVwb3MsIHJlcG9PcHRpb25zKSkge1xuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdFx0dGhpcy5leGlzdGluZ1JlcG9zLm1hcChyZXBvID0+IHtcblx0XHRcdFx0XHRyZXBvX2Ryb3Bkb3duLmFkZChuZXcgT3B0aW9uKHJlcG8sIHJlcG8pKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gaWYgb3JpZ2luYWwgcmVwbyBub3QgaW4gdGhlIHVwZGF0ZWQgZXhpc3RpbmcgcmVwbywgLTEgd2lsbCBiZSByZXR1cm5lZFxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZFJlcG9JbmRleCA9IHRoaXMuZXhpc3RpbmdSZXBvcy5pbmRleE9mKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8pO1xuXHRcdFx0XHQvLyBzZXR0aW5nIHNlbGVjdGVkSW5kZXggdG8gLTEgdG8gaW5kaWNhdGUgbm8gb3B0aW9ucyBzZWxlY3RlZFxuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZFJlcG9JbmRleCBcblx0XHRcdFx0aWYgKHNlbGVjdGVkUmVwb0luZGV4PT09LTEpe1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG8gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcG9fZHJvcGRvd24uZGlzYWJsZWQgPSBmYWxzZVxuXHRcdH1cblx0XHRpZiAocmVmcmVzaEZyb20gPT09IFwiYnJhbmNoKDEpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwicmVwbygwKVwiKSB7XG5cdFx0XHRpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwbyA9PT0gXCJcIikge1xuXHRcdFx0XHRicmFuY2hfZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbGF0ZXN0QnJhbmNoZXMgPSBhd2FpdCB0aGlzLnBsdWdpbi5maXQuZ2V0QnJhbmNoZXMoKTtcblx0XHRcdFx0aWYgKCFzZXRFcXVhbDxzdHJpbmc+KHRoaXMuZXhpc3RpbmdCcmFuY2hlcywgbGF0ZXN0QnJhbmNoZXMpKSB7XG5cdFx0XHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdFx0XHR0aGlzLmV4aXN0aW5nQnJhbmNoZXMgPSBsYXRlc3RCcmFuY2hlc1xuXHRcdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5tYXAoYnJhbmNoID0+IHtcblx0XHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5hZGQobmV3IE9wdGlvbihicmFuY2gsIGJyYW5jaCkpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ly8gaWYgb3JpZ2luYWwgYnJhbmNoIG5vdCBpbiB0aGUgdXBkYXRlZCBleGlzdGluZyBicmFuY2gsIC0xIHdpbGwgYmUgcmV0dXJuZWRcblx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZEJyYW5jaEluZGV4ID0gdGhpcy5leGlzdGluZ0JyYW5jaGVzLmluZGV4T2YodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKTtcblx0XHRcdFx0XHQvLyBzZXR0aW5nIHNlbGVjdGVkSW5kZXggdG8gLTEgdG8gaW5kaWNhdGUgbm8gb3B0aW9ucyBzZWxlY3RlZFxuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRCcmFuY2hJbmRleFxuXHRcdFx0XHRcdGlmIChzZWxlY3RlZEJyYW5jaEluZGV4PT09LTEpe1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoID0gXCJcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmRpc2FibGVkID0gZmFsc2Vcblx0XHR9IFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJsaW5rKDIpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwiYnJhbmNoKDEpXCIgfHwgcmVmcmVzaEZyb20gPT09IFwicmVwbygwKVwiKSB7XG5cdFx0XHR0aGlzLnJlcG9MaW5rID0gdGhpcy5nZXRMYXRlc3RMaW5rKCk7XG5cdFx0XHRsaW5rX2VsLmlubmVyVGV4dCA9IHRoaXMucmVwb0xpbmtcblx0XHR9IFxuXHRcdGlmIChyZWZyZXNoRnJvbSA9PT0gXCJpbml0aWFsaXplXCIpIHtcblx0XHRcdGNvbnN0IHtyZXBvLCBicmFuY2h9ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Ncblx0XHRcdHJlcG9fZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdHJlcG9fZHJvcGRvd24uYWRkKG5ldyBPcHRpb24ocmVwbywgcmVwbykpXG5cdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24oYnJhbmNoLCBicmFuY2gpKVxuXHRcdFx0bGlua19lbC5pbm5lclRleHQgPSB0aGlzLmdldExhdGVzdExpbmsoKVxuXHRcdH1cblx0XHRpZiAocmVmcmVzaEZyb20gPT09IFwid2l0aENhY2hlXCIpIHtcblx0XHRcdHJlcG9fZHJvcGRvd24uZW1wdHkoKVxuXHRcdFx0YnJhbmNoX2Ryb3Bkb3duLmVtcHR5KClcblx0XHRcdGlmICh0aGlzLmV4aXN0aW5nUmVwb3MubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLmV4aXN0aW5nUmVwb3MubWFwKHJlcG8gPT4ge1xuXHRcdFx0XHRcdHJlcG9fZHJvcGRvd24uYWRkKG5ldyBPcHRpb24ocmVwbywgcmVwbykpXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSB0aGlzLmV4aXN0aW5nUmVwb3MuaW5kZXhPZih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5tYXAoYnJhbmNoID0+IHtcblx0XHRcdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24oYnJhbmNoLCBicmFuY2gpKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gLTFcblx0XHRcdFx0fVxuXHRcdFx0XHRicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9IHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5pbmRleE9mKHRoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaClcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvICE9PSBcIlwiKSB7XG5cdFx0XHRcdGlmICh0aGlzLmV4aXN0aW5nUmVwb3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmVwb19kcm9wZG93bi5hZGQobmV3IE9wdGlvbih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXBvX2Ryb3Bkb3duLnNlbGVjdGVkSW5kZXggPSB0aGlzLmV4aXN0aW5nUmVwb3MuaW5kZXhPZih0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXBvKVxuXHRcdFx0XHRcdGlmIChicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHdhcm4oYHdhcm5pbmc6IHNlbGVjdGVkIGJyYW5jaCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaH0gbm90IGZvdW5kLCBleGlzdGluZyBicmFuY2hlczogJHt0aGlzLmV4aXN0aW5nQnJhbmNoZXN9YClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2ggIT09IFwiXCIpIHtcblx0XHRcdFx0aWYgKHRoaXMuZXhpc3RpbmdCcmFuY2hlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRicmFuY2hfZHJvcGRvd24uYWRkKG5ldyBPcHRpb24odGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5icmFuY2gpKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyYW5jaF9kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gdGhpcy5leGlzdGluZ0JyYW5jaGVzLmluZGV4T2YodGhpcy5wbHVnaW4uc2V0dGluZ3MuYnJhbmNoKVxuXHRcdFx0XHRcdGlmIChicmFuY2hfZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHdhcm4oYHdhcm5pbmc6IHNlbGVjdGVkIGJyYW5jaCAke3RoaXMucGx1Z2luLnNldHRpbmdzLmJyYW5jaH0gbm90IGZvdW5kLCBleGlzdGluZyBicmFuY2hlczogJHt0aGlzLmV4aXN0aW5nQnJhbmNoZXN9YClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0dGhpcy5naXRodWJVc2VySW5mb0Jsb2NrKClcblx0XHR0aGlzLnJlcG9JbmZvQmxvY2soKVxuXHRcdHRoaXMudmlld0xpbmtCbG9jaygpXG5cdFx0dGhpcy5sb2NhbENvbmZpZ0Jsb2NrKClcblx0XHR0aGlzLnJlZnJlc2hGaWVsZHMoXCJ3aXRoQ2FjaGVcIilcblx0fVxufSIsICJpbXBvcnQgeyB3YXJuIH0gZnJvbSBcImNvbnNvbGVcIjtcbmltcG9ydCB7IE5vdGljZSwgVEZpbGUsIFZhdWx0LCBiYXNlNjRUb0FycmF5QnVmZmVyIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZhdWx0T3BlcmF0aW9ucyB7XG4gICAgdmF1bHQ6IFZhdWx0XG4gICAgbm90aWNlRHVyYXRpb246IG51bWJlclxuICAgIGRlbGV0ZUZyb21Mb2NhbDogKHBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuICAgIHdyaXRlVG9Mb2NhbDogKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbmV4cG9ydCBjbGFzcyBWYXVsdE9wZXJhdGlvbnMgaW1wbGVtZW50cyBJVmF1bHRPcGVyYXRpb25zIHtcbiAgICB2YXVsdDogVmF1bHRcbiAgICBub3RpY2VEdXJhdGlvbjogbnVtYmVyXG5cbiAgICBjb25zdHJ1Y3Rvcih2YXVsdDogVmF1bHQpIHtcbiAgICAgICAgdGhpcy52YXVsdCA9IHZhdWx0XG4gICAgICAgIHRoaXMubm90aWNlRHVyYXRpb24gPSAxMDAwMFxuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZUZyb21Mb2NhbChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gYWRvcHRlZCBnZXRBYnN0cmFjdEZpbGVCeVBhdGggZm9yIG1vYmlsZSBjb21wYXRpYWJpbGl0eVxuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aClcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0LmRlbGV0ZShmaWxlKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7cGF0aH0gZGVsZXRlZCBmcm9tIGxvY2FsIGRyaXZlLmAsIHRoaXMubm90aWNlRHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gXG4gICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gZGVsZXRlICR7cGF0aH0gZnJvbSBsb2NhbCBidXQgbm90IHN1Y2Nlc3NmdWwsIGZpbGUgaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfS5gKVxuICAgIH1cblxuICAgIGFzeW5jIGVuc3VyZUZvbGRlckV4aXN0cyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gZXh0cmFjdCBmb2xkZXIgcGF0aCwgcmV0dXJuIGVtcHR5IHN0cmluZyBpcyBubyBmb2xkZXIgcGF0aCBpcyBtYXRjaGVkIChleGNsdWRlIHRoZSBsYXN0IC8pXG4gICAgICAgIGNvbnN0IGZvbGRlclBhdGggPSBwYXRoLm1hdGNoKC9eKC4qKVxcLy8pPy5bMV0gfHwgJyc7XG4gICAgICAgIGlmIChmb2xkZXJQYXRoICE9IFwiXCIgJiYgISh0aGlzLnZhdWx0LmdldEZvbGRlckJ5UGF0aChmb2xkZXJQYXRoKSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQuY3JlYXRlRm9sZGVyKGZvbGRlclBhdGgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB3cml0ZVRvTG9jYWwocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gYWRvcHRlZCBnZXRBYnN0cmFjdEZpbGVCeVBhdGggZm9yIG1vYmlsZSBjb21wYXRpYWJpbGl0eVxuICAgICAgICAvLyBUT0RPOiBhZGQgY2FwYWJpbGl0eSBmb3IgY3JlYXRpbmcgZm9sZGVyIGZyb20gcmVtb3RlXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuICAgICAgICBpZiAoZmlsZSAmJiBmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudmF1bHQubW9kaWZ5QmluYXJ5KGZpbGUsIGJhc2U2NFRvQXJyYXlCdWZmZXIoY29udGVudCkpXG4gICAgICAgIH0gZWxzZSBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlRm9sZGVyRXhpc3RzKHBhdGgpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnZhdWx0LmNyZWF0ZUJpbmFyeShwYXRoLCBiYXNlNjRUb0FycmF5QnVmZmVyKGNvbnRlbnQpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybihgJHtwYXRofSB3cml0ZVRvTG9jYWwgb3BlcmF0aW9uIHVuc3VjY2Vzc2Z1bCwgdmF1bHQgYWJzdHJhY3RGaWxlIG9uICR7cGF0aH0gaXMgb2YgdHlwZSAke3R5cGVvZiBmaWxlfWApO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBOb3RpY2UoYCR7cGF0aH0gJHtmaWxlID8gJ3VwZGF0ZWQnIDogJ2NvcGllZCd9IHRvIGxvY2FsIGRyaXZlLmAsIHRoaXMubm90aWNlRHVyYXRpb24pO1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVMb2NhbEZpbGVzKFxuICAgICAgICBhZGRUb0xvY2FsOiB7cGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9W10sIFxuICAgICAgICBkZWxldGVGcm9tTG9jYWw6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZmlsZSBhZGRpdGlvbnMgb3IgdXBkYXRlc1xuICAgICAgICAgICAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gYWRkVG9Mb2NhbC5tYXAoYXN5bmMgKHtwYXRoLCBjb250ZW50fSkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVUb0xvY2FsKHBhdGgsIGNvbnRlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGZpbGUgZGVsZXRpb25zXG4gICAgICAgICAgICBjb25zdCBkZWxldGlvbk9wZXJhdGlvbnMgPSBkZWxldGVGcm9tTG9jYWwubWFwKGFzeW5jIChwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVGcm9tTG9jYWwocGF0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLndyaXRlT3BlcmF0aW9ucywgLi4uZGVsZXRpb25PcGVyYXRpb25zXSk7XG4gICAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUEyQzs7O0FDQXBDLFNBQVMsZUFBZTtBQUM3QixNQUFJLE9BQU8sY0FBYyxZQUFZLGVBQWUsV0FBVztBQUM3RCxXQUFPLFVBQVU7QUFBQSxFQUNuQjtBQUVBLE1BQUksT0FBTyxZQUFZLFlBQVksUUFBUSxZQUFZLFFBQVc7QUFDaEUsV0FBTyxXQUFXLFFBQVEsUUFBUSxPQUFPLENBQUMsTUFBTSxRQUFRLGFBQ3RELFFBQVE7QUFBQSxFQUVaO0FBRUEsU0FBTztBQUNUOzs7QUNWTyxTQUFTLFNBQVMsT0FBTyxNQUFNLFFBQVEsU0FBUztBQUNyRCxNQUFJLE9BQU8sV0FBVyxZQUFZO0FBQ2hDLFVBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLEVBQzdEO0FBRUEsTUFBSSxDQUFDLFNBQVM7QUFDWixjQUFVLENBQUM7QUFBQSxFQUNiO0FBRUEsTUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3ZCLFdBQU8sS0FBSyxRQUFRLEVBQUUsT0FBTyxDQUFDLFVBQVVDLFVBQVM7QUFDL0MsYUFBTyxTQUFTLEtBQUssTUFBTSxPQUFPQSxPQUFNLFVBQVUsT0FBTztBQUFBLElBQzNELEdBQUcsTUFBTSxFQUFFO0FBQUEsRUFDYjtBQUVBLFNBQU8sUUFBUSxRQUFRLEVBQUUsS0FBSyxNQUFNO0FBQ2xDLFFBQUksQ0FBQyxNQUFNLFNBQVMsSUFBSSxHQUFHO0FBQ3pCLGFBQU8sT0FBTyxPQUFPO0FBQUEsSUFDdkI7QUFFQSxXQUFPLE1BQU0sU0FBUyxJQUFJLEVBQUUsT0FBTyxDQUFDQyxTQUFRLGVBQWU7QUFDekQsYUFBTyxXQUFXLEtBQUssS0FBSyxNQUFNQSxTQUFRLE9BQU87QUFBQSxJQUNuRCxHQUFHLE1BQU0sRUFBRTtBQUFBLEVBQ2IsQ0FBQztBQUNIOzs7QUN4Qk8sU0FBUyxRQUFRLE9BQU8sTUFBTSxNQUFNQyxPQUFNO0FBQy9DLFFBQU0sT0FBT0E7QUFDYixNQUFJLENBQUMsTUFBTSxTQUFTLElBQUksR0FBRztBQUN6QixVQUFNLFNBQVMsSUFBSSxJQUFJLENBQUM7QUFBQSxFQUMxQjtBQUVBLE1BQUksU0FBUyxVQUFVO0FBQ3JCLElBQUFBLFFBQU8sQ0FBQyxRQUFRLFlBQVk7QUFDMUIsYUFBTyxRQUFRLFFBQVEsRUFDcEIsS0FBSyxLQUFLLEtBQUssTUFBTSxPQUFPLENBQUMsRUFDN0IsS0FBSyxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFBQSxJQUNwQztBQUFBLEVBQ0Y7QUFFQSxNQUFJLFNBQVMsU0FBUztBQUNwQixJQUFBQSxRQUFPLENBQUMsUUFBUSxZQUFZO0FBQzFCLFVBQUk7QUFDSixhQUFPLFFBQVEsUUFBUSxFQUNwQixLQUFLLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQyxFQUMvQixLQUFLLENBQUMsWUFBWTtBQUNqQixpQkFBUztBQUNULGVBQU8sS0FBSyxRQUFRLE9BQU87QUFBQSxNQUM3QixDQUFDLEVBQ0EsS0FBSyxNQUFNO0FBQ1YsZUFBTztBQUFBLE1BQ1QsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNGO0FBRUEsTUFBSSxTQUFTLFNBQVM7QUFDcEIsSUFBQUEsUUFBTyxDQUFDLFFBQVEsWUFBWTtBQUMxQixhQUFPLFFBQVEsUUFBUSxFQUNwQixLQUFLLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQyxFQUMvQixNQUFNLENBQUMsVUFBVTtBQUNoQixlQUFPLEtBQUssT0FBTyxPQUFPO0FBQUEsTUFDNUIsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNGO0FBRUEsUUFBTSxTQUFTLElBQUksRUFBRSxLQUFLO0FBQUEsSUFDeEIsTUFBTUE7QUFBQSxJQUNOO0FBQUEsRUFDRixDQUFDO0FBQ0g7OztBQzNDTyxTQUFTLFdBQVcsT0FBTyxNQUFNLFFBQVE7QUFDOUMsTUFBSSxDQUFDLE1BQU0sU0FBUyxJQUFJLEdBQUc7QUFDekI7QUFBQSxFQUNGO0FBRUEsUUFBTSxRQUFRLE1BQU0sU0FBUyxJQUFJLEVBQzlCLElBQUksQ0FBQyxlQUFlO0FBQ25CLFdBQU8sV0FBVztBQUFBLEVBQ3BCLENBQUMsRUFDQSxRQUFRLE1BQU07QUFFakIsTUFBSSxVQUFVLElBQUk7QUFDaEI7QUFBQSxFQUNGO0FBRUEsUUFBTSxTQUFTLElBQUksRUFBRSxPQUFPLE9BQU8sQ0FBQztBQUN0Qzs7O0FDWEEsSUFBTSxPQUFPLFNBQVM7QUFDdEIsSUFBTSxXQUFXLEtBQUssS0FBSyxJQUFJO0FBRS9CLFNBQVMsUUFBUUMsT0FBTSxPQUFPLE1BQU07QUFDbEMsUUFBTSxnQkFBZ0IsU0FBUyxZQUFZLElBQUksRUFBRTtBQUFBLElBQy9DO0FBQUEsSUFDQSxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLO0FBQUEsRUFDL0I7QUFDQSxFQUFBQSxNQUFLLE1BQU0sRUFBRSxRQUFRLGNBQWM7QUFDbkMsRUFBQUEsTUFBSyxTQUFTO0FBQ2QsR0FBQyxVQUFVLFNBQVMsU0FBUyxNQUFNLEVBQUUsUUFBUSxDQUFDLFNBQVM7QUFDckQsVUFBTSxPQUFPLE9BQU8sQ0FBQyxPQUFPLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJO0FBQ3RELElBQUFBLE1BQUssSUFBSSxJQUFJQSxNQUFLLElBQUksSUFBSSxJQUFJLFNBQVMsU0FBUyxJQUFJLEVBQUUsTUFBTSxNQUFNLElBQUk7QUFBQSxFQUN4RSxDQUFDO0FBQ0g7QUFFQSxTQUFTLFdBQVc7QUFDbEIsUUFBTSxtQkFBbUIsT0FBTyxVQUFVO0FBQzFDLFFBQU0sb0JBQW9CO0FBQUEsSUFDeEIsVUFBVSxDQUFDO0FBQUEsRUFDYjtBQUNBLFFBQU0sZUFBZSxTQUFTLEtBQUssTUFBTSxtQkFBbUIsZ0JBQWdCO0FBQzVFLFVBQVEsY0FBYyxtQkFBbUIsZ0JBQWdCO0FBQ3pELFNBQU87QUFDVDtBQUVBLFNBQVMsYUFBYTtBQUNwQixRQUFNLFFBQVE7QUFBQSxJQUNaLFVBQVUsQ0FBQztBQUFBLEVBQ2I7QUFFQSxRQUFNQSxRQUFPLFNBQVMsS0FBSyxNQUFNLEtBQUs7QUFDdEMsVUFBUUEsT0FBTSxLQUFLO0FBRW5CLFNBQU9BO0FBQ1Q7QUFFQSxJQUFPLDRCQUFRLEVBQUUsVUFBVSxXQUFXOzs7QUM1Qy9CLFNBQVNDLGdCQUFlO0FBQzdCLE1BQUksT0FBTyxjQUFjLFlBQVksZUFBZSxXQUFXO0FBQzdELFdBQU8sVUFBVTtBQUFBLEVBQ25CO0FBRUEsTUFBSSxPQUFPLFlBQVksWUFBWSxRQUFRLFlBQVksUUFBVztBQUNoRSxXQUFPLFdBQVcsUUFBUSxRQUFRLE9BQU8sQ0FBQyxNQUFNLFFBQVEsYUFDdEQsUUFBUTtBQUFBLEVBRVo7QUFFQSxTQUFPO0FBQ1Q7OztBQ1JBLElBQUksVUFBVTtBQUdkLElBQUksWUFBWSx1QkFBdUIsV0FBV0MsY0FBYTtBQUMvRCxJQUFJLFdBQVc7QUFBQSxFQUNiLFFBQVE7QUFBQSxFQUNSLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLGNBQWM7QUFBQSxFQUNoQjtBQUFBLEVBQ0EsV0FBVztBQUFBLElBQ1QsUUFBUTtBQUFBLEVBQ1Y7QUFDRjtBQUdBLFNBQVMsY0FBYyxRQUFRO0FBQzdCLE1BQUksQ0FBQyxRQUFRO0FBQ1gsV0FBTyxDQUFDO0FBQUEsRUFDVjtBQUNBLFNBQU8sT0FBTyxLQUFLLE1BQU0sRUFBRSxPQUFPLENBQUMsUUFBUSxRQUFRO0FBQ2pELFdBQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxPQUFPLEdBQUc7QUFDdEMsV0FBTztBQUFBLEVBQ1QsR0FBRyxDQUFDLENBQUM7QUFDUDtBQUdBLFNBQVMsY0FBYyxPQUFPO0FBQzVCLE1BQUksT0FBTyxVQUFVLFlBQVksVUFBVTtBQUN6QyxXQUFPO0FBQ1QsTUFBSSxPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUM1QyxXQUFPO0FBQ1QsUUFBTSxRQUFRLE9BQU8sZUFBZSxLQUFLO0FBQ3pDLE1BQUksVUFBVTtBQUNaLFdBQU87QUFDVCxRQUFNLE9BQU8sT0FBTyxVQUFVLGVBQWUsS0FBSyxPQUFPLGFBQWEsS0FBSyxNQUFNO0FBQ2pGLFNBQU8sT0FBTyxTQUFTLGNBQWMsZ0JBQWdCLFFBQVEsU0FBUyxVQUFVLEtBQUssSUFBSSxNQUFNLFNBQVMsVUFBVSxLQUFLLEtBQUs7QUFDOUg7QUFHQSxTQUFTLFVBQVUsVUFBVSxTQUFTO0FBQ3BDLFFBQU0sU0FBUyxPQUFPLE9BQU8sQ0FBQyxHQUFHLFFBQVE7QUFDekMsU0FBTyxLQUFLLE9BQU8sRUFBRSxRQUFRLENBQUMsUUFBUTtBQUNwQyxRQUFJLGNBQWMsUUFBUSxHQUFHLENBQUMsR0FBRztBQUMvQixVQUFJLEVBQUUsT0FBTztBQUNYLGVBQU8sT0FBTyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEdBQUcsUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUFBO0FBRTdDLGVBQU8sR0FBRyxJQUFJLFVBQVUsU0FBUyxHQUFHLEdBQUcsUUFBUSxHQUFHLENBQUM7QUFBQSxJQUN2RCxPQUFPO0FBQ0wsYUFBTyxPQUFPLFFBQVEsRUFBRSxDQUFDLEdBQUcsR0FBRyxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQUEsSUFDL0M7QUFBQSxFQUNGLENBQUM7QUFDRCxTQUFPO0FBQ1Q7QUFHQSxTQUFTLDBCQUEwQixLQUFLO0FBQ3RDLGFBQVcsT0FBTyxLQUFLO0FBQ3JCLFFBQUksSUFBSSxHQUFHLE1BQU0sUUFBUTtBQUN2QixhQUFPLElBQUksR0FBRztBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUdBLFNBQVMsTUFBTSxVQUFVLE9BQU8sU0FBUztBQXZFekM7QUF3RUUsTUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixRQUFJLENBQUMsUUFBUSxHQUFHLElBQUksTUFBTSxNQUFNLEdBQUc7QUFDbkMsY0FBVSxPQUFPLE9BQU8sTUFBTSxFQUFFLFFBQVEsSUFBSSxJQUFJLEVBQUUsS0FBSyxPQUFPLEdBQUcsT0FBTztBQUFBLEVBQzFFLE9BQU87QUFDTCxjQUFVLE9BQU8sT0FBTyxDQUFDLEdBQUcsS0FBSztBQUFBLEVBQ25DO0FBQ0EsVUFBUSxVQUFVLGNBQWMsUUFBUSxPQUFPO0FBQy9DLDRCQUEwQixPQUFPO0FBQ2pDLDRCQUEwQixRQUFRLE9BQU87QUFDekMsUUFBTSxnQkFBZ0IsVUFBVSxZQUFZLENBQUMsR0FBRyxPQUFPO0FBQ3ZELE1BQUksUUFBUSxRQUFRLFlBQVk7QUFDOUIsUUFBSSxjQUFZLGNBQVMsVUFBVSxhQUFuQixtQkFBNkIsU0FBUTtBQUNuRCxvQkFBYyxVQUFVLFdBQVcsU0FBUyxVQUFVLFNBQVM7QUFBQSxRQUM3RCxDQUFDLFlBQVksQ0FBQyxjQUFjLFVBQVUsU0FBUyxTQUFTLE9BQU87QUFBQSxNQUNqRSxFQUFFLE9BQU8sY0FBYyxVQUFVLFFBQVE7QUFBQSxJQUMzQztBQUNBLGtCQUFjLFVBQVUsWUFBWSxjQUFjLFVBQVUsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksUUFBUSxRQUFRLFlBQVksRUFBRSxDQUFDO0FBQUEsRUFDOUg7QUFDQSxTQUFPO0FBQ1Q7QUFHQSxTQUFTLG1CQUFtQixLQUFLLFlBQVk7QUFDM0MsUUFBTSxZQUFZLEtBQUssS0FBSyxHQUFHLElBQUksTUFBTTtBQUN6QyxRQUFNLFFBQVEsT0FBTyxLQUFLLFVBQVU7QUFDcEMsTUFBSSxNQUFNLFdBQVcsR0FBRztBQUN0QixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sTUFBTSxZQUFZLE1BQU0sSUFBSSxDQUFDLFNBQVM7QUFDM0MsUUFBSSxTQUFTLEtBQUs7QUFDaEIsYUFBTyxPQUFPLFdBQVcsRUFBRSxNQUFNLEdBQUcsRUFBRSxJQUFJLGtCQUFrQixFQUFFLEtBQUssR0FBRztBQUFBLElBQ3hFO0FBQ0EsV0FBTyxHQUFHLFFBQVEsbUJBQW1CLFdBQVcsSUFBSSxDQUFDO0FBQUEsRUFDdkQsQ0FBQyxFQUFFLEtBQUssR0FBRztBQUNiO0FBR0EsSUFBSSxtQkFBbUI7QUFDdkIsU0FBUyxlQUFlLGNBQWM7QUFDcEMsU0FBTyxhQUFhLFFBQVEsY0FBYyxFQUFFLEVBQUUsTUFBTSxHQUFHO0FBQ3pEO0FBQ0EsU0FBUyx3QkFBd0IsS0FBSztBQUNwQyxRQUFNLFVBQVUsSUFBSSxNQUFNLGdCQUFnQjtBQUMxQyxNQUFJLENBQUMsU0FBUztBQUNaLFdBQU8sQ0FBQztBQUFBLEVBQ1Y7QUFDQSxTQUFPLFFBQVEsSUFBSSxjQUFjLEVBQUUsT0FBTyxDQUFDLEdBQUcsTUFBTSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyRTtBQUdBLFNBQVMsS0FBSyxRQUFRLFlBQVk7QUFDaEMsUUFBTSxTQUFTLEVBQUUsV0FBVyxLQUFLO0FBQ2pDLGFBQVcsT0FBTyxPQUFPLEtBQUssTUFBTSxHQUFHO0FBQ3JDLFFBQUksV0FBVyxRQUFRLEdBQUcsTUFBTSxJQUFJO0FBQ2xDLGFBQU8sR0FBRyxJQUFJLE9BQU8sR0FBRztBQUFBLElBQzFCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUdBLFNBQVMsZUFBZSxLQUFLO0FBQzNCLFNBQU8sSUFBSSxNQUFNLG9CQUFvQixFQUFFLElBQUksU0FBUyxNQUFNO0FBQ3hELFFBQUksQ0FBQyxlQUFlLEtBQUssSUFBSSxHQUFHO0FBQzlCLGFBQU8sVUFBVSxJQUFJLEVBQUUsUUFBUSxRQUFRLEdBQUcsRUFBRSxRQUFRLFFBQVEsR0FBRztBQUFBLElBQ2pFO0FBQ0EsV0FBTztBQUFBLEVBQ1QsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUNaO0FBQ0EsU0FBUyxpQkFBaUIsS0FBSztBQUM3QixTQUFPLG1CQUFtQixHQUFHLEVBQUUsUUFBUSxZQUFZLFNBQVMsR0FBRztBQUM3RCxXQUFPLE1BQU0sRUFBRSxXQUFXLENBQUMsRUFBRSxTQUFTLEVBQUUsRUFBRSxZQUFZO0FBQUEsRUFDeEQsQ0FBQztBQUNIO0FBQ0EsU0FBUyxZQUFZLFVBQVUsT0FBTyxLQUFLO0FBQ3pDLFVBQVEsYUFBYSxPQUFPLGFBQWEsTUFBTSxlQUFlLEtBQUssSUFBSSxpQkFBaUIsS0FBSztBQUM3RixNQUFJLEtBQUs7QUFDUCxXQUFPLGlCQUFpQixHQUFHLElBQUksTUFBTTtBQUFBLEVBQ3ZDLE9BQU87QUFDTCxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBQ0EsU0FBUyxVQUFVLE9BQU87QUFDeEIsU0FBTyxVQUFVLFVBQVUsVUFBVTtBQUN2QztBQUNBLFNBQVMsY0FBYyxVQUFVO0FBQy9CLFNBQU8sYUFBYSxPQUFPLGFBQWEsT0FBTyxhQUFhO0FBQzlEO0FBQ0EsU0FBUyxVQUFVLFNBQVMsVUFBVSxLQUFLLFVBQVU7QUFDbkQsTUFBSSxRQUFRLFFBQVEsR0FBRyxHQUFHLFNBQVMsQ0FBQztBQUNwQyxNQUFJLFVBQVUsS0FBSyxLQUFLLFVBQVUsSUFBSTtBQUNwQyxRQUFJLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVSxXQUFXO0FBQ3hGLGNBQVEsTUFBTSxTQUFTO0FBQ3ZCLFVBQUksWUFBWSxhQUFhLEtBQUs7QUFDaEMsZ0JBQVEsTUFBTSxVQUFVLEdBQUcsU0FBUyxVQUFVLEVBQUUsQ0FBQztBQUFBLE1BQ25EO0FBQ0EsYUFBTztBQUFBLFFBQ0wsWUFBWSxVQUFVLE9BQU8sY0FBYyxRQUFRLElBQUksTUFBTSxFQUFFO0FBQUEsTUFDakU7QUFBQSxJQUNGLE9BQU87QUFDTCxVQUFJLGFBQWEsS0FBSztBQUNwQixZQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDeEIsZ0JBQU0sT0FBTyxTQUFTLEVBQUUsUUFBUSxTQUFTLFFBQVE7QUFDL0MsbUJBQU87QUFBQSxjQUNMLFlBQVksVUFBVSxRQUFRLGNBQWMsUUFBUSxJQUFJLE1BQU0sRUFBRTtBQUFBLFlBQ2xFO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSCxPQUFPO0FBQ0wsaUJBQU8sS0FBSyxLQUFLLEVBQUUsUUFBUSxTQUFTLEdBQUc7QUFDckMsZ0JBQUksVUFBVSxNQUFNLENBQUMsQ0FBQyxHQUFHO0FBQ3ZCLHFCQUFPLEtBQUssWUFBWSxVQUFVLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUFBLFlBQ2hEO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0YsT0FBTztBQUNMLGNBQU0sTUFBTSxDQUFDO0FBQ2IsWUFBSSxNQUFNLFFBQVEsS0FBSyxHQUFHO0FBQ3hCLGdCQUFNLE9BQU8sU0FBUyxFQUFFLFFBQVEsU0FBUyxRQUFRO0FBQy9DLGdCQUFJLEtBQUssWUFBWSxVQUFVLE1BQU0sQ0FBQztBQUFBLFVBQ3hDLENBQUM7QUFBQSxRQUNILE9BQU87QUFDTCxpQkFBTyxLQUFLLEtBQUssRUFBRSxRQUFRLFNBQVMsR0FBRztBQUNyQyxnQkFBSSxVQUFVLE1BQU0sQ0FBQyxDQUFDLEdBQUc7QUFDdkIsa0JBQUksS0FBSyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzVCLGtCQUFJLEtBQUssWUFBWSxVQUFVLE1BQU0sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQUEsWUFDckQ7QUFBQSxVQUNGLENBQUM7QUFBQSxRQUNIO0FBQ0EsWUFBSSxjQUFjLFFBQVEsR0FBRztBQUMzQixpQkFBTyxLQUFLLGlCQUFpQixHQUFHLElBQUksTUFBTSxJQUFJLEtBQUssR0FBRyxDQUFDO0FBQUEsUUFDekQsV0FBVyxJQUFJLFdBQVcsR0FBRztBQUMzQixpQkFBTyxLQUFLLElBQUksS0FBSyxHQUFHLENBQUM7QUFBQSxRQUMzQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRixPQUFPO0FBQ0wsUUFBSSxhQUFhLEtBQUs7QUFDcEIsVUFBSSxVQUFVLEtBQUssR0FBRztBQUNwQixlQUFPLEtBQUssaUJBQWlCLEdBQUcsQ0FBQztBQUFBLE1BQ25DO0FBQUEsSUFDRixXQUFXLFVBQVUsT0FBTyxhQUFhLE9BQU8sYUFBYSxNQUFNO0FBQ2pFLGFBQU8sS0FBSyxpQkFBaUIsR0FBRyxJQUFJLEdBQUc7QUFBQSxJQUN6QyxXQUFXLFVBQVUsSUFBSTtBQUN2QixhQUFPLEtBQUssRUFBRTtBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQUNBLFNBQVMsU0FBUyxVQUFVO0FBQzFCLFNBQU87QUFBQSxJQUNMLFFBQVEsT0FBTyxLQUFLLE1BQU0sUUFBUTtBQUFBLEVBQ3BDO0FBQ0Y7QUFDQSxTQUFTLE9BQU8sVUFBVSxTQUFTO0FBQ2pDLE1BQUksWUFBWSxDQUFDLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEdBQUc7QUFDbEQsYUFBVyxTQUFTO0FBQUEsSUFDbEI7QUFBQSxJQUNBLFNBQVMsR0FBRyxZQUFZLFNBQVM7QUFDL0IsVUFBSSxZQUFZO0FBQ2QsWUFBSSxXQUFXO0FBQ2YsY0FBTSxTQUFTLENBQUM7QUFDaEIsWUFBSSxVQUFVLFFBQVEsV0FBVyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUk7QUFDbEQscUJBQVcsV0FBVyxPQUFPLENBQUM7QUFDOUIsdUJBQWEsV0FBVyxPQUFPLENBQUM7QUFBQSxRQUNsQztBQUNBLG1CQUFXLE1BQU0sSUFBSSxFQUFFLFFBQVEsU0FBUyxVQUFVO0FBQ2hELGNBQUksTUFBTSw0QkFBNEIsS0FBSyxRQUFRO0FBQ25ELGlCQUFPLEtBQUssVUFBVSxTQUFTLFVBQVUsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztBQUFBLFFBQ3BFLENBQUM7QUFDRCxZQUFJLFlBQVksYUFBYSxLQUFLO0FBQ2hDLGNBQUksWUFBWTtBQUNoQixjQUFJLGFBQWEsS0FBSztBQUNwQix3QkFBWTtBQUFBLFVBQ2QsV0FBVyxhQUFhLEtBQUs7QUFDM0Isd0JBQVk7QUFBQSxVQUNkO0FBQ0Esa0JBQVEsT0FBTyxXQUFXLElBQUksV0FBVyxNQUFNLE9BQU8sS0FBSyxTQUFTO0FBQUEsUUFDdEUsT0FBTztBQUNMLGlCQUFPLE9BQU8sS0FBSyxHQUFHO0FBQUEsUUFDeEI7QUFBQSxNQUNGLE9BQU87QUFDTCxlQUFPLGVBQWUsT0FBTztBQUFBLE1BQy9CO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxNQUFJLGFBQWEsS0FBSztBQUNwQixXQUFPO0FBQUEsRUFDVCxPQUFPO0FBQ0wsV0FBTyxTQUFTLFFBQVEsT0FBTyxFQUFFO0FBQUEsRUFDbkM7QUFDRjtBQUdBLFNBQVMsTUFBTSxTQUFTO0FBelF4QjtBQTBRRSxNQUFJLFNBQVMsUUFBUSxPQUFPLFlBQVk7QUFDeEMsTUFBSSxPQUFPLFFBQVEsT0FBTyxLQUFLLFFBQVEsZ0JBQWdCLE1BQU07QUFDN0QsTUFBSSxVQUFVLE9BQU8sT0FBTyxDQUFDLEdBQUcsUUFBUSxPQUFPO0FBQy9DLE1BQUk7QUFDSixNQUFJLGFBQWEsS0FBSyxTQUFTO0FBQUEsSUFDN0I7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0YsQ0FBQztBQUNELFFBQU0sbUJBQW1CLHdCQUF3QixHQUFHO0FBQ3BELFFBQU0sU0FBUyxHQUFHLEVBQUUsT0FBTyxVQUFVO0FBQ3JDLE1BQUksQ0FBQyxRQUFRLEtBQUssR0FBRyxHQUFHO0FBQ3RCLFVBQU0sUUFBUSxVQUFVO0FBQUEsRUFDMUI7QUFDQSxRQUFNLG9CQUFvQixPQUFPLEtBQUssT0FBTyxFQUFFLE9BQU8sQ0FBQyxXQUFXLGlCQUFpQixTQUFTLE1BQU0sQ0FBQyxFQUFFLE9BQU8sU0FBUztBQUNySCxRQUFNLHNCQUFzQixLQUFLLFlBQVksaUJBQWlCO0FBQzlELFFBQU0sa0JBQWtCLDZCQUE2QixLQUFLLFFBQVEsTUFBTTtBQUN4RSxNQUFJLENBQUMsaUJBQWlCO0FBQ3BCLFFBQUksUUFBUSxVQUFVLFFBQVE7QUFDNUIsY0FBUSxTQUFTLFFBQVEsT0FBTyxNQUFNLEdBQUcsRUFBRTtBQUFBLFFBQ3pDLENBQUMsV0FBVyxPQUFPO0FBQUEsVUFDakI7QUFBQSxVQUNBLHVCQUF1QixRQUFRLFVBQVU7QUFBQSxRQUMzQztBQUFBLE1BQ0YsRUFBRSxLQUFLLEdBQUc7QUFBQSxJQUNaO0FBQ0EsUUFBSSxJQUFJLFNBQVMsVUFBVSxHQUFHO0FBQzVCLFdBQUksYUFBUSxVQUFVLGFBQWxCLG1CQUE0QixRQUFRO0FBQ3RDLGNBQU0sMkJBQTJCLFFBQVEsT0FBTyxNQUFNLHFCQUFxQixLQUFLLENBQUM7QUFDakYsZ0JBQVEsU0FBUyx5QkFBeUIsT0FBTyxRQUFRLFVBQVUsUUFBUSxFQUFFLElBQUksQ0FBQyxZQUFZO0FBQzVGLGdCQUFNLFNBQVMsUUFBUSxVQUFVLFNBQVMsSUFBSSxRQUFRLFVBQVUsV0FBVztBQUMzRSxpQkFBTywwQkFBMEIsa0JBQWtCO0FBQUEsUUFDckQsQ0FBQyxFQUFFLEtBQUssR0FBRztBQUFBLE1BQ2I7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksQ0FBQyxPQUFPLE1BQU0sRUFBRSxTQUFTLE1BQU0sR0FBRztBQUNwQyxVQUFNLG1CQUFtQixLQUFLLG1CQUFtQjtBQUFBLEVBQ25ELE9BQU87QUFDTCxRQUFJLFVBQVUscUJBQXFCO0FBQ2pDLGFBQU8sb0JBQW9CO0FBQUEsSUFDN0IsT0FBTztBQUNMLFVBQUksT0FBTyxLQUFLLG1CQUFtQixFQUFFLFFBQVE7QUFDM0MsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNBLE1BQUksQ0FBQyxRQUFRLGNBQWMsS0FBSyxPQUFPLFNBQVMsYUFBYTtBQUMzRCxZQUFRLGNBQWMsSUFBSTtBQUFBLEVBQzVCO0FBQ0EsTUFBSSxDQUFDLFNBQVMsS0FBSyxFQUFFLFNBQVMsTUFBTSxLQUFLLE9BQU8sU0FBUyxhQUFhO0FBQ3BFLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxPQUFPO0FBQUEsSUFDWixFQUFFLFFBQVEsS0FBSyxRQUFRO0FBQUEsSUFDdkIsT0FBTyxTQUFTLGNBQWMsRUFBRSxLQUFLLElBQUk7QUFBQSxJQUN6QyxRQUFRLFVBQVUsRUFBRSxTQUFTLFFBQVEsUUFBUSxJQUFJO0FBQUEsRUFDbkQ7QUFDRjtBQUdBLFNBQVMscUJBQXFCLFVBQVUsT0FBTyxTQUFTO0FBQ3RELFNBQU8sTUFBTSxNQUFNLFVBQVUsT0FBTyxPQUFPLENBQUM7QUFDOUM7QUFHQSxTQUFTLGFBQWEsYUFBYSxhQUFhO0FBQzlDLFFBQU0sWUFBWSxNQUFNLGFBQWEsV0FBVztBQUNoRCxRQUFNLFlBQVkscUJBQXFCLEtBQUssTUFBTSxTQUFTO0FBQzNELFNBQU8sT0FBTyxPQUFPLFdBQVc7QUFBQSxJQUM5QixVQUFVO0FBQUEsSUFDVixVQUFVLGFBQWEsS0FBSyxNQUFNLFNBQVM7QUFBQSxJQUMzQyxPQUFPLE1BQU0sS0FBSyxNQUFNLFNBQVM7QUFBQSxJQUNqQztBQUFBLEVBQ0YsQ0FBQztBQUNIO0FBR0EsSUFBSSxXQUFXLGFBQWEsTUFBTSxRQUFROzs7QUMzVm5DLFNBQVNDLGdCQUFlO0FBQzdCLE1BQUksT0FBTyxjQUFjLFlBQVksZUFBZSxXQUFXO0FBQzdELFdBQU8sVUFBVTtBQUFBLEVBQ25CO0FBRUEsTUFBSSxPQUFPLFlBQVksWUFBWSxRQUFRLFlBQVksUUFBVztBQUNoRSxXQUFPLFdBQVcsUUFBUSxRQUFRLE9BQU8sQ0FBQyxNQUFNLFFBQVEsYUFDdEQsUUFBUTtBQUFBLEVBRVo7QUFFQSxTQUFPO0FBQ1Q7OztBQ1pBLElBQU0sZUFBTixjQUEyQixNQUFNO0FBQUEsRUFjL0IsWUFBWSxTQUFTLFlBQVksU0FBUztBQUN4QyxVQUFNLE9BQU87QUFkZjtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUdFLFFBQUksTUFBTSxtQkFBbUI7QUFDM0IsWUFBTSxrQkFBa0IsTUFBTSxLQUFLLFdBQVc7QUFBQSxJQUNoRDtBQUNBLFNBQUssT0FBTztBQUNaLFNBQUssU0FBUztBQUNkLFFBQUksY0FBYyxTQUFTO0FBQ3pCLFdBQUssV0FBVyxRQUFRO0FBQUEsSUFDMUI7QUFDQSxVQUFNLGNBQWMsT0FBTyxPQUFPLENBQUMsR0FBRyxRQUFRLE9BQU87QUFDckQsUUFBSSxRQUFRLFFBQVEsUUFBUSxlQUFlO0FBQ3pDLGtCQUFZLFVBQVUsT0FBTyxPQUFPLENBQUMsR0FBRyxRQUFRLFFBQVEsU0FBUztBQUFBLFFBQy9ELGVBQWUsUUFBUSxRQUFRLFFBQVEsY0FBYztBQUFBLFVBQ25EO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQ0EsZ0JBQVksTUFBTSxZQUFZLElBQUksUUFBUSx3QkFBd0IsMEJBQTBCLEVBQUUsUUFBUSx1QkFBdUIseUJBQXlCO0FBQ3RKLFNBQUssVUFBVTtBQUFBLEVBQ2pCO0FBQ0Y7OztBQy9CQSxJQUFJQyxXQUFVO0FBR2QsU0FBU0MsZUFBYyxPQUFPO0FBQzVCLE1BQUksT0FBTyxVQUFVLFlBQVksVUFBVTtBQUN6QyxXQUFPO0FBQ1QsTUFBSSxPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUM1QyxXQUFPO0FBQ1QsUUFBTSxRQUFRLE9BQU8sZUFBZSxLQUFLO0FBQ3pDLE1BQUksVUFBVTtBQUNaLFdBQU87QUFDVCxRQUFNLE9BQU8sT0FBTyxVQUFVLGVBQWUsS0FBSyxPQUFPLGFBQWEsS0FBSyxNQUFNO0FBQ2pGLFNBQU8sT0FBTyxTQUFTLGNBQWMsZ0JBQWdCLFFBQVEsU0FBUyxVQUFVLEtBQUssSUFBSSxNQUFNLFNBQVMsVUFBVSxLQUFLLEtBQUs7QUFDOUg7QUFNQSxTQUFTLGtCQUFrQixVQUFVO0FBQ25DLFNBQU8sU0FBUyxZQUFZO0FBQzlCO0FBR0EsU0FBUyxhQUFhLGdCQUFnQjtBQTdCdEM7QUE4QkUsUUFBTSxNQUFNLGVBQWUsV0FBVyxlQUFlLFFBQVEsTUFBTSxlQUFlLFFBQVEsTUFBTTtBQUNoRyxRQUFNLDZCQUEyQixvQkFBZSxZQUFmLG1CQUF3Qiw4QkFBNkI7QUFDdEYsTUFBSUEsZUFBYyxlQUFlLElBQUksS0FBSyxNQUFNLFFBQVEsZUFBZSxJQUFJLEdBQUc7QUFDNUUsbUJBQWUsT0FBTyxLQUFLLFVBQVUsZUFBZSxJQUFJO0FBQUEsRUFDMUQ7QUFDQSxNQUFJLFVBQVUsQ0FBQztBQUNmLE1BQUk7QUFDSixNQUFJO0FBQ0osTUFBSSxFQUFFLE1BQU0sSUFBSTtBQUNoQixPQUFJLG9CQUFlLFlBQWYsbUJBQXdCLE9BQU87QUFDakMsWUFBUSxlQUFlLFFBQVE7QUFBQSxFQUNqQztBQUNBLE1BQUksQ0FBQyxPQUFPO0FBQ1YsVUFBTSxJQUFJO0FBQUEsTUFDUjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQ0EsU0FBTyxNQUFNLGVBQWUsS0FBSztBQUFBLElBQy9CLFFBQVEsZUFBZTtBQUFBLElBQ3ZCLE1BQU0sZUFBZTtBQUFBO0FBQUEsSUFFckIsU0FBUyxPQUFPO0FBQUEsTUFDZCxPQUFPLFFBQVEsZUFBZSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU07QUFBQSxRQUM1RDtBQUFBLFFBQ0EsT0FBTyxLQUFLO0FBQUEsTUFDZCxDQUFDO0FBQUEsSUFDSDtBQUFBLElBQ0EsU0FBUSxvQkFBZSxZQUFmLG1CQUF3QjtBQUFBO0FBQUE7QUFBQSxJQUdoQyxHQUFHLGVBQWUsUUFBUSxFQUFFLFFBQVEsT0FBTztBQUFBLEVBQzdDLENBQUMsRUFBRSxLQUFLLE9BQU8sYUFBYTtBQUMxQixVQUFNLFNBQVM7QUFDZixhQUFTLFNBQVM7QUFDbEIsZUFBVyxlQUFlLFNBQVMsU0FBUztBQUMxQyxjQUFRLFlBQVksQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDO0FBQUEsSUFDekM7QUFDQSxRQUFJLGlCQUFpQixTQUFTO0FBQzVCLFlBQU0sVUFBVSxRQUFRLFFBQVEsUUFBUSxLQUFLLE1BQU0sOEJBQThCO0FBQ2pGLFlBQU0sa0JBQWtCLFdBQVcsUUFBUSxJQUFJO0FBQy9DLFVBQUk7QUFBQSxRQUNGLHVCQUF1QixlQUFlLFVBQVUsZUFBZSx3REFBd0QsUUFBUSxTQUFTLGtCQUFrQixTQUFTLG9CQUFvQjtBQUFBLE1BQ3pMO0FBQUEsSUFDRjtBQUNBLFFBQUksV0FBVyxPQUFPLFdBQVcsS0FBSztBQUNwQztBQUFBLElBQ0Y7QUFDQSxRQUFJLGVBQWUsV0FBVyxRQUFRO0FBQ3BDLFVBQUksU0FBUyxLQUFLO0FBQ2hCO0FBQUEsTUFDRjtBQUNBLFlBQU0sSUFBSSxhQUFhLFNBQVMsWUFBWSxRQUFRO0FBQUEsUUFDbEQsVUFBVTtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsTUFBTTtBQUFBLFFBQ1I7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYLENBQUM7QUFBQSxJQUNIO0FBQ0EsUUFBSSxXQUFXLEtBQUs7QUFDbEIsWUFBTSxJQUFJLGFBQWEsZ0JBQWdCLFFBQVE7QUFBQSxRQUM3QyxVQUFVO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQSxNQUFNLE1BQU0sZ0JBQWdCLFFBQVE7QUFBQSxRQUN0QztBQUFBLFFBQ0EsU0FBUztBQUFBLE1BQ1gsQ0FBQztBQUFBLElBQ0g7QUFDQSxRQUFJLFVBQVUsS0FBSztBQUNqQixZQUFNLE9BQU8sTUFBTSxnQkFBZ0IsUUFBUTtBQUMzQyxZQUFNLFFBQVEsSUFBSSxhQUFhLGVBQWUsSUFBSSxHQUFHLFFBQVE7QUFBQSxRQUMzRCxVQUFVO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYLENBQUM7QUFDRCxZQUFNO0FBQUEsSUFDUjtBQUNBLFdBQU8sMkJBQTJCLE1BQU0sZ0JBQWdCLFFBQVEsSUFBSSxTQUFTO0FBQUEsRUFDL0UsQ0FBQyxFQUFFLEtBQUssQ0FBQyxTQUFTO0FBQ2hCLFdBQU87QUFBQSxNQUNMO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxVQUFVO0FBQ2xCLFFBQUksaUJBQWlCO0FBQ25CLFlBQU07QUFBQSxhQUNDLE1BQU0sU0FBUztBQUN0QixZQUFNO0FBQ1IsUUFBSSxVQUFVLE1BQU07QUFDcEIsUUFBSSxNQUFNLFNBQVMsZUFBZSxXQUFXLE9BQU87QUFDbEQsVUFBSSxNQUFNLGlCQUFpQixPQUFPO0FBQ2hDLGtCQUFVLE1BQU0sTUFBTTtBQUFBLE1BQ3hCLFdBQVcsT0FBTyxNQUFNLFVBQVUsVUFBVTtBQUMxQyxrQkFBVSxNQUFNO0FBQUEsTUFDbEI7QUFBQSxJQUNGO0FBQ0EsVUFBTSxJQUFJLGFBQWEsU0FBUyxLQUFLO0FBQUEsTUFDbkMsU0FBUztBQUFBLElBQ1gsQ0FBQztBQUFBLEVBQ0gsQ0FBQztBQUNIO0FBQ0EsZUFBZSxnQkFBZ0IsVUFBVTtBQUN2QyxRQUFNLGNBQWMsU0FBUyxRQUFRLElBQUksY0FBYztBQUN2RCxNQUFJLG9CQUFvQixLQUFLLFdBQVcsR0FBRztBQUN6QyxXQUFPLFNBQVMsS0FBSyxFQUFFLE1BQU0sTUFBTSxTQUFTLEtBQUssQ0FBQyxFQUFFLE1BQU0sTUFBTSxFQUFFO0FBQUEsRUFDcEU7QUFDQSxNQUFJLENBQUMsZUFBZSx5QkFBeUIsS0FBSyxXQUFXLEdBQUc7QUFDOUQsV0FBTyxTQUFTLEtBQUs7QUFBQSxFQUN2QjtBQUNBLFNBQU8sa0JBQWtCLFFBQVE7QUFDbkM7QUFDQSxTQUFTLGVBQWUsTUFBTTtBQUM1QixNQUFJLE9BQU8sU0FBUztBQUNsQixXQUFPO0FBQ1QsTUFBSTtBQUNKLE1BQUksdUJBQXVCLE1BQU07QUFDL0IsYUFBUyxNQUFNLEtBQUs7QUFBQSxFQUN0QixPQUFPO0FBQ0wsYUFBUztBQUFBLEVBQ1g7QUFDQSxNQUFJLGFBQWEsTUFBTTtBQUNyQixRQUFJLE1BQU0sUUFBUSxLQUFLLE1BQU0sR0FBRztBQUM5QixhQUFPLEdBQUcsS0FBSyxZQUFZLEtBQUssT0FBTyxJQUFJLEtBQUssU0FBUyxFQUFFLEtBQUssSUFBSSxJQUFJO0FBQUEsSUFDMUU7QUFDQSxXQUFPLEdBQUcsS0FBSyxVQUFVO0FBQUEsRUFDM0I7QUFDQSxTQUFPLGtCQUFrQixLQUFLLFVBQVUsSUFBSTtBQUM5QztBQUdBLFNBQVNDLGNBQWEsYUFBYSxhQUFhO0FBQzlDLFFBQU0sWUFBWSxZQUFZLFNBQVMsV0FBVztBQUNsRCxRQUFNLFNBQVMsU0FBUyxPQUFPLFlBQVk7QUFDekMsVUFBTSxrQkFBa0IsVUFBVSxNQUFNLE9BQU8sVUFBVTtBQUN6RCxRQUFJLENBQUMsZ0JBQWdCLFdBQVcsQ0FBQyxnQkFBZ0IsUUFBUSxNQUFNO0FBQzdELGFBQU8sYUFBYSxVQUFVLE1BQU0sZUFBZSxDQUFDO0FBQUEsSUFDdEQ7QUFDQSxVQUFNLFdBQVcsQ0FBQyxRQUFRLGdCQUFnQjtBQUN4QyxhQUFPO0FBQUEsUUFDTCxVQUFVLE1BQU0sVUFBVSxNQUFNLFFBQVEsV0FBVyxDQUFDO0FBQUEsTUFDdEQ7QUFBQSxJQUNGO0FBQ0EsV0FBTyxPQUFPLFVBQVU7QUFBQSxNQUN0QixVQUFVO0FBQUEsTUFDVixVQUFVQSxjQUFhLEtBQUssTUFBTSxTQUFTO0FBQUEsSUFDN0MsQ0FBQztBQUNELFdBQU8sZ0JBQWdCLFFBQVEsS0FBSyxVQUFVLGVBQWU7QUFBQSxFQUMvRDtBQUNBLFNBQU8sT0FBTyxPQUFPLFFBQVE7QUFBQSxJQUMzQixVQUFVO0FBQUEsSUFDVixVQUFVQSxjQUFhLEtBQUssTUFBTSxTQUFTO0FBQUEsRUFDN0MsQ0FBQztBQUNIO0FBR0EsSUFBSSxVQUFVQSxjQUFhLFVBQVU7QUFBQSxFQUNuQyxTQUFTO0FBQUEsSUFDUCxjQUFjLHNCQUFzQkYsWUFBV0csY0FBYTtBQUFBLEVBQzlEO0FBQ0YsQ0FBQzs7O0FDdk1NLFNBQVNDLGdCQUFlO0FBQzdCLE1BQUksT0FBTyxjQUFjLFlBQVksZUFBZSxXQUFXO0FBQzdELFdBQU8sVUFBVTtBQUFBLEVBQ25CO0FBRUEsTUFBSSxPQUFPLFlBQVksWUFBWSxRQUFRLFlBQVksUUFBVztBQUNoRSxXQUFPLFdBQVcsUUFBUSxRQUFRLE9BQU8sQ0FBQyxNQUFNLFFBQVEsYUFDdEQsUUFBUTtBQUFBLEVBRVo7QUFFQSxTQUFPO0FBQ1Q7OztBQ1BBLElBQUlDLFdBQVU7QUFTZCxTQUFTLCtCQUErQixNQUFNO0FBQzVDLFNBQU87QUFBQSxJQUNMLEtBQUssT0FBTyxJQUFJLENBQUMsTUFBTSxNQUFNLEVBQUUsU0FBUyxFQUFFLEtBQUssSUFBSTtBQUN2RDtBQUNBLElBQUksdUJBQXVCLGNBQWMsTUFBTTtBQUFBLEVBQzdDLFlBQVksVUFBVSxTQUFTLFVBQVU7QUFDdkMsVUFBTSwrQkFBK0IsUUFBUSxDQUFDO0FBVWhELGdDQUFPO0FBQ1A7QUFDQTtBQVhFLFNBQUssVUFBVTtBQUNmLFNBQUssVUFBVTtBQUNmLFNBQUssV0FBVztBQUNoQixTQUFLLFNBQVMsU0FBUztBQUN2QixTQUFLLE9BQU8sU0FBUztBQUNyQixRQUFJLE1BQU0sbUJBQW1CO0FBQzNCLFlBQU0sa0JBQWtCLE1BQU0sS0FBSyxXQUFXO0FBQUEsSUFDaEQ7QUFBQSxFQUNGO0FBSUY7QUFHQSxJQUFJLHVCQUF1QjtBQUFBLEVBQ3pCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0Y7QUFDQSxJQUFJLDZCQUE2QixDQUFDLFNBQVMsVUFBVSxLQUFLO0FBQzFELElBQUksdUJBQXVCO0FBQzNCLFNBQVMsUUFBUSxVQUFVLE9BQU8sU0FBUztBQUN6QyxNQUFJLFNBQVM7QUFDWCxRQUFJLE9BQU8sVUFBVSxZQUFZLFdBQVcsU0FBUztBQUNuRCxhQUFPLFFBQVE7QUFBQSxRQUNiLElBQUksTUFBTSw0REFBNEQ7QUFBQSxNQUN4RTtBQUFBLElBQ0Y7QUFDQSxlQUFXLE9BQU8sU0FBUztBQUN6QixVQUFJLENBQUMsMkJBQTJCLFNBQVMsR0FBRztBQUMxQztBQUNGLGFBQU8sUUFBUTtBQUFBLFFBQ2IsSUFBSTtBQUFBLFVBQ0YsdUJBQXVCO0FBQUEsUUFDekI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxRQUFNLGdCQUFnQixPQUFPLFVBQVUsV0FBVyxPQUFPLE9BQU8sRUFBRSxNQUFNLEdBQUcsT0FBTyxJQUFJO0FBQ3RGLFFBQU0saUJBQWlCLE9BQU87QUFBQSxJQUM1QjtBQUFBLEVBQ0YsRUFBRSxPQUFPLENBQUMsUUFBUSxRQUFRO0FBQ3hCLFFBQUkscUJBQXFCLFNBQVMsR0FBRyxHQUFHO0FBQ3RDLGFBQU8sR0FBRyxJQUFJLGNBQWMsR0FBRztBQUMvQixhQUFPO0FBQUEsSUFDVDtBQUNBLFFBQUksQ0FBQyxPQUFPLFdBQVc7QUFDckIsYUFBTyxZQUFZLENBQUM7QUFBQSxJQUN0QjtBQUNBLFdBQU8sVUFBVSxHQUFHLElBQUksY0FBYyxHQUFHO0FBQ3pDLFdBQU87QUFBQSxFQUNULEdBQUcsQ0FBQyxDQUFDO0FBQ0wsUUFBTSxVQUFVLGNBQWMsV0FBVyxTQUFTLFNBQVMsU0FBUztBQUNwRSxNQUFJLHFCQUFxQixLQUFLLE9BQU8sR0FBRztBQUN0QyxtQkFBZSxNQUFNLFFBQVEsUUFBUSxzQkFBc0IsY0FBYztBQUFBLEVBQzNFO0FBQ0EsU0FBTyxTQUFTLGNBQWMsRUFBRSxLQUFLLENBQUMsYUFBYTtBQUNqRCxRQUFJLFNBQVMsS0FBSyxRQUFRO0FBQ3hCLFlBQU0sVUFBVSxDQUFDO0FBQ2pCLGlCQUFXLE9BQU8sT0FBTyxLQUFLLFNBQVMsT0FBTyxHQUFHO0FBQy9DLGdCQUFRLEdBQUcsSUFBSSxTQUFTLFFBQVEsR0FBRztBQUFBLE1BQ3JDO0FBQ0EsWUFBTSxJQUFJO0FBQUEsUUFDUjtBQUFBLFFBQ0E7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYO0FBQUEsSUFDRjtBQUNBLFdBQU8sU0FBUyxLQUFLO0FBQUEsRUFDdkIsQ0FBQztBQUNIO0FBR0EsU0FBU0MsY0FBYSxVQUFVLGFBQWE7QUFDM0MsUUFBTSxhQUFhLFNBQVMsU0FBUyxXQUFXO0FBQ2hELFFBQU0sU0FBUyxDQUFDLE9BQU8sWUFBWTtBQUNqQyxXQUFPLFFBQVEsWUFBWSxPQUFPLE9BQU87QUFBQSxFQUMzQztBQUNBLFNBQU8sT0FBTyxPQUFPLFFBQVE7QUFBQSxJQUMzQixVQUFVQSxjQUFhLEtBQUssTUFBTSxVQUFVO0FBQUEsSUFDNUMsVUFBVSxXQUFXO0FBQUEsRUFDdkIsQ0FBQztBQUNIO0FBR0EsSUFBSSxXQUFXQSxjQUFhLFNBQVM7QUFBQSxFQUNuQyxTQUFTO0FBQUEsSUFDUCxjQUFjLHNCQUFzQkQsWUFBV0UsY0FBYTtBQUFBLEVBQzlEO0FBQUEsRUFDQSxRQUFRO0FBQUEsRUFDUixLQUFLO0FBQ1AsQ0FBQztBQUNELFNBQVMsa0JBQWtCLGVBQWU7QUFDeEMsU0FBT0QsY0FBYSxlQUFlO0FBQUEsSUFDakMsUUFBUTtBQUFBLElBQ1IsS0FBSztBQUFBLEVBQ1AsQ0FBQztBQUNIOzs7QUMxSEEsSUFBSSwrQkFBK0I7QUFDbkMsSUFBSSx3QkFBd0I7QUFDNUIsSUFBSSwwQkFBMEI7QUFDOUIsZUFBZSxLQUFLLE9BQU87QUFDekIsUUFBTSxRQUFRLE1BQU0sTUFBTSxJQUFJLEVBQUUsV0FBVztBQUMzQyxRQUFNLGlCQUFpQiw2QkFBNkIsS0FBSyxLQUFLLEtBQUssc0JBQXNCLEtBQUssS0FBSztBQUNuRyxRQUFNLGlCQUFpQix3QkFBd0IsS0FBSyxLQUFLO0FBQ3pELFFBQU0sWUFBWSxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixpQkFBaUIsbUJBQW1CO0FBQ3hHLFNBQU87QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDRjtBQUdBLFNBQVMsd0JBQXdCLE9BQU87QUFDdEMsTUFBSSxNQUFNLE1BQU0sSUFBSSxFQUFFLFdBQVcsR0FBRztBQUNsQyxXQUFPLFVBQVU7QUFBQSxFQUNuQjtBQUNBLFNBQU8sU0FBUztBQUNsQjtBQUdBLGVBQWUsS0FBSyxPQUFPRSxVQUFTLE9BQU8sWUFBWTtBQUNyRCxRQUFNQyxZQUFXRCxTQUFRLFNBQVM7QUFBQSxJQUNoQztBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsRUFBQUMsVUFBUyxRQUFRLGdCQUFnQix3QkFBd0IsS0FBSztBQUM5RCxTQUFPRCxTQUFRQyxTQUFRO0FBQ3pCO0FBR0EsSUFBSSxrQkFBa0IsU0FBUyxpQkFBaUIsT0FBTztBQUNyRCxNQUFJLENBQUMsT0FBTztBQUNWLFVBQU0sSUFBSSxNQUFNLDBEQUEwRDtBQUFBLEVBQzVFO0FBQ0EsTUFBSSxPQUFPLFVBQVUsVUFBVTtBQUM3QixVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDQSxVQUFRLE1BQU0sUUFBUSxzQkFBc0IsRUFBRTtBQUM5QyxTQUFPLE9BQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLEdBQUc7QUFBQSxJQUMzQyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUs7QUFBQSxFQUM3QixDQUFDO0FBQ0g7OztBQ2hEQSxJQUFNQyxXQUFVOzs7QUNNaEIsSUFBTSxPQUFPLE1BQU07QUFDbkI7QUFDQSxJQUFNLGNBQWMsUUFBUSxLQUFLLEtBQUssT0FBTztBQUM3QyxJQUFNLGVBQWUsUUFBUSxNQUFNLEtBQUssT0FBTztBQUMvQyxJQUFNLGlCQUFpQixtQkFBbUJDLFlBQVcsYUFBYTtBQUNsRSxJQUFNLFVBQU4sTUFBYztBQUFBLEVBd0NaLFlBQVksVUFBVSxDQUFDLEdBQUc7QUF5RTFCO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBN0VFLFVBQU1DLFFBQU8sSUFBSSwwQkFBSyxXQUFXO0FBQ2pDLFVBQU0sa0JBQWtCO0FBQUEsTUFDdEIsU0FBUyxRQUFRLFNBQVMsU0FBUztBQUFBLE1BQ25DLFNBQVMsQ0FBQztBQUFBLE1BQ1YsU0FBUyxPQUFPLE9BQU8sQ0FBQyxHQUFHLFFBQVEsU0FBUztBQUFBO0FBQUEsUUFFMUMsTUFBTUEsTUFBSyxLQUFLLE1BQU0sU0FBUztBQUFBLE1BQ2pDLENBQUM7QUFBQSxNQUNELFdBQVc7QUFBQSxRQUNULFVBQVUsQ0FBQztBQUFBLFFBQ1gsUUFBUTtBQUFBLE1BQ1Y7QUFBQSxJQUNGO0FBQ0Esb0JBQWdCLFFBQVEsWUFBWSxJQUFJLFFBQVEsWUFBWSxHQUFHLFFBQVEsYUFBYSxtQkFBbUI7QUFDdkcsUUFBSSxRQUFRLFNBQVM7QUFDbkIsc0JBQWdCLFVBQVUsUUFBUTtBQUFBLElBQ3BDO0FBQ0EsUUFBSSxRQUFRLFVBQVU7QUFDcEIsc0JBQWdCLFVBQVUsV0FBVyxRQUFRO0FBQUEsSUFDL0M7QUFDQSxRQUFJLFFBQVEsVUFBVTtBQUNwQixzQkFBZ0IsUUFBUSxXQUFXLElBQUksUUFBUTtBQUFBLElBQ2pEO0FBQ0EsU0FBSyxVQUFVLFFBQVEsU0FBUyxlQUFlO0FBQy9DLFNBQUssVUFBVSxrQkFBa0IsS0FBSyxPQUFPLEVBQUUsU0FBUyxlQUFlO0FBQ3ZFLFNBQUssTUFBTSxPQUFPO0FBQUEsTUFDaEI7QUFBQSxRQUNFLE9BQU87QUFBQSxRQUNQLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxRQUNOLE9BQU87QUFBQSxNQUNUO0FBQUEsTUFDQSxRQUFRO0FBQUEsSUFDVjtBQUNBLFNBQUssT0FBT0E7QUFDWixRQUFJLENBQUMsUUFBUSxjQUFjO0FBQ3pCLFVBQUksQ0FBQyxRQUFRLE1BQU07QUFDakIsYUFBSyxPQUFPLGFBQWE7QUFBQSxVQUN2QixNQUFNO0FBQUEsUUFDUjtBQUFBLE1BQ0YsT0FBTztBQUNMLGNBQU1DLFFBQU8sZ0JBQWdCLFFBQVEsSUFBSTtBQUN6QyxRQUFBRCxNQUFLLEtBQUssV0FBV0MsTUFBSyxJQUFJO0FBQzlCLGFBQUssT0FBT0E7QUFBQSxNQUNkO0FBQUEsSUFDRixPQUFPO0FBQ0wsWUFBTSxFQUFFLGNBQWMsR0FBRyxhQUFhLElBQUk7QUFDMUMsWUFBTUEsUUFBTztBQUFBLFFBQ1gsT0FBTztBQUFBLFVBQ0w7QUFBQSxZQUNFLFNBQVMsS0FBSztBQUFBLFlBQ2QsS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBTVYsU0FBUztBQUFBLFlBQ1QsZ0JBQWdCO0FBQUEsVUFDbEI7QUFBQSxVQUNBLFFBQVE7QUFBQSxRQUNWO0FBQUEsTUFDRjtBQUNBLE1BQUFELE1BQUssS0FBSyxXQUFXQyxNQUFLLElBQUk7QUFDOUIsV0FBSyxPQUFPQTtBQUFBLElBQ2Q7QUFDQSxVQUFNLG1CQUFtQixLQUFLO0FBQzlCLGFBQVMsSUFBSSxHQUFHLElBQUksaUJBQWlCLFFBQVEsUUFBUSxFQUFFLEdBQUc7QUFDeEQsYUFBTyxPQUFPLE1BQU0saUJBQWlCLFFBQVEsQ0FBQyxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQUEsSUFDaEU7QUFBQSxFQUNGO0FBQUEsRUE3R0EsT0FBTyxTQUFTLFVBQVU7QUFDeEIsVUFBTSxzQkFBc0IsY0FBYyxLQUFLO0FBQUEsTUFDN0MsZUFBZSxNQUFNO0FBQ25CLGNBQU0sVUFBVSxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQzVCLFlBQUksT0FBTyxhQUFhLFlBQVk7QUFDbEMsZ0JBQU0sU0FBUyxPQUFPLENBQUM7QUFDdkI7QUFBQSxRQUNGO0FBQ0E7QUFBQSxVQUNFLE9BQU87QUFBQSxZQUNMLENBQUM7QUFBQSxZQUNEO0FBQUEsWUFDQTtBQUFBLFlBQ0EsUUFBUSxhQUFhLFNBQVMsWUFBWTtBQUFBLGNBQ3hDLFdBQVcsR0FBRyxRQUFRLGFBQWEsU0FBUztBQUFBLFlBQzlDLElBQUk7QUFBQSxVQUNOO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVFBLE9BQU8sVUFBVSxZQUFZO0FBMUMvQjtBQTJDSSxVQUFNLGlCQUFpQixLQUFLO0FBQzVCLFVBQU0sY0FBYSxtQkFBYyxLQUFLO0FBQUEsSUFJdEMsR0FIRSxjQURpQixJQUNWLFdBQVUsZUFBZTtBQUFBLE1BQzlCLFdBQVcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxlQUFlLFNBQVMsTUFBTSxDQUFDO0FBQUEsSUFDaEUsSUFIaUI7QUFLbkIsV0FBTztBQUFBLEVBQ1Q7QUFnRkY7QUF0SEUsY0FESSxTQUNHLFdBQVVGO0FBdUJqQixjQXhCSSxTQXdCRyxXQUFVLENBQUM7OztBQ3BCcEIsU0FBUyxlQUFlLEtBQTZCLEtBQTRCO0FBQzdFLFNBQU8sSUFBSSxlQUFlLEdBQUcsSUFBSSxJQUFJLEdBQUcsSUFBSTtBQUNoRDtBQUtPLFNBQVMsV0FDWixlQUNBLGNBQ0EsS0FBbUM7QUFDL0IsUUFBTSxrQkFBa0IsQ0FBQyxZQUEyQixjQUNwRDtBQUNJLFFBQUksY0FBYyxhQUFhLGVBQWUsV0FBVztBQUNyRCxhQUFPLFFBQVEsVUFBVSxZQUFZO0FBQUEsSUFDekMsV0FBVyxjQUFjLENBQUMsV0FBVztBQUNqQyxhQUFPLFFBQVEsVUFBVSxZQUFZO0FBQUEsSUFDekMsV0FBVyxDQUFDLGNBQWMsV0FBVztBQUNqQyxhQUFPLFFBQVEsVUFBVSxZQUFZO0FBQUEsSUFDekM7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUVBLFNBQU8sT0FBTyxLQUFLLEVBQUUsR0FBRyxlQUFlLEdBQUcsYUFBYSxDQUFDLEVBQUUsUUFBUSxDQUFDLFNBQWtDO0FBQ2pHLFVBQU0sQ0FBQyxZQUFZLFNBQVMsSUFBSSxDQUFDLGVBQWUsZUFBZSxJQUFJLEdBQUcsZUFBZSxjQUFjLElBQUksQ0FBQztBQUN4RyxVQUFNLFNBQVMsZ0JBQWdCLFlBQVksU0FBUztBQUNwRCxRQUFJLFFBQVE7QUFDUixhQUFPLENBQUM7QUFBQSxRQUNKO0FBQUEsUUFDQTtBQUFBLFFBQ0EsWUFBWSxrQ0FBYztBQUFBLFFBQzFCLFdBQVcsaUJBQWlCLElBQUk7QUFBQSxNQUNwQyxDQUFDO0FBQUEsSUFDTDtBQUNBLFdBQU8sQ0FBQztBQUFBLEVBQ1osQ0FBQztBQUNUO0FBRU8sSUFBTSx3QkFBd0IsQ0FBQyxPQUFPLE9BQU8sUUFBUSxLQUFLO0FBRWpFLFNBQVMsaUJBQWlCLE1BQWtDO0FBdkQ1RDtBQXdESSxVQUFPLFVBQUssTUFBTSxRQUFRLE1BQW5CLG1CQUF1QjtBQUNsQztBQVlPLFNBQVMsU0FBWSxNQUFnQixNQUFnQjtBQUN4RCxRQUFNLE9BQU8sSUFBSSxJQUFJLElBQUk7QUFDekIsUUFBTSxPQUFPLElBQUksSUFBSSxJQUFJO0FBQ3pCLFFBQU0sVUFBVSxLQUFLLFNBQVMsS0FBSyxRQUFRLENBQUMsR0FBRyxJQUFJLEVBQUUsTUFBTSxXQUFTLEtBQUssSUFBSSxLQUFLLENBQUM7QUFDbkYsU0FBTztBQUNYOzs7QUNqQ08sSUFBTSxtQkFBTixjQUErQixNQUFNO0FBQUEsRUFJeEMsWUFBWSxTQUFpQixRQUFnQixRQUFrQztBQUMzRSxVQUFNLE9BQU87QUFDYixTQUFLLE9BQU87QUFDWixTQUFLLFNBQVM7QUFDZCxTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUNKO0FBRU8sSUFBTSxNQUFOLE1BQTBCO0FBQUEsRUFjN0IsWUFBWSxTQUFzQixhQUEwQixPQUFjO0FBQ3RFLFNBQUssYUFBYSxPQUFPO0FBQ3pCLFNBQUssZUFBZSxXQUFXO0FBQy9CLFNBQUssUUFBUTtBQUNiLFNBQUssVUFBVTtBQUFBO0FBQUE7QUFBQSxNQUdYLGlCQUFpQjtBQUFBLE1BQ2pCLHdCQUF3QjtBQUFBLElBQzVCO0FBQUEsRUFDSjtBQUFBLEVBRUEsYUFBYSxTQUFzQjtBQUMvQixTQUFLLFFBQVEsUUFBUTtBQUNyQixTQUFLLE9BQU8sUUFBUTtBQUNwQixTQUFLLFNBQVMsUUFBUTtBQUN0QixTQUFLLGFBQWEsUUFBUTtBQUMxQixTQUFLLFVBQVUsSUFBSSxRQUFRLEVBQUMsTUFBTSxRQUFRLElBQUcsQ0FBQztBQUFBLEVBQ2xEO0FBQUEsRUFFQSxlQUFlLFlBQXlCO0FBQ3BDLFNBQUssV0FBVyxXQUFXO0FBQzNCLFNBQUssdUJBQXVCLFdBQVc7QUFDdkMsU0FBSyx1QkFBdUIsV0FBVztBQUFBLEVBQzNDO0FBQUEsRUFFQSxNQUFNLFNBQVMsYUFBc0M7QUFDakQsVUFBTSxNQUFNLElBQUksWUFBWTtBQUM1QixVQUFNLFVBQVUsTUFBTSxPQUFPLE9BQU8sT0FBTyxTQUFTLElBQUksT0FBTyxXQUFXLENBQUM7QUFDM0UsVUFBTSxZQUFZLE1BQU0sS0FBSyxJQUFJLFdBQVcsT0FBTyxDQUFDO0FBQ3BELFVBQU0sVUFBVSxVQUFVLElBQUksT0FBSyxFQUFFLFNBQVMsRUFBRSxFQUFFLFNBQVMsR0FBRyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUU7QUFDM0UsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVBLE1BQU0sb0JBQW9CLE1BQStCO0FBQzNELFFBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxRQUFRLE9BQU8sSUFBSSxHQUFHO0FBQzNDLFlBQU0sSUFBSSxNQUFNLHVDQUF1QywyQkFBMkI7QUFBQSxJQUNuRjtBQUVBLFVBQU0sWUFBWSxNQUFNLEtBQUssTUFBTSxRQUFRLEtBQUssSUFBSTtBQUNwRCxXQUFPLE1BQU0sS0FBSyxTQUFTLE9BQU8sU0FBUztBQUFBLEVBQzVDO0FBQUEsRUFFQSxNQUFNLGtCQUFnRDtBQUNyRCxVQUFNLFFBQVEsS0FBSyxNQUFNLFNBQVMsRUFBRSxJQUFJLE9BQUcsRUFBRSxJQUFJO0FBQ2pELFdBQU8sT0FBTztBQUFBLE1BQ2IsTUFBTSxRQUFRO0FBQUEsUUFDYixNQUFNLElBQUksT0FBTyxNQUF3QztBQUN4RCxpQkFBTyxDQUFDLEdBQUcsTUFBTSxLQUFLLG9CQUFvQixDQUFDLENBQUM7QUFBQSxRQUM3QyxDQUFDO0FBQUEsTUFDRjtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBQUEsRUFFRyxNQUFNLGdCQUFnQixpQkFBa0U7QUFDcEYsUUFBSSxDQUFDLEtBQUssVUFBVTtBQUVoQixhQUFPLEtBQUssTUFBTSxTQUFTLEVBQUUsSUFBSSxPQUFLO0FBQ2xDLGVBQU8sRUFBQyxNQUFNLEVBQUUsTUFBTSxRQUFRLFVBQVM7QUFBQSxNQUFDLENBQUM7QUFBQSxJQUNqRDtBQUNBLFFBQUksQ0FBQyxpQkFBaUI7QUFDbEIsd0JBQWtCLE1BQU0sS0FBSyxnQkFBZ0I7QUFBQSxJQUNqRDtBQUNBLFVBQU0sZUFBZSxXQUFXLGlCQUFpQixLQUFLLFVBQVUsT0FBTztBQUN2RSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsTUFBTSxVQUF1RDtBQUN6RCxRQUFJO0FBQ0EsWUFBTSxFQUFDLE1BQU0sU0FBUSxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsUUFDeEM7QUFBQSxRQUFhO0FBQUEsVUFDVCxTQUFTLEtBQUs7QUFBQSxRQUN0QjtBQUFBLE1BQUM7QUFDRCxhQUFPLEVBQUMsT0FBTyxTQUFTLE9BQU8sV0FBVSxTQUFTLFdBQVU7QUFBQSxJQUNoRSxTQUFTLE9BQVA7QUFDRSxZQUFNLElBQUksaUJBQWlCLE1BQU0sU0FBUyxNQUFNLFFBQVEsU0FBUztBQUFBLElBQ3JFO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSxXQUE4QjtBQUNoQyxRQUFJO0FBQ0EsWUFBTSxFQUFDLE1BQU0sU0FBUSxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsUUFDeEM7QUFBQSxRQUFtQjtBQUFBLFVBQ2YsYUFBYTtBQUFBLFVBQ2IsU0FBUyxLQUFLO0FBQUEsUUFDdEI7QUFBQSxNQUFDO0FBQ0QsYUFBTyxTQUFTLElBQUksT0FBSyxFQUFFLElBQUk7QUFBQSxJQUNuQyxTQUFTLE9BQVA7QUFDRSxZQUFNLElBQUksaUJBQWlCLE1BQU0sU0FBUyxNQUFNLFFBQVEsVUFBVTtBQUFBLElBQ3RFO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSxjQUFpQztBQUNuQyxRQUFJO0FBQ0EsWUFBTSxFQUFDLE1BQU0sU0FBUSxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsUUFDeEM7QUFBQSxRQUNBO0FBQUEsVUFDSSxPQUFPLEtBQUs7QUFBQSxVQUNaLE1BQU0sS0FBSztBQUFBLFVBQ1gsU0FBUyxLQUFLO0FBQUEsUUFDdEI7QUFBQSxNQUFDO0FBQ0QsYUFBTyxTQUFTLElBQUksT0FBSyxFQUFFLElBQUk7QUFBQSxJQUNuQyxTQUFTLE9BQVA7QUFDRSxZQUFNLElBQUksaUJBQWlCLE1BQU0sU0FBUyxNQUFNLFFBQVEsVUFBVTtBQUFBLElBQ3RFO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSxPQUFPLEtBQThCO0FBQ3ZDLFFBQUk7QUFDQSxZQUFNLEVBQUMsTUFBTSxTQUFRLElBQUksTUFBTSxLQUFLLFFBQVE7QUFBQSxRQUN4QztBQUFBLFFBQTJDO0FBQUEsVUFDdkMsT0FBTyxLQUFLO0FBQUEsVUFDWixNQUFNLEtBQUs7QUFBQSxVQUNYO0FBQUEsVUFDQSxTQUFTLEtBQUs7QUFBQSxRQUN0QjtBQUFBLE1BQUM7QUFDRCxhQUFPLFNBQVMsT0FBTztBQUFBLElBQzNCLFNBQVMsT0FBUDtBQUNFLFlBQU0sSUFBSSxpQkFBaUIsTUFBTSxTQUFTLE1BQU0sUUFBUSxRQUFRO0FBQUEsSUFDcEU7QUFBQSxFQUNKO0FBQUE7QUFBQSxFQUdBLE1BQU0seUJBQXlCLE1BQU0sU0FBUyxLQUFLLFVBQTJCO0FBQzFFLFdBQU8sTUFBTSxLQUFLLE9BQU8sR0FBRztBQUFBLEVBQ2hDO0FBQUE7QUFBQTtBQUFBLEVBSUEsTUFBTSxpQkFBaUIsS0FBOEI7QUFDakQsVUFBTSxFQUFDLE1BQU0sT0FBTSxJQUFLLE1BQU0sS0FBSyxRQUFRO0FBQUEsTUFDdkM7QUFBQSxNQUEyQztBQUFBLFFBQzNDLE9BQU8sS0FBSztBQUFBLFFBQ1osTUFBTSxLQUFLO0FBQUEsUUFDWDtBQUFBLFFBQ0EsU0FBUyxLQUFLO0FBQUEsTUFDbEI7QUFBQSxJQUFDO0FBQ0QsV0FBTyxPQUFPLE9BQU8sS0FBSztBQUFBLEVBQzlCO0FBQUEsRUFFQSxNQUFNLFFBQVEsVUFBdUM7QUFDakQsVUFBTSxFQUFFLE1BQU0sS0FBSyxJQUFLLE1BQU0sS0FBSyxRQUFRO0FBQUEsTUFDdkMsY0FBYyxLQUFLLFNBQVMsS0FBSyxrQkFBa0I7QUFBQSxNQUFZO0FBQUEsUUFDL0QsT0FBTyxLQUFLO0FBQUEsUUFDWixNQUFNLEtBQUs7QUFBQSxRQUNYO0FBQUEsUUFDQSxXQUFXO0FBQUEsUUFDWCxTQUFTLEtBQUs7QUFBQSxNQUNsQjtBQUFBLElBQUM7QUFDRCxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBO0FBQUEsRUFHQSxNQUFNLGlCQUFpQixVQUFpRDtBQUNwRSxVQUFNLGFBQWEsTUFBTSxLQUFLLFFBQVEsUUFBUTtBQUM5QyxVQUFNLFlBQVksT0FBTyxZQUFZLFdBQVcsSUFBSSxDQUFDLFNBQTJDO0FBRzVGLFVBQUksS0FBSyxRQUFNLFFBQVE7QUFDbkIsWUFBSSxDQUFDLEtBQUssUUFBUSxDQUFDLEtBQUssS0FBSztBQUN6QixnQkFBTSxJQUFJLE1BQU0sK0NBQStDO0FBQUEsUUFDbkU7QUFDQSxlQUFPLENBQUMsS0FBSyxNQUFNLEtBQUssR0FBRztBQUFBLE1BQy9CO0FBQ0EsYUFBTztBQUFBLElBQ1gsQ0FBQyxFQUFFLE9BQU8sT0FBTyxDQUF1QjtBQUN4QyxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsTUFBTSxXQUFXLFNBQWlCLFVBQW1DO0FBQ2pFLFVBQU0sRUFBQyxNQUFNLEtBQUksSUFBSSxNQUFNLEtBQUssUUFBUTtBQUFBLE1BQ3BDO0FBQUEsTUFBd0M7QUFBQSxRQUN4QyxPQUFPLEtBQUs7QUFBQSxRQUNaLE1BQU0sS0FBSztBQUFBLFFBQ1g7QUFBQSxRQUNBO0FBQUEsUUFDQSxTQUFTLEtBQUs7QUFBQSxNQUNsQjtBQUFBLElBQUM7QUFDRCxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBR0EsTUFBTSx1QkFBdUIsRUFBQyxNQUFNLFFBQVEsVUFBUyxHQUFtQztBQUMxRixRQUFJLFdBQVcsV0FBVztBQUN6QixhQUFPO0FBQUEsUUFDTjtBQUFBLFFBQ0EsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBQ04sS0FBSztBQUFBLE1BQ047QUFBQSxJQUNEO0FBQ0EsUUFBSSxDQUFDLEtBQUssTUFBTSxRQUFRLE9BQU8sSUFBSSxHQUFHO0FBQ3JDLFlBQU0sSUFBSTtBQUFBLFFBQ0c7QUFBQTtBQUFBLE1BQ2lFO0FBQUEsSUFDL0U7QUFDQSxRQUFJO0FBQ0osUUFBSTtBQUVKLFFBQUksYUFBYSxzQkFBc0IsU0FBUyxTQUFTLEdBQUc7QUFDM0QsaUJBQVc7QUFDWCxZQUFNLGVBQWUsTUFBTSxLQUFLLE1BQU0sUUFBUSxXQUFXLElBQUk7QUFDN0QsWUFBTSxhQUFhLElBQUksV0FBVyxZQUFZO0FBQzlDLFVBQUksZUFBZTtBQUNuQixlQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxLQUFLO0FBQzNDLHdCQUFnQixPQUFPLGFBQWEsV0FBVyxDQUFDLENBQUM7QUFBQSxNQUNsRDtBQUNBLGdCQUFVLEtBQUssWUFBWTtBQUFBLElBQzVCLE9BQU87QUFDTixpQkFBVztBQUNYLGdCQUFVLE1BQU0sS0FBSyxNQUFNLFFBQVEsS0FBSyxJQUFJO0FBQUEsSUFDN0M7QUFDQSxVQUFNLFVBQVUsTUFBTSxLQUFLLFdBQVcsU0FBUyxRQUFRO0FBQ3ZELFdBQU87QUFBQSxNQUNOO0FBQUEsTUFDQSxNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUEsSUFDTjtBQUFBLEVBQ0Q7QUFBQSxFQUVHLE1BQU0sV0FDRixXQUNBLGVBQ2dCO0FBQ1osVUFBTSxFQUFDLE1BQU0sUUFBTyxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsTUFDdkM7QUFBQSxNQUNBO0FBQUEsUUFDSSxPQUFPLEtBQUs7QUFBQSxRQUNaLE1BQU0sS0FBSztBQUFBLFFBQ1gsTUFBTTtBQUFBLFFBQ04sV0FBVztBQUFBLFFBQ1gsU0FBUyxLQUFLO0FBQUEsTUFDbEI7QUFBQSxJQUNKO0FBQ0EsV0FBTyxRQUFRO0FBQUEsRUFDdkI7QUFBQSxFQUVBLE1BQU0sYUFBYSxTQUFpQixXQUFvQztBQUNwRSxVQUFNLFVBQVUsK0JBQStCLElBQUksS0FBSyxFQUFFLGVBQWU7QUFDekUsVUFBTSxFQUFFLE1BQU0sY0FBYyxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsTUFDL0M7QUFBQSxNQUEyQztBQUFBLFFBQzNDLE9BQU8sS0FBSztBQUFBLFFBQ1osTUFBTSxLQUFLO0FBQUEsUUFDWDtBQUFBLFFBQ0EsTUFBTTtBQUFBLFFBQ04sU0FBUyxDQUFDLFNBQVM7QUFBQSxRQUNuQixTQUFTLEtBQUs7QUFBQSxNQUNsQjtBQUFBLElBQUM7QUFDRCxXQUFPLGNBQWM7QUFBQSxFQUN6QjtBQUFBLEVBRUEsTUFBTSxVQUFVLEtBQWEsTUFBTSxTQUFTLEtBQUssVUFBMkI7QUFDeEUsVUFBTSxFQUFFLE1BQUssV0FBVyxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQUEsTUFDM0M7QUFBQSxNQUE4QztBQUFBLFFBQzlDLE9BQU8sS0FBSztBQUFBLFFBQ1osTUFBTSxLQUFLO0FBQUEsUUFDWDtBQUFBLFFBQ0E7QUFBQSxRQUNBLFNBQVMsS0FBSztBQUFBLE1BQ2xCO0FBQUEsSUFBQztBQUNELFdBQU8sV0FBVyxPQUFPO0FBQUEsRUFDN0I7QUFBQSxFQUVBLE1BQU0sUUFBUSxVQUFrQztBQUM1QyxVQUFNLEVBQUUsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLFFBQVE7QUFBQSxNQUN0QztBQUFBLE1BQWtEO0FBQUEsUUFDbEQsT0FBTyxLQUFLO0FBQUEsUUFDWixNQUFNLEtBQUs7QUFBQSxRQUNYO0FBQUEsUUFDQSxTQUFTLEtBQUs7QUFBQSxNQUNsQjtBQUFBLElBQUM7QUFDRCxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUNKOzs7QUNqVE8sSUFBTSxVQUFOLE1BQWtDO0FBQUEsRUFLckMsWUFBWSxLQUFVLFVBQTJCO0FBQzdDLFNBQUssV0FBVztBQUNoQixTQUFLLE1BQU07QUFBQSxFQUNmO0FBQUEsRUFFQSxNQUFNLGlCQUFpQixlQUErRDtBQUM5RSxRQUFJLENBQUMsS0FBSyxJQUFJLHNCQUFzQjtBQUNoQyxhQUFPLEtBQUssYUFBYSxFQUFFLElBQUksVUFBTTtBQUNqQyxlQUFPLEVBQUMsTUFBTSxRQUFRLFFBQTJCO0FBQUEsTUFDckQsQ0FBQztBQUFBLElBQ0w7QUFDQSxVQUFNLGdCQUFnQjtBQUFBLE1BQ2xCO0FBQUEsTUFBZSxLQUFLLElBQUk7QUFBQSxNQUFzQjtBQUFBLElBQVE7QUFDMUQsV0FBTztBQUFBLEVBQ2Y7QUFBQSxFQUVBLGtCQUFrQixjQUE2QixlQUF3QztBQUNuRixVQUFNLG1CQUFtQixhQUFhLElBQUksT0FBRyxFQUFFLElBQUk7QUFDbkQsVUFBTSxvQkFBb0IsY0FBYyxJQUFJLE9BQUcsRUFBRSxJQUFJO0FBQ3JELFVBQU0sZUFBeUIsaUJBQWlCO0FBQUEsTUFDNUMsVUFBUSxrQkFBa0IsU0FBUyxJQUFJO0FBQUEsSUFBQztBQUM1QyxXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUEsRUFHQSxNQUFNLG1CQUEyQztBQUM3QyxVQUFNLHdCQUF3QixNQUFNLEtBQUssSUFBSSx5QkFBeUI7QUFDdEUsUUFBSSx5QkFBeUIsS0FBSyxJQUFJLHNCQUFzQjtBQUN4RCxhQUFPO0FBQUEsSUFDWDtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFNLHFCQUFxQixjQUEyRDtBQUNsRixVQUFNLHdCQUF3QixNQUFNLEtBQUssaUJBQWlCO0FBQzFELFFBQUksQ0FBQyx1QkFBdUI7QUFDeEIsYUFBTyxFQUFDLFFBQVEscUJBQXFCLGNBQWMsS0FBSTtBQUFBLElBQzNEO0FBQ0EsUUFBSSxDQUFDLGNBQWM7QUFDZixxQkFBZSxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFBQSxJQUNsRDtBQUNBLFVBQU0sZ0JBQWdCLE1BQU0sS0FBSyxJQUFJLGlCQUFpQixxQkFBcUI7QUFDM0UsVUFBTSxnQkFBZ0IsTUFBTSxLQUFLLGlCQUFpQixhQUFhO0FBQy9ELFVBQU0sZUFBZSxLQUFLLGtCQUFrQixjQUFjLGFBQWE7QUFFdkUsVUFBTSxxQkFDRCxjQUFjLFNBQVMsSUFDbkIsYUFBYSxTQUFTLElBQUssdUNBQXVDLDZCQUNuRTtBQUVSLFdBQU87QUFBQSxNQUNILFFBQVE7QUFBQSxNQUNSLGNBQWM7QUFBQSxRQUNWO0FBQUEsUUFBZTtBQUFBLFFBQWU7QUFBQSxRQUF1QjtBQUFBLE1BQ3pEO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQTtBQUFBLEVBR0EsTUFBTSxtQ0FBbUMsWUFBb0M7QUFDekUsVUFBTSxnQkFBZ0IsT0FBTyxRQUFRLFVBQVUsRUFBRSxJQUFJLE9BQU8sQ0FBQyxNQUFNLFFBQVEsTUFBTTtBQUM3RSxZQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksUUFBUSxRQUFRO0FBQy9DLGFBQU8sRUFBQyxNQUFNLFFBQU87QUFBQSxJQUN6QixDQUFDO0FBQ0QsV0FBTyxNQUFNLFFBQVEsSUFBSSxhQUFhO0FBQUEsRUFDMUM7QUFBQSxFQUVBLE1BQU0sd0JBQXdCLGVBQStCO0FBQ3pELFVBQU0sa0JBQWtCLGNBQWMsT0FBTyxPQUFHLEVBQUUsVUFBUSxTQUFTLEVBQUUsSUFBSSxPQUFHLEVBQUUsSUFBSTtBQUN2RixVQUFNLG1CQUFtQixjQUFjLE9BQU8sT0FBRyxFQUFFLFVBQVEsU0FBUyxFQUFFO0FBQUEsTUFDckUsQ0FBQyxLQUFLLFdBQVc7QUFDRCxZQUFJLE9BQU8sSUFBSSxJQUFJLE9BQU87QUFDekMsZUFBTztBQUFBLE1BQ0k7QUFBQSxNQUFHLENBQUM7QUFBQSxJQUEyQjtBQUU3QyxVQUFNLGFBQWEsTUFBTSxLQUFLLG1DQUFtQyxnQkFBZ0I7QUFDM0UsV0FBTyxFQUFDLFlBQVksZ0JBQWU7QUFBQSxFQUN2QztBQUFBLEVBRUEsTUFBTSxrQkFDRixjQUNBLHdCQUNjO0FBQ1YsVUFBTSxFQUFDLGVBQWUsZUFBZSxzQkFBcUIsSUFBSTtBQUM5RCxVQUFNLEVBQUMsWUFBWSxnQkFBZSxJQUFJLE1BQU0sS0FBSyx3QkFBd0IsYUFBYTtBQUcvRixVQUFNLEtBQUssU0FBUyxpQkFBaUIsWUFBWSxlQUFlO0FBQ2hFLFVBQU0sdUJBQXVCO0FBQUEsTUFDaEIsc0JBQXNCO0FBQUEsTUFDdEIsc0JBQXNCO0FBQUEsTUFDdEIsVUFBVSxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFBQSxJQUM3QyxDQUFDO0FBQUEsRUFDVDtBQUNKOzs7QUNySUEsc0JBQXVCO0FBa0NoQixJQUFNLFVBQU4sTUFBa0M7QUFBQSxFQU1yQyxZQUFZLEtBQVUsVUFBMkI7QUFDN0MsU0FBSyxXQUFXO0FBQ2hCLFNBQUssTUFBTTtBQUFBLEVBQ2Y7QUFBQSxFQUdBLE1BQU0sdUJBQW9EO0FBQ3RELFVBQU0sZUFBZSxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFDcEQsVUFBTSxlQUFlLE1BQU0sS0FBSyxJQUFJLGdCQUFnQixZQUFZO0FBQ2hFLFFBQUksYUFBYSxVQUFVLEdBQUc7QUFDMUIsYUFBTyxFQUFDLFFBQVEsMEJBQTBCLGFBQWEsS0FBSTtBQUFBLElBQy9EO0FBQ0EsVUFBTSx3QkFBd0IsTUFBTSxLQUFLLElBQUkseUJBQXlCO0FBQ3RFLFVBQU0sU0FDRCx5QkFBeUIsS0FBSyxJQUFJLHVCQUNuQyxrQkFBa0I7QUFFdEIsV0FBTztBQUFBLE1BQ0g7QUFBQSxNQUNBLGFBQWEsRUFBQyxjQUFjLGNBQWMsaUJBQWlCLHNCQUFxQjtBQUFBLElBQ3BGO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBTSw0QkFBNEIsYUFBMkM7QUFDekUsVUFBTSxFQUFDLGNBQWMsZ0JBQWUsSUFBSTtBQUN4QyxVQUFNLFlBQVksTUFBTSxRQUFRLElBQUksYUFBYSxJQUFJLENBQUMsTUFBTTtBQUN4RCxhQUFPLEtBQUssSUFBSSx1QkFBdUIsQ0FBQztBQUFBLElBQzVDLENBQUMsQ0FBQztBQUNGLFVBQU0sNEJBQTRCLE1BQU0sS0FBSyxJQUFJLGlCQUFpQixlQUFlO0FBQ2pGLFVBQU0saUJBQWlCLE1BQU0sS0FBSyxJQUFJLFdBQVcsV0FBVyx5QkFBeUI7QUFDckYsVUFBTSxtQkFBbUIsTUFBTSxLQUFLLElBQUksYUFBYSxnQkFBZ0IsZUFBZTtBQUNwRixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBSUEsTUFBTSx5QkFDRixhQUNBLHdCQUNjO0FBQ1YsVUFBTSxFQUFDLGNBQWMsYUFBWSxJQUFJO0FBQ3JDLFVBQU0sbUJBQW1CLE1BQU0sS0FBSyw0QkFBNEIsV0FBVztBQUMzRSxVQUFNLGdCQUFnQixNQUFNLEtBQUssSUFBSSxVQUFVLGdCQUFnQjtBQUMvRCxVQUFNLHVCQUF1QixNQUFNLEtBQUssSUFBSSxpQkFBaUIsYUFBYTtBQUUxRSxVQUFNLHVCQUF1QjtBQUFBLE1BQ3pCLHNCQUFzQjtBQUFBLE1BQ3RCLHNCQUFzQjtBQUFBLE1BQ3RCLFVBQVU7QUFBQSxJQUNkLENBQUM7QUFFRCxpQkFBYSxJQUFJLENBQUMsRUFBQyxNQUFNLE9BQU0sTUFBVTtBQUNyQyxZQUFNLGlCQUFpQixFQUFDLFNBQVMsZ0JBQWdCLFNBQVMsWUFBWSxTQUFTLGNBQWE7QUFDNUYsVUFBSSx1QkFBTyxHQUFHLFFBQVEsZUFBZSxNQUFNLGFBQWEsR0FBSztBQUFBLElBQ2pFLENBQUM7QUFBQSxFQUNUO0FBQ0o7OztBQ2pHQSxJQUFBRyxtQkFBK0M7QUFFL0MscUJBQXFCO0FBSXJCLElBQXFCLGdCQUFyQixjQUEyQyxrQ0FBaUI7QUFBQSxFQWEzRCxZQUFZLEtBQVUsUUFBbUI7QUFDeEMsVUFBTSxLQUFLLE1BQU07QUFRbEIseUJBQWdCLE1BQWM7QUFDN0IsWUFBTSxFQUFDLE9BQU8sTUFBTSxPQUFNLElBQUksS0FBSyxPQUFPO0FBQzFDLFVBQUksTUFBTSxTQUFTLEtBQUssS0FBSyxTQUFTLEtBQUssT0FBTyxTQUFTLEdBQUc7QUFDN0QsZUFBTyxzQkFBc0IsU0FBUyxhQUFhO0FBQUEsTUFDcEQ7QUFDQSxhQUFPO0FBQUEsSUFDUjtBQUVBLDJCQUFrQixZQUFZO0FBQzdCLFdBQUssaUJBQWlCO0FBQ3RCLFdBQUssZUFBZSxZQUFZLE9BQU87QUFDdkMsV0FBSyxlQUFlLE1BQU07QUFDMUIsV0FBSyxlQUFlLFlBQVksT0FBTztBQUN2QyxXQUFLLGVBQWUsU0FBUyxLQUFLO0FBQ2xDLFVBQUk7QUFDSCxjQUFNLEVBQUMsT0FBTyxVQUFTLElBQUksTUFBTSxLQUFLLE9BQU8sSUFBSSxRQUFRO0FBQ3pELGFBQUssZUFBZSxZQUFZLEtBQUs7QUFDckMsYUFBSyxlQUFlLFNBQVMsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLFVBQVUsRUFBRSxDQUFDO0FBQ2hFLGFBQUssZUFBZSxRQUFRLEtBQUs7QUFDakMsWUFBSSxVQUFVLEtBQUssT0FBTyxTQUFTLE9BQU87QUFDekMsZUFBSyxPQUFPLFNBQVMsUUFBUTtBQUM3QixlQUFLLE9BQU8sU0FBUyxZQUFZO0FBQ2pDLGVBQUssT0FBTyxTQUFTLE9BQU87QUFDNUIsZUFBSyxPQUFPLFNBQVMsU0FBUztBQUM5QixlQUFLLG1CQUFtQixDQUFDO0FBQ3pCLGVBQUssZ0JBQWdCLENBQUM7QUFDdEIsZ0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0IsZ0JBQU0sS0FBSyxjQUFjLFNBQVM7QUFBQSxRQUNuQztBQUNBLGFBQUssaUJBQWlCO0FBQUEsTUFDdkIsU0FBUyxPQUFQO0FBQ0QsYUFBSyxlQUFlLFlBQVksS0FBSztBQUNyQyxhQUFLLGVBQWUsU0FBUyxPQUFPO0FBQ3BDLGFBQUssZUFBZSxRQUFRLDhEQUE4RDtBQUMxRixhQUFLLE9BQU8sU0FBUyxRQUFRO0FBQzdCLGFBQUssT0FBTyxTQUFTLFlBQVk7QUFDakMsYUFBSyxPQUFPLFNBQVMsT0FBTztBQUM1QixhQUFLLE9BQU8sU0FBUyxTQUFTO0FBQzlCLGFBQUssbUJBQW1CLENBQUM7QUFDekIsYUFBSyxnQkFBZ0IsQ0FBQztBQUN0QixjQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLGFBQUssY0FBYyxZQUFZO0FBQy9CLGFBQUssaUJBQWlCO0FBQUEsTUFDdkI7QUFBQSxJQUNEO0FBRUEsK0JBQXNCLE1BQU07QUFDM0IsWUFBTSxFQUFDLFlBQVcsSUFBSTtBQUN0QixVQUFJLHlCQUFRLFdBQVcsRUFBRSxXQUFXLEVBQ25DLFFBQVEsa0JBQWtCLEVBQzFCLFVBQVUsWUFBVSxPQUNuQixPQUFPLEVBQ1AsY0FBYyxtQkFBbUIsRUFDakMsWUFBWSxLQUFLLGNBQWMsRUFDL0IsUUFBUSxZQUFVO0FBQ2xCLFlBQUksS0FBSztBQUFnQjtBQUN6QixjQUFNLEtBQUssZ0JBQWdCO0FBQUEsTUFDNUIsQ0FBQyxDQUFDO0FBQ0gsV0FBSyxlQUFlLElBQUkseUJBQVEsV0FBVyxFQUN6QyxRQUFRLHNIQUFzSCxFQUM5SCxlQUFlLFlBQVEsT0FDdEIsUUFBUSxRQUFRLEVBQ2hCLFdBQVcsdUJBQXVCLEVBQ2xDLFFBQVEsWUFBVTtBQUNsQixlQUFPLEtBQUssNkJBQTZCLFFBQVE7QUFBQSxNQUNsRCxDQUFDLENBQUM7QUFDSixXQUFLLGFBQWEsT0FBTyxTQUFTLHNCQUFzQjtBQUN4RCxVQUFJLEtBQUssT0FBTyxTQUFTLFVBQVUsSUFBSTtBQUN0QyxhQUFLLGlCQUFpQixLQUFLLGFBQWEsT0FBTztBQUFBLFVBQzlDLEVBQUMsS0FBSyw2QkFBNEI7QUFBQSxRQUFDO0FBQ3BDLGFBQUssaUJBQWlCLEtBQUssYUFBYSxPQUFPLFNBQVMsUUFBUSxFQUFDLEtBQUssb0JBQW1CLENBQUM7QUFDMUYsYUFBSyxlQUFlLFFBQVEsaUJBQWlCO0FBQUEsTUFDOUMsT0FBTztBQUNOLGFBQUssaUJBQWlCLEtBQUssYUFBYSxPQUFPO0FBQUEsVUFDOUMsRUFBQyxLQUFLLHVCQUFzQjtBQUFBLFFBQUM7QUFDOUIsYUFBSyxlQUFlLFNBQVMsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEtBQUssT0FBTyxTQUFTLFVBQVUsRUFBRSxDQUFDO0FBQ3JGLGFBQUssaUJBQWlCLEtBQUssYUFBYSxPQUFPLFNBQVMsUUFBUSxFQUFDLEtBQUssb0JBQW1CLENBQUM7QUFDMUYsYUFBSyxlQUFlLFFBQVEsS0FBSyxPQUFPLFNBQVMsS0FBSztBQUFBLE1BQ3ZEO0FBRUEsV0FBSyxhQUFhLFVBQVUsU0FBUyx5QkFBeUI7QUFFOUQsV0FBSyxhQUFhLElBQUkseUJBQVEsV0FBVyxFQUN2QyxRQUFRLDhCQUE4QixFQUN0QyxRQUFRLHlFQUF5RSxFQUNqRixRQUFRLFVBQVEsS0FDZixlQUFlLDhCQUE4QixFQUM3QyxTQUFTLEtBQUssT0FBTyxTQUFTLEdBQUcsRUFDakMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsYUFBSyxPQUFPLFNBQVMsTUFBTTtBQUMzQixjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDaEMsQ0FBQyxDQUFDLEVBQ0YsZUFBZSxZQUFRLE9BQ3RCLFFBQVEsZUFBZSxFQUN2QixXQUFXLGdCQUFnQixFQUMzQixRQUFRLFlBQVU7QUFDbEIsZUFBTyxLQUFLLDBDQUEwQyxRQUFRO0FBQUEsTUFDL0QsQ0FBQyxDQUFDO0FBQUEsSUFDTDtBQUVBLHlCQUFnQixZQUFZO0FBQzNCLFlBQU0sRUFBQyxZQUFXLElBQUk7QUFDdEIsVUFBSSx5QkFBUSxXQUFXLEVBQUUsV0FBVyxFQUFFLFFBQVEsaUJBQWlCLEVBQzlELFFBQVEsNERBQTRELEVBQ3BFLGVBQWUsWUFBVSxPQUN4QixXQUFXLGlDQUFpQyxFQUM1QyxZQUFZLEtBQUssT0FBTyxTQUFTLFVBQVUsRUFBRSxFQUM3QyxRQUFRLFlBQVksRUFDcEIsUUFBUSxZQUFZO0FBQ3BCLGNBQU0sS0FBSyxjQUFjLFNBQVM7QUFBQSxNQUNuQyxDQUFDLENBQUM7QUFFSCxVQUFJLHlCQUFRLFdBQVcsRUFDckIsUUFBUSwyR0FBMkcsRUFDbkgsZUFBZSxZQUFVLE9BQ3hCLFFBQVEsUUFBUSxFQUNoQixXQUFXLHlCQUF5QixFQUNwQyxRQUFRLE1BQU07QUFDZCxlQUFPLEtBQUssMEJBQTBCLFFBQVE7QUFBQSxNQUMvQyxDQUFDLENBQUM7QUFJSixXQUFLLGNBQWMsSUFBSSx5QkFBUSxXQUFXLEVBQ3hDLFFBQVEsd0JBQXdCLEVBQ2hDLFFBQVEsbUNBQW1DLEVBQzNDLFlBQVksY0FBWTtBQUN4QixpQkFBUyxTQUFTLFNBQVMsZUFBZTtBQUMxQyxhQUFLLGNBQWMsSUFBSSxVQUFNLFNBQVMsVUFBVSxNQUFNLElBQUksQ0FBQztBQUMzRCxpQkFBUyxZQUFZLEtBQUssY0FBYyxXQUFXLENBQUM7QUFDcEQsaUJBQVMsU0FBUyxLQUFLLE9BQU8sU0FBUyxJQUFJO0FBQzNDLGlCQUFTLFNBQVMsT0FBTyxVQUFVO0FBQ2xDLGdCQUFNLGNBQWMsVUFBVSxLQUFLLE9BQU8sU0FBUztBQUNuRCxjQUFJLGFBQWE7QUFDaEIsaUJBQUssT0FBTyxTQUFTLE9BQU87QUFDNUIsa0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0Isa0JBQU0sS0FBSyxjQUFjLFdBQVc7QUFBQSxVQUNyQztBQUFBLFFBQ0QsQ0FBQztBQUFBLE1BQ0YsQ0FBQztBQUVGLFdBQUssZ0JBQWdCLElBQUkseUJBQVEsV0FBVyxFQUMxQyxRQUFRLGFBQWEsRUFDckIsUUFBUSxnREFBZ0QsRUFDeEQsWUFBWSxjQUFZO0FBQ3hCLGlCQUFTLFNBQVMsU0FBUyxpQkFBaUI7QUFDNUMsaUJBQVMsWUFBWSxLQUFLLGlCQUFpQixXQUFXLENBQUM7QUFDdkQsYUFBSyxpQkFBaUIsSUFBSSxVQUFNLFNBQVMsVUFBVSxNQUFNLElBQUksQ0FBQztBQUM5RCxpQkFBUyxTQUFTLEtBQUssT0FBTyxTQUFTLE1BQU07QUFDN0MsaUJBQVMsU0FBUyxPQUFPLFVBQVU7QUFDbEMsZ0JBQU0sZ0JBQWdCLFVBQVUsS0FBSyxPQUFPLFNBQVM7QUFDckQsY0FBSSxlQUFlO0FBQ2xCLGlCQUFLLE9BQU8sU0FBUyxTQUFTO0FBQzlCLGtCQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLGtCQUFNLEtBQUssY0FBYyxTQUFTO0FBQUEsVUFDbkM7QUFBQSxRQUNELENBQUM7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBRUEseUJBQWdCLE1BQU07QUFDckIsWUFBTSxFQUFDLFlBQVcsSUFBSTtBQUN0QixXQUFLLFdBQVcsS0FBSyxjQUFjO0FBQ25DLFVBQUkseUJBQVEsV0FBVyxFQUFFLFdBQVcsRUFBRSxRQUFRLE1BQU07QUFDcEQsWUFBTSxjQUFjLElBQUkseUJBQVEsV0FBVyxFQUN6QyxRQUFRLDJCQUEyQixFQUNuQyxRQUFRLEtBQUssUUFBUSxFQUNyQixlQUFlLFlBQVUsT0FDeEIsUUFBUSxZQUFZLEVBQ3BCLFFBQVEsWUFBWTtBQUNwQixnQkFBUSxJQUFJLEtBQUssY0FBYyxDQUFDO0FBQ2hDLGNBQU0sS0FBSyxjQUFjLFNBQVM7QUFBQSxNQUNuQyxDQUFDLENBQUMsRUFDRjtBQUFBLFFBQWUsWUFBVSxPQUN4QixZQUFZLEtBQUssU0FBUyxXQUFXLENBQUMsRUFDdEMsV0FBVyxnQkFBZ0IsRUFDM0IsUUFBUSxlQUFlLEVBQ3ZCLFFBQVEsTUFBTTtBQUNkLGtCQUFRLElBQUksV0FBVyxLQUFLLFVBQVU7QUFDdEMsaUJBQU8sS0FBSyxLQUFLLFVBQVUsUUFBUTtBQUFBLFFBQ3BDLENBQUM7QUFBQSxNQUNGO0FBQ0Qsa0JBQVksT0FBTyxTQUFTLFdBQVc7QUFBQSxJQUN4QztBQUVBLDRCQUFtQixNQUFNO0FBQ3hCLFlBQU0sRUFBQyxZQUFXLElBQUk7QUFDdEIsVUFBSSx5QkFBUSxXQUFXLEVBQUUsV0FBVyxFQUFFLFFBQVEsc0JBQXNCO0FBQ3BFLFVBQUkseUJBQVEsV0FBVyxFQUNyQixRQUFRLGFBQWEsRUFDckIsUUFBUSw0Q0FBNEMsRUFDcEQsUUFBUSxVQUFRLEtBQ2YsZUFBZSxhQUFhLEVBQzVCLFNBQVMsS0FBSyxPQUFPLFNBQVMsVUFBVSxFQUN4QyxTQUFTLE9BQU8sVUFBVTtBQUMxQixhQUFLLE9BQU8sU0FBUyxhQUFhO0FBQ2xDLGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNoQyxDQUFDLENBQUM7QUFFSixVQUFJLHlCQUFRLFdBQVcsRUFDckIsUUFBUSxvQkFBb0IsRUFDNUIsUUFBUSxrSUFBa0ksRUFDMUk7QUFBQSxRQUFVLGNBQVUsU0FDbkIsU0FBUyxLQUFLLE9BQU8sU0FBUyxnQkFBZ0IsRUFDOUMsU0FBUyxPQUFPQyxjQUFhO0FBQzdCLGVBQUssT0FBTyxTQUFTLG1CQUFtQkE7QUFDeEMsZ0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxRQUNoQyxDQUFDO0FBQUEsTUFDRjtBQUVELFlBQU0sc0JBQXNCLElBQUkseUJBQVEsV0FBVyxFQUNqRCxRQUFRLHVCQUF1QixFQUMvQixRQUFRLGtFQUFrRSxLQUFLLE9BQU8sU0FBUyw2QkFBNkIsRUFDNUg7QUFBQSxRQUFVLFlBQVUsT0FDbkIsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUNsQixTQUFTLEtBQUssT0FBTyxTQUFTLGtCQUFrQixFQUNoRCxrQkFBa0IsRUFDbEIsU0FBUyxPQUFPLFVBQVU7QUFDMUIsZUFBSyxPQUFPLFNBQVMscUJBQXFCO0FBQzFDLGdCQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLDhCQUFvQixRQUFRLGtFQUFrRSxnQkFBZ0I7QUFBQSxRQUMvRyxDQUFDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSx5QkFBZ0IsT0FBTyxnQkFBbUM7QUFDekQsWUFBTSxFQUFDLFlBQVcsSUFBSTtBQUN0QixZQUFNLGdCQUFnQixZQUFZLGNBQWMsZ0JBQWdCO0FBQ2hFLFlBQU0sa0JBQWtCLFlBQVksY0FBYyxrQkFBa0I7QUFDcEUsWUFBTSxVQUFVLFlBQVksY0FBYyxZQUFZO0FBQ3RELFVBQUksZ0JBQWdCLFdBQVc7QUFDOUIsc0JBQWMsV0FBVztBQUN6Qix3QkFBZ0IsV0FBVztBQUMzQixhQUFLLGdCQUFnQixNQUFNLEtBQUssT0FBTyxJQUFJLFNBQVM7QUFDcEQsY0FBTSxjQUFjLE1BQU0sS0FBSyxjQUFjLE9BQU8sRUFBRSxJQUFJLFlBQVUsT0FBTyxLQUFLO0FBQ2hGLFlBQUksQ0FBQyxTQUFpQixLQUFLLGVBQWUsV0FBVyxHQUFHO0FBQ3ZELHdCQUFjLE1BQU07QUFDcEIsZUFBSyxjQUFjLElBQUksVUFBUTtBQUM5QiwwQkFBYyxJQUFJLElBQUksT0FBTyxNQUFNLElBQUksQ0FBQztBQUFBLFVBQ3pDLENBQUM7QUFFRCxnQkFBTSxvQkFBb0IsS0FBSyxjQUFjLFFBQVEsS0FBSyxPQUFPLFNBQVMsSUFBSTtBQUU5RSx3QkFBYyxnQkFBZ0I7QUFDOUIsY0FBSSxzQkFBb0IsSUFBRztBQUMxQixpQkFBSyxPQUFPLFNBQVMsT0FBTztBQUFBLFVBQzdCO0FBQUEsUUFDRDtBQUNBLHNCQUFjLFdBQVc7QUFBQSxNQUMxQjtBQUNBLFVBQUksZ0JBQWdCLGVBQWUsZ0JBQWdCLFdBQVc7QUFDN0QsWUFBSSxLQUFLLE9BQU8sU0FBUyxTQUFTLElBQUk7QUFDckMsMEJBQWdCLE1BQU07QUFBQSxRQUN2QixPQUFPO0FBQ04sZ0JBQU0saUJBQWlCLE1BQU0sS0FBSyxPQUFPLElBQUksWUFBWTtBQUN6RCxjQUFJLENBQUMsU0FBaUIsS0FBSyxrQkFBa0IsY0FBYyxHQUFHO0FBQzdELDRCQUFnQixNQUFNO0FBQ3RCLGlCQUFLLG1CQUFtQjtBQUN4QixpQkFBSyxpQkFBaUIsSUFBSSxZQUFVO0FBQ25DLDhCQUFnQixJQUFJLElBQUksT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUFBLFlBQy9DLENBQUM7QUFFRCxrQkFBTSxzQkFBc0IsS0FBSyxpQkFBaUIsUUFBUSxLQUFLLE9BQU8sU0FBUyxNQUFNO0FBRXJGLDRCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQUksd0JBQXNCLElBQUc7QUFDNUIsbUJBQUssT0FBTyxTQUFTLFNBQVM7QUFBQSxZQUMvQjtBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBQ0Esd0JBQWdCLFdBQVc7QUFBQSxNQUM1QjtBQUNBLFVBQUksZ0JBQWdCLGFBQWEsZ0JBQWdCLGVBQWUsZ0JBQWdCLFdBQVc7QUFDMUYsYUFBSyxXQUFXLEtBQUssY0FBYztBQUNuQyxnQkFBUSxZQUFZLEtBQUs7QUFBQSxNQUMxQjtBQUNBLFVBQUksZ0JBQWdCLGNBQWM7QUFDakMsY0FBTSxFQUFDLE1BQU0sT0FBTSxJQUFJLEtBQUssT0FBTztBQUNuQyxzQkFBYyxNQUFNO0FBQ3BCLHdCQUFnQixNQUFNO0FBQ3RCLHNCQUFjLElBQUksSUFBSSxPQUFPLE1BQU0sSUFBSSxDQUFDO0FBQ3hDLHdCQUFnQixJQUFJLElBQUksT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUM5QyxnQkFBUSxZQUFZLEtBQUssY0FBYztBQUFBLE1BQ3hDO0FBQ0EsVUFBSSxnQkFBZ0IsYUFBYTtBQUNoQyxzQkFBYyxNQUFNO0FBQ3BCLHdCQUFnQixNQUFNO0FBQ3RCLFlBQUksS0FBSyxjQUFjLFNBQVMsR0FBRztBQUNsQyxlQUFLLGNBQWMsSUFBSSxVQUFRO0FBQzlCLDBCQUFjLElBQUksSUFBSSxPQUFPLE1BQU0sSUFBSSxDQUFDO0FBQUEsVUFDekMsQ0FBQztBQUNELHdCQUFjLGdCQUFnQixLQUFLLGNBQWMsUUFBUSxLQUFLLE9BQU8sU0FBUyxJQUFJO0FBQUEsUUFDbkY7QUFDQSxZQUFJLEtBQUssaUJBQWlCLFNBQVMsR0FBRztBQUNyQyxlQUFLLGlCQUFpQixJQUFJLFlBQVU7QUFDbkMsNEJBQWdCLElBQUksSUFBSSxPQUFPLFFBQVEsTUFBTSxDQUFDO0FBQUEsVUFDL0MsQ0FBQztBQUNELGNBQUksS0FBSyxPQUFPLFNBQVMsV0FBVyxJQUFJO0FBQ3ZDLDRCQUFnQixnQkFBZ0I7QUFBQSxVQUNqQztBQUNBLDBCQUFnQixnQkFBZ0IsS0FBSyxpQkFBaUIsUUFBUSxLQUFLLE9BQU8sU0FBUyxNQUFNO0FBQUEsUUFDMUY7QUFDQSxZQUFJLEtBQUssT0FBTyxTQUFTLFNBQVMsSUFBSTtBQUNyQyxjQUFJLEtBQUssY0FBYyxXQUFXLEdBQUc7QUFDcEMsMEJBQWMsSUFBSSxJQUFJLE9BQU8sS0FBSyxPQUFPLFNBQVMsTUFBTSxLQUFLLE9BQU8sU0FBUyxJQUFJLENBQUM7QUFBQSxVQUNuRixPQUFPO0FBQ04sMEJBQWMsZ0JBQWdCLEtBQUssY0FBYyxRQUFRLEtBQUssT0FBTyxTQUFTLElBQUk7QUFDbEYsZ0JBQUksZ0JBQWdCLGtCQUFrQixJQUFJO0FBQ3pDLHVDQUFLLDRCQUE0QixLQUFLLE9BQU8sU0FBUyx3Q0FBd0MsS0FBSyxrQkFBa0I7QUFBQSxZQUN0SDtBQUFBLFVBQ0Q7QUFBQSxRQUNEO0FBQ0EsWUFBSSxLQUFLLE9BQU8sU0FBUyxXQUFXLElBQUk7QUFDdkMsY0FBSSxLQUFLLGlCQUFpQixXQUFXLEdBQUc7QUFDdkMsNEJBQWdCLElBQUksSUFBSSxPQUFPLEtBQUssT0FBTyxTQUFTLFFBQVEsS0FBSyxPQUFPLFNBQVMsTUFBTSxDQUFDO0FBQUEsVUFDekYsT0FBTztBQUNOLDRCQUFnQixnQkFBZ0IsS0FBSyxpQkFBaUIsUUFBUSxLQUFLLE9BQU8sU0FBUyxNQUFNO0FBQ3pGLGdCQUFJLGdCQUFnQixrQkFBa0IsSUFBSTtBQUN6Qyx1Q0FBSyw0QkFBNEIsS0FBSyxPQUFPLFNBQVMsd0NBQXdDLEtBQUssa0JBQWtCO0FBQUEsWUFDdEg7QUFBQSxVQUNEO0FBQUEsUUFDRDtBQUFBLE1BQ0Q7QUFBQSxJQUNEO0FBMVVDLFNBQUssU0FBUztBQUNkLFNBQUssV0FBVyxLQUFLLGNBQWM7QUFDbkMsU0FBSyxpQkFBaUI7QUFDdEIsU0FBSyxnQkFBZ0IsQ0FBQztBQUN0QixTQUFLLG1CQUFtQixDQUFDO0FBQUEsRUFDMUI7QUFBQSxFQXdVQSxNQUFNLFVBQXlCO0FBQzlCLFVBQU0sRUFBQyxZQUFXLElBQUk7QUFFdEIsZ0JBQVksTUFBTTtBQUVsQixTQUFLLG9CQUFvQjtBQUN6QixTQUFLLGNBQWM7QUFDbkIsU0FBSyxjQUFjO0FBQ25CLFNBQUssaUJBQWlCO0FBQ3RCLFNBQUssY0FBYyxXQUFXO0FBQUEsRUFDL0I7QUFDRDs7O0FDOVdBLElBQUFDLGtCQUFxQjtBQUNyQixJQUFBQyxtQkFBMEQ7QUFTbkQsSUFBTSxrQkFBTixNQUFrRDtBQUFBLEVBSXJELFlBQVksT0FBYztBQUN0QixTQUFLLFFBQVE7QUFDYixTQUFLLGlCQUFpQjtBQUFBLEVBQzFCO0FBQUEsRUFFQSxNQUFNLGdCQUFnQixNQUE2QjtBQUUvQyxVQUFNLE9BQU8sS0FBSyxNQUFNLHNCQUFzQixJQUFJO0FBQ2xELFFBQUksUUFBUSxnQkFBZ0Isd0JBQU87QUFDL0IsWUFBTSxLQUFLLE1BQU0sT0FBTyxJQUFJO0FBQzVCLFVBQUksd0JBQU8sR0FBRyxrQ0FBa0MsS0FBSyxjQUFjO0FBQ25FO0FBQUEsSUFDSjtBQUNBLDhCQUFLLHdCQUF3Qix1REFBdUQsT0FBTyxPQUFPO0FBQUEsRUFDdEc7QUFBQSxFQUVBLE1BQU0sbUJBQW1CLE1BQTZCO0FBOUIxRDtBQWdDUSxVQUFNLGVBQWEsVUFBSyxNQUFNLFNBQVMsTUFBcEIsbUJBQXdCLE9BQU07QUFDakQsUUFBSSxjQUFjLE1BQU0sQ0FBRSxLQUFLLE1BQU0sZ0JBQWdCLFVBQVUsR0FBSTtBQUMvRCxZQUFNLEtBQUssTUFBTSxhQUFhLFVBQVU7QUFBQSxJQUM1QztBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sYUFBYSxNQUFjLFNBQWdDO0FBRzdELFVBQU0sT0FBTyxLQUFLLE1BQU0sc0JBQXNCLElBQUk7QUFDbEQsUUFBSSxRQUFRLGdCQUFnQix3QkFBTztBQUMvQixZQUFNLEtBQUssTUFBTSxhQUFhLFVBQU0sc0NBQW9CLE9BQU8sQ0FBQztBQUFBLElBQ3BFLFdBQVcsQ0FBQyxNQUFNO0FBQ2QsV0FBSyxtQkFBbUIsSUFBSTtBQUM1QixZQUFNLEtBQUssTUFBTSxhQUFhLFVBQU0sc0NBQW9CLE9BQU8sQ0FBQztBQUFBLElBQ3BFLE9BQU87QUFDSCxnQ0FBSyxHQUFHLG1FQUFtRSxtQkFBbUIsT0FBTyxNQUFNO0FBQUEsSUFDL0c7QUFDQSxRQUFJLHdCQUFPLEdBQUcsUUFBUSxPQUFPLFlBQVksNEJBQTRCLEtBQUssY0FBYztBQUN4RjtBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0saUJBQ0YsWUFDQSxpQkFBZ0M7QUFFNUIsVUFBTSxrQkFBa0IsV0FBVyxJQUFJLE9BQU8sRUFBQyxNQUFNLFFBQU8sTUFBTTtBQUM5RCxZQUFNLEtBQUssYUFBYSxNQUFNLE9BQU87QUFBQSxJQUN6QyxDQUFDO0FBR0QsVUFBTSxxQkFBcUIsZ0JBQWdCLElBQUksT0FBTyxTQUFTO0FBQzNELFlBQU0sS0FBSyxnQkFBZ0IsSUFBSTtBQUFBLElBQ25DLENBQUM7QUFDRCxVQUFNLFFBQVEsSUFBSSxDQUFDLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLENBQUM7QUFBQSxFQUNyRTtBQUNKOzs7QXJCbERBLElBQU0sbUJBQWdDO0FBQUEsRUFDckMsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsWUFBWTtBQUFBLEVBQ1osa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQ3JCO0FBU0EsSUFBTSxzQkFBbUM7QUFBQSxFQUN4QyxVQUFVLENBQUM7QUFBQSxFQUNYLHNCQUFzQjtBQUFBLEVBQ3RCLHNCQUFzQixDQUFDO0FBQ3hCO0FBR0EsSUFBcUIsWUFBckIsY0FBdUMsd0JBQU87QUFBQSxFQUE5QztBQUFBO0FBMERDO0FBQUEsa0NBQXlCLE9BQU8sZUFBb0Q7QUFDbkYsWUFBTSxLQUFLLGVBQWU7QUFDMUIsV0FBSyxhQUFhLEVBQUMsR0FBRyxLQUFLLFlBQVksR0FBRyxXQUFVO0FBQ3BELFlBQU0sS0FBSyxlQUFlO0FBQUEsSUFDM0I7QUFFQSxnQkFBTyxPQUFPLGVBQXNDO0FBQ25ELFVBQUksQ0FBQyxLQUFLLHdCQUF3QixHQUFHO0FBQUU7QUFBQSxNQUFPO0FBQzlDLFlBQU0sS0FBSyxlQUFlO0FBQzFCLGlCQUFXLFdBQVcsNkJBQTZCO0FBQ25ELFlBQU0sZUFBZSxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFDcEQsWUFBTSxnQkFBZ0IsTUFBTSxLQUFLLFFBQVEscUJBQXFCLFlBQVk7QUFDMUUsVUFBSSxjQUFjLFdBQVcsdUJBQXVCLGFBQWEsV0FBVyxHQUFHO0FBQzlFLG1CQUFXLFdBQVcseURBQXlEO0FBQUEsTUFDaEYsV0FDUyxjQUFjLFdBQVcsdUJBQXVCLGFBQWEsU0FBUyxHQUFHO0FBRWpGLGNBQU0sY0FBYztBQUFBLFVBQ25CO0FBQUEsVUFDQSxjQUFjLE1BQU0sS0FBSyxJQUFJLGdCQUFnQjtBQUFBO0FBQUEsVUFFN0MsaUJBQWlCLEtBQUssV0FBVztBQUFBLFFBQ2xDO0FBQ0EsY0FBTSxLQUFLLFFBQVEseUJBQXlCLGFBQWEsS0FBSyxzQkFBc0I7QUFDcEYsbUJBQVcsV0FBVywyREFBMkQ7QUFBQSxNQUNsRixXQUNTLGNBQWMsV0FBVyw2QkFBNkIsYUFBYSxXQUFXLEdBQUc7QUFDekYsY0FBTSxFQUFFLHNCQUFzQixJQUFJLGNBQWM7QUFDaEQsY0FBTSxLQUFLLHVCQUF1QixFQUFDLHNCQUFzQixzQkFBcUIsQ0FBQztBQUMvRSxtQkFBVyxXQUFXLDBEQUEwRDtBQUFBLE1BQ2pGLFdBQ1MsY0FBYyxXQUFXLDZCQUE2QixhQUFhLFNBQVMsR0FBRztBQUN2RixjQUFNLEVBQUUsc0JBQXNCLElBQUksY0FBYztBQUNoRCxjQUFNLGNBQWM7QUFBQSxVQUNuQjtBQUFBLFVBQ0EsY0FBYyxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFBQSxVQUM3QyxpQkFBaUI7QUFBQSxRQUNsQjtBQUNBLGNBQU0sS0FBSyxRQUFRLHlCQUF5QixhQUFhLEtBQUssc0JBQXNCO0FBQ3BGLG1CQUFXLFdBQVcsNkRBQTZEO0FBQUEsTUFDcEYsV0FDUyxjQUFjLFdBQVcsc0NBQXNDO0FBQ3ZFLG1CQUFXLFdBQVcsK0VBQStFO0FBQUEsTUFDdEcsV0FDUyxjQUFjLFdBQVcsOEJBQThCLGFBQWEsV0FBVyxHQUFHO0FBQzFGLGNBQU0sS0FBSyxRQUFRLGtCQUFrQixjQUFjLGNBQWMsS0FBSyxzQkFBc0I7QUFDNUYsbUJBQVcsV0FBVyxxREFBcUQ7QUFBQSxNQUM1RSxXQUNTLGNBQWMsV0FBVyw4QkFBOEIsYUFBYSxTQUFTLEdBQUc7QUFNeEYsY0FBTSxFQUFDLGFBQVksSUFBSTtBQUN2QixjQUFNLGNBQWM7QUFBQSxVQUNuQjtBQUFBLFVBQ0EsY0FBYyxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFBQSxVQUM3QyxpQkFBaUIsYUFBYTtBQUFBLFFBQy9CO0FBQ0EsY0FBTSxFQUFDLFlBQVksZ0JBQWUsSUFBSSxNQUFNLEtBQUssUUFBUTtBQUFBLFVBQ3hELGFBQWE7QUFBQSxRQUFhO0FBQzNCLGNBQU0sbUJBQW1CLE1BQU0sS0FBSyxRQUFRLDRCQUE0QixXQUFXO0FBQ25GLGNBQU0sZ0JBQWdCLE1BQU0sS0FBSyxJQUFJLFVBQVUsZ0JBQWdCO0FBQy9ELG1CQUFXLFdBQVcsaUNBQWlDO0FBQzlDLGNBQU0sdUJBQXVCLE1BQU0sS0FBSyxJQUFJLGlCQUFpQixhQUFhO0FBQ25GLGNBQU0sS0FBSyxTQUFTLGlCQUFpQixZQUFZLGVBQWU7QUFDaEUsbUJBQVcsV0FBVyx3Q0FBd0M7QUFDOUQsY0FBTSxLQUFLLHVCQUF1QjtBQUFBLFVBQ2pDLHNCQUFzQjtBQUFBLFVBQ3RCLHNCQUFzQjtBQUFBLFVBQ3RCLFVBQVUsTUFBTSxLQUFLLElBQUksZ0JBQWdCO0FBQUEsUUFDMUMsQ0FBQztBQUNELG1CQUFXLFdBQVcsK0JBQStCO0FBQUEsTUFDdEQ7QUFBQSxJQUNEO0FBRUEsZ0JBQU8sT0FBTyxlQUFzQztBQUNuRCxVQUFJLENBQUMsS0FBSyx3QkFBd0IsR0FBRztBQUFFO0FBQUEsTUFBTztBQUM5QyxZQUFNLEtBQUssZUFBZTtBQUMxQixpQkFBVyxXQUFXLDZCQUE2QjtBQUNuRCxZQUFNLHFCQUFxQixNQUFNLEtBQUssUUFBUSxxQkFBcUI7QUFDbkUsVUFBSSxtQkFBbUIsV0FBVyxxQkFBcUI7QUFDdEQsbUJBQVcsV0FBVywrQkFBK0I7QUFBQSxNQUN0RCxXQUFXLG1CQUFtQixXQUFXLHNDQUFzQztBQUU5RSxtQkFBVyxXQUFXLDBFQUEwRTtBQUFBLE1BQ2pHLFdBQVcsbUJBQW1CLFdBQVcsNEJBQTRCO0FBQ3BFLG1CQUFXLFdBQVcsMERBQTBEO0FBQ2hGLGNBQU0sZUFBZSxtQkFBbUI7QUFDeEMsY0FBTSxLQUFLLFFBQVEsa0JBQWtCLGNBQWMsS0FBSyxzQkFBc0I7QUFDOUUsbUJBQVcsV0FBVyx1Q0FBdUM7QUFBQSxNQUM5RCxXQUFXLG1CQUFtQixXQUFXLDJCQUEyQjtBQUNuRSxjQUFNLEVBQUMsdUJBQXVCLHFCQUFvQixJQUFJLG1CQUFtQjtBQUN6RSxhQUFLLHVCQUF1QixFQUFDLHFCQUFvQixDQUFDO0FBQ2xELG1CQUFXLFdBQVcsb0VBQW9FO0FBQUEsTUFDM0Y7QUFDQTtBQUFBLElBQ0Q7QUFFQSxnQkFBTyxPQUFPLGVBQXNDO0FBQ25ELGlCQUFXLFdBQVcsNkJBQTZCO0FBQ25ELFVBQUksQ0FBQyxLQUFLLHdCQUF3QixHQUFHO0FBQ3BDLGFBQUssVUFBVTtBQUNmO0FBQUEsTUFDRDtBQUNBLFlBQU0sS0FBSyxlQUFlO0FBQzFCLFlBQU0scUJBQXFCLE1BQU0sS0FBSyxRQUFRLHFCQUFxQjtBQUNuRSxVQUFJLG1CQUFtQixXQUFXLDBCQUEwQjtBQUMzRCxtQkFBVyxXQUFXLDRCQUE0QjtBQUFBLE1BQ25ELFdBQVcsbUJBQW1CLFdBQVcsaUJBQWlCO0FBQ3pELG1CQUFXLFdBQVcsMERBQTBEO0FBQUEsTUFDakYsV0FBVyxtQkFBbUIsV0FBVywyQkFBMkI7QUFDbkUsY0FBTSxjQUFjLG1CQUFtQjtBQUN2QyxtQkFBVyxXQUFXLDhEQUE4RDtBQUNwRixjQUFNLEtBQUssUUFBUSx5QkFBeUIsYUFBYSxLQUFLLHNCQUFzQjtBQUNwRixtQkFBVyxXQUFXLHdCQUF3QixLQUFLLElBQUksTUFBTTtBQUFBLE1BQzlEO0FBQ0E7QUFBQSxJQUNEO0FBR0E7QUFBQSwrQkFBc0IsT0FBK0IsTUFBa0QsV0FBbUIsU0FBNkI7QUFDdEosVUFBSTtBQUNILGNBQU0sU0FBUyxNQUFNLEtBQUssUUFBUSxHQUFHLElBQUk7QUFDekMsZUFBTztBQUFBLE1BQ1IsU0FBUyxPQUFQO0FBQ0QsWUFBSSxpQkFBaUIsa0JBQWtCO0FBQ3RDLGtCQUFRLE1BQU0sUUFBUTtBQUFBLFlBQ3JCLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFDSixzQkFBUSxNQUFNLDhCQUE4QixNQUFNLE9BQU87QUFDekQsa0JBQUksTUFBTSxXQUFXLEtBQUs7QUFDekIsdUJBQU8sV0FBVyxnRkFBZ0Y7QUFDbEcsdUJBQU87QUFBQSxjQUNSO0FBQ0EscUJBQU8sV0FBVyw4REFBOEQ7QUFDaEYscUJBQU87QUFBQSxZQUNSLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxZQUNMLEtBQUs7QUFBQSxVQUNOO0FBQ0EsaUJBQU87QUFBQSxRQUNSO0FBQ0EsZUFBTyxXQUFXLHFFQUFxRTtBQUN2RixlQUFPO0FBQUEsTUFDUjtBQUFBLElBQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQWhNQSxxQkFBcUI7QUFFcEIsVUFBTSxpQkFBaUIsS0FBSztBQU01QixtQkFBZSxRQUFRLEtBQUs7QUFDNUIsbUJBQWUsUUFBUSxZQUFZLEtBQUs7QUFBQSxFQUN6QztBQUFBLEVBRUEsMEJBQW1DO0FBQ2xDLFVBQU0sY0FBNkIsQ0FBQztBQUNwQyxRQUFJLEtBQUssU0FBUyxRQUFRLElBQUk7QUFDN0Isa0JBQVksS0FBSyxzQ0FBc0M7QUFBQSxJQUN4RDtBQUNBLFFBQUksS0FBSyxTQUFTLFVBQVUsSUFBSTtBQUMvQixrQkFBWSxLQUFLLHlDQUF5QztBQUFBLElBQzNEO0FBQ0EsUUFBSSxLQUFLLFNBQVMsU0FBUyxJQUFJO0FBQzlCLGtCQUFZLEtBQUssZ0NBQWdDO0FBQUEsSUFDbEQ7QUFDQSxRQUFJLEtBQUssU0FBUyxXQUFXLElBQUk7QUFDaEMsa0JBQVksS0FBSyw0QkFBNEI7QUFBQSxJQUM5QztBQUVBLFFBQUksWUFBWSxTQUFTLEdBQUc7QUFDM0IsWUFBTSxpQkFBaUIsS0FBSyxvQkFBb0IsQ0FBQyxRQUFRLENBQUM7QUFDMUQscUJBQWUsV0FBVywyRUFBMkUsWUFBWSxLQUFLLElBQUksQ0FBQztBQUMzSCxXQUFLLG1CQUFtQjtBQUN4QixXQUFLLGdCQUFnQixnQkFBZ0IsUUFBUTtBQUM3QyxhQUFPO0FBQUEsSUFFUjtBQUVBLFNBQUssSUFBSSxhQUFhLEtBQUssUUFBUTtBQUNuQyxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBNEpBLG9CQUFvQixhQUFhLENBQUMsU0FBUyxHQUFXO0FBQ3JELFVBQU0sU0FBUyxJQUFJLHdCQUFPLEtBQUssQ0FBQztBQUNoQyxXQUFPLFNBQVMsU0FBUyxZQUFZO0FBQ3JDLGVBQVcsSUFBSSxTQUFPLE9BQU8sU0FBUyxTQUFTLEdBQUcsQ0FBQztBQUNuRCxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUEsZ0JBQWdCLFFBQWdCLFlBQTJCO0FBQzFELFdBQU8sU0FBUyxZQUFZLFNBQVM7QUFDckMsUUFBSSxZQUFZO0FBQ2YsYUFBTyxTQUFTLFNBQVMsVUFBVTtBQUFBLElBQ3BDLE9BQU87QUFDTixhQUFPLFNBQVMsU0FBUyxNQUFNO0FBQUEsSUFDaEM7QUFDQSxlQUFXLE1BQU0sT0FBTyxLQUFLLEdBQUcsR0FBSTtBQUFBLEVBQ3JDO0FBQUEsRUFFQSxvQkFBb0I7QUFDbkIsUUFBSSxLQUFLLFNBQVMsa0JBQWtCO0FBQ25DLFdBQUssb0JBQW9CLFlBQVksTUFBTTtBQUMzQyxXQUFLLG9CQUFvQixTQUFTLE1BQU07QUFDeEMsV0FBSyxvQkFBb0IsU0FBUyxNQUFNO0FBQUEsSUFDekMsT0FBTztBQUNOLFdBQUssb0JBQW9CLFNBQVMsTUFBTTtBQUN4QyxXQUFLLG9CQUFvQixZQUFZLE1BQU07QUFDM0MsV0FBSyxvQkFBb0IsWUFBWSxNQUFNO0FBQUEsSUFDNUM7QUFBQSxFQUNEO0FBQUEsRUFHQSxrQkFBa0I7QUFFakIsU0FBSyxzQkFBc0IsS0FBSyxjQUFjLFVBQVUsWUFBWSxPQUFPLFFBQW9CO0FBQzlGLFVBQUksS0FBSyxXQUFXLEtBQUssV0FBVyxLQUFLLFNBQVM7QUFBRTtBQUFBLE1BQU87QUFDM0QsV0FBSyxVQUFVO0FBQ2YsV0FBSyxvQkFBb0IsU0FBUyxjQUFjO0FBQ2hELFlBQU0sYUFBYSxLQUFLLG9CQUFvQjtBQUM1QyxZQUFNLGNBQWMsTUFBTSxLQUFLLG9CQUFvQixLQUFLLE1BQU0sVUFBVTtBQUN4RSxXQUFLLG9CQUFvQixZQUFZLGNBQWM7QUFDbkQsVUFBSSxnQkFBZ0IsTUFBTTtBQUN6QixhQUFLLGdCQUFnQixZQUFZLE9BQU87QUFDeEMsYUFBSyxVQUFVO0FBQ2Y7QUFBQSxNQUNEO0FBQ0EsV0FBSyxnQkFBZ0IsVUFBVTtBQUMvQixXQUFLLFVBQVU7QUFBQSxJQUNoQixDQUFDO0FBQ0QsU0FBSyxvQkFBb0IsU0FBUyxvQkFBb0I7QUFHdEQsU0FBSyxzQkFBc0IsS0FBSyxjQUFjLFVBQVUsWUFBWSxPQUFPLFFBQW9CO0FBQzlGLFVBQUksS0FBSyxXQUFXLEtBQUssV0FBVyxLQUFLLFNBQVM7QUFBRTtBQUFBLE1BQU87QUFDM0QsV0FBSyxVQUFVO0FBQ2YsV0FBSyxvQkFBb0IsU0FBUyxjQUFjO0FBQ2hELFlBQU0sYUFBYSxLQUFLLG9CQUFvQjtBQUM1QyxZQUFNLGNBQWMsTUFBTSxLQUFLLG9CQUFvQixLQUFLLE1BQU0sVUFBVTtBQUN4RSxXQUFLLG9CQUFvQixZQUFZLGNBQWM7QUFDbkQsVUFBSSxnQkFBZ0IsTUFBTTtBQUN6QixhQUFLLGdCQUFnQixZQUFZLE9BQU87QUFDeEMsYUFBSyxVQUFVO0FBQ2Y7QUFBQSxNQUNEO0FBQ0EsV0FBSyxnQkFBZ0IsVUFBVTtBQUMvQixXQUFLLFVBQVU7QUFDZixXQUFLLG9CQUFvQixZQUFZLGNBQWM7QUFBQSxJQUNwRCxDQUFDO0FBQ0QsU0FBSyxvQkFBb0IsU0FBUyxvQkFBb0I7QUFHdEQsU0FBSyxzQkFBc0IsS0FBSyxjQUFjLFVBQVUsWUFBWSxPQUFPLFFBQW9CO0FBQzlGLFVBQUksS0FBSyxXQUFXLEtBQUssV0FBVyxLQUFLLFNBQVM7QUFBRTtBQUFBLE1BQU87QUFDM0QsV0FBSyxvQkFBb0IsU0FBUyxjQUFjO0FBQ2hELFdBQUssVUFBVTtBQUNmLFlBQU0sYUFBYSxLQUFLLG9CQUFvQjtBQUM1QyxZQUFNLGNBQWMsTUFBTSxLQUFLLG9CQUFvQixLQUFLLE1BQU0sVUFBVTtBQUN4RSxXQUFLLG9CQUFvQixZQUFZLGNBQWM7QUFDbkQsVUFBSSxnQkFBZ0IsTUFBTTtBQUN6QixhQUFLLGdCQUFnQixZQUFZLE9BQU87QUFDeEMsYUFBSyxVQUFVO0FBQ2Y7QUFBQSxNQUNEO0FBQ0EsV0FBSyxnQkFBZ0IsVUFBVTtBQUMvQixXQUFLLFVBQVU7QUFDZixXQUFLLG9CQUFvQixZQUFZLGNBQWM7QUFBQSxJQUNwRCxDQUFDO0FBQ0QsU0FBSyxvQkFBb0IsU0FBUyxvQkFBb0I7QUFDdEQsU0FBSyxrQkFBa0I7QUFBQSxFQUN4QjtBQUFBLEVBR0EsTUFBTSxTQUFTO0FBQ2QsVUFBTSxLQUFLLGFBQWE7QUFDeEIsVUFBTSxLQUFLLGVBQWU7QUFDMUIsU0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLFVBQVUsS0FBSyxZQUFZLEtBQUssSUFBSSxLQUFLO0FBQ2pFLFNBQUssV0FBVyxJQUFJLGdCQUFnQixLQUFLLElBQUksS0FBSztBQUNsRCxTQUFLLFVBQVUsSUFBSSxRQUFRLEtBQUssS0FBSyxLQUFLLFFBQVE7QUFDbEQsU0FBSyxVQUFVLElBQUksUUFBUSxLQUFLLEtBQUssS0FBSyxRQUFRO0FBQ2xELFNBQUssVUFBVTtBQUNmLFNBQUssVUFBVTtBQUNmLFNBQUssVUFBVTtBQUNmLFNBQUssYUFBYSxJQUFJLGNBQWMsS0FBSyxLQUFLLElBQUk7QUFDbEQsU0FBSyxnQkFBZ0I7QUFJckIsU0FBSyxXQUFXO0FBQUEsTUFDZixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUE7QUFBQSxNQUVMLFVBQVUsWUFBWTtBQUNyQixhQUFLLFdBQVcsV0FBVyxNQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFDMUQsYUFBSyxlQUFlO0FBQ3BCLFlBQUksd0JBQU8sa0dBQWtHO0FBQUEsTUFDOUc7QUFBQSxJQUNELENBQUM7QUFHRixTQUFLLGNBQWMsSUFBSSxjQUFjLEtBQUssS0FBSyxJQUFJLENBQUM7QUFHcEQsU0FBSyxpQkFBaUIsT0FBTyxZQUFZLFlBQVk7QUFDcEQsVUFBSSxLQUFLLHdCQUF3QixHQUFHO0FBQ25DLGNBQU0seUJBQXlCLE1BQU0sS0FBSyxRQUFRLGlCQUFpQjtBQUNuRSxZQUFJLHdCQUF3QjtBQUMzQixnQkFBTSxpQkFBaUIsS0FBSyxvQkFBb0IsQ0FBQyxRQUFRLENBQUM7QUFDMUQseUJBQWUsV0FBVyx5REFBeUQ7QUFBQSxRQUNwRjtBQUFBLE1BQ0Q7QUFBQSxJQUNELEdBQUcsS0FBSyxTQUFTLHFCQUFxQixLQUFLLEdBQUksQ0FBQztBQUFBLEVBQ2pEO0FBQUEsRUFFQSxXQUFXO0FBQUEsRUFBQztBQUFBLEVBRVosTUFBTSxlQUFlO0FBQ3BCLFVBQU0sY0FBYyxNQUFNLEtBQUssU0FBUztBQUN4QyxVQUFNLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsV0FBVztBQUNoRSxVQUFNLGNBQTJCLE9BQU8sS0FBSyxnQkFBZ0IsRUFBRTtBQUFBLE1BQzlELENBQUMsS0FBSyxRQUEyQjtBQUNoQyxZQUFJLFNBQVMsZUFBZSxHQUFHLEdBQUc7QUFDakMsY0FBSSxPQUFPLG9CQUFvQjtBQUM5QixnQkFBSSxHQUFHLElBQUksUUFBUSxTQUFTLEdBQUcsQ0FBQztBQUFBLFVBQ2pDLFdBQVcsT0FBTyxzQkFBc0I7QUFDdkMsZ0JBQUksR0FBRyxJQUFJLE9BQU8sU0FBUyxHQUFHLENBQUM7QUFBQSxVQUNoQyxPQUFPO0FBQ04sZ0JBQUksR0FBRyxJQUFJLFNBQVMsR0FBRztBQUFBLFVBQ3hCO0FBQUEsUUFDRDtBQUNBLGVBQU87QUFBQSxNQUNSO0FBQUEsTUFBRyxDQUFDO0FBQUEsSUFBZ0I7QUFDckIsU0FBSyxXQUFXO0FBQUEsRUFDakI7QUFBQSxFQUVBLE1BQU0saUJBQWlCO0FBQ3RCLFVBQU0sYUFBYSxPQUFPLE9BQU8sQ0FBQyxHQUFHLHFCQUFxQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQy9FLFVBQU0sZ0JBQTZCLE9BQU8sS0FBSyxtQkFBbUIsRUFBRTtBQUFBLE1BQ25FLENBQUMsS0FBSyxRQUEyQjtBQUNoQyxZQUFJLFdBQVcsZUFBZSxHQUFHLEdBQUc7QUFDbkMsY0FBSSxHQUFHLElBQUksV0FBVyxHQUFHO0FBQUEsUUFDMUI7QUFDQSxlQUFPO0FBQUEsTUFDUjtBQUFBLE1BQUcsQ0FBQztBQUFBLElBQWdCO0FBQ3JCLFNBQUssYUFBYTtBQUFBLEVBQ25CO0FBQUE7QUFBQSxFQUdBLE1BQU0saUJBQWlCO0FBQ3RCLFVBQU0sT0FBTyxPQUFPLE9BQU8sQ0FBQyxHQUFHLHFCQUFxQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQ3pFLFVBQU0sS0FBSyxTQUFTLEVBQUMsR0FBRyxNQUFNLEdBQUcsS0FBSyxXQUFVLENBQUM7QUFFakQsU0FBSyxJQUFJLGVBQWUsS0FBSyxVQUFVO0FBQUEsRUFDeEM7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixVQUFNLE9BQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUN0RSxVQUFNLEtBQUssU0FBUyxFQUFDLEdBQUcsTUFBTSxHQUFHLEtBQUssU0FBUSxDQUFDO0FBRS9DLFNBQUssSUFBSSxhQUFhLEtBQUssUUFBUTtBQUNuQyxTQUFLLGtCQUFrQjtBQUFBLEVBQ3hCO0FBQ0Q7IiwKICAibmFtZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJuYW1lIiwgIm1ldGhvZCIsICJob29rIiwgImhvb2siLCAiZ2V0VXNlckFnZW50IiwgImdldFVzZXJBZ2VudCIsICJnZXRVc2VyQWdlbnQiLCAiVkVSU0lPTiIsICJpc1BsYWluT2JqZWN0IiwgIndpdGhEZWZhdWx0cyIsICJnZXRVc2VyQWdlbnQiLCAiZ2V0VXNlckFnZW50IiwgIlZFUlNJT04iLCAid2l0aERlZmF1bHRzIiwgImdldFVzZXJBZ2VudCIsICJyZXF1ZXN0IiwgImVuZHBvaW50IiwgIlZFUlNJT04iLCAiVkVSU0lPTiIsICJob29rIiwgImF1dGgiLCAiaW1wb3J0X29ic2lkaWFuIiwgInNlbGVjdGVkIiwgImltcG9ydF9jb25zb2xlIiwgImltcG9ydF9vYnNpZGlhbiJdCn0K
