/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-excalidraw-plugin/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-excalidraw-plugin/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getEA2 = (view) => {
      try {
        return window.ExcalidrawAutomate.getAPI(view);
      } catch (e) {
        console.log({ message: "Excalidraw not available", fn: getEA2 });
        return null;
      }
    };
    exports.getEA = getEA2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CardNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/dragUpdate.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");

// src/utility.ts
var BLOCKIDREPLACE = () => /[^a-zA-Z\d-]+/g;
var FILENAMEREPLACE = () => /[!"#$%&()*+,.:;<=>?@^`{|}~/[\]\\\r\n]/g;
var HEADINGREPLACE = () => /([:#|^\\\r\n]|%%|\[\[|]])/g;
function throttle(cb, secondTimeout = 0) {
  let timer = false;
  let result;
  return (...args) => {
    if (!timer) {
      timer = true;
      setTimeout(() => {
        timer = false;
      }, 1e3 * secondTimeout);
      result = cb(...args);
    }
    return result;
  };
}
var LineBreak = "\n";
var MarkdownFileExtension = ".md";
function isBreak(name) {
  return name === void 0;
}
function createFullPath(file) {
  const fileName = `${file.fileName}${file.extension}`;
  return file.folderPath.length === 0 ? fileName : `${file.folderPath}/${fileName}`;
}
async function ReCheck(config) {
  let errorMessage;
  let args = config.create();
  let result;
  while (true) {
    try {
      result = await config.provide(args, result, errorMessage);
      if (isBreak(result)) {
        return result;
      }
      const validResult = await config.check(result);
      if (validResult instanceof Error) {
        throw validResult;
      } else {
        return validResult;
      }
    } catch (error) {
      args = config.update(args);
      errorMessage = error.message;
      continue;
    }
  }
}
var LIST = /^([ \t]*)(?<listSymbol>[*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
var TASK = /^([ \t]*)(?<task>\[.\])?( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
function listItemParser(text) {
  const match = LIST.exec(text);
  if (match) {
    const groups = match.groups, listSymbol = groups == null ? void 0 : groups.listSymbol, item = groups == null ? void 0 : groups.item;
    if (item) {
      const taskMatch = TASK.exec(item), taskGroups = taskMatch == null ? void 0 : taskMatch.groups, task = taskGroups == null ? void 0 : taskGroups.task, taskItem = taskGroups == null ? void 0 : taskGroups.item;
      return task ? {
        type: "task",
        listSymbol,
        task,
        item: taskItem != null ? taskItem : ""
      } : {
        type: "list",
        listSymbol,
        item
      };
    } else {
      return {
        type: "list",
        listSymbol,
        item: ""
      };
    }
  }
}
var WIKILINK = () => new RegExp(/^(?<left>!?\[\[)(?<link>.*?)(?<display>\|(?<displayText>.*))?(?<right>]])$/);
var MARKDOWNLINK = () => /^(?<left>!?\[)(?<displayText>.*?)(?<mid>]\(\s*)(?<link>[^ ]+)(?<right>(?:\s+.*?)?\))$/;
function UpdateLinkText(sourcePath, linkInfo, newPath) {
  const linkMatch = [
    {
      regex: WIKILINK(),
      newText: (match, path) => {
        var _a, _b, _c, _d;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.display) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${path}${display}${(_d = match.groups) == null ? void 0 : _d.right}`;
      }
    },
    {
      regex: MARKDOWNLINK(),
      newText(match, path) {
        var _a, _b, _c, _d, _e;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.displayText) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${display}${(_d = match.groups) == null ? void 0 : _d.mid}${path}${(_e = match.groups) == null ? void 0 : _e.right}`;
      }
    }
  ];
  for (const r of linkMatch) {
    const match = r.regex.exec(linkInfo.link.original);
    if (match) {
      const np = newPath(linkInfo);
      const newText = r.newText(match, np);
      return {
        change: newText,
        reference: linkInfo.link,
        sourcePath
      };
    }
  }
  return {
    change: `[[${newPath(linkInfo)}]]`,
    reference: linkInfo.link,
    sourcePath
  };
}
function LinkToChanges(linkMap, newPath) {
  const change = {
    data: {},
    keys: () => Object.keys(change.data),
    add: (key, value) => {
      const values = change.data[key];
      if (values && !values.contains(value)) {
        if (!values.contains(value)) {
          values.push(value);
        }
      } else {
        change.data[key] = [value];
      }
    },
    remove: (key, value) => {
      const values = change.data[key];
      values == null ? void 0 : values.remove(value);
    },
    removeKey: (key) => {
      delete change.data[key];
    },
    get: (key) => change.data[key],
    clear: (key) => change.removeKey(key),
    clearAll: () => {
      change.data = {};
    },
    contains: (key, value) => {
      var _a;
      return (_a = change.data[key]) == null ? void 0 : _a.contains(value);
    },
    count: () => {
      let c = 0;
      for (const key in change.data) {
        const len = change.data[key].length;
        c += len;
      }
      return c;
    }
  };
  linkMap.forEach((value, key) => {
    const changeInfo = value.map((text) => UpdateLinkText(key, text, newPath));
    change.data[key] = changeInfo;
  });
  return change;
}

// src/dragUpdate.ts
var import_obsidian3 = require("obsidian");

// src/ui.ts
var import_obsidian = require("obsidian");
var FileNameCheckModal = class extends import_obsidian.Modal {
  constructor(config) {
    super(config.plugin.app);
    this.getNameDesc = (fileName, blockName) => {
      const frag = document.createDocumentFragment();
      frag.createDiv().innerText = `Create file ${fileName}`;
      if (blockName) {
        frag.createDiv().innerText = `or`;
        frag.createDiv().innerText = `Link to block ${fileName}`;
      }
      return frag;
    };
    this.plugin = config.plugin;
    this.userInput = config.name;
    this.section = config.section;
    this.onSubmit = config.onSubmit;
    this.errorMessage = config.errorMessage;
  }
  onOpen() {
    const linkReferenceDescription = this.section.type === "reference" ? isHeadingBlock(this.section.block) ? " or link to heading" : " or link to block" : "";
    const { contentEl } = this;
    let userInputText;
    const nameSetting = new import_obsidian.Setting(contentEl).setDesc(`Create file${linkReferenceDescription}`).addText((text) => {
      var _a;
      userInputText = text;
      text.setValue((_a = this.userInput) != null ? _a : "");
      text.onChange((value) => {
        this.userInput = value;
      });
    }).addButton((btn) => {
      btn.setIcon("dices").setTooltip("Create random block id").setCta().onClick(() => {
        this.userInput = this.plugin.createRandomBlockId();
        userInputText == null ? void 0 : userInputText.setValue(this.userInput);
      });
    });
    const actions = new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setIcon("file-plus-2").setTooltip("Create file").setCta().onClick(() => {
        this.onSubmit({ type: "createFile", newName: this.userInput.trimEnd() });
        this.close();
      });
    });
    if (this.section.type === "reference") {
      const section = this.section;
      actions.addButton((btn) => {
        btn.setIcon("link").setTooltip("Link to reference").setCta().onClick(() => {
          this.onSubmit({
            type: "linkToReference",
            section,
            newName: this.userInput.trimEnd()
          });
          this.close();
        });
      });
    }
    actions.addButton((btn) => {
      btn.setIcon("scissors").setTooltip("Cut").setCta().onClick(() => {
        this.onSubmit({ type: "cut" });
        this.close();
      });
    }).addButton((btn) => {
      btn.setIcon("x").setTooltip(`Cancel`).setCta().onClick(() => {
        this.onSubmit({ type: "cancel" });
        this.close();
      });
    });
    if (this.errorMessage) {
      actions.setDesc(this.errorMessage);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  trySetDescription(setting, desc) {
    try {
      setting == null ? void 0 : setting.setDesc(desc);
    } catch (e) {
      console.log("expect set description before closing Modal", e);
    }
  }
  debounce(fn, sec) {
    let timer;
    return (...arg) => {
      clearTimeout(timer);
      return new Promise((resolve) => {
        timer = setTimeout(() => {
          const res = fn(...arg);
          resolve(res);
        }, sec * 1e3);
      });
    };
  }
  parseToValidFile(text) {
    return text.replace(FILENAMEREPLACE(), "");
  }
  parseToValidBlockName(text) {
    if (this.section.type === "reference") {
      const block = this.section.block;
      return isHeadingBlock(block) ? text : text.replace(BLOCKIDREPLACE(), "");
    }
  }
};

// src/adapters/obsidian-excalidraw-plugin/index.ts
var import_obsidian2 = require("obsidian");
var import_obsidian_excalidraw_plugin = __toESM(require_lib());
var VIEW_TYPE_EXCALIDRAW = "excalidraw";
function getEA(view) {
  return (0, import_obsidian_excalidraw_plugin.getEA)(view);
}
function isExcalidrawView(view) {
  return view.getViewType() === VIEW_TYPE_EXCALIDRAW;
}
var MAX_IMAGE_SIZE = 500;
async function insertEmbeddableOnDrawing(event, view, fileLink, file, plugin) {
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addEmbeddable(
      pos.x,
      pos.y,
      MAX_IMAGE_SIZE,
      MAX_IMAGE_SIZE,
      fileLink,
      file
    );
    await ea.addElementsToView(false, true, true);
    ea.selectElementsInView([id]);
  } catch (error) {
    console.log(error);
  }
}
async function createTextOnDrawing(event, view, text, plugin) {
  var _a, _b, _c, _d, _e;
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const appState = view.excalidrawAPI.getAppState();
    ea.style.strokeColor = (_a = appState.currentItemStrokeColor) != null ? _a : "black";
    ea.style.opacity = (_b = appState.currentItemOpacity) != null ? _b : 1;
    ea.style.fontFamily = (_c = appState.currentItemFontFamily) != null ? _c : 1;
    ea.style.fontSize = (_d = appState.currentItemFontSize) != null ? _d : 20;
    ea.style.textAlign = (_e = appState.currentItemTextAlign) != null ? _e : "left";
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addText(
      pos.x,
      pos.y,
      text
    );
    await view.addElements(ea.getElements(), false, true, void 0, true);
  } catch (error) {
    console.log(error);
  }
}

// src/adapters/obsidian/index.ts
var OBSIDIAN_CANVAS = "canvas";
function isObsidianCanvasView(view) {
  return (view == null ? void 0 : view.getViewType()) === OBSIDIAN_CANVAS;
}
function isCanvasFileNode(node) {
  return "file" in node;
}

// src/dragUpdate.ts
function isNamedBlock(block) {
  return "name" in block && block.name !== void 0;
}
function isHeadingBlock(block) {
  return "type" in block && block.type === "heading";
}
function isListBlock(block) {
  return "type" in block && block.type === "list";
}
function getSelectOffset(select) {
  var _a;
  if (select.type === "line" && ((_a = select.section) == null ? void 0 : _a.type) === "reference") {
    const pos = select.section.block.cache.position;
    return {
      from: pos.start.offset - select.textOffset,
      to: pos.end.offset - select.textOffset
    };
  } else {
    return {
      from: select.selection.from,
      to: select.selection.to
    };
  }
}
function getLinkBlocks(select, file, plugin) {
  const textOffset = select.textOffset;
  if (!file) {
    return [[], []];
  } else if (select.type === "mutiple") {
    const res = select.selections.map((sel) => plugin.findLinkBlocks(file, sel.from + textOffset, sel.to + textOffset));
    const blocks = res.flatMap((r) => r[0]);
    const headings = res.flatMap((r) => r[1]);
    return [blocks, headings];
  } else {
    const { from, to } = getSelectOffset(select);
    return plugin.findLinkBlocks(file, from + textOffset, to + textOffset);
  }
}
async function userAction(plugin, section, selected) {
  const folderPath = plugin.settings.defaultFolder;
  const getUserRename = (config) => {
    return new Promise((resolve) => {
      const onSubmit = (action2) => {
        resolve({ ...action2 });
      };
      new FileNameCheckModal({ ...config, onSubmit }).open();
    });
  };
  const provide = async (arg, unvalid, error) => {
    if ((unvalid == null ? void 0 : unvalid.type) !== "cancel" && (unvalid == null ? void 0 : unvalid.type) !== "cut") {
      const newName = unvalid == null ? void 0 : unvalid.newName;
      const name = newName && newName.length !== 0 ? newName : arg.name;
      return getUserRename({ ...arg, name, errorMessage: error });
    }
  };
  const check = async (value) => {
    if (value.type !== "cancel" && value.type !== "cut") {
      const newName = value.newName;
      if (value.type === "createFile") {
        const file = await plugin.checkFileName({ folderPath, fileName: newName, extension: MarkdownFileExtension });
        return file instanceof Error ? file : { ...value, file };
      }
      if (value.type === "linkToReference") {
        const findUnvalidBlockSymbol = () => BLOCKIDREPLACE().exec(value.newName);
        return isHeadingBlock(value.section.block) ? value : findUnvalidBlockSymbol() ? new Error("Block id only accept alphanumeric and -") : value;
      }
    }
    return value;
  };
  const action = await ReCheck({
    create() {
      var _a;
      const getDefault = () => {
        return selected.content.split(LineBreak, 1)[0].substring(0, 20).trim();
      };
      const defulatName = section.type === "reference" ? isNamedBlock(section.block) ? section.block.name : isListBlock(section.block) ? (_a = listItemParser(selected.content)) == null ? void 0 : _a.item : getDefault() : getDefault();
      return {
        plugin,
        section,
        name: defulatName != null ? defulatName : ""
      };
    },
    update(prev) {
      return prev;
    },
    provide,
    check
  });
  return action;
}
function getSection(source, selected, plugin) {
  var _a, _b, _c;
  if (source && ((_a = source == null ? void 0 : source.fileEditor) == null ? void 0 : _a.file) instanceof import_obsidian3.TFile && selected.type !== "mutiple") {
    const { offset, fileEditor } = source, sourceFile = fileEditor.file;
    const fileCache = plugin.app.metadataCache.getFileCache(sourceFile), matchStart = (block2) => {
      const start = selected.selection.from + offset;
      return block2.position.start.offset === start;
    }, touch = (block2) => {
      const start = selected.selection.from + offset, end = selected.selection.to + offset, blockStart = block2.position.start.offset, blockEnd = block2.position.end.offset;
      return blockEnd > start && blockEnd <= end || blockStart >= start && blockStart < end;
    }, findCorrespondBlock = () => {
      var _a2;
      const start = selected.selection.from + offset;
      const block2 = (_a2 = fileCache == null ? void 0 : fileCache.sections) == null ? void 0 : _a2.find((cache) => {
        if (cache.type === "list") {
          return cache.position.start.offset <= start && start <= cache.position.end.offset;
        } else {
          return matchStart(cache);
        }
      });
      return block2;
    };
    const blockCache = findCorrespondBlock(), getList = () => {
      var _a2;
      const listItem = (_a2 = fileCache == null ? void 0 : fileCache.listItems) == null ? void 0 : _a2.find((item) => {
        const listStartPosition = item.position.start, listEndPosition = item.position.end, listStart = listStartPosition.offset, listEnd = listEndPosition.offset, listLineStart = listStart - listStartPosition.col, selectStart = selected.selection.from + offset, selectEnd = selected.selection.to + offset;
        return selectStart >= listLineStart && (listStart >= selectStart && listEnd <= selectEnd);
      });
      if (listItem) {
        return {
          type: "list",
          cache: listItem,
          name: listItem.id
        };
      }
    }, getHeading = () => {
      var _a2;
      const heading = (_a2 = fileCache == null ? void 0 : fileCache.headings) == null ? void 0 : _a2.find(matchStart);
      if (heading) {
        return {
          type: "heading",
          name: heading == null ? void 0 : heading.heading,
          cache: heading
        };
      }
    }, getBlock = () => {
      if (blockCache) {
        if (blockCache.type === "list") {
          return getList();
        } else if (blockCache.type === "heading") {
          return getHeading();
        } else {
          return blockCache.id ? {
            type: "linkBlock",
            cache: blockCache,
            name: blockCache.id
          } : {
            cache: blockCache
          };
        }
      }
    };
    const block = (_c = (_b = getList()) != null ? _b : getHeading()) != null ? _c : getBlock();
    return block ? {
      type: "reference",
      block,
      file: sourceFile
    } : {
      type: "unreference"
    };
  } else {
    return {
      type: "unreference"
    };
  }
}
function fileUpdateObserver(plugin, file) {
  let res, waiting = [];
  const metadataCache = plugin.app.metadataCache;
  const e = metadataCache.on("changed", (changeFile, data, cache) => {
    if (changeFile === file) {
      const r = {
        file: changeFile,
        data,
        cache
      };
      res = Promise.resolve(r);
      waiting.forEach((resolve) => resolve(r));
      waiting = [];
    }
  });
  return {
    getUpdate: () => res != null ? res : new Promise((resolve) => {
      waiting.push(resolve);
    }),
    close: () => metadataCache.offref(e)
  };
}
async function onFilesUpdated(plugin, files, on, timeLimited) {
  const time = timeLimited * files.length, observers = files.map((file) => fileUpdateObserver(plugin, file)), closeObserver = () => observers.forEach((ob) => ob.close()), update = observers.map((ob) => ob.getUpdate());
  return new Promise((resolve, reject) => {
    resolve(Promise.all(update).then((data) => {
      closeObserver();
      on(data);
    }));
    setTimeout(() => {
      closeObserver();
      reject(`files: ${files.map((file) => file.path)} are not detected in ${time} seconds, `);
    }, 1e3 * time);
  });
}
async function extractSelect(action, extract, view, activeFile, whiteboard, plugin) {
  const updateInternalLinks = async (sourceFile, createNewPath, match, updateAfterDraw) => {
    var _a;
    const linksInFiles = plugin.findLinks(sourceFile, match);
    onFilesUpdated(plugin, updateAfterDraw, async (data) => {
      const [selfLinks, _2] = await linksInFiles;
      if (selfLinks) {
        const linksSet = selfLinks.map((l) => l.link.link);
        const res = /* @__PURE__ */ new Map();
        data.map((d) => {
          var _a2, _b;
          const links = (_a2 = d.cache.links) != null ? _a2 : [];
          const embeds = (_b = d.cache.embeds) != null ? _b : [];
          const all = links.concat(embeds);
          const linkRef = all.filter((cache) => linksSet.contains(cache.link)).map(plugin.createLinkInfo);
          return {
            file: d.file.path,
            linkRef
          };
        }).forEach((d) => {
          if (d.linkRef.length > 0) {
            res.set(d.file, d.linkRef);
          }
        });
        plugin.updateInternalLinks(res, (text) => {
          const newPath = createNewPath({ path: text.path, subpath: text.subpath });
          return `${newPath.path}${newPath.subpath}`;
        });
      }
    }, 10);
    const [_, outer] = await linksInFiles;
    const canvasHasMatchLinks = plugin.getCanvas((canvasPath, embed) => {
      var _a2;
      const subpath = embed.subpath;
      return match({ path: (_a2 = embed.file) != null ? _a2 : "", subpath });
    });
    const whiteboardPath = (_a = whiteboard.located.file) == null ? void 0 : _a.path, updateLinksInDraw = () => {
      whiteboard.updateLinks({
        getNewPath: createNewPath,
        linkMatch: match
      });
    };
    if (outer.has(whiteboardPath != null ? whiteboardPath : "")) {
      outer.delete(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    } else if (canvasHasMatchLinks.contains(whiteboardPath != null ? whiteboardPath : "")) {
      canvasHasMatchLinks.remove(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    }
    plugin.updateInternalLinks(outer, (text) => {
      const newPath = createNewPath({ path: text.path, subpath: text.subpath });
      return `${newPath.path}${newPath.subpath}`;
    });
    plugin.updateCanvasLinks(canvasHasMatchLinks, (node) => {
      if (match({ path: node.file, subpath: node.subpath })) {
        const newPath = createNewPath({ path: node.file, subpath: node.subpath });
        return {
          ...node,
          file: newPath.path + MarkdownFileExtension,
          subpath: newPath.subpath
        };
      }
      return node;
    });
  };
  if (action.type === "createFile") {
    const updateConfig = () => {
      var _a;
      if ((_a = activeFile == null ? void 0 : activeFile.fileEditor) == null ? void 0 : _a.file) {
        const sourceFile = activeFile.fileEditor.file;
        const match = (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && subpathSet.contains(link.subpath);
        const createNewPath = (oldPath) => {
          return plugin.createLinkText(newFile, oldPath.subpath, oldPath.displayText);
        };
        const [blocks, headings] = getLinkBlocks(extract, sourceFile, plugin);
        const subpathSet = [...blocks.map((block) => `#^${block.id}`), ...headings.map((cache) => `#${plugin.normalizeHeadingToLinkText(cache.heading)}`)];
        return {
          sourceFile,
          match,
          createNewPath,
          subpathSet
        };
      }
    };
    const config = updateConfig();
    const filePath = action.file.fileName;
    const newFile = await plugin.app.vault.create(filePath, extract.content);
    const newFileLink = plugin.createLinkText(newFile);
    const replaceTextWithLink = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract), insert: newFileLink.text } : extract.selections.map((line) => {
          return { from: line.from, to: line.to, insert: newFileLink.text };
        })
      });
      view.dispatch(trans);
    };
    replaceTextWithLink();
    if (config && config.subpathSet.length !== 0) {
      const { sourceFile, createNewPath, match } = config;
      await updateInternalLinks(sourceFile, createNewPath, match, [sourceFile, newFile]);
    }
    whiteboard.draw(newFileLink);
  } else if (action.type === "linkToReference") {
    const block = action.section.block, sourceFile = action.section.file;
    const name = action.newName;
    const subpath = isHeadingBlock(block) ? {
      symbol: "#",
      path: plugin.normalizeHeadingToLinkText(name)
    } : {
      symbol: "#^",
      path: name
    };
    const oldBlock = isNamedBlock(block) ? block : void 0;
    const newPath = plugin.createLinkText(sourceFile, subpath.symbol + subpath.path);
    if (oldBlock) {
      const reName = () => oldBlock.name !== name;
      if (reName()) {
        const oldName = oldBlock.name, oldPath = isHeadingBlock(oldBlock) ? "#" + plugin.normalizeHeadingToLinkText(oldName) : "#^" + oldName, from = block.cache.position.end.offset - extract.textOffset - oldName.length, to = block.cache.position.end.offset - extract.textOffset;
        const trans = view.state.update({
          changes: { from, to, insert: subpath.path }
        });
        view.dispatch(trans);
        await updateInternalLinks(
          sourceFile,
          (old) => newPath,
          (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && link.subpath === oldPath,
          [sourceFile]
        );
      }
    } else {
      const insertNamePosition = block.cache.position.end.offset - extract.textOffset;
      const trans = view.state.update({
        changes: { from: insertNamePosition, insert: " ^" + name }
      });
      view.dispatch(trans);
    }
    whiteboard.draw(newPath);
  } else {
    const deleteText = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract) } : extract.selections.map((line) => {
          return { from: line.from, to: line.to };
        })
      });
      view.dispatch(trans);
    };
    deleteText();
    whiteboard.draw(extract.content);
  }
}
var dragExtension = (plugin) => {
  const addDragStartEvent = (dragSymbol, view) => {
    let info;
    let source;
    let listener;
    const handleDrop = async (e) => {
      const createFileAndDraw = async (whiteboard) => {
        var _a;
        const section = info.type === "line" && info.section ? info.section : getSection(source, info, plugin);
        const action = await userAction(plugin, section, info);
        if (!isBreak(action) && action.type !== "cancel") {
          extractSelect(
            action,
            { ...info, textOffset: (_a = source == null ? void 0 : source.offset) != null ? _a : 0 },
            view,
            source,
            whiteboard,
            plugin
          );
        }
      };
      const locate = plugin.app.workspace.getDropLocation(e);
      const target = locate.children.find((child) => child.tabHeaderEl.className.contains("active"));
      const drawView = target == null ? void 0 : target.view;
      if (isExcalidrawView(drawView)) {
        createFileAndDraw(
          {
            located: drawView,
            draw: (target2) => {
              if (typeof target2 !== "string") {
                insertEmbeddableOnDrawing(e, drawView, target2.text, target2.file, plugin);
              } else {
                createTextOnDrawing(e, drawView, target2, plugin);
              }
            },
            updateLinks: (para) => {
              const { linkMatch, getNewPath } = para;
              const nodes = Array.from(drawView.canvasNodeFactory.nodes.entries()).map((value) => {
                const [id, refNode] = value;
                const getLinkInfo = (node) => {
                  return { path: node.filePath, subpath: node.subpath };
                };
                if (isCanvasFileNode(refNode) && linkMatch(getLinkInfo(refNode))) {
                  return { id, link: getNewPath(getLinkInfo(refNode)) };
                }
              }).filter((v) => v !== void 0);
              nodes.forEach(
                (node) => {
                  const elements = drawView.excalidrawAPI.getSceneElements().filter((e2) => e2.id === node.id);
                  elements.forEach((elem) => {
                    drawView.excalidrawData.elementLinks.set(node.id, node.link.text);
                    ExcalidrawLib.mutateElement(elem, { link: node.link.text });
                  });
                }
              );
              drawView.setDirty(99);
              drawView.updateScene({});
            }
          }
        );
      } else if (isObsidianCanvasView(drawView)) {
        const pos = drawView.canvas.posFromEvt(e);
        createFileAndDraw({
          located: drawView,
          draw: (target2) => {
            if (typeof target2 !== "string") {
              drawView.canvas.createFileNode({
                file: target2.file,
                pos,
                subpath: target2.subpath,
                save: true
              });
            } else {
              drawView.canvas.createTextNode({
                text: target2,
                pos,
                save: true
              });
            }
          },
          updateLinks: (para) => {
            const { linkMatch, getNewPath } = para;
            drawView.canvas.nodes.forEach((node, id) => {
              var _a;
              const path = (node2) => ({
                path: node2.filePath,
                file: node2.file,
                subpath: node2.subpath
              });
              if (isCanvasFileNode(node) && linkMatch(path(node))) {
                const newPath = getNewPath(path(node));
                node.setFilePath(newPath.file.path, (_a = newPath.subpath) != null ? _a : "");
              }
            });
            drawView.canvas.requestSave();
          }
        });
      }
    };
    dragSymbol.addEventListener("dragstart", (e) => {
      source = plugin.getActiveEditorFile();
      const getSelection = () => {
        const selectLines = view.state.selection.ranges.map((range) => ({
          from: range.from,
          to: range.to
        }));
        const content = selectLines.map((range) => {
          return view.state.sliceDoc(range.from, range.to);
        }).join().trim();
        return { content, selectLines };
      };
      const getLineString = () => {
        var _a;
        const statefield = view.state.field(dragSymbolSet);
        const start = statefield.iter().from;
        const doc = view.state.doc;
        const line = view.state.doc.lineAt(start);
        const foldableRange = (0, import_language.foldable)(view.state, line.from, line.to);
        if (foldableRange) {
          return {
            type: "foldable",
            startLine: line,
            selection: {
              from: line.from,
              to: foldableRange.to
            },
            content: doc.sliceString(line.from, foldableRange.to)
          };
        } else {
          const selected = {
            type: "line",
            line,
            selection: {
              from: line.from,
              to: line.to
            }
          };
          const referenceTextOffset = (_a = source == null ? void 0 : source.offset) != null ? _a : 0;
          const section = getSection(source, { ...selected, content: "" }, plugin);
          const content = section && section.type === "reference" ? doc.sliceString(
            section.block.cache.position.start.offset - referenceTextOffset,
            section.block.cache.position.end.offset - referenceTextOffset
          ) : line.text;
          return {
            ...selected,
            content,
            section
          };
        }
      };
      const defaultSelect = getSelection();
      info = defaultSelect.content.length === 0 ? getLineString() : defaultSelect.selectLines.length === 1 ? { type: "single", selection: defaultSelect.selectLines.first(), content: defaultSelect.content } : { type: "mutiple", selections: defaultSelect.selectLines, content: defaultSelect.content };
      setTimeout(() => {
        listener = plugin.listenDragAndDrop(e, info.content, handleDrop);
      });
    });
    return {
      reset: () => listener == null ? void 0 : listener.reset()
    };
  };
  const dragMarker = new class extends import_view.GutterMarker {
    destroy(dom) {
    }
    toDOM(view) {
      const dragSymbol = document.createElement("div");
      dragSymbol.draggable = true;
      const symbol = dragSymbol.createSpan();
      symbol.innerText = plugin.settings.dragSymbol;
      symbol.style.fontSize = `${plugin.settings.dragSymbolSize}px`;
      const { reset } = addDragStartEvent(dragSymbol, view);
      dragSymbol.addEventListener("dragend", () => {
        reset();
      });
      return dragSymbol;
    }
  }();
  const mousemoveEffect = import_state.StateEffect.define({
    map: (val, mapping) => ({ from: mapping.mapPos(val.from), to: mapping.mapPos(val.to) })
  });
  const dragSymbolSet = import_state.StateField.define({
    create() {
      return import_state.RangeSet.empty;
    },
    update(set, transaction) {
      set = set.map(transaction.changes);
      for (const e of transaction.effects) {
        if (e.is(mousemoveEffect)) {
          set = import_state.RangeSet.of(dragMarker.range(e.value.from));
        }
      }
      return set;
    },
    //依此stateField狀態所需要更新的Extension都可以放在provide funciton中提供出來
    provide: (value) => {
      const gut = (0, import_view.gutter)({
        markers: (v) => {
          const range_set = v.state.field(value);
          return v.state.doc.length !== 0 ? range_set : import_state.RangeSet.empty;
        },
        initialSpacer: () => dragMarker
      });
      return [gut];
    }
  });
  const addSymbolWhenMouseMove = (event, view) => {
    const pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    });
    if (pos) {
      const dragLine = view.state.field(dragSymbolSet);
      const line = view.lineBlockAt(pos);
      let hasDragPoint = false;
      dragLine.between(line.from, line.from, () => {
        hasDragPoint = true;
      });
      if (!hasDragPoint) {
        view.dispatch({
          effects: mousemoveEffect.of({ from: line.from, to: line.to })
        });
      }
    }
    return pos;
  };
  const mouseMoveWatch = import_view.EditorView.domEventHandlers({
    mousemove: (event, view) => {
      throttle(addSymbolWhenMouseMove, 0.2)(event, view);
    }
  });
  return [
    dragSymbolSet,
    mouseMoveWatch
  ];
};

// main.ts
var DEFAULT_SETTINGS = {
  dragSymbol: "\u{1F494}",
  dragSymbolSize: 18,
  defaultFolder: ""
};
var CardNote = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEditorExtension(dragExtension(this));
    this.addSettingTab(new CardNoteTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createPath(file, subpath, displayText) {
    return this.app.metadataCache.fileToLinktext(
      file,
      file.path,
      file.extension === "md"
    );
  }
  createLinkText(file, subpath, displayText) {
    const fileLinkPath = this.createPath(file);
    const sub = subpath != null ? subpath : "";
    const fullLinkPath = `${fileLinkPath}${sub}`;
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    const markdownLink = () => {
      const display = displayText != null ? displayText : fullLinkPath;
      return `[${display}](${fullLinkPath.replace(" ", "%20")})`;
    };
    const wikiLink = () => {
      const display = displayText ? `|${displayText}` : "";
      return `[[${fullLinkPath}${display}]]`;
    };
    const linkText = useMarkdownLink ? markdownLink() : wikiLink();
    return {
      path: fileLinkPath,
      subpath,
      file,
      text: linkText,
      displayText
    };
  }
  getActiveEditorFile() {
    var _a, _b;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.TextFileView);
    if (view) {
      if (isObsidianCanvasView(view)) {
        const [selectNode] = view.canvas.selection;
        return selectNode && isCanvasFileNode(selectNode) ? { fileEditor: selectNode, offset: selectNode.child.before.length } : void 0;
      }
      if (isExcalidrawView(view)) {
        const embeddable = view.getActiveEmbeddable(), before = (_b = (_a = embeddable == null ? void 0 : embeddable.node) == null ? void 0 : _a.child.before) != null ? _b : "";
        return (embeddable == null ? void 0 : embeddable.node) && isCanvasFileNode(embeddable.node) ? { fileEditor: embeddable.node, offset: before.length } : void 0;
      }
    }
    return { fileEditor: this.app.workspace.activeEditor, offset: 0 };
  }
  async checkFileName(file) {
    const fileName = file.fileName;
    if (fileName.length === 0) {
      return new Error("File Name can not be empty!");
    } else if (fileName.endsWith(" ")) {
      return new Error("File Name can not end with white space!");
    } else {
      const matchInvalidSymbol = FILENAMEREPLACE().exec(fileName);
      if (matchInvalidSymbol) {
        return new Error(`File Name can not contains symbols [!"#$%&()*+,.:;<=>?@^\`{|}~/[]\r
]`);
      }
    }
    const filePathUncheck = createFullPath(file);
    const normalFilePath = (0, import_obsidian5.normalizePath)(filePathUncheck);
    this.app.vault.checkPath(normalFilePath);
    if (await this.app.vault.adapter.exists(normalFilePath)) {
      return new Error("File exist!");
    }
    return { ...file, fileName: normalFilePath };
  }
  updateInternalLinks(linkMap, newPath) {
    const changes = LinkToChanges(linkMap, newPath);
    this.app.fileManager.updateInternalLinks(changes);
  }
  renameCanvasSubpath(origin, newFile) {
    var _a, _b;
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    if (origin.file.path === newFile.file.path && origin.subpath !== newFile.subpath) {
      canvasUpdater.renameSubpath(origin.file, (_a = origin.subpath) != null ? _a : "", (_b = newFile.subpath) != null ? _b : "");
    }
  }
  getCanvas(filter) {
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    const canvases = canvasUpdater.canvas.index.getAll();
    const queue = [];
    for (const canvasFilePath in canvases) {
      const canvasCache = canvases[canvasFilePath];
      const find = canvasCache.embeds.find((embed) => {
        var _a;
        return (_a = filter == null ? void 0 : filter(canvasFilePath, embed)) != null ? _a : true;
      });
      if (find) {
        queue.push(canvasFilePath);
      }
    }
    return queue;
  }
  updateCanvasNodes(canvasPath, newNode) {
    const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
    if (canvasFile instanceof import_obsidian5.TFile && canvasFile.extension === "canvas") {
      return this.app.vault.process(canvasFile, (data) => {
        const canvasData = JSON.parse(data);
        const nodeUpdate = canvasData.nodes.map(newNode);
        const newData = {
          edges: canvasData.edges,
          nodes: nodeUpdate
        };
        return JSON.stringify(newData);
      });
    }
  }
  updateCanvasLinks(canvasPathSet, map) {
    const result = canvasPathSet.map((canvasPath) => this.updateCanvasNodes(canvasPath, (node) => {
      if (node.type === "file") {
        return map(node);
      }
      return node;
    }));
    return Promise.all(result);
  }
  findLinkBlocks(file, from, to) {
    var _a, _b;
    const cache = this.app.metadataCache.getFileCache(file);
    const blocks = cache == null ? void 0 : cache.blocks;
    const inRange = (item) => {
      const end = item.position.end;
      return end.offset > from && end.offset <= to;
    };
    const blocksInRange = [];
    for (const blockName in blocks) {
      const blockInfo = blocks[blockName];
      if (inRange(blockInfo)) {
        blocksInRange.push(blockInfo);
      }
    }
    const headingInRange = (_b = (_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.filter(inRange)) != null ? _b : [];
    return [blocksInRange, headingInRange];
  }
  createLinkInfo(cache) {
    const normalizeLink = cache.link.replace(/\u00A0/, "").normalize();
    const path = normalizeLink.split("#")[0];
    const subpath = normalizeLink.substring(path.length);
    return {
      path,
      subpath,
      link: cache
    };
  }
  findLinks(targetFile, match) {
    return new Promise((res) => {
      const cache = this.app.metadataCache;
      const fileManger = this.app.fileManager;
      const linkMap = /* @__PURE__ */ new Map();
      fileManger.iterateAllRefs((fileName, linkCache) => {
        var _a;
        fileName.normalize();
        const linkInfo = this.createLinkInfo(linkCache);
        const { path, subpath } = linkInfo;
        if (match({ path, subpath, file: (_a = cache.getFirstLinkpathDest(path, fileName)) != null ? _a : void 0 })) {
          const links = linkMap.get(fileName);
          if (links) {
            links.push(linkInfo);
          } else {
            linkMap.set(fileName, [linkInfo]);
          }
        }
      });
      const selfLink = linkMap.get(targetFile.path);
      linkMap.delete(targetFile.path);
      res([selfLink, linkMap]);
    });
  }
  normalizeHeadingToLinkText(heading) {
    const path = heading.replace(HEADINGREPLACE(), " ").replace(/\s+/g, " ");
    return path;
  }
  replaceSpaceInLinkText(link) {
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    return useMarkdownLink ? link.replace(" ", "%20") : link;
  }
  createRandomBlockId(length = 6) {
    const id = [...Array(6).keys()].map((_) => (16 * Math.random() | 0).toString(16)).join("");
    return id;
  }
  listenDragAndDrop(e, content, dropEvent) {
    const trim = content.trim(), display = trim.length > 600 ? trim.substring(0, 600).concat(" ...") : trim;
    const floatingSplits = this.app.workspace.floatingSplit, popoutWindows = floatingSplits.children.map((win) => win.containerEl), allWindows = [this.app.workspace.containerEl].concat(popoutWindows), eventListeners = allWindows.map((container) => this.createDraggingAndDropEvent(e, container, display, dropEvent));
    return {
      reset: () => eventListeners.forEach((listen) => listen.reset())
    };
  }
  createDraggingAndDropEvent(e, container, content, dropEvent) {
    const dragContentEle = document.createElement("div");
    dragContentEle.hide();
    dragContentEle.style.transform = `translate(${e.clientX}px,${e.clientY}px)`;
    dragContentEle.style.width = "300px";
    dragContentEle.style.height = "min-content";
    dragContentEle.style.position = "absolute";
    dragContentEle.style.padding = "5px 25px";
    dragContentEle.style.borderWidth = "3px";
    dragContentEle.style.borderRadius = "10px";
    dragContentEle.style.border = "solid";
    dragContentEle.style.pointerEvents = "none";
    const dragoverBackground = document.createElement("div");
    dragoverBackground.setCssStyles({
      opacity: "0",
      width: "100%",
      height: "100%",
      position: "fixed"
    });
    import_obsidian5.MarkdownRenderer.render(
      this.app,
      content,
      dragContentEle,
      "",
      this
    );
    container.appendChild(dragoverBackground);
    container.appendChild(dragContentEle);
    const showDragContent = (e2) => {
      dragContentEle.show();
    };
    const moveDragContent = (e2) => {
      const x = e2.clientX, y = e2.clientY;
      dragContentEle.style.transform = `translate(${x}px,${y}px)`;
      e2.preventDefault();
    };
    const hideDragContent = (e2) => {
      if (e2.target === dragoverBackground) {
        dragContentEle.hide();
      }
    };
    this.registerDomEvent(container, "dragenter", showDragContent);
    this.registerDomEvent(container, "dragover", moveDragContent);
    this.registerDomEvent(container, "dragleave", hideDragContent);
    this.registerDomEvent(container, "drop", dropEvent);
    return {
      reset: () => {
        container.removeChild(dragContentEle);
        container.removeChild(dragoverBackground);
        container.removeEventListener("drop", dropEvent);
        container.removeEventListener("dragover", moveDragContent);
        container.removeEventListener("dragenter", showDragContent);
        container.removeEventListener("dragleave", hideDragContent);
      }
    };
  }
};
var CardNoteTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Drag symbol").setDesc("You can set your prefer drag symbol here").addText(
      (text) => text.setPlaceholder("Enter your drag symbol here").setValue(this.plugin.settings.dragSymbol).onChange(async (value) => {
        this.plugin.settings.dragSymbol = value;
        await this.plugin.saveSettings();
      })
    );
    this.addSizeSetting();
    new import_obsidian5.Setting(containerEl).setName("Default folder").setDesc("Default loction for new note. if empty, new note will be created in the vault root.").addText(
      (text) => text.setPlaceholder("/sub folder name").setValue(this.plugin.settings.defaultFolder).onChange(async (value) => {
        this.plugin.settings.defaultFolder = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addSizeSetting() {
    const desc = (value) => {
      return `Change your symbol size. Current size is ${value != null ? value : this.plugin.settings.dragSymbolSize}.(min=1 max=100)`;
    };
    const sizeSetting = new import_obsidian5.Setting(this.containerEl).setName("Symbol size (px)").setDesc(desc()).addSlider(
      (slider) => {
        var _a;
        slider.setLimits(1, 100, 1).setValue((_a = this.plugin.settings.dragSymbolSize) != null ? _a : 18).onChange(async (value) => {
          sizeSetting.setDesc(desc(value));
          this.plugin.settings.dragSymbolSize = value;
          await this.plugin.saveSettings();
        }).setDynamicTooltip();
      }
    );
  }
};
